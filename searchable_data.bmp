[{"name": "add_units.eq_neg_of_add_eq_zero_left", "description": ""}, {"name": "units.is_unit", "description": ""}, {"name": "units.unique", "description": ""}, {"name": "add_units.decidable_eq", "description": ""}, {"name": "add_units.add_zero_class", "description": ""}, {"name": "is_unit_of_mul_eq_one", "description": ""}, {"name": "is_unit", "description": " An element `a : M` of a monoid is a unit if it has a two-sided inverse.\nThe actual definition says that `a` is equal to some `u : M\u02e3`, where\n`M\u02e3` is a bundled version of `is_unit`."}, {"name": "add_units.is_add_unit_add_units_add", "description": "Addition of a `u : add_units M` on the left doesn't affect `is_add_unit`."}, {"name": "add_units.add_neg_cancel_left", "description": ""}, {"name": "is_add_unit.add_unit_spec", "description": ""}, {"name": "divp_mul_eq_mul_divp", "description": ""}, {"name": "units.mul_one_class", "description": ""}, {"name": "add_units.add_comm_group", "description": ""}, {"name": "eq_divp_iff_mul_eq", "description": ""}, {"name": "units.coe_eq_one", "description": ""}, {"name": "units.mul_eq_one_iff_inv_eq", "description": ""}, {"name": "add_units.neg_add_eq_zero", "description": ""}, {"name": "units.has_repr", "description": ""}, {"name": "units.inv_mul", "description": ""}, {"name": "add_units.add_eq_zero_iff_neg_eq", "description": ""}, {"name": "is_unit.exists_left_inv", "description": ""}, {"name": "unique_has_zero", "description": ""}, {"name": "units.simps.coe", "description": "See Note [custom simps projection]"}, {"name": "add_units.ext_iff", "description": ""}, {"name": "is_unit_of_subsingleton", "description": ""}, {"name": "divp_self", "description": ""}, {"name": "units.mul_inv_eq_iff_eq_mul", "description": ""}, {"name": "units.coe_mk_of_mul_eq_one", "description": ""}, {"name": "add_units.copy_eq", "description": ""}, {"name": "add_units.eq_add_neg_iff_add_eq", "description": ""}, {"name": "units.inv_eq_of_mul_eq_one_left", "description": ""}, {"name": "divp_left_inj", "description": ""}, {"name": "is_unit.decidable", "description": "`is_unit x` is decidable if we can decide if `x` comes from `M\u02e3`."}, {"name": "add_units.coe_eq_zero", "description": ""}, {"name": "units.mul_left_inj", "description": ""}, {"name": "units.inhabited", "description": ""}, {"name": "is_add_unit_of_subsingleton", "description": ""}, {"name": "is_add_unit.add_coe_neg", "description": ""}, {"name": "is_unit.unit_spec", "description": ""}, {"name": "units.eq_inv_mul_iff_mul_eq", "description": ""}, {"name": "divp_assoc", "description": ""}, {"name": "add_units.neg_unique", "description": ""}, {"name": "add_units.simps.coe", "description": "See Note [custom simps projection]"}, {"name": "is_unit_iff_exists_inv", "description": ""}, {"name": "units.inv_mul_cancel_left", "description": ""}, {"name": "is_add_unit.add_right_inj", "description": ""}, {"name": "unique_has_one", "description": ""}, {"name": "is_unit.unit_of_coe_units", "description": ""}, {"name": "is_unit.mul_left_cancel", "description": ""}, {"name": "is_unit_one", "description": ""}, {"name": "units.coe_mk", "description": ""}, {"name": "is_unit.mul_iff", "description": ""}, {"name": "divp_eq_one_iff_eq", "description": ""}, {"name": "units.coe_copy", "description": ""}, {"name": "units.mul_inv", "description": ""}, {"name": "units.ext", "description": ""}, {"name": "add_units.neg_add", "description": ""}, {"name": "is_add_unit.exists_neg'", "description": ""}, {"name": "is_add_unit_iff_exists_neg'", "description": ""}, {"name": "add_units.coe_copy", "description": ""}, {"name": "add_units.eq_neg_add_iff_add_eq", "description": ""}, {"name": "add_units.add_neg_eq_iff_eq_add", "description": ""}, {"name": "is_add_unit.add_iff", "description": ""}, {"name": "divp_divp_eq_divp_mul", "description": ""}, {"name": "add_units.neg_eq_of_add_eq_zero_right", "description": ""}, {"name": "add_units.add_left_inj", "description": ""}, {"name": "is_unit.mul_right_inj", "description": ""}, {"name": "units.group", "description": "Units of a monoid form a group."}, {"name": "add_units.coe_mk_of_add_eq_zero", "description": ""}, {"name": "is_add_unit.add_right_cancel", "description": ""}, {"name": "add_units.unique", "description": ""}, {"name": "add_units.inhabited", "description": ""}, {"name": "units.has_inv", "description": ""}, {"name": "add_units.add_eq_zero_iff_eq_neg", "description": ""}, {"name": "units.simps.coe_inv", "description": "See Note [custom simps projection]"}, {"name": "is_add_unit.add_right_injective", "description": ""}, {"name": "units.eq_inv_of_mul_eq_one_left", "description": ""}, {"name": "add_units.eq_neg_of_add_eq_zero_right", "description": ""}, {"name": "add_units.simps.coe_neg", "description": "See Note [custom simps projection]"}, {"name": "is_add_unit_zero", "description": ""}, {"name": "add_units.neg_add_eq_iff_eq_add", "description": ""}, {"name": "units.is_unit_units_mul", "description": "Multiplication by a `u : M\u02e3` on the left doesn't affect `is_unit`."}, {"name": "add_units.has_repr", "description": ""}, {"name": "add_units.neg_add_cancel_right", "description": ""}, {"name": "units.coe_inv_copy", "description": ""}, {"name": "is_add_unit_iff_exists_neg", "description": ""}, {"name": "units.eq_inv_of_mul_eq_one_right", "description": ""}, {"name": "add_units.add_neg_of_eq", "description": ""}, {"name": "divp_eq_iff_mul_eq", "description": ""}, {"name": "divp_mul_cancel", "description": ""}, {"name": "add_units.add_neg", "description": ""}, {"name": "units.coe_one", "description": ""}, {"name": "is_add_unit.add", "description": ""}, {"name": "add_units.neg_mk", "description": ""}, {"name": "units.inv_mul_eq_iff_eq_mul", "description": ""}, {"name": "is_add_unit.add_unit", "description": "The element of the additive group of additive units, corresponding to an element of\nan additive monoid which is an additive unit. When `\u03b1` is a `subtraction_monoid`, use\n`is_add_unit.add_unit'` instead."}, {"name": "units.copy_eq", "description": ""}, {"name": "add_units.neg_add_of_eq", "description": ""}, {"name": "is_add_unit.coe_neg_add", "description": ""}, {"name": "units.val_eq_coe", "description": ""}, {"name": "units.mk_coe", "description": ""}, {"name": "add_units.add_neg_cancel_right", "description": ""}, {"name": "inv_eq_one_divp'", "description": "Used for `field_simp` to deal with inverses of units. This form of the lemma\nis essential since `field_simp` likes to use `inv_eq_one_div` to rewrite\n`\u2191u\u207b\u00b9 = \u2191(1 / u)`."}, {"name": "is_add_unit.add_unit_of_coe_add_units", "description": ""}, {"name": "add_units.add_right_inj", "description": ""}, {"name": "is_add_unit_of_add_is_add_unit_right", "description": ""}, {"name": "is_unit.coe_inv_mul", "description": ""}, {"name": "is_unit.exists_right_inv", "description": ""}, {"name": "units.comm_group", "description": ""}, {"name": "is_unit_iff_exists_inv'", "description": ""}, {"name": "add_units.is_add_unit_add_add_units", "description": "Addition of a `u : add_units M` on the right doesn't\naffect `is_add_unit`."}, {"name": "is_unit.mul_left_inj", "description": ""}, {"name": "add_units", "description": " Units of an `add_monoid`, bundled version.\n\nAn element of an `add_monoid` is a unit if it has a two-sided additive inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `is_add_unit`."}, {"name": "add_units.val", "description": " Units of an `add_monoid`, bundled version.\n\nAn element of an `add_monoid` is a unit if it has a two-sided additive inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `is_add_unit`."}, {"name": "add_units.neg", "description": " Units of an `add_monoid`, bundled version.\n\nAn element of an `add_monoid` is a unit if it has a two-sided additive inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `is_add_unit`."}, {"name": "add_units.val_neg", "description": " Units of an `add_monoid`, bundled version.\n\nAn element of an `add_monoid` is a unit if it has a two-sided additive inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `is_add_unit`."}, {"name": "add_units.neg_val", "description": " Units of an `add_monoid`, bundled version.\n\nAn element of an `add_monoid` is a unit if it has a two-sided additive inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `is_add_unit`."}, {"name": "add_units.coe_neg_copy", "description": ""}, {"name": "is_unit.mul_right_cancel", "description": ""}, {"name": "units.inv_mul_of_eq", "description": ""}, {"name": "units.copy", "description": "Copy a unit, adjusting definition equalities."}, {"name": "units.eq_iff", "description": ""}, {"name": "is_unit_of_mul_is_unit_left", "description": ""}, {"name": "is_unit.mul", "description": ""}, {"name": "mul_divp_cancel", "description": ""}, {"name": "add_units.mk_of_add_eq_zero", "description": "For `a, b` in an `add_comm_monoid` such that `a + b = 0`, makes an add_unit\nout of `a`."}, {"name": "units.mul_inv_cancel_left", "description": ""}, {"name": "units.inv_eq_coe_inv", "description": ""}, {"name": "units.ext_iff", "description": ""}, {"name": "is_unit.unit", "description": " The element of the group of units, corresponding to an element of a monoid which is a unit. When\n`\u03b1` is a `division_monoid`, use `is_unit.unit'` instead."}, {"name": "is_add_unit.add_left_cancel", "description": ""}, {"name": "add_units.coe_zero", "description": ""}, {"name": "is_unit.mul_right_injective", "description": ""}, {"name": "add_units.neg_eq_coe_neg", "description": ""}, {"name": "units.inv_mk", "description": ""}, {"name": "add_units.eq_iff", "description": ""}, {"name": "units.mk_of_mul_eq_one", "description": "For `a, b` in a `comm_monoid` such that `a * b = 1`, makes a unit out of `a`."}, {"name": "is_add_unit_of_add_eq_zero", "description": ""}, {"name": "inv_eq_one_divp", "description": "Used for `field_simp` to deal with inverses of units."}, {"name": "add_units.is_add_unit_add_unit", "description": ""}, {"name": "is_add_unit.add_left_injective", "description": ""}, {"name": "is_add_unit", "description": "An element `a : M` of an add_monoid is an `add_unit` if it has\na two-sided additive inverse. The actual definition says that `a` is equal to some\n`u : add_units M`, where `add_units M` is a bundled version of `is_add_unit`."}, {"name": "coe_div_eq_divp", "description": "`field_simp` moves division inside `\u03b1\u02e3` to the right, and this lemma\nlifts the calculation to `\u03b1`."}, {"name": "comm_group_of_is_unit", "description": "Constructs a `comm_group` structure on a `comm_monoid` consisting only of units."}, {"name": "add_units.add_group", "description": "Additive units of an additive monoid form an additive group."}, {"name": "add_units.neg_eq_of_add_eq_zero_left", "description": ""}, {"name": "add_units.mk_coe", "description": ""}, {"name": "units.mul_inv_of_eq", "description": ""}, {"name": "is_unit_of_mul_is_unit_right", "description": ""}, {"name": "units.can_lift", "description": ""}, {"name": "add_units.add_neg_eq_zero", "description": ""}, {"name": "group_of_is_unit", "description": "Constructs a `group` structure on a `monoid` consisting only of units."}, {"name": "units.eq_mul_inv_iff_mul_eq", "description": ""}, {"name": "is_add_unit.add_left_inj", "description": ""}, {"name": "add_units.val_eq_coe", "description": ""}, {"name": "is_add_unit.exists_neg", "description": ""}, {"name": "units.mul_right_inj", "description": ""}, {"name": "units.decidable_eq", "description": ""}, {"name": "add_units.coe_add", "description": ""}, {"name": "units.mul_inv_eq_one", "description": ""}, {"name": "divp_inv", "description": ""}, {"name": "is_unit.mul_coe_inv", "description": ""}, {"name": "add_units.has_coe", "description": ""}, {"name": "is_add_unit_of_add_is_add_unit_left", "description": ""}, {"name": "add_units.coe_mk", "description": ""}, {"name": "add_units.has_neg", "description": ""}, {"name": "divp_assoc'", "description": "`field_simp` needs the reverse direction of `divp_assoc` to move all `/\u209a` to the right."}, {"name": "units.inv_eq_of_mul_eq_one_right", "description": ""}, {"name": "divp_one", "description": ""}, {"name": "add_units.ext", "description": ""}, {"name": "units", "description": " Units of a `monoid`, bundled version. Notation: `\u03b1\u02e3`.\n\nAn element of a `monoid` is a unit if it has a two-sided inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `is_unit`."}, {"name": "units.val", "description": " Units of a `monoid`, bundled version. Notation: `\u03b1\u02e3`.\n\nAn element of a `monoid` is a unit if it has a two-sided inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `is_unit`."}, {"name": "units.inv", "description": " Units of a `monoid`, bundled version. Notation: `\u03b1\u02e3`.\n\nAn element of a `monoid` is a unit if it has a two-sided inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `is_unit`."}, {"name": "units.val_inv", "description": " Units of a `monoid`, bundled version. Notation: `\u03b1\u02e3`.\n\nAn element of a `monoid` is a unit if it has a two-sided inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `is_unit`."}, {"name": "units.inv_val", "description": " Units of a `monoid`, bundled version. Notation: `\u03b1\u02e3`.\n\nAn element of a `monoid` is a unit if it has a two-sided inverse.\nThis version bundles the inverse element so that it can be computed.\nFor a predicate see `is_unit`."}, {"name": "units.mul_eq_one_iff_eq_inv", "description": ""}, {"name": "divp", "description": "Partial division. It is defined when the\n second argument is invertible, and unlike the division operator\n in `division_ring` it is not totalized at zero."}, {"name": "units.inv_mul_eq_one", "description": ""}, {"name": "one_divp", "description": ""}, {"name": "divp_eq_divp_iff", "description": ""}, {"name": "units.inv_unique", "description": ""}, {"name": "add_units.copy", "description": "Copy an `add_unit`, adjusting definitional equalities."}, {"name": "units.mul_inv_cancel_right", "description": ""}, {"name": "units.has_coe", "description": ""}, {"name": "units.coe_mul", "description": ""}, {"name": "divp_mul_divp", "description": ""}, {"name": "add_units.can_lift", "description": ""}, {"name": "units.inv_mul_cancel_right", "description": ""}, {"name": "add_units.neg_add_cancel_left", "description": ""}, {"name": "is_unit.mul_left_injective", "description": ""}, {"name": "units.is_unit_mul_units", "description": "Multiplication by a `u : M\u02e3` on the right doesn't affect `is_unit`."}, {"name": "set.dual_Ioo", "description": ""}, {"name": "set.right_mem_Ico", "description": ""}, {"name": "set.Ioc_inter_Ioo_of_left_lt", "description": ""}, {"name": "set.Iic_diff_right", "description": ""}, {"name": "set.not_mem_Ico_of_ge", "description": ""}, {"name": "set.Ioo_insert_left", "description": ""}, {"name": "set.Ioo_subset_Ioo", "description": ""}, {"name": "order_iso.Ici_bot", "description": "Order isomorphism between `Ici (\u22a5 : \u03b1)` and `\u03b1` when `\u03b1` has a bottom element"}, {"name": "set.Ioo_union_Ioo", "description": ""}, {"name": "is_top.Iic_eq", "description": ""}, {"name": "set.left_mem_Ioo", "description": ""}, {"name": "set.Ioc_top", "description": ""}, {"name": "set.Ioo_subset_Ioi_self", "description": ""}, {"name": "set.Ioi_ssubset_Ici_self", "description": ""}, {"name": "set.Iic.no_min_order", "description": ""}, {"name": "set.Iic_inter_Iic", "description": ""}, {"name": "set.Icc_subset_Ici_self", "description": ""}, {"name": "set.decidable_mem_Ioi", "description": ""}, {"name": "set.Ico_self", "description": ""}, {"name": "set.Ioc_diff_Iic", "description": ""}, {"name": "set.nonempty_Ioo_subtype", "description": ""}, {"name": "set.Ico_def", "description": ""}, {"name": "set.Iic_union_Icc_eq_Iic", "description": ""}, {"name": "set.Ioo_union_Ioi", "description": ""}, {"name": "set.decidable_mem_Icc", "description": ""}, {"name": "set.Iic_union_Icc'", "description": ""}, {"name": "order_iso.preimage_Iic", "description": ""}, {"name": "set.inv_mem_Ioo_iff", "description": ""}, {"name": "set.Iio_def", "description": ""}, {"name": "set.nonempty_Icc", "description": ""}, {"name": "set.Ioo_subset_Ioc_union_Ico", "description": ""}, {"name": "set.not_mem_Iio", "description": ""}, {"name": "set.Ioc_subset_Ioc_left", "description": ""}, {"name": "set.Iio_union_Ico'", "description": ""}, {"name": "set.Ioi_subset_Ioi_iff", "description": ""}, {"name": "set.Ico_subset_Ici_self", "description": ""}, {"name": "set.Icc_subset_Icc_left", "description": ""}, {"name": "set.add_mem_Ioo_iff_left", "description": ""}, {"name": "set.Ioc_subset_Iic_self", "description": ""}, {"name": "set.Icc_eq_empty_iff", "description": ""}, {"name": "set.mem_Ico", "description": ""}, {"name": "set.Iic_union_Ici", "description": ""}, {"name": "set.nonempty_Ico_subtype", "description": ""}, {"name": "set.Ioo_subset_Ioo_iff", "description": ""}, {"name": "set.Iic_union_Ioc_eq_Iic", "description": ""}, {"name": "order_iso.preimage_Ioi", "description": ""}, {"name": "set.mem_Ioc", "description": ""}, {"name": "set.Ico_subset_Icc_self", "description": ""}, {"name": "set.mem_Ioo", "description": ""}, {"name": "set.Icc_subset_Ioi_iff", "description": ""}, {"name": "set.Ioo_eq_empty_iff", "description": ""}, {"name": "set.Icc_subset_Ioo_iff", "description": ""}, {"name": "set.Icc_union_Ici_eq_Ici", "description": ""}, {"name": "set.Ico_union_Ico'", "description": ""}, {"name": "set.Iio.no_min_order", "description": ""}, {"name": "set.neg_mem_Ico_iff", "description": ""}, {"name": "set.Ico_subset_Ico_union_Ico", "description": ""}, {"name": "set.Ioi_inter_Iio", "description": ""}, {"name": "set.Ici_subset_Ioi", "description": ""}, {"name": "set.Iic_def", "description": ""}, {"name": "set.compl_Iic", "description": ""}, {"name": "set.Ioc_diff_Ioo_same", "description": ""}, {"name": "set.decidable_mem_Iic", "description": ""}, {"name": "set.nonempty_Ioc_subtype", "description": ""}, {"name": "set.Ico_eq_empty_of_le", "description": ""}, {"name": "set.Ioo_union_right", "description": ""}, {"name": "set.Iio_union_Ioo", "description": ""}, {"name": "set.Ioc_subset_Ioi_self", "description": ""}, {"name": "order_iso.image_Ico", "description": ""}, {"name": "set.Ioc_def", "description": ""}, {"name": "set.Ioi_union_left", "description": ""}, {"name": "set.add_mem_Ioc_iff_left", "description": ""}, {"name": "set.right_mem_Iic", "description": ""}, {"name": "set.not_mem_Ioo_of_ge", "description": ""}, {"name": "set.Icc_diff_Ioo_same", "description": ""}, {"name": "set.decidable_mem_Ioc", "description": ""}, {"name": "set.Icc_subset_Icc_iff", "description": ""}, {"name": "set.Ico_bot", "description": ""}, {"name": "set.mem_Iic", "description": ""}, {"name": "set.mem_Icc_of_Ioo", "description": ""}, {"name": "set.Iic_diff_Iio", "description": ""}, {"name": "set.Ioi_subset_Ioo_union_Ici", "description": ""}, {"name": "set.nonempty_Iio", "description": ""}, {"name": "set.Iio_subset_Iic", "description": " If `a \u2264 b`, then `(-\u221e, a) \u2286 (-\u221e, b]`. In preorders, this is just an implication. If you need\nthe equivalence in dense linear orders, use `Iio_subset_Iic_iff`."}, {"name": "set.not_mem_Ioi", "description": ""}, {"name": "set.Iic_union_Ioo_eq_Iio", "description": ""}, {"name": "set.Iic_diff_Iic", "description": ""}, {"name": "set.Ioi.no_min_order", "description": ""}, {"name": "set.Iic_prod_eq", "description": ""}, {"name": "set.Icc_subset_Icc", "description": ""}, {"name": "set.Icc_subset_Ico_right", "description": ""}, {"name": "set.Ioi_diff_Ioi", "description": ""}, {"name": "set.Ico_union_right", "description": ""}, {"name": "set.Ioc_union_Ici_eq_Ioi", "description": ""}, {"name": "set.Ioo_union_Ici_eq_Ioi", "description": ""}, {"name": "set.Ico_union_Ico", "description": ""}, {"name": "set.Ico_subset_Ico", "description": ""}, {"name": "set.Iic_inter_Ici", "description": ""}, {"name": "set.Ico_eq_Ico_iff", "description": ""}, {"name": "set.mem_Ioc_of_Ioo", "description": ""}, {"name": "order_iso.image_Ici", "description": ""}, {"name": "set.mem_Ici_of_Ioi", "description": ""}, {"name": "set.Icc_diff_Ico_same", "description": ""}, {"name": "set.nonempty_Ioi", "description": ""}, {"name": "set.Ioc_union_Ioc_symm", "description": ""}, {"name": "set.Ioi_subset_Ioc_union_Ici", "description": ""}, {"name": "set.Icc_subset_Icc_union_Ioc", "description": ""}, {"name": "set.Ici_diff_Ici", "description": ""}, {"name": "set.Iic", "description": "Left-infinite right-closed interval"}, {"name": "set.Icc_subset_Icc_union_Icc", "description": ""}, {"name": "set.Ioo_subset_Ioc_self", "description": ""}, {"name": "set.left_mem_Icc", "description": ""}, {"name": "set.Ico_inter_Ici", "description": ""}, {"name": "set.Ioo_inter_Ioo", "description": ""}, {"name": "set.Ioc_union_Ico_eq_Ioo", "description": ""}, {"name": "set.Ioc_subset_Ioo_right", "description": ""}, {"name": "set.Ioi_insert", "description": ""}, {"name": "set.Icc_subset_Ico_iff", "description": ""}, {"name": "set.Ico_eq_empty_iff", "description": ""}, {"name": "set.Icc_union_Ioc_eq_Icc", "description": ""}, {"name": "set.decidable_mem_Ico", "description": ""}, {"name": "order_iso.image_Ioc", "description": ""}, {"name": "set.sub_mem_Icc_iff_left", "description": ""}, {"name": "set.Ioc", "description": "Left-open right-closed interval"}, {"name": "set.Icc_ssubset_Icc_right", "description": ""}, {"name": "set.Iio_inter_Iio", "description": ""}, {"name": "set.Ici_subset_Icc_union_Ioi", "description": ""}, {"name": "set.left_mem_Ioc", "description": ""}, {"name": "set.Ici_diff_left", "description": ""}, {"name": "set.Icc_union_Ioo_eq_Ico", "description": ""}, {"name": "set.Icc_union_Icc_eq_Icc", "description": ""}, {"name": "set.right_mem_Ioc", "description": ""}, {"name": "set.Icc_prod_Icc", "description": ""}, {"name": "set.Iio_diff_Iic", "description": ""}, {"name": "set.Icc_diff_Ioc_same", "description": ""}, {"name": "set.nonempty_Ici", "description": ""}, {"name": "set.Icc_union_Icc'", "description": ""}, {"name": "set.Icc", "description": "Left-closed right-closed interval"}, {"name": "set.Icc_bot", "description": ""}, {"name": "set.Icc_subset_Iic_self", "description": ""}, {"name": "set.Icc_diff_right", "description": ""}, {"name": "set.neg_mem_Ioo_iff", "description": ""}, {"name": "set.Ioo.no_max_order", "description": ""}, {"name": "set.nonempty_Ico", "description": ""}, {"name": "set.Icc_diff_both", "description": ""}, {"name": "set.Iic_union_Ioc'", "description": ""}, {"name": "set.Ioc_union_Icc_eq_Ioc", "description": ""}, {"name": "set.Ico_diff_Iio", "description": ""}, {"name": "set.Iio_union_Ici_of_le", "description": ""}, {"name": "set.neg_mem_Icc_iff", "description": ""}, {"name": "set.Ioo_subset_Iio_self", "description": ""}, {"name": "set.Ioc_inter_Iic", "description": ""}, {"name": "set.Ioi_subset_Ici_self", "description": ""}, {"name": "set.Icc_self", "description": ""}, {"name": "set.mem_Icc_iff_abs_le", "description": ""}, {"name": "set.Ici_subset_Ico_union_Ici", "description": ""}, {"name": "set.mem_Ioi", "description": ""}, {"name": "set.Ioc_subset_Ioc_union_Ioc", "description": ""}, {"name": "set.Iio_diff_Iio", "description": ""}, {"name": "set.Iic_union_Ici_of_le", "description": ""}, {"name": "set.Ioo_eq_empty_of_le", "description": ""}, {"name": "set.Iio_union_Ioo'", "description": ""}, {"name": "set.Ioc_subset_Ioc_right", "description": ""}, {"name": "set.Ici_def", "description": ""}, {"name": "set.Iio_subset_Iio_union_Ico", "description": ""}, {"name": "set.not_mem_Ico_of_lt", "description": ""}, {"name": "set.Iic_union_Ioi_of_le", "description": ""}, {"name": "set.sub_mem_Ioc_iff_right", "description": ""}, {"name": "set.Iio_union_Ici", "description": ""}, {"name": "order_iso.image_Iic", "description": ""}, {"name": "set.Ico_insert_right", "description": ""}, {"name": "set.Ioc_insert_left", "description": ""}, {"name": "set.Ioc_subset_Ioc_union_Icc", "description": ""}, {"name": "set.Icc_union_Ici'", "description": ""}, {"name": "order_iso.Iic_top", "description": "Order isomorphism between `Iic (\u22a4 : \u03b1)` and `\u03b1` when `\u03b1` has a top element"}, {"name": "set.Ioc_diff_right", "description": ""}, {"name": "set.Icc_union_Ioi_eq_Ici", "description": ""}, {"name": "set.Ico_union_Ico_eq_Ico", "description": ""}, {"name": "set.Icc_eq_empty_of_lt", "description": ""}, {"name": "set.Ioi_inter_Iic", "description": ""}, {"name": "set.Ioc_inter_Ioo_of_right_le", "description": ""}, {"name": "set.Ioo_subset_Ioo_union_Ico", "description": ""}, {"name": "set.Ico_union_Icc_eq_Icc", "description": ""}, {"name": "set.Ioc_subset_Ioo_union_Icc", "description": ""}, {"name": "set.Icc_def", "description": ""}, {"name": "set.mem_Ico_of_Ioo", "description": ""}, {"name": "set.sub_mem_Ioc_iff_left", "description": ""}, {"name": "set.nonempty_Icc_subtype", "description": ""}, {"name": "set.Ici_prod_eq", "description": ""}, {"name": "set.Iic_union_Icc", "description": ""}, {"name": "set.Ici_diff_Ioi_same", "description": ""}, {"name": "set.Ioc_union_Ioo_eq_Ioo", "description": ""}, {"name": "set.compl_Ioi", "description": ""}, {"name": "is_bot.Ici_eq", "description": ""}, {"name": "set.dual_Iic", "description": ""}, {"name": "set.Iio_union_Ico_eq_Iio", "description": ""}, {"name": "set.Icc_union_Ici", "description": ""}, {"name": "set.Iio_inter_Ioi", "description": ""}, {"name": "set.Ioc_union_Ioc'", "description": ""}, {"name": "set.nonempty_Iio_subtype", "description": "In an order without minimal elements, the intervals `Iio` are nonempty."}, {"name": "set.Ico_diff_left", "description": ""}, {"name": "order_iso.image_Ioo", "description": ""}, {"name": "order_iso.image_Icc", "description": ""}, {"name": "set.Ico_eq_empty", "description": ""}, {"name": "set.Iic_subset_Iio_union_Icc", "description": ""}, {"name": "set.Ico_diff_Ioo_same", "description": ""}, {"name": "set.Ioi_subset_Ici_iff", "description": ""}, {"name": "set.Iio_ssubset_Iic_self", "description": ""}, {"name": "set.inv_mem_Icc_iff", "description": ""}, {"name": "set.Icc_ssubset_Icc_left", "description": ""}, {"name": "set.eq_left_or_mem_Ioo_of_mem_Ico", "description": ""}, {"name": "set.Ico_subset_Ioo_left", "description": ""}, {"name": "set.Ioc_union_Ioc", "description": ""}, {"name": "set.Icc_prod_eq", "description": ""}, {"name": "set.Icc_inter_Icc_eq_singleton", "description": ""}, {"name": "set.Ioo_inter_Ioc_of_right_lt", "description": ""}, {"name": "set.inv_mem_Ico_iff", "description": ""}, {"name": "order_iso.preimage_Ici", "description": ""}, {"name": "set.Ioc_inter_Ioc", "description": ""}, {"name": "set.sub_mem_Ico_iff_left", "description": ""}, {"name": "set.Ico_subset_Iio_self", "description": ""}, {"name": "set.Ici_inter_Iic", "description": ""}, {"name": "set.Ico_union_Ici_eq_Ici", "description": ""}, {"name": "set.Iic_inter_Ioc_of_le", "description": ""}, {"name": "set.Iio_subset_Iio_iff", "description": ""}, {"name": "set.Ioo_subset_Icc_self", "description": ""}, {"name": "set.Iio_union_Icc_eq_Iic", "description": ""}, {"name": "set.dual_Ico", "description": ""}, {"name": "set.nonempty_Ioi_subtype", "description": "In an order without maximal elements, the intervals `Ioi` are nonempty."}, {"name": "order_iso.preimage_Iio", "description": ""}, {"name": "set.Ici_inter_Iio", "description": ""}, {"name": "set.Ico", "description": "Left-closed right-open interval"}, {"name": "set.nonempty_Ico_sdiff", "description": "If we remove a smaller interval from a larger, the result is nonempty"}, {"name": "set.Iio_subset_Iio", "description": " If `a \u2264 b`, then `(-\u221e, a) \u2286 (-\u221e, b)`. In preorders, this is just an implication. If you need\nthe equivalence in linear orders, use `Iio_subset_Iio_iff`."}, {"name": "is_max.Ici_eq", "description": ""}, {"name": "set.Iio.no_max_order", "description": ""}, {"name": "set.Icc_subset_Iio_iff", "description": ""}, {"name": "set.Icc_eq_empty", "description": ""}, {"name": "set.Iio_union_Ioi_of_lt", "description": ""}, {"name": "set.right_mem_Ioo", "description": ""}, {"name": "set.Ioc_union_Ioi'", "description": ""}, {"name": "set.Iic_subset_Iic", "description": ""}, {"name": "set.Iic_subset_Iic_union_Ioc", "description": ""}, {"name": "set.Ici_top", "description": ""}, {"name": "set.Ioo_union_Ioi'", "description": ""}, {"name": "set.Ici_inter_Ici", "description": ""}, {"name": "order_iso.preimage_Ioo", "description": ""}, {"name": "set.eq_right_or_mem_Ioo_of_mem_Ioc", "description": ""}, {"name": "set.Iio_bot", "description": ""}, {"name": "set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset", "description": ""}, {"name": "set.inv_mem_Ioc_iff", "description": ""}, {"name": "set.add_mem_Icc_iff_left", "description": ""}, {"name": "set.mem_Iic_Iio_of_subset_of_subset", "description": ""}, {"name": "set.Ici.no_max_order", "description": ""}, {"name": "set.Iic_subset_Iic_union_Icc", "description": ""}, {"name": "set.mem_Ici", "description": ""}, {"name": "set.nonempty_Ioc", "description": ""}, {"name": "set.mem_Iic_of_Iio", "description": ""}, {"name": "set.Iio_inter_Ici", "description": ""}, {"name": "set.Ioc_eq_empty", "description": ""}, {"name": "set.Ioi_subset_Ioc_union_Ioi", "description": ""}, {"name": "set.not_mem_Ici", "description": ""}, {"name": "set.not_mem_Ioc_of_gt", "description": ""}, {"name": "set.Iic_bot", "description": ""}, {"name": "set.not_mem_Icc_of_gt", "description": ""}, {"name": "set.Ioi_subset_Ici", "description": " If `a \u2264 b`, then `(b, +\u221e) \u2286 [a, +\u221e)`. In preorders, this is just an implication. If you need\nthe equivalence in dense linear orders, use `Ioi_subset_Ici_iff`."}, {"name": "set.Iio_subset_Iic_iff", "description": ""}, {"name": "set.Iic_inter_Ioi", "description": ""}, {"name": "set.dual_Icc", "description": ""}, {"name": "set.Ioo_union_Ico_eq_Ioo", "description": ""}, {"name": "set.left_mem_Ici", "description": ""}, {"name": "set.Ioo_union_Ioo'", "description": ""}, {"name": "set.neg_mem_Ioc_iff", "description": ""}, {"name": "set.Ioo.no_min_order", "description": ""}, {"name": "set.add_mem_Ico_iff_left", "description": ""}, {"name": "set.not_mem_Ioc_of_le", "description": ""}, {"name": "set.Iio_union_Ioi", "description": ""}, {"name": "set.left_mem_Ico", "description": ""}, {"name": "set.Ioc_inter_Ioi", "description": ""}, {"name": "set.Ico_subset_Icc_union_Ioo", "description": ""}, {"name": "set.Iio_union_Ico", "description": ""}, {"name": "set.Ioi_subset_Ioi", "description": " If `a \u2264 b`, then `(b, +\u221e) \u2286 (a, +\u221e)`. In preorders, this is just an implication. If you need\nthe equivalence in linear orders, use `Ioi_subset_Ioi_iff`."}, {"name": "set.Ioi_def", "description": ""}, {"name": "is_min.Iic_eq", "description": ""}, {"name": "set.dual_Ioc", "description": ""}, {"name": "set.sub_mem_Ioo_iff_right", "description": ""}, {"name": "set.Ici_bot", "description": ""}, {"name": "set.Iic_subset_Iio", "description": ""}, {"name": "set.Ico_subset_Ico_left", "description": ""}, {"name": "set.Ioo_union_Icc_eq_Ioc", "description": ""}, {"name": "set.add_mem_Icc_iff_right", "description": ""}, {"name": "set.Icc_subset_Ici_iff", "description": ""}, {"name": "order_iso.image_Iio", "description": ""}, {"name": "set.Icc_union_Ico_eq_Ico", "description": ""}, {"name": "set.not_mem_Iic", "description": ""}, {"name": "set.Ici", "description": "Left-closed right-infinite interval"}, {"name": "set.eq_endpoints_or_mem_Ioo_of_mem_Icc", "description": ""}, {"name": "set.Icc_subset_Ico_union_Icc", "description": ""}, {"name": "set.Ici_subset_Ici", "description": ""}, {"name": "set.Ico.no_max_order", "description": ""}, {"name": "set.Iic_union_Ioi", "description": ""}, {"name": "set.decidable_mem_Iio", "description": ""}, {"name": "set.mem_Ici_Ioi_of_subset_of_subset", "description": ""}, {"name": "set.Ioo", "description": "Left-open right-open interval"}, {"name": "set.Icc_top", "description": ""}, {"name": "set.Icc_subset_Icc_right", "description": ""}, {"name": "set.Iic_prod_Iic", "description": ""}, {"name": "set.Ioc_union_Ioc_union_Ioc_cycle", "description": ""}, {"name": "set.Ioc_self", "description": ""}, {"name": "set.decidable_mem_Ici", "description": ""}, {"name": "set.Iio_insert", "description": ""}, {"name": "set.Ici_prod_Ici", "description": ""}, {"name": "set.mem_Icc_of_Ioc", "description": ""}, {"name": "set.Ioi_diff_Ici", "description": ""}, {"name": "set.dual_Ici", "description": ""}, {"name": "set.sub_mem_Ioo_iff_left", "description": ""}, {"name": "set.add_mem_Ico_iff_right", "description": ""}, {"name": "set.Icc_eq_singleton_iff", "description": ""}, {"name": "set.Ico_subset_Icc_union_Ico", "description": ""}, {"name": "set.mem_Iio", "description": ""}, {"name": "set.Iic_union_Ico_eq_Iio", "description": ""}, {"name": "order_iso.preimage_Icc", "description": ""}, {"name": "set.Ioo_insert_right", "description": ""}, {"name": "set.Ioo_def", "description": ""}, {"name": "order_iso.preimage_Ico", "description": ""}, {"name": "is_min.Iio_eq", "description": ""}, {"name": "order_iso.preimage_Ioc", "description": ""}, {"name": "set.Ioo_subset_Ioo_left", "description": ""}, {"name": "set.Ioi", "description": "Left-open right-infinite interval"}, {"name": "set.Iio", "description": "Left-infinite right-open interval"}, {"name": "set.Ici_diff_Ioi", "description": ""}, {"name": "set.Icc_bot_top", "description": ""}, {"name": "set.Ico_union_Ici", "description": ""}, {"name": "set.Ioo_subset_Ioo_right", "description": ""}, {"name": "set.nonempty_Ioo", "description": ""}, {"name": "set.right_mem_Icc", "description": ""}, {"name": "set.not_mem_Ioo_of_le", "description": ""}, {"name": "set.Iio_subset_Iic_union_Ioo", "description": ""}, {"name": "set.nonempty_Iic", "description": ""}, {"name": "set.sub_mem_Icc_iff_right", "description": ""}, {"name": "set.Ioc_eq_empty_of_le", "description": ""}, {"name": "set.Ioi_top", "description": ""}, {"name": "set.Iio_union_right", "description": ""}, {"name": "set.Icc_union_Icc", "description": "We cannot replace `<` by `\u2264` in the hypotheses.\nOtherwise for `b < a = d < c` the l.h.s. is `\u2205` and the r.h.s. is `{a}`."}, {"name": "order_iso.image_Ioi", "description": ""}, {"name": "set.Ico_inter_Ico", "description": ""}, {"name": "set.Icc_inter_Icc", "description": ""}, {"name": "set.Icc_subset_Iic_iff", "description": ""}, {"name": "set.Icc_subset_Ioo", "description": ""}, {"name": "set.Iic_top", "description": ""}, {"name": "set.dual_Ioi", "description": ""}, {"name": "set.Ioc_union_Ioc_right", "description": ""}, {"name": "set.sub_mem_Ico_iff_right", "description": ""}, {"name": "set.Ioc_union_Ioc_eq_Ioc", "description": ""}, {"name": "set.Ioc_union_left", "description": ""}, {"name": "set.mem_Icc", "description": ""}, {"name": "set.Iio_subset_Iic_union_Ico", "description": ""}, {"name": "set.Ioo_eq_empty", "description": ""}, {"name": "set.Ioc_eq_empty_iff", "description": ""}, {"name": "set.Ioc_union_Ioc_left", "description": ""}, {"name": "set.add_mem_Ioc_iff_right", "description": ""}, {"name": "set.compl_Iio", "description": ""}, {"name": "set.Ioc_diff_Ioi", "description": ""}, {"name": "set.compl_Ici", "description": ""}, {"name": "set.Ioc_subset_Ioc", "description": ""}, {"name": "set.Ico_union_Ici'", "description": ""}, {"name": "set.Ioi_inter_Ioi", "description": ""}, {"name": "is_max.Ioi_eq", "description": ""}, {"name": "set.Ico_inter_Iio", "description": ""}, {"name": "set.Iic_union_Ioc", "description": ""}, {"name": "set.Icc_subset_Ioc_iff", "description": ""}, {"name": "set.Iio_subset_Iic_self", "description": ""}, {"name": "set.Ico_subset_Ico_right", "description": ""}, {"name": "set.Ioo_union_left", "description": ""}, {"name": "set.Ioo_subset_Ioc_union_Ioo", "description": ""}, {"name": "set.dual_Iio", "description": ""}, {"name": "set.Ico_subset_Ico_iff", "description": ""}, {"name": "set.decidable_mem_Ioo", "description": ""}, {"name": "set.Ici_subset_Icc_union_Ici", "description": ""}, {"name": "set.Ioi.no_max_order", "description": ""}, {"name": "set.mem_Icc_of_Ico", "description": ""}, {"name": "set.nonempty_Ici_subtype", "description": "An interval `Ici a` is nonempty."}, {"name": "set.Ioc.no_min_order", "description": ""}, {"name": "set.Iic_diff_Iio_same", "description": ""}, {"name": "set.Ioo_subset_Ico_self", "description": ""}, {"name": "set.nonempty_Iic_subtype", "description": "An interval `Iic a` is nonempty."}, {"name": "set.Ioo_self", "description": ""}, {"name": "set.Ioc_union_Ioi_eq_Ioi", "description": ""}, {"name": "set.Ioc_union_Ioi", "description": ""}, {"name": "set.Icc_diff_left", "description": ""}, {"name": "set.Ioc_subset_Icc_self", "description": ""}, {"name": "set.not_mem_Icc_of_lt", "description": ""}, {"name": "set.Ioo_inter_Ioc_of_left_le", "description": ""}, {"name": "set.add_mem_Ioo_iff_right", "description": ""}, {"name": "set.Ioc_subset_Ioc_iff", "description": ""}, {"name": "heq.elim", "description": ""}, {"name": "iff.refl", "description": ""}, {"name": "if_ctx_simp_congr_prop", "description": ""}, {"name": "as_false", "description": ""}, {"name": "transitive", "description": ""}, {"name": "true_and", "description": ""}, {"name": "heq_of_eq_rec_left", "description": ""}, {"name": "commutative", "description": ""}, {"name": "if_t_t", "description": ""}, {"name": "exists_prop_decidable", "description": ""}, {"name": "ite.decidable", "description": ""}, {"name": "subsingleton.elim", "description": ""}, {"name": "as_true", "description": ""}, {"name": "imp_congr_ctx", "description": ""}, {"name": "right_commutative", "description": ""}, {"name": "decidable.of_not_not", "description": ""}, {"name": "ulift", "description": "Universe lifting operation"}, {"name": "ulift.down", "description": "Universe lifting operation"}, {"name": "decidable_of_decidable_of_iff", "description": ""}, {"name": "non_contradictory", "description": ""}, {"name": "decidable_eq_inl_refl", "description": ""}, {"name": "subsingleton.helim", "description": ""}, {"name": "iff.symm", "description": ""}, {"name": "and.imp", "description": ""}, {"name": "decidable.rec_on_true", "description": ""}, {"name": "ne.decidable", "description": ""}, {"name": "or.by_cases", "description": ""}, {"name": "let_body_eq", "description": ""}, {"name": "not_of_iff_false", "description": ""}, {"name": "is_dec_eq", "description": ""}, {"name": "flip", "description": ""}, {"name": "true_iff_false", "description": ""}, {"name": "iff.rfl", "description": ""}, {"name": "id", "description": ""}, {"name": "or.assoc", "description": ""}, {"name": "arbitrary", "description": ""}, {"name": "congr_fun", "description": ""}, {"name": "ne_false_of_self", "description": ""}, {"name": "associative", "description": ""}, {"name": "left_commutative", "description": ""}, {"name": "dite.decidable", "description": ""}, {"name": "if_congr", "description": ""}, {"name": "implies_of_if_pos", "description": ""}, {"name": "and_iff_left", "description": ""}, {"name": "reflexive", "description": ""}, {"name": "and_assoc", "description": ""}, {"name": "ne_true_of_not", "description": ""}, {"name": "bool.decidable_eq", "description": ""}, {"name": "if_ctx_congr_prop", "description": ""}, {"name": "of_heq_true", "description": ""}, {"name": "or.imp_right", "description": ""}, {"name": "non_contradictory_intro", "description": ""}, {"name": "and_congr", "description": ""}, {"name": "is_dec_refl", "description": ""}, {"name": "and.comm", "description": ""}, {"name": "imp_congr_right", "description": ""}, {"name": "and.symm", "description": ""}, {"name": "true_ne_false", "description": ""}, {"name": "exists_unique_of_exists_of_unique", "description": ""}, {"name": "right_comm", "description": ""}, {"name": "dif_pos", "description": ""}, {"name": "nonempty.elim", "description": ""}, {"name": "not_and_self", "description": ""}, {"name": "implies.decidable", "description": ""}, {"name": "not_non_contradictory_iff_absurd", "description": ""}, {"name": "iff_false_intro", "description": ""}, {"name": "true_iff", "description": ""}, {"name": "cast", "description": ""}, {"name": "if_pos", "description": ""}, {"name": "not.decidable", "description": ""}, {"name": "or_iff_right_of_imp", "description": ""}, {"name": "and.swap", "description": ""}, {"name": "iff_true_intro", "description": ""}, {"name": "and_true", "description": ""}, {"name": "xor.decidable", "description": ""}, {"name": "or.imp", "description": ""}, {"name": "opt_param_eq", "description": ""}, {"name": "exists_unique.intro", "description": ""}, {"name": "to_bool_false_eq_ff", "description": ""}, {"name": "false_of_ne", "description": ""}, {"name": "if_ctx_congr", "description": ""}, {"name": "false_iff", "description": ""}, {"name": "exists_unique", "description": ""}, {"name": "bool.inhabited", "description": ""}, {"name": "let_value_heq", "description": ""}, {"name": "ulift.up_down", "description": ""}, {"name": "nonempty_of_exists", "description": ""}, {"name": "eq.substr", "description": ""}, {"name": "to_bool_true_eq_tt", "description": ""}, {"name": "if_simp_congr_prop", "description": ""}, {"name": "if_true", "description": ""}, {"name": "exists_of_exists_unique", "description": ""}, {"name": "false_iff_true", "description": ""}, {"name": "trans_rel_right", "description": ""}, {"name": "trivial", "description": ""}, {"name": "subsingleton", "description": ""}, {"name": "subsingleton.intro", "description": ""}, {"name": "inv_image.irreflexive", "description": ""}, {"name": "not_of_eq_false", "description": ""}, {"name": "of_as_true", "description": ""}, {"name": "false_implies_iff", "description": ""}, {"name": "false_or", "description": ""}, {"name": "left_identity", "description": ""}, {"name": "and.left_comm", "description": ""}, {"name": "or.neg_resolve_left", "description": ""}, {"name": "anti_symmetric", "description": ""}, {"name": "and_implies", "description": ""}, {"name": "not.intro", "description": ""}, {"name": "true.inhabited", "description": ""}, {"name": "congr_arg", "description": ""}, {"name": "id.def", "description": ""}, {"name": "eq.mp", "description": ""}, {"name": "left_cancelative", "description": ""}, {"name": "eq_comm", "description": ""}, {"name": "decidable.by_contradiction", "description": ""}, {"name": "decidable.rec_on_false", "description": ""}, {"name": "iff_self", "description": ""}, {"name": "true_eq_false_of_false", "description": ""}, {"name": "left_distributive", "description": ""}, {"name": "or_iff_left_of_imp", "description": ""}, {"name": "right_inverse", "description": ""}, {"name": "and_comm", "description": ""}, {"name": "right_distributive", "description": ""}, {"name": "exists.elim", "description": ""}, {"name": "false_of_true_eq_false", "description": ""}, {"name": "true_implies_iff", "description": ""}, {"name": "implies", "description": ""}, {"name": "decidable.subsingleton", "description": ""}, {"name": "heq_of_eq_of_heq", "description": ""}, {"name": "imp_congr", "description": ""}, {"name": "or.swap", "description": ""}, {"name": "not_of_not_not_not", "description": ""}, {"name": "equivalence", "description": ""}, {"name": "or.resolve_right", "description": ""}, {"name": "eq.mpr", "description": ""}, {"name": "eq_rec_compose", "description": ""}, {"name": "ne.symm", "description": ""}, {"name": "mk_equivalence", "description": ""}, {"name": "or.left_comm", "description": ""}, {"name": "or.comm", "description": ""}, {"name": "non_contradictory_em", "description": ""}, {"name": "ne.irrefl", "description": ""}, {"name": "subsingleton_prop", "description": ""}, {"name": "plift", "description": "Universe lifting operation from Sort to Type"}, {"name": "plift.down", "description": "Universe lifting operation from Sort to Type"}, {"name": "dif_ctx_congr", "description": ""}, {"name": "nonempty", "description": ""}, {"name": "nonempty.intro", "description": ""}, {"name": "implies_true_iff", "description": ""}, {"name": "iff.trans", "description": ""}, {"name": "true_or", "description": ""}, {"name": "ne_self_iff_false", "description": ""}, {"name": "eq_self_iff_true", "description": ""}, {"name": "nonempty_of_inhabited", "description": ""}, {"name": "and_congr_right", "description": ""}, {"name": "forall_congr", "description": ""}, {"name": "let_value_eq", "description": ""}, {"name": "not_or", "description": ""}, {"name": "not_true", "description": ""}, {"name": "inv_image.trans", "description": ""}, {"name": "not_false", "description": ""}, {"name": "not_congr", "description": ""}, {"name": "empty_relation", "description": ""}, {"name": "irreflexive", "description": ""}, {"name": "or_false", "description": ""}, {"name": "iff", "description": " `iff P Q`, with notation `P \u2194 Q`, is the proposition asserting that `P` and `Q` are equivalent,\nthat is, have the same truth value."}, {"name": "iff.mp", "description": " `iff P Q`, with notation `P \u2194 Q`, is the proposition asserting that `P` and `Q` are equivalent,\nthat is, have the same truth value."}, {"name": "iff.mpr", "description": " `iff P Q`, with notation `P \u2194 Q`, is the proposition asserting that `P` and `Q` are equivalent,\nthat is, have the same truth value."}, {"name": "exists_unique.elim", "description": ""}, {"name": "ulift.down_up", "description": ""}, {"name": "ne", "description": ""}, {"name": "iff_true", "description": ""}, {"name": "xor", "description": ""}, {"name": "unique_of_exists_unique", "description": ""}, {"name": "of_eq_true", "description": ""}, {"name": "Exists", "description": "The existential quantifier.\n\nTo prove a goal of the form `\u22a2 \u2203 x, p x`, you can provide a witness `y` with the tactic `existsi y`.\nIf you are working in a project that depends on mathlib, then we recommend the `use` tactic\ninstead.\nYou'll then be left with the goal `\u22a2 p y`.\n\nTo extract a witness `x` and proof `hx : p x` from a hypothesis `h : \u2203 x, p x`,\nuse the tactic `cases h with x hx`. See also the mathlib tactics `obtain` and `rcases`."}, {"name": "Exists.intro", "description": "The existential quantifier.\n\nTo prove a goal of the form `\u22a2 \u2203 x, p x`, you can provide a witness `y` with the tactic `existsi y`.\nIf you are working in a project that depends on mathlib, then we recommend the `use` tactic\ninstead.\nYou'll then be left with the goal `\u22a2 p y`.\n\nTo extract a witness `x` and proof `hx : p x` from a hypothesis `h : \u2203 x, p x`,\nuse the tactic `cases h with x hx`. See also the mathlib tactics `obtain` and `rcases`."}, {"name": "dif_eq_if", "description": ""}, {"name": "inv_image", "description": ""}, {"name": "cast_proof_irrel", "description": ""}, {"name": "type_eq_of_heq", "description": ""}, {"name": "iff_iff_implies_and_implies", "description": ""}, {"name": "heq.symm", "description": ""}, {"name": "and_iff_right", "description": ""}, {"name": "ne.intro", "description": ""}, {"name": "right_identity", "description": ""}, {"name": "ite", "description": ""}, {"name": "neq_of_not_iff", "description": ""}, {"name": "subrelation", "description": ""}, {"name": "or.neg_resolve_right", "description": ""}, {"name": "let_eq", "description": ""}, {"name": "if_false", "description": ""}, {"name": "ne.def", "description": ""}, {"name": "of_iff_true", "description": ""}, {"name": "not_iff_self", "description": ""}, {"name": "trans_rel_left", "description": ""}, {"name": "dif_neg", "description": ""}, {"name": "if_neg", "description": ""}, {"name": "or_true", "description": ""}, {"name": "forall_not_of_not_exists", "description": ""}, {"name": "not_false_iff", "description": ""}, {"name": "iff.elim_left", "description": ""}, {"name": "not_not_intro", "description": ""}, {"name": "decidable.true", "description": ""}, {"name": "not_iff_not_of_iff", "description": ""}, {"name": "false.elim", "description": ""}, {"name": "dif_ctx_simp_congr", "description": ""}, {"name": "decidable_eq_of_bool_pred", "description": ""}, {"name": "proof_irrel", "description": ""}, {"name": "iff.decidable", "description": ""}, {"name": "bool.ff_ne_tt", "description": ""}, {"name": "decidable.em", "description": "Law of Excluded Middle."}, {"name": "decidable.not_and_iff_or_not", "description": ""}, {"name": "and_self", "description": ""}, {"name": "heq.subst", "description": ""}, {"name": "heq_of_eq_rec_right", "description": ""}, {"name": "decidable.not_or_iff_and_not", "description": ""}, {"name": "prop.inhabited", "description": ""}, {"name": "and_not_self", "description": ""}, {"name": "iff.comm", "description": ""}, {"name": "heq_self_iff_true", "description": ""}, {"name": "or.imp_left", "description": ""}, {"name": "decidable.not_not_iff", "description": ""}, {"name": "pi.inhabited", "description": ""}, {"name": "or_assoc", "description": ""}, {"name": "implies.trans", "description": "Implication `\u2192` is transitive. If `P \u2192 Q` and `Q \u2192 R` then `P \u2192 R`."}, {"name": "and.assoc", "description": ""}, {"name": "decidable_of_decidable_of_eq", "description": ""}, {"name": "symmetric", "description": ""}, {"name": "eq_rec_heq", "description": ""}, {"name": "decidable.by_cases", "description": ""}, {"name": "heq.trans", "description": ""}, {"name": "ne.elim", "description": ""}, {"name": "or.elim", "description": ""}, {"name": "and.decidable", "description": ""}, {"name": "iff_congr", "description": ""}, {"name": "cast_heq", "description": ""}, {"name": "or_congr", "description": ""}, {"name": "plift.down_up", "description": ""}, {"name": "if_congr_prop", "description": ""}, {"name": "exists.intro", "description": ""}, {"name": "or_comm", "description": ""}, {"name": "and.elim", "description": ""}, {"name": "decidable_eq_inr_neg", "description": ""}, {"name": "iff.elim_right", "description": ""}, {"name": "forall_prop_decidable", "description": ""}, {"name": "right_cancelative", "description": ""}, {"name": "absurd", "description": "We can't have `a` and `\u00aca`, that would be absurd!"}, {"name": "iff.elim", "description": ""}, {"name": "iff_false", "description": ""}, {"name": "or.symm", "description": ""}, {"name": "cast_eq", "description": ""}, {"name": "dite", "description": ""}, {"name": "decidable.false", "description": ""}, {"name": "inhabited", "description": ""}, {"name": "inhabited.default", "description": ""}, {"name": "and_false", "description": ""}, {"name": "implies_of_if_neg", "description": ""}, {"name": "eq.to_iff", "description": ""}, {"name": "congr", "description": ""}, {"name": "heq_of_heq_of_eq", "description": ""}, {"name": "or.resolve_left", "description": ""}, {"name": "or.decidable", "description": ""}, {"name": "iff_not_self", "description": ""}, {"name": "heq_of_eq", "description": ""}, {"name": "rec_subsingleton", "description": ""}, {"name": "false_and", "description": ""}, {"name": "decidable.to_bool", "description": ""}, {"name": "or_self", "description": ""}, {"name": "mt", "description": "Modus tollens. If an implication is true, then so is its contrapositive."}, {"name": "false_of_true_iff_false", "description": ""}, {"name": "total", "description": ""}, {"name": "exists_imp_exists", "description": ""}, {"name": "exists_congr", "description": ""}, {"name": "left_comm", "description": ""}, {"name": "exists_unique_congr", "description": ""}, {"name": "plift.up_down", "description": ""}, {"name": "format.paren", "description": "Surround with \"()\"."}, {"name": "format.join", "description": ""}, {"name": "name.has_to_format", "description": ""}, {"name": "format.of_options", "description": ""}, {"name": "format.sbracket", "description": "Surround with \"[]\"."}, {"name": "format.when", "description": ""}, {"name": "sigma.has_to_format", "description": ""}, {"name": "string_to_format", "description": ""}, {"name": "sum_has_to_format", "description": ""}, {"name": "trace_fmt", "description": "Traces the given format to the output window, then performs the given continuation."}, {"name": "format.highlight", "description": "Make the given format be displayed a particular color."}, {"name": "format.to_string", "description": ""}, {"name": "subtype.has_to_format", "description": ""}, {"name": "format.color", "description": ""}, {"name": "format.color.red", "description": ""}, {"name": "format.color.green", "description": ""}, {"name": "format.color.orange", "description": ""}, {"name": "format.color.blue", "description": ""}, {"name": "format.color.pink", "description": ""}, {"name": "format.color.cyan", "description": ""}, {"name": "format.color.grey", "description": ""}, {"name": "format.indent", "description": ""}, {"name": "format.space", "description": "The whitespace character `\" \"`."}, {"name": "format.inhabited", "description": ""}, {"name": "format.color.to_string", "description": ""}, {"name": "format.flatten", "description": "Flattening removes all of the `format.nest` items from the format tree."}, {"name": "char.has_to_format", "description": ""}, {"name": "options.has_to_format", "description": ""}, {"name": "format.has_to_format", "description": ""}, {"name": "list.has_to_format", "description": ""}, {"name": "decidable.has_to_format", "description": ""}, {"name": "format.has_append", "description": ""}, {"name": "format.of_string", "description": ""}, {"name": "format.compose", "description": "Concatenate the given format strings."}, {"name": "prod.has_to_format", "description": ""}, {"name": "option.has_to_format", "description": ""}, {"name": "bool.has_to_format", "description": ""}, {"name": "list.to_format", "description": ""}, {"name": "has_to_format", "description": " Use this instead of `has_to_string` to enable prettier formatting.\nSee docstring for `format` for more on the differences between `format` and `string`.\nNote that `format` is `meta` while `string` is not."}, {"name": "has_to_format.to_format", "description": " Use this instead of `has_to_string` to enable prettier formatting.\nSee docstring for `format` for more on the differences between `format` and `string`.\nNote that `format` is `meta` while `string` is not."}, {"name": "format.cbrace", "description": "Surround with \"{}\"."}, {"name": "unsigned.has_to_format", "description": ""}, {"name": "nat.has_to_format", "description": ""}, {"name": "format.line", "description": "Indicate that it is ok to put a linebreak in here if the line is too long."}, {"name": "format.of_nat", "description": ""}, {"name": "to_fmt", "description": ""}, {"name": "nat_to_format", "description": ""}, {"name": "format.bracket", "description": ""}, {"name": "format.nest", "description": " `format.nest n f` tells the formatter that `f` is nested inside something with length `n`\nso that it is pretty-printed with the correct tabs on a line break.\nFor example, in `list.to_format` we have:\n\n```lean\n(nest 1 $ format.join $ list.intersperse (\",\" ++ line) $ xs.map to_fmt)\n```\n\nThis will be written all on one line, but when the list is too large, it will put in linebreaks after the comma and indent later lines by 1."}, {"name": "format.nil", "description": "= `\"\"`"}, {"name": "format.is_nil", "description": ""}, {"name": "format.group", "description": "When printing the given format `f`, if `f.flatten` fits without need for linebreaks then print the `f.flatten`, else print `f` unflattened with linebreaks."}, {"name": "string.has_to_format", "description": ""}, {"name": "format", "description": "Format is a rich string with highlighting and information about how tabs should be put in if linebreaks are needed. A 'pretty string'."}, {"name": "format.has_to_string", "description": ""}, {"name": "format.dcbrace", "description": "Surround with \"\u2983\u2984\"."}, {"name": "unit.has_to_format", "description": ""}, {"name": "finset.has_sdiff", "description": "`s \\ t` is the set consisting of the elements of `s` that are not in `t`."}, {"name": "list.to_finset_val", "description": ""}, {"name": "finset.insert_subset_insert", "description": ""}, {"name": "finset.mem_range_iff_mem_finset_range_of_mod_eq", "description": ""}, {"name": "finset.filter_inter", "description": ""}, {"name": "finset.piecewise_idem_left", "description": ""}, {"name": "finset.ssubset_of_subset_of_ssubset", "description": ""}, {"name": "finset.inter_left_idem", "description": ""}, {"name": "finset.eq_singleton_iff_nonempty_unique_mem", "description": ""}, {"name": "finset.sdiff_eq_sdiff_iff_inter_eq_inter", "description": ""}, {"name": "finset.piecewise_piecewise_of_subset_left", "description": ""}, {"name": "finset.filter_subset", "description": ""}, {"name": "finset.disjoint_empty_left", "description": ""}, {"name": "finset.has_union.union.is_commutative", "description": ""}, {"name": "multiset.to_finset_union", "description": ""}, {"name": "finset.map_disj_union'", "description": "A version of `finset.map_disj_union` for writing in the other direction."}, {"name": "finset.cons_subset_cons", "description": ""}, {"name": "finset.image_to_finset", "description": ""}, {"name": "finset.mem_image_const", "description": ""}, {"name": "finset.singleton_bUnion", "description": ""}, {"name": "finset.inter_congr_left", "description": ""}, {"name": "finset.sdiff_eq_empty_iff_subset", "description": ""}, {"name": "finset.mem_insert_coe", "description": ""}, {"name": "finset.insert_val'", "description": ""}, {"name": "finset.piecewise_mem_Icc'", "description": ""}, {"name": "finset.sdiff_singleton_not_mem_eq_self", "description": ""}, {"name": "finset.piecewise_le_piecewise", "description": ""}, {"name": "finset.coe_insert", "description": ""}, {"name": "finset.insert_sdiff_of_not_mem", "description": ""}, {"name": "finset.sdiff_idem", "description": ""}, {"name": "finset.not_mem_empty", "description": ""}, {"name": "finset.singleton_iff_unique_mem", "description": ""}, {"name": "finset.subtype", "description": " Given a finset `s` and a predicate `p`, `s.subtype p` is the finset of `subtype p` whose\nelements belong to `s`."}, {"name": "finset.distrib_lattice", "description": ""}, {"name": "finset.map_erase", "description": ""}, {"name": "finset.has_decidable_eq", "description": ""}, {"name": "multiset.to_finset", "description": "`to_finset s` removes duplicates from the multiset `s` to produce a finset."}, {"name": "finset.mem_attach", "description": ""}, {"name": "finset.mem_range_le", "description": ""}, {"name": "finset.left_eq_union_iff_subset", "description": ""}, {"name": "finset.filter_singleton", "description": ""}, {"name": "finset.attach_empty", "description": ""}, {"name": "finset.union_distrib_left", "description": ""}, {"name": "finset.filter_inter_filter_neg_eq", "description": ""}, {"name": "finset.attach_eq_empty_iff", "description": ""}, {"name": "finset.disjoint_map", "description": ""}, {"name": "finset.has_sep", "description": "The following instance allows us to write `{x \u2208 s | p x}` for `finset.filter p s`.\n Since the former notation requires us to define this for all propositions `p`, and `finset.filter`\n only works for decidable propositions, the notation `{x \u2208 s | p x}` is only compatible with\n classical logic because it uses `classical.prop_decidable`.\n We don't want to redo all lemmas of `finset.filter` for `has_sep.sep`, so we make sure that `simp`\n unfolds the notation `{x \u2208 s | p x}` to `finset.filter p s`. If `p` happens to be decidable, the\n simp-lemma `finset.filter_congr_decidable` will make sure that `finset.filter` uses the right\n instance for decidability."}, {"name": "finset.disjoint_filter_filter_neg", "description": ""}, {"name": "equiv.finset_congr_refl", "description": ""}, {"name": "finset.image_congr", "description": ""}, {"name": "multiset.nodup.to_finset_inj", "description": ""}, {"name": "finset.subset_union_left", "description": ""}, {"name": "finset.union_eq_right_iff_subset", "description": ""}, {"name": "finset.filter_true", "description": ""}, {"name": "finset.mem_range_succ_iff", "description": ""}, {"name": "finset.range_sdiff_zero", "description": ""}, {"name": "equiv.finset_congr_apply", "description": ""}, {"name": "finset.map_val", "description": ""}, {"name": "finset.not_nonempty_empty", "description": ""}, {"name": "finset.mem_insert_self", "description": ""}, {"name": "finset.ssubset_def", "description": ""}, {"name": "finset.union_distrib_right", "description": ""}, {"name": "finset.choose_spec", "description": ""}, {"name": "finset.inter_assoc", "description": ""}, {"name": "finset.coe_eq_empty", "description": ""}, {"name": "finset.inter_subset_inter_left", "description": ""}, {"name": "finset.partial_order", "description": ""}, {"name": "finset.union_idempotent", "description": ""}, {"name": "finset.ext_iff", "description": ""}, {"name": "finset.empty_subset", "description": ""}, {"name": "finset.coe_union", "description": ""}, {"name": "finset.nonempty.subset_singleton_iff", "description": ""}, {"name": "finset.induction_on'", "description": "To prove a proposition about `S : finset \u03b1`,\nit suffices to prove it for the empty `finset`,\nand to show that if it holds for some `finset \u03b1 \u2286 S`,\nthen it holds for the `finset` obtained by inserting a new element of `S`."}, {"name": "finset.subset_iff", "description": ""}, {"name": "finset.union_right_idem", "description": ""}, {"name": "finset.has_ssubset.ssubset.is_irrefl", "description": ""}, {"name": "finset.sdiff_union_distrib", "description": ""}, {"name": "finset.union_eq_left_iff_subset", "description": ""}, {"name": "finset.forall_coe", "description": ""}, {"name": "finset.insert_ne_self", "description": ""}, {"name": "finset.nonempty_mk_coe", "description": ""}, {"name": "finset.disjoint_right", "description": ""}, {"name": "finset.eq_of_not_mem_of_mem_insert", "description": ""}, {"name": "finset.coe_emb", "description": "Coercion to `set \u03b1` as an `order_embedding`."}, {"name": "finset.union_sdiff_symm", "description": ""}, {"name": "finset.mem_range_iff_mem_finset_range_of_mod_eq'", "description": ""}, {"name": "list.perm_of_nodup_nodup_to_finset_eq", "description": ""}, {"name": "finset.not_nonempty_iff_eq_empty", "description": ""}, {"name": "finset.range_subset", "description": ""}, {"name": "list.to_finset_union", "description": ""}, {"name": "finset.sdiff_union_inter", "description": ""}, {"name": "finset.piecewise_idem_right", "description": ""}, {"name": "finset.forall_mem_cons", "description": ""}, {"name": "finset.insert_eq_self", "description": ""}, {"name": "finset.image_mono", "description": ""}, {"name": "finset.mem_cons_self", "description": ""}, {"name": "finset.map_map", "description": ""}, {"name": "finset.forall_mem_union", "description": ""}, {"name": "finset.eq_empty_or_nonempty", "description": ""}, {"name": "finset.disjoint_of_subset_left", "description": ""}, {"name": "finset.sdiff_erase", "description": ""}, {"name": "finset.insert_eq", "description": ""}, {"name": "finset.union_eq_empty_iff", "description": ""}, {"name": "finset.subset.rfl", "description": ""}, {"name": "finset.map_empty", "description": ""}, {"name": "finset.disjoint_singleton_right", "description": ""}, {"name": "disjoint.forall_ne_finset", "description": ""}, {"name": "finset.disjoint_sdiff", "description": ""}, {"name": "finset.disjoint_image", "description": ""}, {"name": "finset.mem_map'", "description": ""}, {"name": "finset.singleton_val", "description": ""}, {"name": "finset.subset_erase", "description": ""}, {"name": "finset.attach_insert", "description": ""}, {"name": "finset.decidable_mem'", "description": ""}, {"name": "finset.decidable_disjoint", "description": ""}, {"name": "finset.filter_and", "description": ""}, {"name": "finset.exists_mem_empty_iff", "description": ""}, {"name": "finset.union_comm", "description": ""}, {"name": "finset.filter_eq_self", "description": ""}, {"name": "finset.exists_coe", "description": ""}, {"name": "finset.filter_mem_image_eq_image", "description": ""}, {"name": "finset.range_succ", "description": ""}, {"name": "finset.union_sdiff_right", "description": ""}, {"name": "finset.union_subset", "description": ""}, {"name": "finset.bUnion_subset", "description": ""}, {"name": "finset.insert_eq_of_mem", "description": ""}, {"name": "finset.coe_image_subset_range", "description": ""}, {"name": "not_mem_range_equiv", "description": "Equivalence between the set of natural numbers which are `\u2265 k` and `\u2115`, given by `n \u2192 n - k`."}, {"name": "finset.to_list_to_finset", "description": ""}, {"name": "finset.val_inj", "description": ""}, {"name": "finset.singleton_inter_of_mem", "description": ""}, {"name": "finset.decidable_dforall_finset", "description": ""}, {"name": "finset.union_inter_cancel_left", "description": ""}, {"name": "finset.inf_eq_inter", "description": ""}, {"name": "finset.erase_subset", "description": ""}, {"name": "finset.has_mem", "description": ""}, {"name": "finset.filter_eq_empty_iff", "description": ""}, {"name": "finset.bot_eq_empty", "description": ""}, {"name": "finset.map_eq_empty", "description": ""}, {"name": "finset.has_ssubset", "description": ""}, {"name": "finset.insert_inter_of_not_mem", "description": ""}, {"name": "finset.bUnion_empty", "description": ""}, {"name": "finset.bUnion_singleton", "description": ""}, {"name": "finset.sdiff_inter_self_left", "description": ""}, {"name": "finset.mem_subtype", "description": ""}, {"name": "finset.subset_empty", "description": ""}, {"name": "finset.has_union", "description": "`s \u222a t` is the set such that `a \u2208 s \u222a t` iff `a \u2208 s` or `a \u2208 t`."}, {"name": "finset.subset.antisymm", "description": ""}, {"name": "finset.ssubset_cons", "description": ""}, {"name": "finset.singleton_disj_union", "description": ""}, {"name": "finset.mem_insert_of_mem", "description": ""}, {"name": "finset.right_eq_union_iff_subset", "description": ""}, {"name": "finset.eq_empty_of_is_empty", "description": "A `finset` for an empty type is empty."}, {"name": "finset.disjoint_range_add_left_embedding", "description": ""}, {"name": "finset.not_mem_singleton", "description": ""}, {"name": "finset.coe_bUnion", "description": ""}, {"name": "finset.is_lawful_singleton", "description": ""}, {"name": "finset.disjoint_iff_ne", "description": ""}, {"name": "finset.ext", "description": ""}, {"name": "finset.sdiff_sdiff_left'", "description": ""}, {"name": "finset.disjoint_union_left", "description": ""}, {"name": "finset.disjoint_empty_right", "description": ""}, {"name": "finset.nonempty.to_set", "description": "**Alias** of the reverse direction of `finset.coe_nonempty`."}, {"name": "finset.map_inj", "description": ""}, {"name": "finset.filter_empty", "description": ""}, {"name": "finset.map_union", "description": ""}, {"name": "finset.image_inter_subset", "description": ""}, {"name": "finset.le_eq_subset", "description": ""}, {"name": "function.semiconj.finset_image", "description": ""}, {"name": "finset.bUnion_bUnion", "description": ""}, {"name": "multiset.to_finset_val", "description": ""}, {"name": "finset.map_subtype_subset", "description": " If a `finset` of a subtype is converted to the main type with\n`embedding.subtype`, the result is a subset of the set giving the\nsubtype."}, {"name": "finset.coe_map_subset_range", "description": ""}, {"name": "finset.inter_sdiff_self", "description": ""}, {"name": "finset.coe_erase", "description": ""}, {"name": "finset.sdiff_singleton_eq_erase", "description": ""}, {"name": "finset.image_eq_empty", "description": ""}, {"name": "finset.empty_sdiff", "description": ""}, {"name": "finset.ne_empty_of_mem", "description": ""}, {"name": "finset.bUnion_nonempty", "description": ""}, {"name": "finset.sdiff_eq_self_of_disjoint", "description": ""}, {"name": "finset.disjoint_filter", "description": ""}, {"name": "finset.has_union.union.is_associative", "description": ""}, {"name": "finset.filter_ssubset", "description": ""}, {"name": "finset.union_sdiff_distrib", "description": ""}, {"name": "finset.subset_image_iff", "description": ""}, {"name": "finset.insert_inter_of_mem", "description": ""}, {"name": "finset.to_list_empty", "description": ""}, {"name": "finset.bUnion_congr", "description": ""}, {"name": "finset.subset_singleton_iff'", "description": ""}, {"name": "finset.ssubset_iff_subset_ne", "description": ""}, {"name": "finset.choose_mem", "description": ""}, {"name": "finset.exists_mem_insert", "description": ""}, {"name": "finset.has_ssubset.ssubset.is_nonstrict_strict_order", "description": ""}, {"name": "finset.erase_eq_self", "description": ""}, {"name": "finset.inter_right_comm", "description": ""}, {"name": "finset.coe_coe_emb", "description": ""}, {"name": "finset.subset_inter_iff", "description": ""}, {"name": "finset.piecewise_insert", "description": ""}, {"name": "list.to_finset.ext_iff", "description": ""}, {"name": "finset.bUnion", "description": " `bUnion s t` is the union of `t x` over `x \u2208 s`.\n(This was formerly `bind` due to the monad structure on types with `decidable_eq`.)"}, {"name": "finset.has_subset", "description": ""}, {"name": "finset.nonempty", "description": " The property `s.nonempty` expresses the fact that the finset `s` is not empty. It should be used\nin theorem assumptions instead of `\u2203 x, x \u2208 s` or `s \u2260 \u2205` as it gives access to a nice API thanks\nto the dot notation."}, {"name": "finset.filter_mem_eq_inter", "description": ""}, {"name": "finset.mem_bUnion", "description": ""}, {"name": "finset.mem_map", "description": ""}, {"name": "finset.coe_subset", "description": ""}, {"name": "finset.induction", "description": ""}, {"name": "finset.mem_inter_of_mem", "description": ""}, {"name": "finset.inhabited_finset", "description": ""}, {"name": "finset.pairwise_subtype_iff_pairwise_finset", "description": ""}, {"name": "finset.empty_union", "description": ""}, {"name": "finset.coe_empty", "description": ""}, {"name": "finset.sup_eq_union", "description": ""}, {"name": "finset.mem_of_mem_filter", "description": ""}, {"name": "finset.subtype_insert_equiv_option", "description": "Inserting an element to a finite set is equivalent to the option type."}, {"name": "finset.mem_of_mem_erase", "description": ""}, {"name": "multiset.mem_to_finset", "description": ""}, {"name": "finset.erase_eq_of_not_mem", "description": ""}, {"name": "finset.exists_list_nodup_eq", "description": ""}, {"name": "finset.sdiff_empty", "description": ""}, {"name": "finset.attach_image_val", "description": ""}, {"name": "finset.insert_def", "description": ""}, {"name": "finset.bUnion_inter", "description": ""}, {"name": "finset.nonempty_of_ne_empty", "description": ""}, {"name": "finset.empty_disj_union", "description": ""}, {"name": "finset.erase_inj_on", "description": ""}, {"name": "finset.has_ssubset.ssubset.is_asymm", "description": ""}, {"name": "finset.filter_eq'", "description": "After filtering out everything that does not equal a given value, at most that value remains.\n\nThis is equivalent to `filter_eq` with the equality the other way."}, {"name": "equiv.sigma_equiv_option_of_inhabited", "description": "Inhabited types are equivalent to `option \u03b2` for some `\u03b2` by identifying `default \u03b1` with `none`."}, {"name": "finset.image_val_of_inj_on", "description": ""}, {"name": "finset.insert_subset", "description": ""}, {"name": "finset.image_union", "description": ""}, {"name": "finset.filter_nonempty_iff", "description": ""}, {"name": "list.to_finset_coe", "description": ""}, {"name": "finset.image_insert", "description": ""}, {"name": "finset.insert_idem", "description": ""}, {"name": "finset.induction_on", "description": "To prove a proposition about an arbitrary `finset \u03b1`,\nit suffices to prove it for the empty `finset`,\nand to show that if it holds for some `finset \u03b1`,\nthen it holds for the `finset` obtained by inserting a new element."}, {"name": "finset.map_eq_image", "description": ""}, {"name": "finset.not_mem_union", "description": ""}, {"name": "finset.decidable_dexists_finset", "description": ""}, {"name": "finset.decidable_eq_pi_finset", "description": "decidable equality for functions whose domain is bounded by finsets"}, {"name": "finset.not_mem_range_self", "description": ""}, {"name": "finset.image_comm", "description": ""}, {"name": "finset.ssubset_insert", "description": ""}, {"name": "finset.sdiff_eq_filter", "description": ""}, {"name": "multiset.to_finset_subset", "description": ""}, {"name": "finset.disj_union_empty", "description": ""}, {"name": "list.to_finset_eq_iff_perm_dedup", "description": ""}, {"name": "finset.mem_image_of_mem", "description": ""}, {"name": "finset.has_emptyc", "description": ""}, {"name": "finset.cons_induction_on", "description": ""}, {"name": "finset.coe_map", "description": ""}, {"name": "finset.map_disj_union", "description": ""}, {"name": "finset.erase_image_subset_image_erase", "description": ""}, {"name": "finset.attach_image_coe", "description": ""}, {"name": "finset.inter_subset_inter", "description": ""}, {"name": "finset.subset_singleton_iff", "description": ""}, {"name": "finset.union_union_union_comm", "description": ""}, {"name": "finset.has_insert.insert.nonempty", "description": ""}, {"name": "directed_on.exists_mem_subset_of_finset_subset_bUnion", "description": ""}, {"name": "finset.inter_sdiff", "description": ""}, {"name": "finset.eq_empty_of_forall_not_mem", "description": ""}, {"name": "multiset.to_finset_singleton", "description": ""}, {"name": "multiset.to_finset_cons", "description": ""}, {"name": "finset.eq_of_mem_of_not_mem_erase", "description": " An element of `s` that is not an element of `erase s a` must be\n`a`."}, {"name": "finset.image_filter", "description": ""}, {"name": "finset.range_eq_empty_iff", "description": ""}, {"name": "finset.not_mem_erase", "description": ""}, {"name": "finset.sdiff_val", "description": ""}, {"name": "finset.union_left_idem", "description": ""}, {"name": "finset.pairwise_cons", "description": ""}, {"name": "finset.mem_range_sub_ne_zero", "description": ""}, {"name": "finset.mk_zero", "description": ""}, {"name": "finset.ssubset_iff_of_subset", "description": ""}, {"name": "finset.range", "description": "`range n` is the set of natural numbers less than `n`."}, {"name": "finset.ssubset_of_ssubset_of_subset", "description": ""}, {"name": "list.mem_to_finset", "description": ""}, {"name": "finset.filter_false", "description": ""}, {"name": "finset.union_subset_iff", "description": ""}, {"name": "finset.sdiff_inter_self_right", "description": ""}, {"name": "finset.range_add", "description": ""}, {"name": "finset.piecewise_mem_Icc_of_mem_of_mem", "description": ""}, {"name": "finset.erase_subset_erase", "description": ""}, {"name": "finset.piecewise_insert_self", "description": ""}, {"name": "finset.subtype_mono", "description": ""}, {"name": "multiset.to_finset_zero", "description": ""}, {"name": "finset.union_congr_right", "description": ""}, {"name": "finset.filter_not", "description": ""}, {"name": "finset.sdiff_self", "description": ""}, {"name": "finset.filter_insert", "description": ""}, {"name": "finset.can_lift", "description": ""}, {"name": "finset.union_eq_union_iff_right", "description": ""}, {"name": "finset.image_inter_of_inj_on", "description": ""}, {"name": "finset.singleton_subset_iff", "description": ""}, {"name": "finset.mem_image_const_self", "description": ""}, {"name": "finset.piecewise_congr", "description": ""}, {"name": "finset.filter_ne", "description": ""}, {"name": "finset.eq_of_veq", "description": ""}, {"name": "finset.map_disj_union_aux", "description": "A helper lemma to produce a default proof for `finset.map_disj_union`."}, {"name": "finset.piecewise_cases", "description": ""}, {"name": "equiv.finset_congr_symm", "description": ""}, {"name": "list.to_finset_surjective", "description": ""}, {"name": "finset.pair_eq_singleton", "description": ""}, {"name": "finset.coe_sort_coe", "description": ""}, {"name": "finset.nonempty_iff_ne_empty", "description": ""}, {"name": "finset.filter_true_of_mem", "description": "If all elements of a `finset` satisfy the predicate `p`, `s.filter p` is `s`."}, {"name": "finset.erase_right_comm", "description": ""}, {"name": "finset.sdiff_subset", "description": ""}, {"name": "finset.map_refl", "description": ""}, {"name": "finset.map_embedding_apply", "description": ""}, {"name": "finset.coe_mem", "description": ""}, {"name": "finset.monotone_filter_left", "description": ""}, {"name": "finset.bind_to_finset", "description": ""}, {"name": "finset.bUnion_insert", "description": ""}, {"name": "finset.map_comm", "description": ""}, {"name": "coe_not_mem_range_equiv", "description": ""}, {"name": "finset.not_mem_map_subtype_of_not_property", "description": " If a `finset` of a subtype is converted to the main type with\n`embedding.subtype`, the result does not contain any value that does\nnot satisfy the property of the subtype."}, {"name": "finset.singleton_nonempty", "description": ""}, {"name": "finset.erase_bUnion", "description": ""}, {"name": "finset.image_singleton", "description": ""}, {"name": "multiset.to_finset_map", "description": ""}, {"name": "finset.map_insert", "description": ""}, {"name": "finset.erase_singleton", "description": ""}, {"name": "finset.union_union_distrib_right", "description": ""}, {"name": "finset.property_of_mem_map_subtype", "description": " If a `finset` of a subtype is converted to the main type with\n`embedding.subtype`, all elements of the result have the property of\nthe subtype."}, {"name": "finset.mem_to_list", "description": ""}, {"name": "finset.inter_eq_inter_iff_right", "description": ""}, {"name": "finset.inter_val_nd", "description": ""}, {"name": "finset.coe_singleton", "description": ""}, {"name": "finset.range_coe", "description": ""}, {"name": "finset.mem_union_left", "description": ""}, {"name": "finset.piecewise_singleton", "description": ""}, {"name": "finset.forall_mem_map", "description": ""}, {"name": "finset.val_to_finset", "description": ""}, {"name": "finset.piecewise_coe", "description": ""}, {"name": "finset.ssubset_iff", "description": ""}, {"name": "finset.val_lt_iff", "description": ""}, {"name": "finset.filter_inter_distrib", "description": ""}, {"name": "finset.disj_union", "description": " `disj_union s t h` is the set such that `a \u2208 disj_union s t h` iff `a \u2208 s` or `a \u2208 t`.\nIt is the same as `s \u222a t`, but it does not require decidable equality on the type. The hypothesis\nensures that the sets are disjoint."}, {"name": "finset.map_subset_map", "description": ""}, {"name": "finset.singleton_subset_set_iff", "description": ""}, {"name": "finset.inter_inter_distrib_right", "description": ""}, {"name": "finset.coe_inter", "description": ""}, {"name": "list.to_finset_repeat_of_ne_zero", "description": ""}, {"name": "finset.attach_nonempty_iff", "description": ""}, {"name": "finset.subset_insert_iff_of_not_mem", "description": ""}, {"name": "finset.disjoint_coe", "description": ""}, {"name": "finset.filter_cons", "description": ""}, {"name": "finset.map_embedding", "description": " Associate to an embedding `f` from `\u03b1` to `\u03b2` the order embedding that maps a finset to its\nimage under `f`."}, {"name": "finset.insert_val_of_not_mem", "description": ""}, {"name": "finset.induction_on_union", "description": "To prove a relation on pairs of `finset X`, it suffices to show that it is\n  * symmetric,\n  * it holds when one of the `finset`s is empty,\n  * it holds for pairs of singletons,\n  * if it holds for `[a, c]` and for `[b, c]`, then it holds for `[a \u222a b, c]`."}, {"name": "finset.nonempty.map", "description": "**Alias** of the reverse direction of `finset.map_nonempty`."}, {"name": "finset.mk_coe", "description": ""}, {"name": "finset.mem_map_of_mem", "description": ""}, {"name": "finset.is_empty_coe_sort", "description": ""}, {"name": "finset.erase_inj", "description": ""}, {"name": "multiset.to_finset_inter", "description": ""}, {"name": "finset.map_cons", "description": ""}, {"name": "function.injective.mem_finset_image", "description": ""}, {"name": "finset.mem_of_mem_inter_left", "description": ""}, {"name": "multiset.to_finset_nsmul", "description": ""}, {"name": "equiv.finset_congr_trans", "description": ""}, {"name": "finset.nontrivial", "description": ""}, {"name": "finset.erase_eq_empty_iff", "description": ""}, {"name": "finset.to_list_insert", "description": ""}, {"name": "finset.filter_ne'", "description": ""}, {"name": "multiset.to_finset_add", "description": ""}, {"name": "finset.image_subset_image_iff", "description": ""}, {"name": "finset.insert_union", "description": ""}, {"name": "finset.mem_of_subset", "description": ""}, {"name": "finset.filter_union", "description": ""}, {"name": "finset.filter_cons_of_pos", "description": ""}, {"name": "function.commute.finset_map", "description": ""}, {"name": "finset.piecewise_eq_of_mem", "description": ""}, {"name": "finset.subtype_map_of_mem", "description": " If all elements of a `finset` satisfy the predicate `p`,\n`s.subtype p` converts back to `s` with `embedding.subtype`."}, {"name": "finset.range_zero", "description": ""}, {"name": "finset.to_list", "description": "Produce a list of the elements in the finite set using choice."}, {"name": "finset.insert_sdiff_insert", "description": ""}, {"name": "finset.nonempty.forall_const", "description": ""}, {"name": "finset.coe_eq_singleton", "description": ""}, {"name": "finset.nonempty.cons_induction", "description": " To prove a proposition about a nonempty `s : finset \u03b1`, it suffices to show it holds for all\nsingletons and that if it holds for nonempty `t : finset \u03b1`, then it also holds for the `finset`\nobtained by inserting an element in `t`."}, {"name": "finset.map", "description": " When `f` is an embedding of `\u03b1` in `\u03b2` and `s` is a finset in `\u03b1`, then `s.map f` is the image\nfinset in `\u03b2`. The embedding condition guarantees that there are no duplicates in the image."}, {"name": "finset.generalized_boolean_algebra", "description": ""}, {"name": "list.to_finset_reverse", "description": ""}, {"name": "finset.subset_insert", "description": ""}, {"name": "finset.bUnion_singleton_eq_self", "description": ""}, {"name": "finset.singleton_inter_of_not_mem", "description": ""}, {"name": "finset.self_mem_range_succ", "description": ""}, {"name": "finset.inter_union_self", "description": ""}, {"name": "finset.has_subset.subset.is_refl", "description": ""}, {"name": "finset.erase_insert_subset", "description": ""}, {"name": "finset.exists_of_ssubset", "description": ""}, {"name": "finset.empty_inter", "description": ""}, {"name": "finset.cons", "description": " `cons a s h` is the set `{a} \u222a s` containing `a` and the elements of `s`. It is the same as\n`insert a s` when it is defined, but unlike `insert a s` it does not require `decidable_eq \u03b1`,\nand the union is guaranteed to be disjoint."}, {"name": "finset.union_left_comm", "description": ""}, {"name": "finset.erase_inj_on'", "description": ""}, {"name": "finset.singleton_inj", "description": ""}, {"name": "finset.filter_val", "description": ""}, {"name": "finset.inter_inter_inter_comm", "description": ""}, {"name": "finset.subset_union_elim", "description": ""}, {"name": "finset.union_union_distrib_left", "description": ""}, {"name": "finset.map_injective", "description": ""}, {"name": "finset.piecewise_mem_set_pi", "description": ""}, {"name": "finset.not_ssubset_empty", "description": ""}, {"name": "finset.piecewise_empty", "description": ""}, {"name": "equiv.finset_congr_to_embedding", "description": ""}, {"name": "finset.empty_val", "description": ""}, {"name": "finset.mem_disj_union", "description": ""}, {"name": "finset.erase_ssubset", "description": ""}, {"name": "finset.union_empty", "description": ""}, {"name": "finset.subset_insert_iff", "description": ""}, {"name": "finset.disjoint_self_iff_empty", "description": ""}, {"name": "finset.nonempty_range_succ", "description": ""}, {"name": "finset.inter_empty", "description": ""}, {"name": "finset.inter_bUnion", "description": ""}, {"name": "finset.sdiff_insert", "description": ""}, {"name": "finset.mem_sdiff", "description": ""}, {"name": "finset.piecewise_mem_Icc", "description": ""}, {"name": "finset.ite_subset_union", "description": ""}, {"name": "finset.nonempty.bex", "description": ""}, {"name": "finset.image_bUnion", "description": ""}, {"name": "finset.finset_coe.can_lift", "description": ""}, {"name": "finset.bUnion_filter_eq_of_maps_to", "description": ""}, {"name": "finset.has_insert", "description": "`insert a s` is the set `{a} \u222a s` containing `a` and the elements of `s`."}, {"name": "finset.nonempty.bUnion", "description": ""}, {"name": "finset.insert_inj", "description": ""}, {"name": "finset.singleton_injective", "description": ""}, {"name": "finset.image_inter", "description": ""}, {"name": "finset.union_val_nd", "description": ""}, {"name": "finset.coe_nonempty", "description": ""}, {"name": "finset.filter_eq", "description": "After filtering out everything that does not equal a given value, at most that value remains.\n\nThis is equivalent to `filter_eq'` with the equality the other way."}, {"name": "finset.subset_bUnion_of_mem", "description": ""}, {"name": "finset.val_le_iff", "description": ""}, {"name": "finset.not_subset", "description": ""}, {"name": "finset.erase_subset_iff_of_mem", "description": ""}, {"name": "finset.range_mono", "description": ""}, {"name": "multiset.to_finset_eq_empty", "description": ""}, {"name": "finset.nonempty_cons", "description": ""}, {"name": "finset.map_perm", "description": "If the only elements outside `s` are those left fixed by `\u03c3`, then mapping by `\u03c3` has no effect."}, {"name": "finset.disjoint_bUnion_left", "description": ""}, {"name": "finset.bUnion_subset_iff_forall_subset", "description": ""}, {"name": "finset.cons_val", "description": ""}, {"name": "finset.disj_union_comm", "description": ""}, {"name": "finset.pairwise_subtype_iff_pairwise_finset'", "description": ""}, {"name": "finset.image_id'", "description": ""}, {"name": "finset.disjoint_range_add_right_embedding", "description": ""}, {"name": "finset.map_filter", "description": ""}, {"name": "coe_not_mem_range_equiv_symm", "description": ""}, {"name": "finset.bUnion_mono", "description": ""}, {"name": "finset.mem_image", "description": ""}, {"name": "list.to_finset_inter", "description": ""}, {"name": "finset.insert_erase", "description": ""}, {"name": "finset.filter_false_of_mem", "description": "If all elements of a `finset` fail to satisfy the predicate `p`, `s.filter p` is `\u2205`."}, {"name": "finset.lt_eq_subset", "description": ""}, {"name": "finset.inter_eq_left_iff_subset", "description": ""}, {"name": "finset.inter_self", "description": ""}, {"name": "list.to_finset_eq_of_perm", "description": ""}, {"name": "finset.lt_iff_ssubset", "description": ""}, {"name": "finset.cons_subset", "description": ""}, {"name": "finset.disjoint_sdiff_inter", "description": ""}, {"name": "finset.piecewise_piecewise_of_subset_right", "description": ""}, {"name": "finset.has_ssubset.ssubset.is_trans", "description": ""}, {"name": "finset.range_add_one", "description": ""}, {"name": "finset.update_piecewise_of_mem", "description": ""}, {"name": "finset.sdiff_eq_self", "description": ""}, {"name": "finset.mem_of_mem_inter_right", "description": ""}, {"name": "finset.map_singleton", "description": ""}, {"name": "finset.apply_coe_mem_map", "description": ""}, {"name": "finset.insert_sdiff_of_mem", "description": ""}, {"name": "finset.image_const", "description": ""}, {"name": "finset.coe_to_list", "description": ""}, {"name": "finset.sdiff_union_of_subset", "description": ""}, {"name": "finset.mem_union", "description": ""}, {"name": "finset.lattice", "description": ""}, {"name": "finset.union_congr_left", "description": ""}, {"name": "finset.mk_cons", "description": ""}, {"name": "finset.union_right_comm", "description": ""}, {"name": "finset.inter_eq_inter_iff_left", "description": ""}, {"name": "finset.union_sdiff_self_eq_union", "description": ""}, {"name": "finset.filter", "description": "`filter p s` is the set of elements of `s` that satisfy `p`."}, {"name": "finset.union_insert", "description": ""}, {"name": "equiv.finset_congr", "description": "Given an equivalence `\u03b1` to `\u03b2`, produce an equivalence between `finset \u03b1` and `finset \u03b2`."}, {"name": "finset.mem_map_equiv", "description": ""}, {"name": "finset.mem_erase_of_ne_of_mem", "description": ""}, {"name": "finset", "description": "`finset \u03b1` is the type of finite sets of elements of `\u03b1`. It is implemented\n as a multiset (a list up to permutation) which has no duplicate elements."}, {"name": "finset.val", "description": "`finset \u03b1` is the type of finite sets of elements of `\u03b1`. It is implemented\n as a multiset (a list up to permutation) which has no duplicate elements."}, {"name": "finset.nodup", "description": "`finset \u03b1` is the type of finite sets of elements of `\u03b1`. It is implemented\n as a multiset (a list up to permutation) which has no duplicate elements."}, {"name": "finset.inter_congr_right", "description": ""}, {"name": "finset.inter_subset_inter_right", "description": ""}, {"name": "finset.erase_cons", "description": ""}, {"name": "finset.disjoint_insert_right", "description": ""}, {"name": "finset.empty", "description": "The empty finset"}, {"name": "finset.sdiff_inter_self", "description": ""}, {"name": "finset.sdiff_subset_sdiff", "description": ""}, {"name": "finset.sep_def", "description": ""}, {"name": "finset.attach", "description": " `attach s` takes the elements of `s` and forms a new set of elements of the subtype\n`{x // x \u2208 s}`."}, {"name": "finset.inter_singleton_of_mem", "description": ""}, {"name": "finset.union_assoc", "description": ""}, {"name": "finset.disjoint_bUnion_right", "description": ""}, {"name": "finset.update_piecewise", "description": ""}, {"name": "finset.disjoint_union_right", "description": ""}, {"name": "list.to_finset", "description": "`to_finset l` removes duplicates from the list `l` to produce a finset."}, {"name": "finset.mem_insert", "description": ""}, {"name": "finset.ssubset_iff_exists_subset_erase", "description": ""}, {"name": "finset.not_disjoint_iff", "description": ""}, {"name": "finset.val_le_iff_val_subset", "description": ""}, {"name": "finset.has_singleton", "description": "`{a} : finset a` is the set `{a}` containing `a` and nothing else.\n\nThis differs from `insert a \u2205` in that it does not require a `decidable_eq` instance for `\u03b1`."}, {"name": "finset.singleton_ne_empty", "description": ""}, {"name": "finset.filter_congr", "description": ""}, {"name": "finset.set_of_mem", "description": ""}, {"name": "finset.disj_union_singleton", "description": ""}, {"name": "finset.disj_union_eq_union", "description": ""}, {"name": "finset.pi_finset_coe.can_lift", "description": ""}, {"name": "finset.set.has_coe_t", "description": "Convert a finset to a set in the natural way."}, {"name": "finset.image_id", "description": ""}, {"name": "finset.not_mem_mono", "description": ""}, {"name": "finset.forall_mem_insert", "description": ""}, {"name": "finset.superset.trans", "description": ""}, {"name": "finset.union_sdiff_self", "description": ""}, {"name": "finset.filter_union_right", "description": ""}, {"name": "list.to_finset_append", "description": ""}, {"name": "finset.subset.trans", "description": ""}, {"name": "finset.disjoint_singleton_left", "description": ""}, {"name": "finset.erase", "description": "`erase s a` is the set `s - {a}`, that is, the elements of `s` which are\n not equal to `a`."}, {"name": "finset.piecewise", "description": " `s.piecewise f g` is the function equal to `f` on the finset `s`, and to `g` on its\ncomplement."}, {"name": "finset.choose_property", "description": ""}, {"name": "finset.eq_singleton_iff_unique_mem", "description": ""}, {"name": "finset.image_subset_iff", "description": ""}, {"name": "finset.sdiff_ssubset", "description": ""}, {"name": "finset.fiber_nonempty_iff_mem_image", "description": ""}, {"name": "finset.has_union.union.is_idempotent", "description": ""}, {"name": "finset.inter_distrib_left", "description": ""}, {"name": "finset.mem_singleton", "description": ""}, {"name": "disjoint.of_image_finset", "description": ""}, {"name": "finset.coe_cons", "description": ""}, {"name": "finset.choose_x", "description": " Given a finset `l` and a predicate `p`, associate to a proof that there is a unique element of\n`l` satisfying `p` this unique element, as an element of the corresponding subtype."}, {"name": "finset.nodup_to_list", "description": ""}, {"name": "finset.inter_comm", "description": ""}, {"name": "finset.map_inter", "description": ""}, {"name": "function.commute.finset_image", "description": ""}, {"name": "finset.sdiff_insert_of_not_mem", "description": ""}, {"name": "finset.union_eq_sdiff_union_sdiff_union_inter", "description": ""}, {"name": "finset.eq_empty_iff_forall_not_mem", "description": ""}, {"name": "finset.union_self", "description": ""}, {"name": "finset.map_nonempty", "description": ""}, {"name": "finset.pi_finset_coe.can_lift'", "description": ""}, {"name": "finset.subset_coe_filter_of_subset_forall", "description": ""}, {"name": "finset.eq_empty_of_ssubset_singleton", "description": ""}, {"name": "finset.mem_filter", "description": ""}, {"name": "finset.coe_sdiff", "description": ""}, {"name": "finset.coe_inj", "description": ""}, {"name": "finset.inter_distrib_right", "description": ""}, {"name": "finset.not_mem_sdiff_of_mem_right", "description": ""}, {"name": "finset.inter_insert_of_not_mem", "description": ""}, {"name": "finset.erase_insert", "description": ""}, {"name": "finset.mem_of_mem_insert_of_ne", "description": ""}, {"name": "finset.sdiff_union_self_eq_union", "description": ""}, {"name": "finset.nonempty.mono", "description": ""}, {"name": "finset.image_erase", "description": ""}, {"name": "finset.inter_subset_left", "description": ""}, {"name": "finset.mem_def", "description": ""}, {"name": "finset.subset_def", "description": ""}, {"name": "finset.disjoint_filter_filter", "description": ""}, {"name": "finset.subset_cons", "description": ""}, {"name": "finset.inter_left_comm", "description": ""}, {"name": "finset.le_iff_subset", "description": ""}, {"name": "finset.range_one", "description": ""}, {"name": "finset.mem_range", "description": ""}, {"name": "finset.image_val", "description": ""}, {"name": "list.to_finset_nil", "description": ""}, {"name": "finset.filter_or", "description": ""}, {"name": "finset.cons_eq_insert", "description": ""}, {"name": "finset.filter_congr_decidable", "description": ""}, {"name": "finset.sizeof_lt_sizeof_of_mem", "description": ""}, {"name": "finset.map_cast_heq", "description": ""}, {"name": "finset.has_inter", "description": "`s \u2229 t` is the set such that `a \u2208 s \u2229 t` iff `a \u2208 s` and `a \u2208 t`."}, {"name": "finset.subtype_eq_empty", "description": ""}, {"name": "multiset.to_finset_eq", "description": ""}, {"name": "finset.insert_inj_on", "description": ""}, {"name": "finset.inter_val", "description": ""}, {"name": "finset.image_empty", "description": ""}, {"name": "finset.inter_filter", "description": ""}, {"name": "finset.sdiff_disjoint", "description": ""}, {"name": "finset.subtype_map", "description": " `s.subtype p` converts back to `s.filter p` with\n`embedding.subtype`."}, {"name": "finset.image_subset_image", "description": ""}, {"name": "finset.unique", "description": ""}, {"name": "finset.mem_singleton_self", "description": ""}, {"name": "finset.insert_ne_empty", "description": ""}, {"name": "finset.union_sdiff_of_subset", "description": ""}, {"name": "finset.decidable_nonempty", "description": ""}, {"name": "finset.piecewise_le_of_le_of_le", "description": ""}, {"name": "finset.pairwise_disjoint_coe", "description": ""}, {"name": "list.disjoint_to_finset_iff_disjoint", "description": ""}, {"name": "finset.filter_cons_of_neg", "description": ""}, {"name": "finset.union_inter_cancel_right", "description": ""}, {"name": "finset.inter_subset_right", "description": ""}, {"name": "finset.image_bUnion_filter_eq", "description": ""}, {"name": "finset.disjoint_val", "description": ""}, {"name": "finset.inter_eq_right_iff_subset", "description": ""}, {"name": "finset.subset_union_right", "description": ""}, {"name": "finset.subset.antisymm_iff", "description": ""}, {"name": "finset.erase_empty", "description": ""}, {"name": "finset.disjoint_of_subset_right", "description": ""}, {"name": "finset.disjoint_insert_left", "description": ""}, {"name": "finset.mem_erase", "description": ""}, {"name": "finset.image", "description": "`image f s` is the forward image of `s` under `f`."}, {"name": "finset.union_eq_union_iff_left", "description": ""}, {"name": "finset.disjoint_left", "description": ""}, {"name": "finset.filter_disj_union", "description": ""}, {"name": "finset.le_piecewise_of_le_of_le", "description": ""}, {"name": "finset.filter_union_filter_neg_eq", "description": ""}, {"name": "finset.filter_erase", "description": ""}, {"name": "finset.order_bot", "description": ""}, {"name": "finset.nonempty_range_iff", "description": ""}, {"name": "finset.inter_insert_of_mem", "description": ""}, {"name": "finset.inter_singleton_of_not_mem", "description": ""}, {"name": "finset.filter_subset_filter", "description": ""}, {"name": "finset.pair_comm", "description": ""}, {"name": "finset.sdiff_sdiff_eq_self", "description": ""}, {"name": "finset.disjoint_iff_inter_eq_empty", "description": ""}, {"name": "finset.sdiff_sdiff_self_left", "description": ""}, {"name": "finset.subset_inter", "description": ""}, {"name": "finset.to_list_cons", "description": ""}, {"name": "finset.subset_of_eq", "description": ""}, {"name": "finset.coe_ssubset", "description": ""}, {"name": "finset.mem_cons", "description": ""}, {"name": "list.to_finset.ext", "description": ""}, {"name": "multiset.disjoint_to_finset", "description": ""}, {"name": "finset.eq_of_mem_singleton", "description": ""}, {"name": "finset.forall_mem_empty_iff", "description": ""}, {"name": "finset.mem_inter", "description": ""}, {"name": "finset.erase_ne_self", "description": ""}, {"name": "finset.sdiff_eq_self_iff_disjoint", "description": ""}, {"name": "finset.union_subset_right", "description": ""}, {"name": "finset.mem_coe", "description": ""}, {"name": "finset.disjoint_singleton", "description": ""}, {"name": "finset.sdiff_inter_distrib_right", "description": ""}, {"name": "finset.inter_subset_ite", "description": ""}, {"name": "finset.erase_ssubset_insert", "description": ""}, {"name": "finset.sdiff_insert_insert_of_mem_of_not_mem", "description": ""}, {"name": "finset.has_coe_to_sort", "description": "Coercion from a finset to the corresponding subtype."}, {"name": "finset.erase_val", "description": ""}, {"name": "finset.attach_map_val", "description": ""}, {"name": "finset.union_val", "description": ""}, {"name": "finset.insert.comm", "description": ""}, {"name": "finset.piecewise_eq_of_not_mem", "description": ""}, {"name": "finset.insert_union_distrib", "description": ""}, {"name": "finset.decidable_mem", "description": ""}, {"name": "finset.subset.refl", "description": ""}, {"name": "finset.insert_val", "description": ""}, {"name": "finset.update_piecewise_of_not_mem", "description": ""}, {"name": "list.to_finset_eq", "description": ""}, {"name": "finset.union_subset_union", "description": ""}, {"name": "finset.val_eq_zero", "description": ""}, {"name": "finset.ssubset_iff_exists_cons_subset", "description": ""}, {"name": "list.to_finset_eq_empty_iff", "description": ""}, {"name": "finset.coe_filter", "description": ""}, {"name": "finset.cons_induction", "description": ""}, {"name": "finset.range_add_one'", "description": ""}, {"name": "finset.erase_insert_eq_erase", "description": ""}, {"name": "finset.mem_union_right", "description": ""}, {"name": "list.to_finset_surj_on", "description": ""}, {"name": "finset.piecewise_le_piecewise'", "description": ""}, {"name": "finset.bUnion_val", "description": ""}, {"name": "finset.mem_mk", "description": ""}, {"name": "finset.bUnion_subset_bUnion_of_subset_left", "description": ""}, {"name": "finset.coe_image", "description": ""}, {"name": "finset.erase_idem", "description": ""}, {"name": "finset.pairwise_cons'", "description": ""}, {"name": "finset.dedup_eq_self", "description": ""}, {"name": "list.to_finset_cons", "description": ""}, {"name": "finset.insert_erase_subset", "description": ""}, {"name": "finset.image_image", "description": ""}, {"name": "finset.ssubset_singleton_iff", "description": ""}, {"name": "finset.inter_right_idem", "description": ""}, {"name": "finset.not_mem_sdiff_of_not_mem_left", "description": ""}, {"name": "finset.monotone_filter_right", "description": ""}, {"name": "finset.union_sdiff_left", "description": ""}, {"name": "function.semiconj.finset_map", "description": ""}, {"name": "finset.update_eq_piecewise", "description": ""}, {"name": "finset.has_subset.subset.is_trans", "description": ""}, {"name": "finset.nonempty.image", "description": ""}, {"name": "finset.map_to_finset", "description": ""}, {"name": "finset.inter_inter_distrib_left", "description": ""}, {"name": "finset.nonempty.image_iff", "description": ""}, {"name": "directed.exists_mem_subset_of_finset_subset_bUnion", "description": ""}, {"name": "finset.filter_bUnion", "description": ""}, {"name": "finset.ne_of_mem_erase", "description": ""}, {"name": "finset.ne_insert_of_not_mem", "description": ""}, {"name": "finset.nonempty_coe_sort", "description": ""}, {"name": "finset.coe_injective", "description": ""}, {"name": "finset.piecewise_insert_of_ne", "description": ""}, {"name": "finset.bUnion_image", "description": ""}, {"name": "finset.nonempty.ne_empty", "description": ""}, {"name": "finset.sdiff_nonempty", "description": ""}, {"name": "finset.filter_filter", "description": ""}, {"name": "finset.has_subset.subset.is_antisymm", "description": ""}, {"name": "finset.union_subset_left", "description": ""}, {"name": "finset.insert_nonempty", "description": ""}, {"name": "finset.attach_val", "description": ""}, {"name": "finset.choose", "description": " Given a finset `l` and a predicate `p`, associate to a proof that there is a unique element of\n`l` satisfying `p` this unique element, as an element of the ambient type."}, {"name": "with_bot.is_well_order.gt", "description": ""}, {"name": "codisjoint_top_left", "description": ""}, {"name": "not_is_bot_iff_ne_bot", "description": ""}, {"name": "with_top.some_lt_some", "description": ""}, {"name": "with_bot.le_coe_get_or_else", "description": ""}, {"name": "is_compl.inf_left_le_of_le_sup_right", "description": ""}, {"name": "order_bot", "description": " An order is an `order_bot` if it has a least element.\nWe state this using a data mixin, holding the value of `\u22a5` and the least element constraint."}, {"name": "order_bot.bot", "description": " An order is an `order_bot` if it has a least element.\nWe state this using a data mixin, holding the value of `\u22a5` and the least element constraint."}, {"name": "order_bot.bot_le", "description": " An order is an `order_bot` if it has a least element.\nWe state this using a data mixin, holding the value of `\u22a5` and the least element constraint."}, {"name": "codisjoint.sup_left'", "description": ""}, {"name": "Prop.linear_order", "description": ""}, {"name": "with_bot.well_founded_lt", "description": ""}, {"name": "with_bot.get_or_else_bot_le_iff", "description": ""}, {"name": "is_top_top", "description": ""}, {"name": "eq_bot_iff", "description": ""}, {"name": "strict_mono.with_bot_map", "description": ""}, {"name": "with_bot.has_to_format", "description": ""}, {"name": "bool.bounded_order", "description": ""}, {"name": "with_top.order_bot", "description": ""}, {"name": "with_bot.map_bot", "description": ""}, {"name": "with_top.rec_top_coe_coe", "description": ""}, {"name": "disjoint_sup_left", "description": ""}, {"name": "disjoint_bot_right", "description": ""}, {"name": "disjoint_sup_right", "description": ""}, {"name": "disjoint_to_dual_iff", "description": ""}, {"name": "with_bot.coe_eq_coe", "description": ""}, {"name": "bot_eq_ff", "description": ""}, {"name": "with_top.order_top", "description": ""}, {"name": "with_bot.semilattice_inf", "description": ""}, {"name": "disjoint.ne", "description": ""}, {"name": "with_top.is_total_le", "description": ""}, {"name": "antitone_lt", "description": ""}, {"name": "ne_bot_of_le_ne_bot", "description": ""}, {"name": "disjoint.eq_bot_of_le", "description": ""}, {"name": "order_bot.ext", "description": ""}, {"name": "is_compl.sup_eq_top", "description": ""}, {"name": "max_bot_right", "description": ""}, {"name": "with_top.le_none", "description": ""}, {"name": "with_bot.semilattice_sup", "description": ""}, {"name": "monotone_lt", "description": ""}, {"name": "eq_top_mono", "description": ""}, {"name": "disjoint", "description": "Two elements of a lattice are disjoint if their inf is the bottom element.\n (This generalizes disjoint sets, viewed as members of the subset lattice.)"}, {"name": "strict_mono.with_top_map", "description": ""}, {"name": "is_compl.left_unique", "description": ""}, {"name": "ne.lt_top'", "description": ""}, {"name": "top_disjoint", "description": ""}, {"name": "disjoint.inf_left'", "description": ""}, {"name": "with_top.top_ne_coe", "description": ""}, {"name": "with_bot.linear_order", "description": ""}, {"name": "order_dual.order_bot", "description": ""}, {"name": "is_min_iff_eq_bot", "description": ""}, {"name": "inf_Prop_eq", "description": ""}, {"name": "monotone.with_top_map", "description": ""}, {"name": "with_top.bounded_order", "description": ""}, {"name": "with_top.untop'", "description": "Specialization of `option.get_or_else` to values in `with_top \u03b1` that respects API boundaries."}, {"name": "subtype.coe_eq_top_iff", "description": ""}, {"name": "ne.bot_lt'", "description": ""}, {"name": "with_top.lt_iff_exists_coe_btwn", "description": ""}, {"name": "is_compl.inf_eq_bot", "description": ""}, {"name": "with_bot.trichotomous.gt", "description": ""}, {"name": "exists_ge_and_iff_exists", "description": ""}, {"name": "pi.top_apply", "description": ""}, {"name": "bot_sup_eq", "description": ""}, {"name": "disjoint_self", "description": ""}, {"name": "is_max_top", "description": ""}, {"name": "bounded_order.to_order_bot", "description": ""}, {"name": "sup_eq_bot_iff", "description": ""}, {"name": "disjoint.eq_bot_of_ge", "description": ""}, {"name": "not_lt_bot", "description": ""}, {"name": "max_eq_top", "description": ""}, {"name": "with_top.semilattice_sup", "description": ""}, {"name": "bounded_order.lift", "description": "Pullback a `bounded_order`."}, {"name": "order_top.ext_top", "description": ""}, {"name": "with_bot.get_or_else_bot_lt_iff", "description": ""}, {"name": "top_sup_eq", "description": ""}, {"name": "ne_top_of_le_ne_top", "description": ""}, {"name": "with_top.map", "description": "Lift a map `f : \u03b1 \u2192 \u03b2` to `with_top \u03b1 \u2192 with_top \u03b2`. Implemented using `option.map`."}, {"name": "is_bot_bot", "description": ""}, {"name": "codisjoint.sup_left", "description": ""}, {"name": "with_bot.is_well_order.lt", "description": ""}, {"name": "bot_order_or_no_bot_order", "description": " An order is (noncomputably) either an `order_bot` or a `no_order_bot`. Use as\n`casesI bot_order_or_no_bot_order \u03b1`."}, {"name": "with_top.rec_top_coe_top", "description": ""}, {"name": "with_top.densely_ordered", "description": ""}, {"name": "disjoint.symm", "description": ""}, {"name": "with_bot.not_coe_le_bot", "description": ""}, {"name": "codisjoint.of_codisjoint_sup_of_le'", "description": ""}, {"name": "bot_codisjoint", "description": ""}, {"name": "codisjoint.left_le_of_le_inf_left", "description": ""}, {"name": "subtype.order_bot", "description": "A subtype remains a `\u22a5`-order if the property holds at `\u22a5`."}, {"name": "ne_top_of_lt", "description": ""}, {"name": "bot_unique", "description": ""}, {"name": "eq_bot_of_is_compl_top", "description": ""}, {"name": "with_bot.none_le", "description": ""}, {"name": "Prop.bounded_order", "description": "Propositions form a bounded order."}, {"name": "is_compl.right_unique", "description": ""}, {"name": "with_top.map_top", "description": ""}, {"name": "with_bot.coe_lt_coe", "description": ""}, {"name": "codisjoint_iff", "description": ""}, {"name": "with_bot.densely_ordered", "description": ""}, {"name": "codisjoint.mono", "description": ""}, {"name": "monotone_or", "description": ""}, {"name": "order_bot.ext_bot", "description": ""}, {"name": "monotone.ball", "description": ""}, {"name": "is_compl.dual", "description": ""}, {"name": "with_top.coe_untop", "description": ""}, {"name": "bot_lt_top", "description": ""}, {"name": "strict_mono.minimal_preimage_bot", "description": ""}, {"name": "is_compl.sup_inf", "description": ""}, {"name": "with_top.coe_lt_iff", "description": ""}, {"name": "with_top.inhabited", "description": ""}, {"name": "with_bot.some_le_some", "description": ""}, {"name": "eq_bot_or_bot_lt", "description": ""}, {"name": "with_bot.trichotomous.lt", "description": ""}, {"name": "has_bot_nonempty", "description": ""}, {"name": "Prop.distrib_lattice", "description": "Propositions form a distributive lattice."}, {"name": "with_bot.order_top", "description": ""}, {"name": "pi.bounded_order", "description": ""}, {"name": "with_top.has_reflect", "description": ""}, {"name": "is_top.eq_top", "description": "**Alias** of the forward direction of `is_top_iff_eq_top`."}, {"name": "strict_mono.maximal_preimage_top", "description": ""}, {"name": "order_dual.to_dual_top", "description": ""}, {"name": "with_bot.decidable_lt", "description": ""}, {"name": "disjoint.mono_right", "description": ""}, {"name": "codisjoint.symm", "description": ""}, {"name": "order_dual.of_dual_top", "description": ""}, {"name": "with_bot.lt_coe_iff", "description": ""}, {"name": "with_top", "description": "Attach `\u22a4` to a type."}, {"name": "codisjoint.of_codisjoint_sup_of_le", "description": ""}, {"name": "disjoint_assoc", "description": ""}, {"name": "max_eq_bot", "description": ""}, {"name": "min_top_right", "description": ""}, {"name": "is_min.eq_bot", "description": "**Alias** of the forward direction of `is_min_iff_eq_bot`."}, {"name": "with_top.no_min_order", "description": ""}, {"name": "top_inf_eq", "description": ""}, {"name": "top_ne_bot", "description": ""}, {"name": "with_top.well_founded_gt", "description": ""}, {"name": "codisjoint.eq_top_of_le", "description": ""}, {"name": "subsingleton_of_top_le_bot", "description": ""}, {"name": "is_compl.left_le_iff", "description": ""}, {"name": "with_top.some_eq_coe", "description": ""}, {"name": "with_bot.well_founded_gt", "description": ""}, {"name": "bounded_order.to_order_top", "description": ""}, {"name": "disjoint_top", "description": ""}, {"name": "pi.top_def", "description": ""}, {"name": "with_bot.get_or_else_bot", "description": ""}, {"name": "min_bot_right", "description": ""}, {"name": "with_bot.is_total_le", "description": ""}, {"name": "monotone_le", "description": ""}, {"name": "is_bot_iff_eq_bot", "description": ""}, {"name": "lt_top_iff_ne_top", "description": ""}, {"name": "max_top_left", "description": ""}, {"name": "codisjoint_left_comm", "description": ""}, {"name": "is_complemented", "description": " A complemented bounded lattice is one where every element has a (not necessarily unique)\ncomplement."}, {"name": "is_complemented.exists_is_compl", "description": " A complemented bounded lattice is one where every element has a (not necessarily unique)\ncomplement."}, {"name": "with_bot.unbot'_bot", "description": ""}, {"name": "with_top.decidable_le", "description": ""}, {"name": "with_bot.has_coe_t", "description": ""}, {"name": "with_bot.coe_min", "description": ""}, {"name": "bounded_order.ext", "description": ""}, {"name": "bot_ne_top", "description": ""}, {"name": "is_compl.right_le_iff", "description": ""}, {"name": "disjoint.eq_bot_of_self", "description": "**Alias** of the forward direction of `disjoint_self`."}, {"name": "with_top.coe_lt_top", "description": ""}, {"name": "order_dual.of_dual_bot", "description": ""}, {"name": "with_top.lattice", "description": ""}, {"name": "with_top.coe_inf", "description": ""}, {"name": "with_top.coe_le_coe", "description": ""}, {"name": "with_bot.map_le_iff", "description": ""}, {"name": "with_top.coe_ne_top", "description": ""}, {"name": "with_bot.coe_le_iff", "description": ""}, {"name": "with_top.is_well_order.lt", "description": ""}, {"name": "with_top.rec_top_coe", "description": "Recursor for `with_top` using the preferred forms `\u22a4` and `\u2191a`."}, {"name": "with_bot.has_le", "description": ""}, {"name": "with_top.map_coe", "description": ""}, {"name": "with_top.has_lt", "description": ""}, {"name": "is_compl.of_dual", "description": ""}, {"name": "strict_mono.apply_eq_bot_iff", "description": ""}, {"name": "inf_top_eq", "description": ""}, {"name": "with_bot", "description": "Attach `\u22a5` to a type."}, {"name": "ne_bot_of_gt", "description": ""}, {"name": "with_top.not_none_lt", "description": ""}, {"name": "with_bot.coe_max", "description": ""}, {"name": "Prop.le_is_total", "description": ""}, {"name": "with_top.untop'_coe", "description": ""}, {"name": "codisjoint_inf_right", "description": ""}, {"name": "is_compl.disjoint_right_iff", "description": ""}, {"name": "order_top", "description": " An order is an `order_top` if it has a greatest element.\nWe state this using a data mixin, holding the value of `\u22a4` and the greatest element constraint."}, {"name": "order_top.top", "description": " An order is an `order_top` if it has a greatest element.\nWe state this using a data mixin, holding the value of `\u22a4` and the greatest element constraint."}, {"name": "order_top.le_top", "description": " An order is an `order_top` if it has a greatest element.\nWe state this using a data mixin, holding the value of `\u22a4` and the greatest element constraint."}, {"name": "top_eq_tt", "description": ""}, {"name": "with_bot.unbot'_coe", "description": ""}, {"name": "with_bot.inhabited", "description": ""}, {"name": "with_bot.has_repr", "description": ""}, {"name": "is_compl_top_bot", "description": ""}, {"name": "with_top.preorder", "description": ""}, {"name": "with_top.linear_order", "description": ""}, {"name": "prod.order_top", "description": ""}, {"name": "with_bot.rec_bot_coe", "description": "Recursor for `with_bot` using the preferred forms `\u22a5` and `\u2191a`."}, {"name": "is_compl.antitone", "description": ""}, {"name": "subtype.mk_eq_bot_iff", "description": ""}, {"name": "with_bot.preorder", "description": ""}, {"name": "disjoint_left_comm", "description": ""}, {"name": "eq_top_iff", "description": ""}, {"name": "with_bot.coe_le", "description": ""}, {"name": "disjoint.dual", "description": ""}, {"name": "not_lt_top_iff", "description": ""}, {"name": "eq_top_of_bot_is_compl", "description": ""}, {"name": "with_bot.some_eq_coe", "description": ""}, {"name": "with_bot.order_bot", "description": ""}, {"name": "bounded_order", "description": "A bounded order describes an order `(\u2264)` with a top and bottom element,\n denoted `\u22a4` and `\u22a5` respectively."}, {"name": "bounded_order.top", "description": "A bounded order describes an order `(\u2264)` with a top and bottom element,\n denoted `\u22a4` and `\u22a5` respectively."}, {"name": "bounded_order.le_top", "description": "A bounded order describes an order `(\u2264)` with a top and bottom element,\n denoted `\u22a4` and `\u22a5` respectively."}, {"name": "bounded_order.bot", "description": "A bounded order describes an order `(\u2264)` with a top and bottom element,\n denoted `\u22a4` and `\u22a5` respectively."}, {"name": "bounded_order.bot_le", "description": "A bounded order describes an order `(\u2264)` with a top and bottom element,\n denoted `\u22a4` and `\u22a5` respectively."}, {"name": "eq_top_of_bot_eq_top", "description": ""}, {"name": "codisjoint.inf_left", "description": ""}, {"name": "with_bot.no_top_order", "description": ""}, {"name": "is_compl.le_sup_right_iff_inf_left_le", "description": ""}, {"name": "with_top.ne_top_iff_exists", "description": ""}, {"name": "eq_bot_of_top_is_compl", "description": ""}, {"name": "is_compl.inf_right_eq_bot_iff", "description": ""}, {"name": "has_top_nonempty", "description": ""}, {"name": "disjoint.inf_right'", "description": ""}, {"name": "is_compl.inf_left_eq_bot_iff", "description": ""}, {"name": "is_top_iff_eq_top", "description": ""}, {"name": "subsingleton_iff_bot_eq_top", "description": ""}, {"name": "with_bot.bounded_order", "description": ""}, {"name": "is_complemented.order_dual.is_complemented", "description": ""}, {"name": "codisjoint.comm", "description": ""}, {"name": "codisjoint.sup_right", "description": ""}, {"name": "with_top.le_coe", "description": ""}, {"name": "codisjoint.dual", "description": ""}, {"name": "with_bot.map_coe", "description": ""}, {"name": "with_bot.rec_bot_coe_coe", "description": ""}, {"name": "bot_le", "description": ""}, {"name": "order_dual.to_dual_bot", "description": ""}, {"name": "with_top.can_lift", "description": ""}, {"name": "is_bot.eq_bot", "description": "**Alias** of the forward direction of `is_bot_iff_eq_bot`."}, {"name": "with_top.is_well_order.gt", "description": ""}, {"name": "with_top.le_coe_iff", "description": ""}, {"name": "with_top.coe_min", "description": ""}, {"name": "with_bot.none_eq_bot", "description": ""}, {"name": "sup_bot_eq", "description": ""}, {"name": "eq_bot_of_minimal", "description": ""}, {"name": "subtype.bounded_order", "description": "A subtype remains a bounded order if the property holds at `\u22a5` and `\u22a4`."}, {"name": "is_compl.symm", "description": ""}, {"name": "subtype.coe_bot", "description": ""}, {"name": "eq_top_of_is_compl_bot", "description": ""}, {"name": "disjoint_bot_left", "description": ""}, {"name": "is_compl.disjoint_left_iff", "description": ""}, {"name": "prod.order_bot", "description": ""}, {"name": "disjoint.sup_left", "description": ""}, {"name": "disjoint.sup_right", "description": ""}, {"name": "order_top.lift", "description": "Pullback an `order_top`."}, {"name": "min_eq_top", "description": ""}, {"name": "has_bot", "description": "Typeclass for the `\u22a5` (`\\bot`) notation"}, {"name": "has_bot.bot", "description": "Typeclass for the `\u22a5` (`\\bot`) notation"}, {"name": "disjoint_iff", "description": ""}, {"name": "disjoint.of_disjoint_inf_of_le'", "description": ""}, {"name": "exists_le_and_iff_exists", "description": ""}, {"name": "disjoint_right_comm", "description": ""}, {"name": "with_top.semilattice_inf", "description": ""}, {"name": "with_bot.can_lift", "description": ""}, {"name": "subtype.mk_eq_top_iff", "description": ""}, {"name": "subtype.mk_top", "description": ""}, {"name": "codisjoint.mono_right", "description": ""}, {"name": "with_top.no_bot_order", "description": ""}, {"name": "with_top.some_le_some", "description": ""}, {"name": "prod.bounded_order", "description": ""}, {"name": "not_is_max_bot", "description": ""}, {"name": "with_top.untop_coe", "description": ""}, {"name": "strict_anti.apply_eq_top_iff", "description": ""}, {"name": "disjoint.eq_bot", "description": ""}, {"name": "symmetric_disjoint", "description": ""}, {"name": "codisjoint_inf_left", "description": ""}, {"name": "top_unique", "description": ""}, {"name": "antitone_le", "description": ""}, {"name": "with_top.has_to_format", "description": ""}, {"name": "codisjoint.eq_top", "description": ""}, {"name": "codisjoint.mono_left", "description": ""}, {"name": "codisjoint_of_dual_iff", "description": ""}, {"name": "not_is_min_top", "description": ""}, {"name": "is_compl.inf_sup", "description": ""}, {"name": "not_bot_lt_iff", "description": ""}, {"name": "le_top", "description": ""}, {"name": "pi.has_top", "description": ""}, {"name": "with_bot.lt_iff_exists_coe", "description": ""}, {"name": "with_bot.bot_ne_coe", "description": ""}, {"name": "disjoint.mono", "description": ""}, {"name": "codisjoint_assoc", "description": ""}, {"name": "with_bot.decidable_le", "description": ""}, {"name": "with_bot.coe_le_coe", "description": ""}, {"name": "has_top", "description": "Typeclass for the `\u22a4` (`\\top`) notation"}, {"name": "has_top.top", "description": "Typeclass for the `\u22a4` (`\\top`) notation"}, {"name": "with_top.has_le", "description": ""}, {"name": "with_top.partial_order", "description": ""}, {"name": "order_bot.to_has_bot", "description": ""}, {"name": "with_bot.le_coe_iff", "description": ""}, {"name": "with_bot.coe_unbot", "description": ""}, {"name": "eq_bot_mono", "description": ""}, {"name": "with_bot.lattice", "description": ""}, {"name": "with_bot.map", "description": "Lift a map `f : \u03b1 \u2192 \u03b2` to `with_bot \u03b1 \u2192 with_bot \u03b2`. Implemented using `option.map`."}, {"name": "not_is_max_iff_ne_top", "description": ""}, {"name": "antitone.ball", "description": ""}, {"name": "is_compl_bot_top", "description": ""}, {"name": "with_top.coe_max", "description": ""}, {"name": "with_bot.none_lt_some", "description": ""}, {"name": "inf_eq_top_iff", "description": ""}, {"name": "prod.has_top", "description": ""}, {"name": "min_top_left", "description": ""}, {"name": "codisjoint_self", "description": ""}, {"name": "disjoint.left_le_of_le_sup_left", "description": ""}, {"name": "with_top.has_top", "description": ""}, {"name": "subtype.coe_eq_bot_iff", "description": ""}, {"name": "is_compl.of_eq", "description": ""}, {"name": "monotone_and", "description": ""}, {"name": "with_bot.some_lt_some", "description": ""}, {"name": "with_top.some_lt_none", "description": ""}, {"name": "codisjoint_top_right", "description": ""}, {"name": "disjoint.mono_left", "description": ""}, {"name": "min_eq_bot", "description": ""}, {"name": "pi.has_bot", "description": ""}, {"name": "order_dual.has_top", "description": ""}, {"name": "with_top.untop'_top", "description": ""}, {"name": "with_top.coe_lt_coe", "description": ""}, {"name": "ne.bot_lt", "description": ""}, {"name": "with_bot.unbot'", "description": "Specialization of `option.get_or_else` to values in `with_bot \u03b1` that respects API boundaries."}, {"name": "disjoint.inf_left", "description": ""}, {"name": "is_min_bot", "description": ""}, {"name": "order_dual.order_top", "description": ""}, {"name": "with_bot.bot_lt_coe", "description": ""}, {"name": "sup_top_eq", "description": ""}, {"name": "with_bot.has_bot", "description": ""}, {"name": "disjoint.comm", "description": ""}, {"name": "prod.has_bot", "description": ""}, {"name": "subtype.order_top", "description": "A subtype remains a `\u22a4`-order if the property holds at `\u22a4`."}, {"name": "not_top_lt", "description": ""}, {"name": "strict_anti.apply_eq_bot_iff", "description": ""}, {"name": "max_bot_left", "description": ""}, {"name": "codisjoint.left_le_of_le_inf_right", "description": ""}, {"name": "eq_top_or_lt_top", "description": ""}, {"name": "with_top.not_top_le_coe", "description": ""}, {"name": "with_bot.unbot_coe", "description": ""}, {"name": "codisjoint.inf_right", "description": ""}, {"name": "bot_inf_eq", "description": ""}, {"name": "subtype.mk_bot", "description": ""}, {"name": "with_top.has_coe_t", "description": ""}, {"name": "codisjoint.ne", "description": ""}, {"name": "with_top.trichotomous.lt", "description": ""}, {"name": "symmetric_codisjoint", "description": ""}, {"name": "top_le_iff", "description": ""}, {"name": "codisjoint_to_dual_iff", "description": ""}, {"name": "with_bot.rec_bot_coe_bot", "description": ""}, {"name": "with_bot.partial_order", "description": ""}, {"name": "monotone.with_bot_map", "description": ""}, {"name": "has_lt.lt.ne_top", "description": "**Alias** of `ne_top_of_lt`."}, {"name": "disjoint_of_dual_iff", "description": ""}, {"name": "subtype.coe_top", "description": ""}, {"name": "order_dual.bounded_order", "description": ""}, {"name": "is_compl_of_dual_iff", "description": ""}, {"name": "codisjoint", "description": "Two elements of a lattice are codisjoint if their sup is the top element."}, {"name": "disjoint.inf_right", "description": ""}, {"name": "has_lt.lt.ne_bot", "description": "**Alias** of `ne_bot_of_gt`."}, {"name": "codisjoint_right_comm", "description": ""}, {"name": "ne.lt_top", "description": ""}, {"name": "disjoint.le_of_codisjoint", "description": ""}, {"name": "codisjoint.eq_top_of_ge", "description": ""}, {"name": "with_bot.ne_bot_iff_exists", "description": ""}, {"name": "disjoint.left_le_of_le_sup_right", "description": ""}, {"name": "with_top.coe_sup", "description": ""}, {"name": "top_order_or_no_top_order", "description": " An order is (noncomputably) either an `order_top` or a `no_order_top`. Use as\n`casesI bot_order_or_no_bot_order \u03b1`."}, {"name": "with_bot.coe_ne_bot", "description": ""}, {"name": "le_bot_iff", "description": ""}, {"name": "pi.bot_def", "description": ""}, {"name": "with_top.untop", "description": "Deconstruct a `x : with_top \u03b1` to the underlying value in `\u03b1`, given a proof that `x \u2260 \u22a4`."}, {"name": "not_is_min_iff_ne_bot", "description": ""}, {"name": "with_top.coe_le_iff", "description": ""}, {"name": "antitone.forall", "description": ""}, {"name": "strict_mono.apply_eq_top_iff", "description": ""}, {"name": "pi.order_top", "description": ""}, {"name": "codisjoint_bot", "description": ""}, {"name": "bot_lt_iff_ne_bot", "description": ""}, {"name": "pi.order_bot", "description": ""}, {"name": "with_top.decidable_lt", "description": ""}, {"name": "with_top.well_founded_lt", "description": ""}, {"name": "with_top.lt_iff_exists_coe", "description": ""}, {"name": "codisjoint.eq_top_of_self", "description": "**Alias** of the forward direction of `codisjoint_self`."}, {"name": "order_top.to_has_top", "description": ""}, {"name": "order_bot.lift", "description": "Pullback an `order_bot`."}, {"name": "with_top.map_le_iff", "description": ""}, {"name": "is_max.with_bot", "description": ""}, {"name": "is_compl_to_dual_iff", "description": ""}, {"name": "with_bot.has_lt", "description": ""}, {"name": "is_compl", "description": "Two elements `x` and `y` are complements of each other if `x \u2294 y = \u22a4` and `x \u2293 y = \u22a5`."}, {"name": "is_compl.disjoint", "description": "Two elements `x` and `y` are complements of each other if `x \u2294 y = \u22a4` and `x \u2293 y = \u22a5`."}, {"name": "is_compl.codisjoint", "description": "Two elements `x` and `y` are complements of each other if `x \u2294 y = \u22a4` and `x \u2293 y = \u22a5`."}, {"name": "with_top.trichotomous.gt", "description": ""}, {"name": "with_bot.lt_iff_exists_coe_btwn", "description": ""}, {"name": "inf_bot_eq", "description": ""}, {"name": "subsingleton_of_bot_eq_top", "description": ""}, {"name": "with_top.none_eq_top", "description": ""}, {"name": "with_bot.coe_sup", "description": ""}, {"name": "pi.bot_apply", "description": ""}, {"name": "is_min.with_top", "description": ""}, {"name": "order_dual.has_bot", "description": ""}, {"name": "disjoint.of_disjoint_inf_of_le", "description": ""}, {"name": "order_top.ext", "description": ""}, {"name": "is_max.eq_top", "description": "**Alias** of the forward direction of `is_max_iff_eq_top`."}, {"name": "with_bot.coe_inf", "description": ""}, {"name": "monotone.forall", "description": ""}, {"name": "with_bot.has_reflect", "description": ""}, {"name": "is_compl.le_right_iff", "description": ""}, {"name": "with_bot.unbot", "description": "Deconstruct a `x : with_bot \u03b1` to the underlying value in `\u03b1`, given a proof that `x \u2260 \u22a5`."}, {"name": "with_bot.not_lt_none", "description": ""}, {"name": "codisjoint.sup_right'", "description": ""}, {"name": "with_bot.no_max_order", "description": ""}, {"name": "eq_bot_of_bot_eq_top", "description": ""}, {"name": "with_top.coe_eq_coe", "description": ""}, {"name": "is_max_iff_eq_top", "description": ""}, {"name": "is_compl.le_left_iff", "description": ""}, {"name": "not_is_top_iff_ne_top", "description": ""}, {"name": "max_top_right", "description": ""}, {"name": "sup_Prop_eq", "description": ""}, {"name": "with_top.has_repr", "description": ""}, {"name": "min_bot_left", "description": ""}, {"name": "lt_add_one", "description": ""}, {"name": "mul_self_le_mul_self_of_le_of_neg_le", "description": ""}, {"name": "neg_of_mul_pos_right", "description": ""}, {"name": "mul_le_mul_right", "description": ""}, {"name": "linear_ordered_ring.to_nontrivial", "description": ""}, {"name": "one_lt_mul", "description": ""}, {"name": "abs_cases", "description": "For an element `a` of a linear ordered ring, either `abs a = a` and `0 \u2264 a`,\n   or `abs a = -a` and `a < 0`.\n   Use cases on this lemma to automate linarith in inequalities"}, {"name": "monotone.mul_const", "description": ""}, {"name": "mul_self_pos", "description": ""}, {"name": "linear_ordered_semiring.to_ordered_semiring", "description": ""}, {"name": "dvd_abs", "description": ""}, {"name": "one_lt_mul_of_lt_of_le", "description": ""}, {"name": "with_bot.mul_coe", "description": ""}, {"name": "decidable.mul_nonneg", "description": ""}, {"name": "with_top.comm_monoid_with_zero", "description": ""}, {"name": "ordered_comm_semiring.to_comm_semiring", "description": ""}, {"name": "lt_mul_left", "description": ""}, {"name": "abs_mul_abs_self", "description": ""}, {"name": "mul_lt_mul_of_neg_left", "description": ""}, {"name": "le_neg_self_iff", "description": ""}, {"name": "with_bot.bot_mul", "description": ""}, {"name": "strict_mono.mul_const", "description": ""}, {"name": "mul_pos_iff", "description": ""}, {"name": "mul_nonpos_of_nonpos_of_nonneg", "description": ""}, {"name": "decidable.mul_lt_one_of_nonneg_of_lt_one_right", "description": ""}, {"name": "le_iff_exists_nonneg_add", "description": ""}, {"name": "decidable.mul_lt_mul", "description": ""}, {"name": "decidable.mul_le_of_le_one_left", "description": ""}, {"name": "mul_le_mul_left", "description": ""}, {"name": "abs_eq_iff_mul_self_eq", "description": ""}, {"name": "with_bot.monoid_with_zero", "description": ""}, {"name": "mul_lt_mul_of_pos_left", "description": ""}, {"name": "with_top.no_zero_divisors", "description": ""}, {"name": "add_le_mul_of_left_le_right", "description": ""}, {"name": "zero_lt_one'", "description": ""}, {"name": "linear_ordered_semiring", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.add", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.add_assoc", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.zero", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.zero_add", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.add_zero", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.nsmul", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.nsmul_zero'", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.nsmul_succ'", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.add_comm", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.mul", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.left_distrib", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.right_distrib", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.zero_mul", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.mul_zero", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.mul_assoc", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.one", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.one_mul", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.mul_one", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.nat_cast", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.nat_cast_zero", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.nat_cast_succ", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.npow", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.npow_zero'", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.npow_succ'", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.add_left_cancel", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.le", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.lt", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.le_refl", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.le_trans", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.lt_iff_le_not_le", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.le_antisymm", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.add_le_add_left", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.le_of_add_le_add_left", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.zero_le_one", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.mul_lt_mul_of_pos_left", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.mul_lt_mul_of_pos_right", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.le_total", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.decidable_le", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.decidable_eq", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.decidable_lt", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.max", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.max_def", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.min", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.min_def", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_semiring.exists_pair_ne", "description": "A `linear_ordered_semiring \u03b1` is a nontrivial semiring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "mul_nonneg_of_nonpos_of_nonpos", "description": ""}, {"name": "mul_le_iff_le_one_left", "description": ""}, {"name": "mul_le_mul_of_nonneg_right", "description": ""}, {"name": "pos_of_mul_neg_left", "description": ""}, {"name": "ordered_comm_ring.to_comm_ring", "description": ""}, {"name": "neg_le_self_iff", "description": ""}, {"name": "zero_lt_four", "description": ""}, {"name": "le_mul_iff_one_le_right", "description": ""}, {"name": "two_ne_zero", "description": ""}, {"name": "with_bot.coe_mul", "description": ""}, {"name": "pos_iff_neg_of_mul_neg", "description": ""}, {"name": "with_bot.mul_eq_bot_iff", "description": ""}, {"name": "neg_of_mul_pos_left", "description": ""}, {"name": "ring.total_positive_cone", "description": "A positive cone in a ring induces a linear order if `1` is a positive element."}, {"name": "ring.total_positive_cone.nonneg", "description": "A positive cone in a ring induces a linear order if `1` is a positive element."}, {"name": "ring.total_positive_cone.pos", "description": "A positive cone in a ring induces a linear order if `1` is a positive element."}, {"name": "ring.total_positive_cone.pos_iff", "description": "A positive cone in a ring induces a linear order if `1` is a positive element."}, {"name": "ring.total_positive_cone.zero_nonneg", "description": "A positive cone in a ring induces a linear order if `1` is a positive element."}, {"name": "ring.total_positive_cone.add_nonneg", "description": "A positive cone in a ring induces a linear order if `1` is a positive element."}, {"name": "ring.total_positive_cone.nonneg_antisymm", "description": "A positive cone in a ring induces a linear order if `1` is a positive element."}, {"name": "ring.total_positive_cone.one_nonneg", "description": "A positive cone in a ring induces a linear order if `1` is a positive element."}, {"name": "ring.total_positive_cone.mul_pos", "description": "A positive cone in a ring induces a linear order if `1` is a positive element."}, {"name": "ring.total_positive_cone.nonneg_decidable", "description": "A positive cone in a ring induces a linear order if `1` is a positive element."}, {"name": "ring.total_positive_cone.nonneg_total", "description": "A positive cone in a ring induces a linear order if `1` is a positive element."}, {"name": "ring.total_positive_cone.one_pos", "description": "A positive cone in a ring induces a linear order if `1` is a positive element."}, {"name": "mul_le_mul_left_of_neg", "description": ""}, {"name": "nonneg_of_mul_nonneg_left", "description": ""}, {"name": "canonically_ordered_comm_semiring.zero_lt_one", "description": "A version of `zero_lt_one : 0 < 1` for a `canonically_ordered_comm_semiring`."}, {"name": "monoid_with_zero_hom.with_top_map_apply", "description": ""}, {"name": "decidable.mul_le_one", "description": ""}, {"name": "lt_two_mul_self", "description": ""}, {"name": "ordered_comm_ring.to_ordered_ring", "description": ""}, {"name": "order_dual.non_unital_comm_ring", "description": ""}, {"name": "add_le_mul_two_add", "description": ""}, {"name": "nonneg_of_mul_nonpos_right", "description": ""}, {"name": "canonically_ordered_comm_semiring.mul_pos", "description": ""}, {"name": "with_top.top_mul", "description": ""}, {"name": "mul_add_mul_le_mul_add_mul'", "description": "Binary **rearrangement inequality**."}, {"name": "bit1_le_bit1", "description": ""}, {"name": "mul_lt_mul_left", "description": ""}, {"name": "with_bot.comm_monoid_with_zero", "description": ""}, {"name": "mul_neg_iff", "description": ""}, {"name": "ordered_ring.mk_of_positive_cone", "description": " Construct an `ordered_ring` by\ndesignating a positive cone in an existing `ring`."}, {"name": "ordered_comm_semiring.to_ordered_semiring", "description": ""}, {"name": "zero_lt_mul_right", "description": ""}, {"name": "ring.positive_cone.to_positive_cone", "description": "Forget that a positive cone in a ring respects the multiplicative structure."}, {"name": "order_dual.has_distrib_neg", "description": ""}, {"name": "lt_mul_of_one_lt_left", "description": ""}, {"name": "lt_mul_iff_one_lt_left", "description": ""}, {"name": "with_top.monoid_with_zero", "description": ""}, {"name": "nonneg_le_nonneg_of_sq_le_sq", "description": ""}, {"name": "linear_ordered_ring.to_linear_order", "description": ""}, {"name": "with_bot.comm_semiring", "description": ""}, {"name": "order_dual.non_assoc_ring", "description": ""}, {"name": "le_mul_of_one_le_right", "description": ""}, {"name": "order_dual.distrib", "description": ""}, {"name": "max_mul_of_nonneg", "description": ""}, {"name": "abs_dvd_abs", "description": ""}, {"name": "mul_self_lt_mul_self_iff", "description": ""}, {"name": "with_top.mul_zero_one_class", "description": "`nontrivial \u03b1` is needed here as otherwise we have `1 * \u22a4 = \u22a4` but also `= 0 * \u22a4 = 0`."}, {"name": "mul_lt_mul_of_neg_right", "description": ""}, {"name": "ordered_semiring.to_semiring", "description": ""}, {"name": "order_dual.non_unital_semiring", "description": ""}, {"name": "mul_lt_mul", "description": ""}, {"name": "mul_add_mul_lt_mul_add_mul", "description": "Binary strict **rearrangement inequality**."}, {"name": "decidable.mul_le_of_le_one_right", "description": ""}, {"name": "lt_of_mul_lt_mul_right", "description": ""}, {"name": "with_bot.mul_zero_one_class", "description": "`nontrivial \u03b1` is needed here as otherwise we have `1 * \u22a5 = \u22a5` but also `= 0 * \u22a5 = 0`."}, {"name": "le_of_mul_le_of_one_le", "description": ""}, {"name": "mul_add_mul_le_mul_add_mul", "description": "Binary **rearrangement inequality**."}, {"name": "mul_pos", "description": ""}, {"name": "ring_hom.with_top_map", "description": "A version of `with_top.map` for `ring_hom`s."}, {"name": "add_le_mul'", "description": ""}, {"name": "canonically_ordered_comm_semiring", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.add", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.add_assoc", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.zero", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.zero_add", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.add_zero", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.nsmul", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.nsmul_zero'", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.nsmul_succ'", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.add_comm", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.le", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.lt", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.le_refl", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.le_trans", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.lt_iff_le_not_le", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.le_antisymm", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.add_le_add_left", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.bot", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.bot_le", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.exists_add_of_le", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.le_self_add", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.mul", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.left_distrib", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.right_distrib", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.zero_mul", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.mul_zero", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.mul_assoc", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.one", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.one_mul", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.mul_one", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.nat_cast", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.nat_cast_zero", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.nat_cast_succ", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.npow", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.npow_zero'", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.npow_succ'", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.mul_comm", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "canonically_ordered_comm_semiring.eq_zero_or_eq_zero_of_mul_eq_zero", "description": " A canonically ordered commutative semiring is an ordered, commutative semiring\nin which `a \u2264 b` iff there exists `c` with `b = a + c`. This is satisfied by the\nnatural numbers, for example, but not the integers or other ordered groups."}, {"name": "decidable.lt_mul_of_one_lt_right", "description": ""}, {"name": "four_ne_zero", "description": ""}, {"name": "linear_ordered_comm_ring", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.add", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.add_assoc", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.zero", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.zero_add", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.add_zero", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.nsmul", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.nsmul_zero'", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.nsmul_succ'", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.neg", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.sub", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.sub_eq_add_neg", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.zsmul", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.zsmul_zero'", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.zsmul_succ'", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.zsmul_neg'", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.add_left_neg", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.add_comm", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.int_cast", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.nat_cast", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.one", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.nat_cast_zero", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.nat_cast_succ", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.int_cast_of_nat", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.int_cast_neg_succ_of_nat", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.mul", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.mul_assoc", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.one_mul", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.mul_one", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.npow", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.npow_zero'", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.npow_succ'", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.left_distrib", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.right_distrib", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.le", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.lt", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.le_refl", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.le_trans", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.lt_iff_le_not_le", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.le_antisymm", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.add_le_add_left", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.zero_le_one", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.mul_pos", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.le_total", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.decidable_le", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.decidable_eq", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.decidable_lt", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.max", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.max_def", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.min", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.min_def", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.exists_pair_ne", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_comm_ring.mul_comm", "description": " A `linear_ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a linear order\nsuch that addition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "mul_self_le_mul_self_iff", "description": ""}, {"name": "ring.positive_cone", "description": " A positive cone in a ring consists of a positive cone in underlying `add_comm_group`,\nwhich contains `1` and such that the positive elements are closed under multiplication."}, {"name": "ring.positive_cone.nonneg", "description": " A positive cone in a ring consists of a positive cone in underlying `add_comm_group`,\nwhich contains `1` and such that the positive elements are closed under multiplication."}, {"name": "ring.positive_cone.pos", "description": " A positive cone in a ring consists of a positive cone in underlying `add_comm_group`,\nwhich contains `1` and such that the positive elements are closed under multiplication."}, {"name": "ring.positive_cone.pos_iff", "description": " A positive cone in a ring consists of a positive cone in underlying `add_comm_group`,\nwhich contains `1` and such that the positive elements are closed under multiplication."}, {"name": "ring.positive_cone.zero_nonneg", "description": " A positive cone in a ring consists of a positive cone in underlying `add_comm_group`,\nwhich contains `1` and such that the positive elements are closed under multiplication."}, {"name": "ring.positive_cone.add_nonneg", "description": " A positive cone in a ring consists of a positive cone in underlying `add_comm_group`,\nwhich contains `1` and such that the positive elements are closed under multiplication."}, {"name": "ring.positive_cone.nonneg_antisymm", "description": " A positive cone in a ring consists of a positive cone in underlying `add_comm_group`,\nwhich contains `1` and such that the positive elements are closed under multiplication."}, {"name": "ring.positive_cone.one_nonneg", "description": " A positive cone in a ring consists of a positive cone in underlying `add_comm_group`,\nwhich contains `1` and such that the positive elements are closed under multiplication."}, {"name": "ring.positive_cone.mul_pos", "description": " A positive cone in a ring consists of a positive cone in underlying `add_comm_group`,\nwhich contains `1` and such that the positive elements are closed under multiplication."}, {"name": "mul_nonneg_iff_right_nonneg_of_pos", "description": ""}, {"name": "le_mul_of_one_le_left", "description": ""}, {"name": "neg_iff_pos_of_mul_neg", "description": ""}, {"name": "one_lt_mul_of_le_of_lt", "description": ""}, {"name": "decidable.mul_le_mul", "description": ""}, {"name": "order_dual.non_unital_non_assoc_semiring", "description": ""}, {"name": "units.inv_neg", "description": ""}, {"name": "decidable.one_lt_mul_of_lt_of_le", "description": ""}, {"name": "bit1_pos", "description": ""}, {"name": "max_mul_mul_le_max_mul_max", "description": ""}, {"name": "linear_ordered_semiring.to_no_max_order", "description": ""}, {"name": "abs_eq_neg_self", "description": ""}, {"name": "nonpos_of_mul_nonneg_left", "description": ""}, {"name": "function.injective.ordered_ring", "description": " Pullback an `ordered_ring` under an injective map.\nSee note [reducible non-instances]."}, {"name": "order_dual.ring", "description": ""}, {"name": "function.injective.linear_ordered_comm_ring", "description": " Pullback a `linear_ordered_comm_ring` under an injective map.\nSee note [reducible non-instances]."}, {"name": "mul_lt_mul''", "description": ""}, {"name": "pos_of_mul_pos_right", "description": ""}, {"name": "abs_lt_iff_mul_self_lt", "description": ""}, {"name": "with_top.mul_coe", "description": ""}, {"name": "bit1_pos'", "description": ""}, {"name": "mul_lt_of_lt_one_left", "description": ""}, {"name": "with_bot.bot_mul_bot", "description": ""}, {"name": "ordered_semiring", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.add", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.add_assoc", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.zero", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.zero_add", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.add_zero", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.nsmul", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.nsmul_zero'", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.nsmul_succ'", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.add_comm", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.mul", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.left_distrib", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.right_distrib", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.zero_mul", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.mul_zero", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.mul_assoc", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.one", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.one_mul", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.mul_one", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.nat_cast", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.nat_cast_zero", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.nat_cast_succ", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.npow", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.npow_zero'", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.npow_succ'", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.add_left_cancel", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.le", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.lt", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.le_refl", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.le_trans", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.lt_iff_le_not_le", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.le_antisymm", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.add_le_add_left", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.le_of_add_le_add_left", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.zero_le_one", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.mul_lt_mul_of_pos_left", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_semiring.mul_lt_mul_of_pos_right", "description": " An `ordered_semiring \u03b1` is a semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.to_linear_ordered_add_comm_group", "description": ""}, {"name": "with_bot.no_zero_divisors", "description": ""}, {"name": "lt_mul_self", "description": ""}, {"name": "abs_mul", "description": ""}, {"name": "zero_le_mul_left", "description": ""}, {"name": "with_top.mul_def", "description": ""}, {"name": "decidable.one_lt_mul_of_le_of_lt", "description": ""}, {"name": "decidable.mul_le_mul_of_nonpos_right", "description": ""}, {"name": "tsub_mul", "description": ""}, {"name": "linear_ordered_ring.to_linear_ordered_semiring", "description": ""}, {"name": "with_top.mul_eq_top_iff", "description": ""}, {"name": "mul_lt_of_lt_one_right", "description": ""}, {"name": "zero_le_bit0", "description": ""}, {"name": "lt_mul_of_one_lt_right", "description": ""}, {"name": "decidable.mul_lt_mul''", "description": ""}, {"name": "zero_lt_two", "description": ""}, {"name": "mul_nonneg_le_one_le", "description": ""}, {"name": "with_top.mul_top", "description": ""}, {"name": "linear_ordered_ring", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.add", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.add_assoc", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.zero", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.zero_add", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.add_zero", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.nsmul", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.nsmul_zero'", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.nsmul_succ'", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.neg", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.sub", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.sub_eq_add_neg", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.zsmul", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.zsmul_zero'", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.zsmul_succ'", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.zsmul_neg'", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.add_left_neg", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.add_comm", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.int_cast", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.nat_cast", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.one", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.nat_cast_zero", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.nat_cast_succ", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.int_cast_of_nat", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.int_cast_neg_succ_of_nat", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.mul", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.mul_assoc", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.one_mul", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.mul_one", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.npow", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.npow_zero'", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.npow_succ'", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.left_distrib", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.right_distrib", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.le", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.lt", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.le_refl", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.le_trans", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.lt_iff_le_not_le", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.le_antisymm", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.add_le_add_left", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.zero_le_one", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.mul_pos", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.le_total", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.decidable_le", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.decidable_eq", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.decidable_lt", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.max", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.max_def", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.min", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.min_def", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "linear_ordered_ring.exists_pair_ne", "description": " A `linear_ordered_ring \u03b1` is a ring `\u03b1` with a linear order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "mul_neg_of_neg_of_pos", "description": ""}, {"name": "strict_mono.const_mul", "description": ""}, {"name": "decidable.le_mul_of_one_le_right", "description": ""}, {"name": "order_dual.non_assoc_semiring", "description": ""}, {"name": "order_dual.non_unital_ring", "description": ""}, {"name": "mul_pos_of_neg_of_neg", "description": ""}, {"name": "decidable.mul_self_le_mul_self", "description": ""}, {"name": "order_dual.non_unital_comm_semiring", "description": ""}, {"name": "le_of_mul_le_mul_right", "description": ""}, {"name": "add_le_mul_of_right_le_left", "description": ""}, {"name": "decidable.mul_nonpos_of_nonpos_of_nonneg", "description": ""}, {"name": "ring.total_positive_cone.to_total_positive_cone", "description": "Forget that a `total_positive_cone` in a ring respects the multiplicative structure."}, {"name": "decidable.add_le_mul_two_add", "description": ""}, {"name": "mul_le_mul_of_nonpos_left", "description": ""}, {"name": "decidable.le_mul_of_one_le_left", "description": ""}, {"name": "abs_eq_self", "description": ""}, {"name": "with_bot.bot_lt_mul", "description": ""}, {"name": "nonneg_of_mul_nonneg_right", "description": ""}, {"name": "mul_le_mul_of_nonneg_left", "description": ""}, {"name": "pos_of_mul_neg_right", "description": ""}, {"name": "decidable.one_le_mul_of_one_le_of_one_le", "description": ""}, {"name": "le_of_mul_le_mul_left", "description": ""}, {"name": "monotone.mul_strict_mono", "description": ""}, {"name": "mul_add_mul_lt_mul_add_mul'", "description": "Binary **rearrangement inequality**."}, {"name": "neg_of_mul_neg_right", "description": ""}, {"name": "linear_ordered_ring.to_ordered_ring", "description": ""}, {"name": "with_top.canonically_ordered_comm_semiring", "description": ""}, {"name": "ordered_semiring.to_ordered_cancel_add_comm_monoid", "description": ""}, {"name": "decidable.mul_lt_mul'", "description": ""}, {"name": "canonically_ordered_comm_semiring.to_covariant_mul_le", "description": ""}, {"name": "canonically_ordered_comm_semiring.to_comm_semiring", "description": ""}, {"name": "with_top.top_mul_top", "description": ""}, {"name": "ring.total_positive_cone.to_positive_cone", "description": "Forget that a `total_positive_cone` in a ring is total."}, {"name": "bit0_le_bit0", "description": ""}, {"name": "ordered_ring.mul_nonneg", "description": ""}, {"name": "nonpos_of_mul_nonpos_left", "description": ""}, {"name": "mul_self_lt_mul_self", "description": ""}, {"name": "ordered_ring.mul_le_mul_of_nonneg_right", "description": ""}, {"name": "linear_ordered_semiring.to_linear_ordered_add_comm_monoid", "description": ""}, {"name": "order_dual.non_unital_non_assoc_ring", "description": ""}, {"name": "with_bot.mul_def", "description": ""}, {"name": "min_mul_of_nonneg", "description": ""}, {"name": "with_bot.mul_bot", "description": ""}, {"name": "mul_lt_iff_lt_one_right", "description": ""}, {"name": "strict_mono_on_mul_self", "description": ""}, {"name": "ring_hom.with_top_map_apply", "description": ""}, {"name": "neg_lt_self_iff", "description": ""}, {"name": "gt_of_mul_lt_mul_neg_left", "description": ""}, {"name": "mul_tsub", "description": ""}, {"name": "order_dual.comm_ring", "description": ""}, {"name": "pos_of_mul_pos_left", "description": ""}, {"name": "lt_of_mul_lt_mul_left", "description": ""}, {"name": "with_top.comm_semiring", "description": " This instance requires `canonically_ordered_comm_semiring` as it is the smallest class\nthat derives from both `non_assoc_non_unital_semiring` and `canonically_ordered_add_monoid`, both\nof which are required for distributivity."}, {"name": "zero_lt_bit0", "description": ""}, {"name": "mul_self_inj", "description": ""}, {"name": "monoid_with_zero_hom.with_top_map", "description": "A version of `with_top.map` for `monoid_with_zero_hom`s."}, {"name": "self_dvd_abs", "description": ""}, {"name": "ordered_comm_semiring", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.add", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.add_assoc", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.zero", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.zero_add", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.add_zero", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.nsmul", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.nsmul_zero'", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.nsmul_succ'", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.add_comm", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.mul", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.left_distrib", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.right_distrib", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.zero_mul", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.mul_zero", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.mul_assoc", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.one", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.one_mul", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.mul_one", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.nat_cast", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.nat_cast_zero", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.nat_cast_succ", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.npow", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.npow_zero'", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.npow_succ'", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.add_left_cancel", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.le", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.lt", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.le_refl", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.le_trans", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.lt_iff_le_not_le", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.le_antisymm", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.add_le_add_left", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.le_of_add_le_add_left", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.zero_le_one", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.mul_lt_mul_of_pos_left", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.mul_lt_mul_of_pos_right", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_semiring.mul_comm", "description": " An `ordered_comm_semiring \u03b1` is a commutative semiring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "with_bot.mul_zero_class", "description": ""}, {"name": "mul_le_of_le_one_left", "description": ""}, {"name": "linear_ordered_comm_ring.to_linear_ordered_ring", "description": ""}, {"name": "one_le_bit1", "description": ""}, {"name": "linear_ordered_ring.is_domain", "description": ""}, {"name": "lt_mul_iff_one_lt_right", "description": ""}, {"name": "three_ne_zero", "description": ""}, {"name": "linear_ordered_semiring.to_char_zero", "description": ""}, {"name": "one_lt_bit1", "description": ""}, {"name": "pow_pos", "description": ""}, {"name": "neg_of_mul_neg_left", "description": ""}, {"name": "mul_lt_one_of_nonneg_of_lt_one_right", "description": ""}, {"name": "zero_lt_mul_left", "description": ""}, {"name": "mul_le_of_le_one_right", "description": ""}, {"name": "one_le_mul_of_one_le_of_one_le", "description": ""}, {"name": "eq_zero_of_mul_self_add_mul_self_eq_zero", "description": ""}, {"name": "mul_nonneg_of_three", "description": "Out of three elements of a `linear_ordered_ring`, two must have the same sign."}, {"name": "le_mul_iff_one_le_left", "description": ""}, {"name": "mul_lt_mul_right_of_neg", "description": ""}, {"name": "mul_nonneg_iff_left_nonneg_of_pos", "description": ""}, {"name": "abs_le_one_iff_mul_self_le_one", "description": ""}, {"name": "function.injective.linear_ordered_semiring", "description": " Pullback a `linear_ordered_semiring` under an injective map.\nSee note [reducible non-instances]."}, {"name": "lt_mul_right", "description": ""}, {"name": "mul_le_mul_right_of_neg", "description": ""}, {"name": "decidable.mul_nonneg_of_nonpos_of_nonpos", "description": ""}, {"name": "abs_dvd_self", "description": ""}, {"name": "one_pos", "description": "**Alias** of `zero_lt_one`."}, {"name": "mul_neg_of_pos_of_neg", "description": ""}, {"name": "mul_nonpos_iff", "description": ""}, {"name": "order_dual.comm_semiring", "description": ""}, {"name": "canonically_ordered_comm_semiring.to_no_zero_divisors", "description": ""}, {"name": "decidable.lt_mul_of_one_lt_left", "description": ""}, {"name": "one_lt_two", "description": ""}, {"name": "mul_max_of_nonneg", "description": ""}, {"name": "linear_ordered_ring.mk_of_positive_cone", "description": " Construct a `linear_ordered_ring` by\ndesignating a positive cone in an existing `ring`."}, {"name": "ordered_ring.mul_lt_mul_of_pos_right", "description": ""}, {"name": "mul_le_iff_le_one_right", "description": ""}, {"name": "ordered_ring.to_ordered_add_comm_group", "description": ""}, {"name": "monotone.const_mul", "description": ""}, {"name": "mul_self_add_mul_self_eq_zero", "description": "The sum of two squares is zero iff both elements are zero."}, {"name": "abs_one", "description": ""}, {"name": "function.injective.linear_ordered_ring", "description": " Pullback a `linear_ordered_ring` under an injective map.\nSee note [reducible non-instances]."}, {"name": "with_top.semigroup_with_zero", "description": ""}, {"name": "decidable.ordered_ring.mul_nonneg", "description": ""}, {"name": "units.inv_pos", "description": ""}, {"name": "ordered_comm_ring", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.add", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.add_assoc", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.zero", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.zero_add", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.add_zero", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.nsmul", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.nsmul_zero'", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.nsmul_succ'", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.neg", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.sub", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.sub_eq_add_neg", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.zsmul", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.zsmul_zero'", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.zsmul_succ'", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.zsmul_neg'", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.add_left_neg", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.add_comm", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.int_cast", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.nat_cast", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.one", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.nat_cast_zero", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.nat_cast_succ", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.int_cast_of_nat", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.int_cast_neg_succ_of_nat", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.mul", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.mul_assoc", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.one_mul", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.mul_one", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.npow", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.npow_zero'", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.npow_succ'", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.left_distrib", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.right_distrib", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.le", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.lt", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.le_refl", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.le_trans", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.lt_iff_le_not_le", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.le_antisymm", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.add_le_add_left", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.zero_le_one", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.mul_pos", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_comm_ring.mul_comm", "description": " An `ordered_comm_ring \u03b1` is a commutative ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "pow_nonneg", "description": ""}, {"name": "ordered_ring.mul_le_mul_of_nonneg_left", "description": ""}, {"name": "abs_sub_sq", "description": ""}, {"name": "two_pos", "description": "**Alias** of `zero_lt_two`."}, {"name": "with_bot.semigroup_with_zero", "description": ""}, {"name": "lt_one_add", "description": ""}, {"name": "mul_lt_one_of_nonneg_of_lt_one_left", "description": ""}, {"name": "order_dual.semiring", "description": ""}, {"name": "strict_mono_mul_right_of_pos", "description": ""}, {"name": "decidable.mul_le_mul_of_nonpos_left", "description": ""}, {"name": "nat.strict_mono_cast", "description": ""}, {"name": "abs_le_iff_mul_self_le", "description": ""}, {"name": "abs_two", "description": ""}, {"name": "add_le_cancellable.tsub_mul", "description": ""}, {"name": "monotone.mul", "description": ""}, {"name": "zero_lt_three", "description": ""}, {"name": "decidable.ordered_ring.mul_le_mul_of_nonneg_right", "description": ""}, {"name": "mul_nonpos_of_nonneg_of_nonpos", "description": ""}, {"name": "sub_one_lt", "description": ""}, {"name": "with_top.mul_lt_top", "description": ""}, {"name": "decidable.mul_lt_one_of_nonneg_of_lt_one_left", "description": ""}, {"name": "decidable.mul_le_mul_of_nonneg_right", "description": ""}, {"name": "ordered_semiring.to_char_zero", "description": " Note this is not an instance as `char_zero` implies `nontrivial`,\nand this would risk forming a loop."}, {"name": "add_le_cancellable.mul_tsub", "description": ""}, {"name": "mul_self_nonneg", "description": ""}, {"name": "mul_nonneg_iff", "description": ""}, {"name": "monotone_mul_right_of_nonneg", "description": ""}, {"name": "nonpos_of_mul_nonpos_right", "description": ""}, {"name": "decidable.strict_mono_on_mul_self", "description": ""}, {"name": "decidable.mul_self_lt_mul_self", "description": ""}, {"name": "nonneg_and_nonneg_or_nonpos_and_nonpos_of_mul_nnonneg", "description": ""}, {"name": "decidable.one_lt_mul", "description": ""}, {"name": "zero_le_mul_right", "description": ""}, {"name": "with_bot.nontrivial", "description": ""}, {"name": "monotone_mul_left_of_nonneg", "description": ""}, {"name": "add_le_mul", "description": ""}, {"name": "mul_nonneg", "description": ""}, {"name": "with_top.nontrivial", "description": ""}, {"name": "ordered_comm_ring.to_ordered_comm_semiring", "description": ""}, {"name": "mul_le_one", "description": ""}, {"name": "lt_neg_self_iff", "description": ""}, {"name": "function.injective.ordered_comm_semiring", "description": " Pullback an `ordered_comm_semiring` under an injective map.\nSee note [reducible non-instances]."}, {"name": "function.injective.ordered_comm_ring", "description": " Pullback an `ordered_comm_ring` under an injective map.\nSee note [reducible non-instances]."}, {"name": "ordered_ring.to_ordered_semiring", "description": ""}, {"name": "mul_lt_mul_of_pos_right", "description": ""}, {"name": "decidable.mul_nonneg_le_one_le", "description": ""}, {"name": "decidable.ordered_ring.mul_le_mul_of_nonneg_left", "description": ""}, {"name": "zero_lt_one", "description": ""}, {"name": "ordered_semiring.zero_le_one_class", "description": ""}, {"name": "bit1_lt_bit1", "description": ""}, {"name": "abs_hom", "description": "`abs` as a `monoid_with_zero_hom`."}, {"name": "nonpos_of_mul_nonneg_right", "description": ""}, {"name": "canonically_ordered_comm_semiring.to_canonically_ordered_add_monoid", "description": ""}, {"name": "strict_mono.mul", "description": ""}, {"name": "mul_lt_mul_right", "description": ""}, {"name": "max_zero_add_max_neg_zero_eq_abs_self", "description": ""}, {"name": "mul_lt_iff_lt_one_left", "description": ""}, {"name": "strict_mono.mul_monotone", "description": ""}, {"name": "ordered_ring.mul_lt_mul_of_pos_left", "description": ""}, {"name": "three_pos", "description": "**Alias** of `zero_lt_three`."}, {"name": "with_top.mul_zero_class", "description": ""}, {"name": "mul_lt_mul'", "description": ""}, {"name": "with_top.untop'_zero_mul", "description": ""}, {"name": "abs_dvd", "description": ""}, {"name": "decidable.mul_le_mul_of_nonneg_left", "description": ""}, {"name": "with_top.coe_mul", "description": ""}, {"name": "mul_lt_mul_left_of_neg", "description": ""}, {"name": "ordered_ring", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.add", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.add_assoc", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.zero", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.zero_add", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.add_zero", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.nsmul", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.nsmul_zero'", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.nsmul_succ'", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.neg", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.sub", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.sub_eq_add_neg", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.zsmul", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.zsmul_zero'", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.zsmul_succ'", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.zsmul_neg'", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.add_left_neg", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.add_comm", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.int_cast", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.nat_cast", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.one", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.nat_cast_zero", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.nat_cast_succ", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.int_cast_of_nat", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.int_cast_neg_succ_of_nat", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.mul", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.mul_assoc", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.one_mul", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.mul_one", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.npow", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.npow_zero'", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.npow_succ'", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.left_distrib", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.right_distrib", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.le", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.lt", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.le_refl", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.le_trans", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.lt_iff_le_not_le", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.le_antisymm", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.add_le_add_left", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.zero_le_one", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "ordered_ring.mul_pos", "description": " An `ordered_ring \u03b1` is a ring `\u03b1` with a partial order such that\naddition is monotone and multiplication by a positive number is strictly monotone."}, {"name": "pos_and_pos_or_neg_and_neg_of_mul_pos", "description": ""}, {"name": "linear_ordered_comm_ring.to_linear_ordered_semiring", "description": ""}, {"name": "four_pos", "description": "**Alias** of `zero_lt_four`."}, {"name": "mul_min_of_nonneg", "description": ""}, {"name": "linear_ordered_comm_ring.to_ordered_comm_ring", "description": ""}, {"name": "abs_mul_self", "description": ""}, {"name": "mul_self_le_mul_self", "description": ""}, {"name": "add_one_le_two_mul", "description": ""}, {"name": "decidable.mul_nonpos_of_nonneg_of_nonpos", "description": ""}, {"name": "function.injective.ordered_semiring", "description": " Pullback an `ordered_semiring` under an injective map.\nSee note [reducible non-instances]."}, {"name": "linear_ordered_comm_ring.to_comm_monoid", "description": ""}, {"name": "bit0_lt_bit0", "description": ""}, {"name": "pos_iff_pos_of_mul_pos", "description": ""}, {"name": "linear_ordered_semiring.to_nontrivial", "description": ""}, {"name": "nonneg_of_mul_nonpos_left", "description": ""}, {"name": "mul_le_mul", "description": ""}, {"name": "neg_one_lt_zero", "description": ""}, {"name": "ordered_ring.to_ring", "description": ""}, {"name": "strict_mono_mul_left_of_pos", "description": ""}, {"name": "neg_iff_neg_of_mul_pos", "description": ""}, {"name": "mul_le_mul_of_nonpos_right", "description": ""}, {"name": "monoid_hom.compl\u2082_apply", "description": ""}, {"name": "add_monoid.End.mul_left_apply_apply", "description": ""}, {"name": "add_monoid.End.mul_right", "description": "The right multiplication map: `(a, b) \u21a6 b * a`. See also `add_monoid_hom.mul_right`."}, {"name": "add_monoid_hom.comp_hom'_apply_apply", "description": ""}, {"name": "add_monoid_hom.compl\u2082", "description": "The expression `\u03bb m q, f m (g q)` as an `add_monoid_hom`.\n\nNote that the expression `\u03bb q n, f (g q) n` is simply `add_monoid_hom.comp`.\n\nThis also exists as a `linear_map` version, `linear_map.compl\u2082`"}, {"name": "add_monoid_hom.flip_hom", "description": "Flipping arguments of additive monoid morphisms (`add_monoid_hom.flip`)\nas an additive monoid morphism."}, {"name": "monoid_hom.flip", "description": "`flip` arguments of `f : M \u2192* N \u2192* P`"}, {"name": "add_monoid_hom.coe_flip_mul", "description": ""}, {"name": "monoid_hom.comm_group", "description": "If `G` is a commutative group, then `M \u2192* G` is a commutative group too."}, {"name": "add_monoid.End.add_comm_monoid", "description": ""}, {"name": "monoid_hom.compr\u2082_apply", "description": ""}, {"name": "add_monoid_hom.map_mul\u2082", "description": ""}, {"name": "add_monoid_hom.map_one\u2082", "description": ""}, {"name": "add_monoid.End.ring", "description": ""}, {"name": "monoid_hom.flip_apply", "description": ""}, {"name": "monoid_hom.ext_iff\u2082", "description": ""}, {"name": "add_monoid_hom.comp_hom'", "description": "The expression `\u03bb g m, g (f m)` as a `add_monoid_hom`.\nEquivalently, `(\u03bb g, monoid_hom.comp g f)` as a `add_monoid_hom`.\n\nThis also exists in a `linear_map` version, `linear_map.lcomp`."}, {"name": "add_monoid_hom.map_mul_iff", "description": " An `add_monoid_hom` preserves multiplication if pre- and post- composition with\n`add_monoid_hom.mul` are equivalent. By converting the statement into an equality of\n`add_monoid_hom`s, this lemma allows various specialized `ext` lemmas about `\u2192+` to then be applied."}, {"name": "monoid_hom.compl\u2082", "description": " The expression `\u03bb m q, f m (g q)` as a `monoid_hom`.\n\nNote that the expression `\u03bb q n, f (g q) n` is simply `monoid_hom.comp`."}, {"name": "monoid_hom.eval_apply_apply", "description": ""}, {"name": "add_monoid_hom.add_comm_group", "description": "If `G` is an additive commutative group, then `M \u2192+ G` is an additive commutative\ngroup too."}, {"name": "add_monoid_hom.flip_apply", "description": ""}, {"name": "monoid_hom.flip_hom_apply", "description": ""}, {"name": "monoid_hom.compr\u2082", "description": "The expression `\u03bb m n, g (f m n)` as a `monoid_hom`."}, {"name": "monoid_hom.comp_hom_apply_apply", "description": ""}, {"name": "monoid_hom.map_inv\u2082", "description": ""}, {"name": "add_monoid_hom.map_inv\u2082", "description": ""}, {"name": "add_monoid.End.mul_right_apply_apply", "description": ""}, {"name": "add_monoid_hom.mul", "description": " Multiplication of an element of a (semi)ring is an `add_monoid_hom` in both arguments.\n\nThis is a more-strongly bundled version of `add_monoid_hom.mul_left` and `add_monoid_hom.mul_right`.\n\nStronger versions of this exists for algebras as `linear_map.mul`, `non_unital_alg_hom.mul`\nand `algebra.lmul`."}, {"name": "monoid_hom.comp_hom", "description": " Composition of monoid morphisms (`monoid_hom.comp`) as a monoid morphism.\n\nNote that unlike `monoid_hom.comp_hom'` this requires commutativity of `N`."}, {"name": "add_monoid_hom.compr\u2082_apply", "description": ""}, {"name": "add_monoid_hom.compr\u2082", "description": "The expression `\u03bb m n, g (f m n)` as an `add_monoid_hom`.\n\nThis also exists as a linear_map version, `linear_map.compr\u2082`"}, {"name": "monoid_hom.comp_hom'", "description": " The expression `\u03bb g m, g (f m)` as a `monoid_hom`.\nEquivalently, `(\u03bb g, monoid_hom.comp g f)` as a `monoid_hom`."}, {"name": "add_monoid_hom.add_comm_monoid", "description": "`(M \u2192+ N)` is an `add_comm_monoid` if `N` is commutative."}, {"name": "add_monoid_hom.comp_hom", "description": "Composition of additive monoid morphisms (`add_monoid_hom.comp`) as an additive\nmonoid morphism.\n\nNote that unlike `add_monoid_hom.comp_hom'` this requires commutativity of `N`.\n\nThis also exists in a `linear_map` version, `linear_map.llcomp`."}, {"name": "add_monoid_hom.comp_hom_apply_apply", "description": ""}, {"name": "add_monoid_hom.ext_iff\u2082", "description": ""}, {"name": "add_monoid_hom.eval", "description": "Evaluation of an `add_monoid_hom` at a point as an additive monoid homomorphism.\nSee also `add_monoid_hom.apply` for the evaluation of any function at a point."}, {"name": "monoid_hom.comm_monoid", "description": "`(M \u2192* N)` is a `comm_monoid` if `N` is commutative."}, {"name": "add_monoid_hom.compl\u2082_apply", "description": ""}, {"name": "add_monoid_hom.eval_apply_apply", "description": ""}, {"name": "monoid_hom.map_div\u2082", "description": ""}, {"name": "add_monoid_hom.flip", "description": "`flip` arguments of `f : M \u2192+ N \u2192+ P`"}, {"name": "monoid_hom.comp_hom'_apply_apply", "description": ""}, {"name": "add_monoid.End.semiring", "description": ""}, {"name": "monoid_hom.eval", "description": " Evaluation of a `monoid_hom` at a point as a monoid homomorphism. See also `monoid_hom.apply`\nfor the evaluation of any function at a point."}, {"name": "monoid_hom.flip_hom", "description": "Flipping arguments of monoid morphisms (`monoid_hom.flip`) as a monoid morphism."}, {"name": "add_monoid.End.mul_left", "description": "The left multiplication map: `(a, b) \u21a6 a * b`. See also `add_monoid_hom.mul_left`."}, {"name": "monoid_hom.map_mul\u2082", "description": ""}, {"name": "add_monoid_hom.mul_apply", "description": ""}, {"name": "add_monoid_hom.map_div\u2082", "description": ""}, {"name": "add_monoid_hom.coe_mul", "description": ""}, {"name": "add_monoid_hom.flip_hom_apply", "description": ""}, {"name": "monoid_hom.map_one\u2082", "description": ""}, {"name": "setoid.refl'", "description": ""}, {"name": "setoid.decidable_rel", "description": ""}, {"name": "quotient.eq_rel", "description": "A version of `quotient.eq'` compatible with `setoid.rel`, to make rewriting possible."}, {"name": "setoid.ext_iff", "description": ""}, {"name": "setoid.injective_iff_ker_bot", "description": "A function from \u03b1 to \u03b2 is injective iff its kernel is the bottom element of the complete lattice\n   of equivalence relations on \u03b1."}, {"name": "setoid.Sup_def", "description": "The supremum of a set of equivalence relations is the equivalence closure of the\n   supremum of the set's image under the map to the underlying binary operation."}, {"name": "setoid.eqv_gen_mono", "description": "Equivalence closure of binary relations is monotone."}, {"name": "setoid.map_of_surjective", "description": "Given a surjective function f whose kernel is contained in an equivalence relation r, the\n   equivalence relation on f's codomain defined by x \u2248 y \u2194 the elements of f\u207b\u00b9(x) are related to\n   the elements of f\u207b\u00b9(y) by r."}, {"name": "setoid.comm'", "description": ""}, {"name": "setoid.ker_iff_mem_preimage", "description": "The elements related to x \u2208 \u03b1 by the kernel of f are those in the preimage of f(x) under f."}, {"name": "setoid.symm'", "description": ""}, {"name": "setoid.Inf_def", "description": "The underlying binary operation of the infimum of a set of equivalence relations\n   is the infimum of the set's image under the map to the underlying binary operation."}, {"name": "setoid.ker_lift_injective", "description": "Given a map f from \u03b1 to \u03b2, the natural map from the quotient of \u03b1 by the kernel of f is\n   injective."}, {"name": "setoid.eq_top_iff", "description": ""}, {"name": "setoid.Sup_eq_eqv_gen", "description": "The supremum of a set S of equivalence relations is the equivalence closure of the binary\n   relation `there exists r \u2208 S relating x and y`."}, {"name": "setoid.quotient_ker_equiv_of_right_inverse_apply", "description": ""}, {"name": "setoid.le_def", "description": ""}, {"name": "setoid.lift_equiv", "description": " Equivalence between functions `\u03b1 \u2192 \u03b2` such that `r x y \u2192 f x = f y` and functions\n`quotient r \u2192 \u03b2`."}, {"name": "setoid.ker_def", "description": ""}, {"name": "setoid.ker_mk_eq", "description": "The kernel of the quotient map induced by an equivalence relation r equals r."}, {"name": "setoid.inf_def", "description": "The infimum of 2 equivalence relations r and s is the same relation as the infimum\n   of the underlying binary operations."}, {"name": "setoid.inf_iff_and", "description": ""}, {"name": "setoid.rel", "description": "A version of `setoid.r` that takes the equivalence relation as an explicit argument."}, {"name": "setoid.quotient_ker_equiv_of_surjective", "description": " The quotient of \u03b1 by the kernel of a surjective function f bijects with f's codomain.\n\nIf a specific right-inverse of `f` is known, `setoid.quotient_ker_equiv_of_right_inverse` can be\ndefinitionally more useful."}, {"name": "setoid.has_inf", "description": "The infimum of two equivalence relations."}, {"name": "setoid.sup_def", "description": "The supremum of 2 equivalence relations r and s is the equivalence closure of the\n   supremum of the underlying binary operations."}, {"name": "setoid.ker_apply_mk_out'", "description": ""}, {"name": "setoid.complete_lattice", "description": "The complete lattice of equivalence relations on a type, with bottom element `=`\n   and top element the trivial equivalence relation."}, {"name": "setoid.ker", "description": "The kernel of a function is an equivalence relation."}, {"name": "setoid.correspondence", "description": " Given an equivalence relation `r` on `\u03b1`, the order-preserving bijection between the set of\nequivalence relations containing `r` and the equivalence relations on the quotient of `\u03b1` by `r`."}, {"name": "setoid.prod", "description": "Given types `\u03b1`, `\u03b2`, the product of two equivalence relations `r` on `\u03b1` and `s` on `\u03b2`:\n   `(x\u2081, x\u2082), (y\u2081, y\u2082) \u2208 \u03b1 \u00d7 \u03b2` are related by `r.prod s` iff `x\u2081` is related to `y\u2081`\n   by `r` and `x\u2082` is related to `y\u2082` by `s`."}, {"name": "setoid.quotient_ker_equiv_of_right_inverse_symm_apply", "description": ""}, {"name": "setoid.comap_rel", "description": ""}, {"name": "quotient.subsingleton_iff", "description": ""}, {"name": "setoid.map_of_surjective_eq_map", "description": "A special case of the equivalence closure of an equivalence relation r equalling r."}, {"name": "setoid.ext'", "description": ""}, {"name": "setoid.comap_eq", "description": "Given a map `f : N \u2192 M` and an equivalence relation `r` on `\u03b2`, the equivalence relation\n   induced on `\u03b1` by `f` equals the kernel of `r`'s quotient map composed with `f`."}, {"name": "setoid.bot_def", "description": ""}, {"name": "setoid.eqv_gen_idem", "description": "Equivalence closure is idempotent."}, {"name": "setoid.gi", "description": "There is a Galois insertion of equivalence relations on \u03b1 into binary relations\n   on \u03b1, with equivalence closure the lower adjoint."}, {"name": "setoid.comap", "description": " Given a function `f : \u03b1 \u2192 \u03b2`, an equivalence relation `r` on `\u03b2` induces an equivalence\nrelation on `\u03b1` defined by '`x \u2248 y` iff `f(x)` is related to `f(y)` by `r`'.\n\nSee note [reducible non-instances]."}, {"name": "setoid.eqv_gen_le", "description": "The equivalence closure of a binary relation r is contained in any equivalence\n   relation containing r."}, {"name": "setoid.comap_quotient_equiv", "description": "The second isomorphism theorem for sets."}, {"name": "quot.subsingleton_iff", "description": ""}, {"name": "setoid.sup_eq_eqv_gen", "description": "The supremum of two equivalence relations r and s is the equivalence closure of the binary\n   relation `x is related to y by r or s`."}, {"name": "setoid.partial_order", "description": ""}, {"name": "setoid.quotient_ker_equiv_range", "description": "The first isomorphism theorem for sets: the quotient of \u03b1 by the kernel of a function f\n   bijects with f's image."}, {"name": "setoid.quotient_quotient_equiv_quotient", "description": "The third isomorphism theorem for sets."}, {"name": "setoid.eqv_gen_of_setoid", "description": "The equivalence closure of an equivalence relation r is r."}, {"name": "setoid.quotient_ker_equiv_of_right_inverse", "description": " If `f` has a computable right-inverse, then the quotient by its kernel is equivalent to its\ndomain."}, {"name": "setoid.has_le", "description": "Defining `\u2264` for equivalence relations."}, {"name": "setoid.has_Inf", "description": "The infimum of a set of equivalence relations."}, {"name": "setoid.map", "description": "Given a function `f : \u03b1 \u2192 \u03b2` and equivalence relation `r` on `\u03b1`, the equivalence\n   closure of the relation on `f`'s image defined by '`x \u2248 y` iff the elements of `f\u207b\u00b9(x)` are\n   related to the elements of `f\u207b\u00b9(y)` by `r`.'"}, {"name": "setoid.ker_eq_lift_of_injective", "description": "Given a map f from \u03b1 to \u03b2, the kernel of f is the unique equivalence relation on \u03b1 whose\n   induced map from the quotient of \u03b1 to \u03b2 is injective."}, {"name": "setoid.top_def", "description": ""}, {"name": "setoid.eqv_gen_eq", "description": "The inductively defined equivalence closure of a binary relation r is the infimum\n   of the set of all equivalence relations containing r."}, {"name": "setoid.lift_unique", "description": "The uniqueness part of the universal property for quotients of an arbitrary type."}, {"name": "setoid.trans'", "description": ""}, {"name": "setoid.ker_apply_mk_out", "description": ""}, {"name": "setoid.eq_iff_rel_eq", "description": "Two equivalence relations are equal iff their underlying binary operations are equal."}, {"name": "function.right_inverse.comp_eq_id", "description": ""}, {"name": "function.extend_injective", "description": ""}, {"name": "function.injective.surjective_comp_right", "description": ""}, {"name": "function.sometimes_spec", "description": ""}, {"name": "function.injective2.left", "description": "A binary injective function is injective when only the left argument varies."}, {"name": "function.surjective.forall", "description": ""}, {"name": "function.bijective_iff_exists_unique", "description": ""}, {"name": "function.surjective.of_comp", "description": ""}, {"name": "function.bijective.exists_unique", "description": "Shorthand for using projection notation with `function.bijective_iff_exists_unique`."}, {"name": "function.surj_inv_eq", "description": ""}, {"name": "function.update_eq_iff", "description": ""}, {"name": "function.injective.of_comp_iff", "description": ""}, {"name": "function.left_inverse_surj_inv", "description": ""}, {"name": "function.extend_apply", "description": ""}, {"name": "function.const_apply", "description": ""}, {"name": "function.involutive.surjective", "description": ""}, {"name": "function.surjective.comp_left", "description": "Composition by an surjective function on the left is itself surjective."}, {"name": "function.involutive.left_inverse", "description": ""}, {"name": "function.update_eq_self", "description": ""}, {"name": "function.inv_fun_eq", "description": ""}, {"name": "function.left_inverse.right_inverse", "description": ""}, {"name": "function.has_uncurry_induction", "description": ""}, {"name": "function.inv_fun", "description": "The inverse of a function (which is a left inverse if `f` is injective\n and a right inverse if `f` is surjective)."}, {"name": "function.injective2.right'", "description": "As a map from the right argument to a unary function, `f` is injective."}, {"name": "function.injective.decidable_eq", "description": " If the co-domain `\u03b2` of an injective function `f : \u03b1 \u2192 \u03b2` has decidable equality, then\nthe domain `\u03b1` also has decidable equality."}, {"name": "function.surjective_of_right_cancellable_Prop", "description": ""}, {"name": "function.right_inverse_iff_comp", "description": ""}, {"name": "function.forall_update_iff", "description": ""}, {"name": "function.left_inverse_inv_fun", "description": ""}, {"name": "function.injective2.uncurry", "description": ""}, {"name": "function.update", "description": "Replacing the value of a function at a given point by a given value."}, {"name": "function.surjective.of_comp_iff'", "description": ""}, {"name": "eq_mp_bijective", "description": ""}, {"name": "function.injective.eq_iff", "description": ""}, {"name": "function.injective_of_partial_inv_right", "description": ""}, {"name": "function.bijective.of_comp_iff", "description": ""}, {"name": "function.surjective.has_right_inverse", "description": ""}, {"name": "function.inv_fun_eq_of_injective_of_right_inverse", "description": ""}, {"name": "function.left_inverse.surjective", "description": ""}, {"name": "function.injective2.left'", "description": "As a map from the left argument to a unary function, `f` is injective."}, {"name": "function.involutive.comp_self", "description": ""}, {"name": "function.update_same", "description": ""}, {"name": "function.surjective.forall\u2082", "description": ""}, {"name": "function.extend_apply'", "description": ""}, {"name": "function.surj_inv", "description": "The inverse of a surjective function. (Unlike `inv_fun`, this does not require\n `\u03b1` to be inhabited.)"}, {"name": "function.apply_extend", "description": ""}, {"name": "function.sometimes", "description": " `sometimes f` evaluates to some value of `f`, if it exists. This function is especially\ninteresting in the case where `\u03b1` is a proposition, in which case `f` is necessarily a\nconstant function, so that `sometimes f = f a` for all `a`."}, {"name": "function.injective.of_comp", "description": ""}, {"name": "eq_mpr_bijective", "description": ""}, {"name": "function.decidable_eq_pfun", "description": ""}, {"name": "function.bicompr", "description": "Compose an unary function `f` with a binary function `g`."}, {"name": "function.injective2", "description": " The property of a binary function `f : \u03b1 \u2192 \u03b2 \u2192 \u03b3` being injective.\nMathematically this should be thought of as the corresponding function `\u03b1 \u00d7 \u03b2 \u2192 \u03b3` being injective."}, {"name": "function.bijective.comp_left", "description": "Composition by an bijective function on the left is itself bijective."}, {"name": "function.surjective_to_subsingleton", "description": ""}, {"name": "function.update_comp_eq_of_forall_ne", "description": "Non-dependent version of `function.update_comp_eq_of_forall_ne'`"}, {"name": "function.const_comp", "description": ""}, {"name": "function.right_inverse_surj_inv", "description": ""}, {"name": "function.uncurry_bicompr", "description": ""}, {"name": "function.has_uncurry_base", "description": ""}, {"name": "function.sometimes_eq", "description": ""}, {"name": "function.injective_of_partial_inv", "description": ""}, {"name": "function.surjective_eval", "description": ""}, {"name": "function.injective_surj_inv", "description": ""}, {"name": "function.partial_inv", "description": "We can use choice to construct explicitly a partial inverse for\n a given injective function `f`."}, {"name": "function.surjective.forall\u2083", "description": ""}, {"name": "function.curry_apply", "description": ""}, {"name": "function.is_partial_inv", "description": "`g` is a partial inverse to `f` (an injective but not necessarily\n surjective function) if `g y = some x` implies `f x = y`, and `g y = none`\n implies that `y` is not in the range of `f`."}, {"name": "function.left_inverse_iff_comp", "description": ""}, {"name": "function.involutive.injective", "description": ""}, {"name": "function.inv_fun_surjective", "description": ""}, {"name": "function.left_inverse.eq_rec_on_eq", "description": ""}, {"name": "function.bijective.surjective", "description": ""}, {"name": "inv_image.equivalence", "description": ""}, {"name": "function.injective.comp_left", "description": "Composition by an injective function on the left is itself injective."}, {"name": "function.comp_apply", "description": ""}, {"name": "function.update_comm", "description": ""}, {"name": "function.update_idem", "description": ""}, {"name": "function.surjective_iff_has_right_inverse", "description": ""}, {"name": "function.surjective.exists\u2082", "description": ""}, {"name": "function.uncurry_apply_pair", "description": ""}, {"name": "function.bijective.comp_right", "description": ""}, {"name": "function.extend_comp", "description": ""}, {"name": "function.not_surjective_Type", "description": "There is no surjection from `\u03b1 : Type u` into `Type u`. This theorem\n demonstrates why `Type : Type` would be inconsistent in Lean."}, {"name": "function.inv_fun_neg", "description": ""}, {"name": "function.const_inj", "description": ""}, {"name": "cast_bijective", "description": ""}, {"name": "function.injective.ne", "description": ""}, {"name": "function.hfunext", "description": ""}, {"name": "function.const_def", "description": ""}, {"name": "function.involutive", "description": "A function is involutive, if `f \u2218 f = id`."}, {"name": "function.eval_apply", "description": ""}, {"name": "function.update_comp_eq_of_forall_ne'", "description": ""}, {"name": "function.exists_update_iff", "description": ""}, {"name": "function.partial_inv_left", "description": ""}, {"name": "function.surjective.of_comp_iff", "description": ""}, {"name": "function.surjective.exists", "description": ""}, {"name": "function.injective_of_subsingleton", "description": ""}, {"name": "function.update_noteq", "description": ""}, {"name": "function.apply_update\u2082", "description": ""}, {"name": "function.left_inverse.comp_eq_id", "description": ""}, {"name": "function.injective.eq_iff'", "description": ""}, {"name": "function.bijective.of_comp_iff'", "description": ""}, {"name": "function.left_inverse.right_inverse_of_injective", "description": ""}, {"name": "function.injective.dite", "description": ""}, {"name": "function.injective_iff_has_left_inverse", "description": ""}, {"name": "function.update_comp_eq_of_injective'", "description": ""}, {"name": "set.piecewise", "description": "`s.piecewise f g` is the function equal to `f` on the set `s`, and to `g` on its complement."}, {"name": "function.uncurry_def", "description": ""}, {"name": "function.eval", "description": "Evaluate a function at an argument. Useful if you want to talk about the partially applied\n `function.eval x : (\u03a0 x, \u03b2 x) \u2192 \u03b2 x`."}, {"name": "function.comp_update", "description": ""}, {"name": "function.right_inverse.left_inverse_of_surjective", "description": ""}, {"name": "function.injective.ne_iff", "description": ""}, {"name": "function.bijective.exists_unique_iff", "description": ""}, {"name": "function.involutive.right_inverse", "description": ""}, {"name": "set.separates_points", "description": " A set of functions \"separates points\"\nif for each pair of distinct points there is a function taking different values on them."}, {"name": "cast_inj", "description": ""}, {"name": "function.comp_const", "description": ""}, {"name": "function.apply_update", "description": ""}, {"name": "function.left_inverse.right_inverse_of_surjective", "description": ""}, {"name": "function.bijective.injective", "description": ""}, {"name": "function.left_inverse.eq_rec_eq", "description": ""}, {"name": "function.extend", "description": " `extend f g e'` extends a function `g : \u03b1 \u2192 \u03b3`\nalong a function `f : \u03b1 \u2192 \u03b2` to a function `\u03b2 \u2192 \u03b3`,\nby using the values of `g` on the range of `f`\nand the values of an auxiliary function `e' : \u03b2 \u2192 \u03b3` elsewhere.\n\nMostly useful when `f` is injective."}, {"name": "eq_rec_on_bijective", "description": ""}, {"name": "function.extend_def", "description": ""}, {"name": "function.involutive.bijective", "description": ""}, {"name": "function.cantor_surjective", "description": " **Cantor's diagonal argument** implies that there are no surjective functions from `\u03b1`\nto `set \u03b1`."}, {"name": "function.involutive.ite_not", "description": "Involuting an `ite` of an involuted value `x : \u03b1` negates the `Prop` condition in the `ite`."}, {"name": "function.update_apply", "description": "On non-dependent functions, `function.update` can be expressed as an `ite`"}, {"name": "function.right_inverse.comp", "description": ""}, {"name": "function.injective.surjective_comp_right'", "description": ""}, {"name": "function.id_def", "description": ""}, {"name": "function.is_partial_inv_left", "description": ""}, {"name": "function.left_inverse.cast_eq", "description": ""}, {"name": "function.involutive.eq_iff", "description": "An involution commutes across an equality. Compare to `function.injective.eq_iff`."}, {"name": "function.right_inverse.left_inverse_of_injective", "description": ""}, {"name": "function.surjective.injective_comp_right", "description": ""}, {"name": "function.update_comp_eq_of_injective", "description": "Non-dependent version of `function.update_comp_eq_of_injective'`"}, {"name": "function.left_inverse.eq_right_inverse", "description": ""}, {"name": "function.surjective.exists\u2083", "description": ""}, {"name": "function.update_injective", "description": ""}, {"name": "function.uncurry_bicompl", "description": ""}, {"name": "function.inv_fun_comp", "description": ""}, {"name": "function.partial_inv_of_injective", "description": ""}, {"name": "function.injective.of_comp_iff'", "description": ""}, {"name": "function.left_inverse.comp", "description": ""}, {"name": "eq_rec_inj", "description": ""}, {"name": "function.injective2.eq_iff", "description": ""}, {"name": "function.const_injective", "description": ""}, {"name": "function.cantor_injective", "description": " **Cantor's diagonal argument** implies that there are no injective functions from `set \u03b1`\nto `\u03b1`."}, {"name": "function.injective2.right", "description": "A binary injective function is injective when only the right argument varies."}, {"name": "function.funext_iff", "description": ""}, {"name": "function.right_inverse_inv_fun", "description": ""}, {"name": "function.bijective_iff_has_inverse", "description": ""}, {"name": "function.has_uncurry", "description": " Records a way to turn an element of `\u03b1` into a function from `\u03b2` to `\u03b3`. The most generic use\nis to recursively uncurry. For instance `f : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4` will be turned into\n`\u21bff : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 \u2192 \u03b4`. One can also add instances for bundled maps."}, {"name": "function.has_uncurry.uncurry", "description": " Records a way to turn an element of `\u03b1` into a function from `\u03b2` to `\u03b3`. The most generic use\nis to recursively uncurry. For instance `f : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4` will be turned into\n`\u21bff : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 \u2192 \u03b4`. One can also add instances for bundled maps."}, {"name": "function.ne_iff", "description": ""}, {"name": "function.involutive_iff_iter_2_eq_id", "description": ""}, {"name": "function.eq_update_iff", "description": ""}, {"name": "function.right_inverse.injective", "description": ""}, {"name": "is_symm_op.flip_eq", "description": ""}, {"name": "function.injective.ne_iff'", "description": ""}, {"name": "function.bicompl", "description": " Compose a binary function `f` with a pair of unary functions `g` and `h`.\nIf both arguments of `f` have the same type and `g = h`, then `bicompl f g g = f on g`."}, {"name": "function.right_inverse.left_inverse", "description": ""}, {"name": "function.surjective.right_cancellable", "description": ""}, {"name": "function.injective.has_left_inverse", "description": ""}, {"name": "multiset.zero_bind", "description": ""}, {"name": "multiset.sigma_singleton", "description": ""}, {"name": "multiset.sigma", "description": "`sigma s t` is the dependent version of `product`. It is the sum of\n `(a, b)` as `a` ranges over `s` and `b` ranges over `t a`."}, {"name": "multiset.add_product", "description": ""}, {"name": "multiset.prod_bind", "description": ""}, {"name": "multiset.rel_bind", "description": ""}, {"name": "multiset.bind_zero", "description": ""}, {"name": "multiset.singleton_join", "description": ""}, {"name": "multiset.coe_bind", "description": ""}, {"name": "multiset.bind_map", "description": ""}, {"name": "multiset.join_zero", "description": ""}, {"name": "multiset.card_sigma", "description": ""}, {"name": "multiset.card_bind", "description": ""}, {"name": "multiset.zero_product", "description": ""}, {"name": "multiset.product_add", "description": ""}, {"name": "multiset.product", "description": "The multiplicity of `(a, b)` in `s.product t` is\n the product of the multiplicity of `a` in `s` and `b` in `t`."}, {"name": "multiset.bind_map_comm", "description": ""}, {"name": "multiset.zero_sigma", "description": ""}, {"name": "multiset.rel_join", "description": ""}, {"name": "multiset.bind_add", "description": ""}, {"name": "multiset.sigma_add", "description": ""}, {"name": "multiset.add_sigma", "description": ""}, {"name": "multiset.card_join", "description": ""}, {"name": "multiset.cons_bind", "description": ""}, {"name": "multiset.join_cons", "description": ""}, {"name": "multiset.coe_product", "description": ""}, {"name": "multiset.bind", "description": " `s.bind f` is the monad bind operation, defined as `(s.map f).join`. It is the union of `f a` as\n`a` ranges over `s`."}, {"name": "multiset.card_product", "description": ""}, {"name": "multiset.count_bind", "description": ""}, {"name": "multiset.cons_product", "description": ""}, {"name": "multiset.mem_join", "description": ""}, {"name": "multiset.add_bind", "description": ""}, {"name": "multiset.mem_sigma", "description": ""}, {"name": "multiset.mem_product", "description": ""}, {"name": "multiset.join_add", "description": ""}, {"name": "multiset.bind_congr", "description": ""}, {"name": "multiset.count_sum", "description": ""}, {"name": "multiset.bind_assoc", "description": ""}, {"name": "multiset.bind_bind", "description": ""}, {"name": "multiset.bind_singleton", "description": ""}, {"name": "multiset.singleton_bind", "description": ""}, {"name": "multiset.bind_cons", "description": ""}, {"name": "multiset.join", "description": "`join S`, where `S` is a multiset of multisets, is the lift of the list join\n operation, that is, the union of all the sets.\n    join {{1, 2}, {1, 2}, {0, 1}} = {0, 1, 1, 1, 2, 2}"}, {"name": "multiset.coe_join", "description": ""}, {"name": "multiset.sum_bind", "description": ""}, {"name": "multiset.product_singleton", "description": ""}, {"name": "multiset.map_bind", "description": ""}, {"name": "multiset.coe_sigma", "description": ""}, {"name": "multiset.le_bind", "description": ""}, {"name": "multiset.cons_sigma", "description": ""}, {"name": "multiset.bind_hcongr", "description": ""}, {"name": "multiset.mem_bind", "description": ""}, {"name": "buffer.nil", "description": ""}, {"name": "buffer.take", "description": ""}, {"name": "string.to_char_buffer", "description": ""}, {"name": "format.to_buffer", "description": "Convert a format object into a character buffer with the provided\n   formatting options."}, {"name": "buffer.write", "description": ""}, {"name": "buffer.to_array", "description": ""}, {"name": "buffer.iterate", "description": ""}, {"name": "buffer.foreach", "description": ""}, {"name": "buffer.map", "description": "Map a function over the buffer."}, {"name": "buffer.mmap", "description": "Monadically map a function over the buffer."}, {"name": "buffer.read_eq_read'", "description": ""}, {"name": "buffer.pop_back", "description": ""}, {"name": "buffer.drop", "description": ""}, {"name": "buffer.has_to_tactic_format", "description": ""}, {"name": "buffer.lt_aux_2", "description": ""}, {"name": "buffer.reverse", "description": ""}, {"name": "buffer.has_append", "description": ""}, {"name": "buffer.take_right", "description": ""}, {"name": "buffer.write_eq_write'", "description": ""}, {"name": "buffer.append_list", "description": ""}, {"name": "buffer.append", "description": ""}, {"name": "buffer.has_repr", "description": ""}, {"name": "buffer.lt_aux_3", "description": ""}, {"name": "buffer.append_string", "description": ""}, {"name": "buffer.read'", "description": ""}, {"name": "buffer.write'", "description": ""}, {"name": "buffer.has_mem", "description": ""}, {"name": "buffer.rev_iterate", "description": ""}, {"name": "buffer.to_list", "description": ""}, {"name": "buffer.append_array", "description": ""}, {"name": "buffer.read", "description": ""}, {"name": "buffer.has_to_format", "description": ""}, {"name": "mk_buffer", "description": ""}, {"name": "char_buffer", "description": ""}, {"name": "buffer.lt_aux_1", "description": ""}, {"name": "buffer.to_string", "description": ""}, {"name": "buffer.mem", "description": ""}, {"name": "buffer", "description": ""}, {"name": "buffer.size", "description": ""}, {"name": "buffer.foldl", "description": ""}, {"name": "array.to_buffer", "description": ""}, {"name": "buffer.push_back", "description": ""}, {"name": "list.to_buffer", "description": ""}, {"name": "prod.semilattice_inf", "description": ""}, {"name": "monotone.map_inf", "description": ""}, {"name": "inf_eq_min", "description": ""}, {"name": "antitone.map_sup", "description": ""}, {"name": "inf_of_le_right", "description": ""}, {"name": "monotone.of_map_inf", "description": ""}, {"name": "sup_congr_right", "description": ""}, {"name": "inf_lt_left", "description": ""}, {"name": "inf_sup_left", "description": ""}, {"name": "prod.has_sup", "description": ""}, {"name": "pi.sup_apply", "description": ""}, {"name": "pi.has_inf", "description": ""}, {"name": "le_iff_exists_sup", "description": ""}, {"name": "sup_comm", "description": ""}, {"name": "right_eq_sup", "description": ""}, {"name": "antitone.map_inf", "description": ""}, {"name": "pi.inf_apply", "description": ""}, {"name": "semilattice_inf.ext_inf", "description": ""}, {"name": "inf_inf_distrib_left", "description": ""}, {"name": "lattice.to_semilattice_inf", "description": ""}, {"name": "sup_eq_left", "description": ""}, {"name": "antitone.max", "description": "Pointwise maximum of two monotone functions is a monotone function."}, {"name": "to_dual_sup", "description": ""}, {"name": "inf_is_idempotent", "description": ""}, {"name": "right_eq_inf", "description": ""}, {"name": "monotone.map_sup", "description": ""}, {"name": "monotone.max", "description": "Pointwise maximum of two monotone functions is a monotone function."}, {"name": "monotone.map_inf_le", "description": ""}, {"name": "function.injective.semilattice_inf", "description": " A type endowed with `\u2293` is a `semilattice_inf`, if it admits an injective map that\npreserves `\u2293` to a `semilattice_inf`.\nSee note [reducible non-instances]."}, {"name": "inf_congr_right", "description": ""}, {"name": "sup_of_le_right", "description": ""}, {"name": "left_eq_sup", "description": ""}, {"name": "monotone.le_map_sup", "description": ""}, {"name": "inf_le_right'", "description": ""}, {"name": "inf_lt_right", "description": ""}, {"name": "sup_right_idem", "description": ""}, {"name": "distrib_lattice.to_lattice", "description": ""}, {"name": "inf_le_of_left_le", "description": ""}, {"name": "semilattice_sup.ext", "description": ""}, {"name": "sup_assoc", "description": ""}, {"name": "order_dual.semilattice_inf", "description": ""}, {"name": "function.injective.semilattice_sup", "description": " A type endowed with `\u2294` is a `semilattice_sup`, if it admits an injective map that\npreserves `\u2294` to a `semilattice_sup`.\nSee note [reducible non-instances]."}, {"name": "sup_ind", "description": ""}, {"name": "inf_eq_right", "description": ""}, {"name": "le_inf", "description": ""}, {"name": "prod.semilattice_sup", "description": ""}, {"name": "pi.semilattice_sup", "description": ""}, {"name": "order_dual.has_sup", "description": ""}, {"name": "sup_le_sup", "description": ""}, {"name": "linear_order.to_distrib_lattice", "description": ""}, {"name": "sup_inf_self", "description": ""}, {"name": "le_inf_iff", "description": ""}, {"name": "inf_assoc", "description": ""}, {"name": "sup_inf_left", "description": ""}, {"name": "inf_eq_left", "description": ""}, {"name": "sup_le", "description": ""}, {"name": "antitone.inf", "description": "Pointwise infimum of two monotone functions is a monotone function."}, {"name": "inf_left_comm", "description": ""}, {"name": "subtype.lattice", "description": " A subtype forms a lattice if `\u2294` and `\u2293` preserve the property.\nSee note [reducible non-instances]."}, {"name": "pi.lattice", "description": ""}, {"name": "semilattice_sup", "description": "A `semilattice_sup` is a join-semilattice, that is, a partial order\n with a join (a.k.a. lub / least upper bound, sup / supremum) operation\n `\u2294` which is the least element larger than both factors."}, {"name": "semilattice_sup.sup", "description": "A `semilattice_sup` is a join-semilattice, that is, a partial order\n with a join (a.k.a. lub / least upper bound, sup / supremum) operation\n `\u2294` which is the least element larger than both factors."}, {"name": "semilattice_sup.le", "description": "A `semilattice_sup` is a join-semilattice, that is, a partial order\n with a join (a.k.a. lub / least upper bound, sup / supremum) operation\n `\u2294` which is the least element larger than both factors."}, {"name": "semilattice_sup.lt", "description": "A `semilattice_sup` is a join-semilattice, that is, a partial order\n with a join (a.k.a. lub / least upper bound, sup / supremum) operation\n `\u2294` which is the least element larger than both factors."}, {"name": "semilattice_sup.le_refl", "description": "A `semilattice_sup` is a join-semilattice, that is, a partial order\n with a join (a.k.a. lub / least upper bound, sup / supremum) operation\n `\u2294` which is the least element larger than both factors."}, {"name": "semilattice_sup.le_trans", "description": "A `semilattice_sup` is a join-semilattice, that is, a partial order\n with a join (a.k.a. lub / least upper bound, sup / supremum) operation\n `\u2294` which is the least element larger than both factors."}, {"name": "semilattice_sup.lt_iff_le_not_le", "description": "A `semilattice_sup` is a join-semilattice, that is, a partial order\n with a join (a.k.a. lub / least upper bound, sup / supremum) operation\n `\u2294` which is the least element larger than both factors."}, {"name": "semilattice_sup.le_antisymm", "description": "A `semilattice_sup` is a join-semilattice, that is, a partial order\n with a join (a.k.a. lub / least upper bound, sup / supremum) operation\n `\u2294` which is the least element larger than both factors."}, {"name": "semilattice_sup.le_sup_left", "description": "A `semilattice_sup` is a join-semilattice, that is, a partial order\n with a join (a.k.a. lub / least upper bound, sup / supremum) operation\n `\u2294` which is the least element larger than both factors."}, {"name": "semilattice_sup.le_sup_right", "description": "A `semilattice_sup` is a join-semilattice, that is, a partial order\n with a join (a.k.a. lub / least upper bound, sup / supremum) operation\n `\u2294` which is the least element larger than both factors."}, {"name": "semilattice_sup.sup_le", "description": "A `semilattice_sup` is a join-semilattice, that is, a partial order\n with a join (a.k.a. lub / least upper bound, sup / supremum) operation\n `\u2294` which is the least element larger than both factors."}, {"name": "semilattice_sup.to_has_sup", "description": ""}, {"name": "sup_inf_le", "description": ""}, {"name": "monotone.min", "description": "Pointwise minimum of two monotone functions is a monotone function."}, {"name": "lattice.to_semilattice_sup", "description": ""}, {"name": "le_antisymm'", "description": ""}, {"name": "le_of_inf_eq", "description": ""}, {"name": "semilattice_inf.to_has_inf", "description": ""}, {"name": "inf_sup_right", "description": ""}, {"name": "nat.distrib_lattice", "description": ""}, {"name": "sup_is_idempotent", "description": ""}, {"name": "bool.distrib_lattice", "description": ""}, {"name": "inf_lt_left_or_right", "description": ""}, {"name": "antitone_on.sup", "description": "Pointwise supremum of two antitone functions is a antitone function."}, {"name": "lt_sup_iff", "description": ""}, {"name": "le_of_inf_le_sup_le", "description": ""}, {"name": "subtype.mk_inf_mk", "description": ""}, {"name": "order_dual.lattice", "description": ""}, {"name": "inf_is_commutative", "description": ""}, {"name": "left_or_right_lt_sup", "description": ""}, {"name": "semilattice_sup.to_partial_order", "description": ""}, {"name": "sup_left_right_swap", "description": ""}, {"name": "ite_le_sup", "description": ""}, {"name": "sup_is_associative", "description": ""}, {"name": "antitone.map_sup_le", "description": ""}, {"name": "inf_lt_iff", "description": ""}, {"name": "subtype.semilattice_sup", "description": " A subtype forms a `\u2294`-semilattice if `\u2294` preserves the property.\nSee note [reducible non-instances]."}, {"name": "of_dual_inf", "description": ""}, {"name": "inf_le_of_right_le", "description": ""}, {"name": "right_lt_sup", "description": ""}, {"name": "le_inf_sup", "description": ""}, {"name": "subtype.semilattice_inf", "description": " A subtype forms a `\u2293`-semilattice if `\u2293` preserves the property.\nSee note [reducible non-instances]."}, {"name": "monotone.sup", "description": "Pointwise supremum of two monotone functions is a monotone function."}, {"name": "antitone.min", "description": "Pointwise minimum of two monotone functions is a monotone function."}, {"name": "inf_le_right", "description": ""}, {"name": "le_sup_of_le_left", "description": ""}, {"name": "left_lt_sup", "description": ""}, {"name": "lt_sup_of_lt_right", "description": ""}, {"name": "function.injective.distrib_lattice", "description": " A type endowed with `\u2294` and `\u2293` is a `distrib_lattice`, if it admits an injective map that\npreserves `\u2294` and `\u2293` to a `distrib_lattice`.\nSee note [reducible non-instances]."}, {"name": "order_dual.has_inf", "description": ""}, {"name": "sup_le_sup_right", "description": ""}, {"name": "sup_left_comm", "description": ""}, {"name": "semilattice_inf", "description": "A `semilattice_inf` is a meet-semilattice, that is, a partial order\n with a meet (a.k.a. glb / greatest lower bound, inf / infimum) operation\n `\u2293` which is the greatest element smaller than both factors."}, {"name": "semilattice_inf.inf", "description": "A `semilattice_inf` is a meet-semilattice, that is, a partial order\n with a meet (a.k.a. glb / greatest lower bound, inf / infimum) operation\n `\u2293` which is the greatest element smaller than both factors."}, {"name": "semilattice_inf.le", "description": "A `semilattice_inf` is a meet-semilattice, that is, a partial order\n with a meet (a.k.a. glb / greatest lower bound, inf / infimum) operation\n `\u2293` which is the greatest element smaller than both factors."}, {"name": "semilattice_inf.lt", "description": "A `semilattice_inf` is a meet-semilattice, that is, a partial order\n with a meet (a.k.a. glb / greatest lower bound, inf / infimum) operation\n `\u2293` which is the greatest element smaller than both factors."}, {"name": "semilattice_inf.le_refl", "description": "A `semilattice_inf` is a meet-semilattice, that is, a partial order\n with a meet (a.k.a. glb / greatest lower bound, inf / infimum) operation\n `\u2293` which is the greatest element smaller than both factors."}, {"name": "semilattice_inf.le_trans", "description": "A `semilattice_inf` is a meet-semilattice, that is, a partial order\n with a meet (a.k.a. glb / greatest lower bound, inf / infimum) operation\n `\u2293` which is the greatest element smaller than both factors."}, {"name": "semilattice_inf.lt_iff_le_not_le", "description": "A `semilattice_inf` is a meet-semilattice, that is, a partial order\n with a meet (a.k.a. glb / greatest lower bound, inf / infimum) operation\n `\u2293` which is the greatest element smaller than both factors."}, {"name": "semilattice_inf.le_antisymm", "description": "A `semilattice_inf` is a meet-semilattice, that is, a partial order\n with a meet (a.k.a. glb / greatest lower bound, inf / infimum) operation\n `\u2293` which is the greatest element smaller than both factors."}, {"name": "semilattice_inf.inf_le_left", "description": "A `semilattice_inf` is a meet-semilattice, that is, a partial order\n with a meet (a.k.a. glb / greatest lower bound, inf / infimum) operation\n `\u2293` which is the greatest element smaller than both factors."}, {"name": "semilattice_inf.inf_le_right", "description": "A `semilattice_inf` is a meet-semilattice, that is, a partial order\n with a meet (a.k.a. glb / greatest lower bound, inf / infimum) operation\n `\u2293` which is the greatest element smaller than both factors."}, {"name": "semilattice_inf.le_inf", "description": "A `semilattice_inf` is a meet-semilattice, that is, a partial order\n with a meet (a.k.a. glb / greatest lower bound, inf / infimum) operation\n `\u2293` which is the greatest element smaller than both factors."}, {"name": "subtype.coe_inf", "description": ""}, {"name": "le_sup_inf", "description": ""}, {"name": "inf_le_inf_right", "description": ""}, {"name": "of_dual_max", "description": ""}, {"name": "inf_lt_of_right_lt", "description": ""}, {"name": "inf_le_inf_left", "description": ""}, {"name": "left_eq_inf", "description": ""}, {"name": "sup_inf_right", "description": ""}, {"name": "inf_congr_left", "description": ""}, {"name": "function.injective.lattice", "description": " A type endowed with `\u2294` and `\u2293` is a `lattice`, if it admits an injective map that\npreserves `\u2294` and `\u2293` to a `lattice`.\nSee note [reducible non-instances]."}, {"name": "semilattice_sup.dual_dual", "description": ""}, {"name": "sup_is_commutative", "description": ""}, {"name": "inf_inf_distrib_right", "description": ""}, {"name": "order_dual.semilattice_sup", "description": ""}, {"name": "inf_right_comm", "description": ""}, {"name": "monotone_on.inf", "description": "Pointwise infimum of two monotone functions is a monotone function."}, {"name": "prod.lattice", "description": ""}, {"name": "inf_sup_self", "description": ""}, {"name": "inf_le_left'", "description": ""}, {"name": "monotone_on.sup", "description": "Pointwise supremum of two monotone functions is a monotone function."}, {"name": "sup_eq_iff_inf_eq", "description": ""}, {"name": "pi.inf_def", "description": ""}, {"name": "sup_lt_iff", "description": ""}, {"name": "prod.distrib_lattice", "description": ""}, {"name": "inf_right_idem", "description": ""}, {"name": "semilattice_sup.ext_sup", "description": ""}, {"name": "sup_sup_distrib_right", "description": ""}, {"name": "antitone_on.min", "description": "Pointwise minimum of two antitone functions is a antitone function."}, {"name": "pi.distrib_lattice", "description": ""}, {"name": "sup_eq_sup_iff_left", "description": ""}, {"name": "to_dual_max", "description": ""}, {"name": "distrib_lattice", "description": " A distributive lattice is a lattice that satisfies any of four\nequivalent distributive properties (of `sup` over `inf` or `inf` over `sup`,\non the left or right).\n\nThe definition here chooses `le_sup_inf`: `(x \u2294 y) \u2293 (x \u2294 z) \u2264 x \u2294 (y \u2293 z)`. To prove distributivity\nfrom the dual law, use `distrib_lattice.of_inf_sup_le`.\n\nA classic example of a distributive lattice\nis the lattice of subsets of a set, and in fact this example is\ngeneric in the sense that every distributive lattice is realizable\nas a sublattice of a powerset lattice."}, {"name": "distrib_lattice.sup", "description": " A distributive lattice is a lattice that satisfies any of four\nequivalent distributive properties (of `sup` over `inf` or `inf` over `sup`,\non the left or right).\n\nThe definition here chooses `le_sup_inf`: `(x \u2294 y) \u2293 (x \u2294 z) \u2264 x \u2294 (y \u2293 z)`. To prove distributivity\nfrom the dual law, use `distrib_lattice.of_inf_sup_le`.\n\nA classic example of a distributive lattice\nis the lattice of subsets of a set, and in fact this example is\ngeneric in the sense that every distributive lattice is realizable\nas a sublattice of a powerset lattice."}, {"name": "distrib_lattice.le", "description": " A distributive lattice is a lattice that satisfies any of four\nequivalent distributive properties (of `sup` over `inf` or `inf` over `sup`,\non the left or right).\n\nThe definition here chooses `le_sup_inf`: `(x \u2294 y) \u2293 (x \u2294 z) \u2264 x \u2294 (y \u2293 z)`. To prove distributivity\nfrom the dual law, use `distrib_lattice.of_inf_sup_le`.\n\nA classic example of a distributive lattice\nis the lattice of subsets of a set, and in fact this example is\ngeneric in the sense that every distributive lattice is realizable\nas a sublattice of a powerset lattice."}, {"name": "distrib_lattice.lt", "description": " A distributive lattice is a lattice that satisfies any of four\nequivalent distributive properties (of `sup` over `inf` or `inf` over `sup`,\non the left or right).\n\nThe definition here chooses `le_sup_inf`: `(x \u2294 y) \u2293 (x \u2294 z) \u2264 x \u2294 (y \u2293 z)`. To prove distributivity\nfrom the dual law, use `distrib_lattice.of_inf_sup_le`.\n\nA classic example of a distributive lattice\nis the lattice of subsets of a set, and in fact this example is\ngeneric in the sense that every distributive lattice is realizable\nas a sublattice of a powerset lattice."}, {"name": "distrib_lattice.le_refl", "description": " A distributive lattice is a lattice that satisfies any of four\nequivalent distributive properties (of `sup` over `inf` or `inf` over `sup`,\non the left or right).\n\nThe definition here chooses `le_sup_inf`: `(x \u2294 y) \u2293 (x \u2294 z) \u2264 x \u2294 (y \u2293 z)`. To prove distributivity\nfrom the dual law, use `distrib_lattice.of_inf_sup_le`.\n\nA classic example of a distributive lattice\nis the lattice of subsets of a set, and in fact this example is\ngeneric in the sense that every distributive lattice is realizable\nas a sublattice of a powerset lattice."}, {"name": "distrib_lattice.le_trans", "description": " A distributive lattice is a lattice that satisfies any of four\nequivalent distributive properties (of `sup` over `inf` or `inf` over `sup`,\non the left or right).\n\nThe definition here chooses `le_sup_inf`: `(x \u2294 y) \u2293 (x \u2294 z) \u2264 x \u2294 (y \u2293 z)`. To prove distributivity\nfrom the dual law, use `distrib_lattice.of_inf_sup_le`.\n\nA classic example of a distributive lattice\nis the lattice of subsets of a set, and in fact this example is\ngeneric in the sense that every distributive lattice is realizable\nas a sublattice of a powerset lattice."}, {"name": "distrib_lattice.lt_iff_le_not_le", "description": " A distributive lattice is a lattice that satisfies any of four\nequivalent distributive properties (of `sup` over `inf` or `inf` over `sup`,\non the left or right).\n\nThe definition here chooses `le_sup_inf`: `(x \u2294 y) \u2293 (x \u2294 z) \u2264 x \u2294 (y \u2293 z)`. To prove distributivity\nfrom the dual law, use `distrib_lattice.of_inf_sup_le`.\n\nA classic example of a distributive lattice\nis the lattice of subsets of a set, and in fact this example is\ngeneric in the sense that every distributive lattice is realizable\nas a sublattice of a powerset lattice."}, {"name": "distrib_lattice.le_antisymm", "description": " A distributive lattice is a lattice that satisfies any of four\nequivalent distributive properties (of `sup` over `inf` or `inf` over `sup`,\non the left or right).\n\nThe definition here chooses `le_sup_inf`: `(x \u2294 y) \u2293 (x \u2294 z) \u2264 x \u2294 (y \u2293 z)`. To prove distributivity\nfrom the dual law, use `distrib_lattice.of_inf_sup_le`.\n\nA classic example of a distributive lattice\nis the lattice of subsets of a set, and in fact this example is\ngeneric in the sense that every distributive lattice is realizable\nas a sublattice of a powerset lattice."}, {"name": "distrib_lattice.le_sup_left", "description": " A distributive lattice is a lattice that satisfies any of four\nequivalent distributive properties (of `sup` over `inf` or `inf` over `sup`,\non the left or right).\n\nThe definition here chooses `le_sup_inf`: `(x \u2294 y) \u2293 (x \u2294 z) \u2264 x \u2294 (y \u2293 z)`. To prove distributivity\nfrom the dual law, use `distrib_lattice.of_inf_sup_le`.\n\nA classic example of a distributive lattice\nis the lattice of subsets of a set, and in fact this example is\ngeneric in the sense that every distributive lattice is realizable\nas a sublattice of a powerset lattice."}, {"name": "distrib_lattice.le_sup_right", "description": " A distributive lattice is a lattice that satisfies any of four\nequivalent distributive properties (of `sup` over `inf` or `inf` over `sup`,\non the left or right).\n\nThe definition here chooses `le_sup_inf`: `(x \u2294 y) \u2293 (x \u2294 z) \u2264 x \u2294 (y \u2293 z)`. To prove distributivity\nfrom the dual law, use `distrib_lattice.of_inf_sup_le`.\n\nA classic example of a distributive lattice\nis the lattice of subsets of a set, and in fact this example is\ngeneric in the sense that every distributive lattice is realizable\nas a sublattice of a powerset lattice."}, {"name": "distrib_lattice.sup_le", "description": " A distributive lattice is a lattice that satisfies any of four\nequivalent distributive properties (of `sup` over `inf` or `inf` over `sup`,\non the left or right).\n\nThe definition here chooses `le_sup_inf`: `(x \u2294 y) \u2293 (x \u2294 z) \u2264 x \u2294 (y \u2293 z)`. To prove distributivity\nfrom the dual law, use `distrib_lattice.of_inf_sup_le`.\n\nA classic example of a distributive lattice\nis the lattice of subsets of a set, and in fact this example is\ngeneric in the sense that every distributive lattice is realizable\nas a sublattice of a powerset lattice."}, {"name": "distrib_lattice.inf", "description": " A distributive lattice is a lattice that satisfies any of four\nequivalent distributive properties (of `sup` over `inf` or `inf` over `sup`,\non the left or right).\n\nThe definition here chooses `le_sup_inf`: `(x \u2294 y) \u2293 (x \u2294 z) \u2264 x \u2294 (y \u2293 z)`. To prove distributivity\nfrom the dual law, use `distrib_lattice.of_inf_sup_le`.\n\nA classic example of a distributive lattice\nis the lattice of subsets of a set, and in fact this example is\ngeneric in the sense that every distributive lattice is realizable\nas a sublattice of a powerset lattice."}, {"name": "distrib_lattice.inf_le_left", "description": " A distributive lattice is a lattice that satisfies any of four\nequivalent distributive properties (of `sup` over `inf` or `inf` over `sup`,\non the left or right).\n\nThe definition here chooses `le_sup_inf`: `(x \u2294 y) \u2293 (x \u2294 z) \u2264 x \u2294 (y \u2293 z)`. To prove distributivity\nfrom the dual law, use `distrib_lattice.of_inf_sup_le`.\n\nA classic example of a distributive lattice\nis the lattice of subsets of a set, and in fact this example is\ngeneric in the sense that every distributive lattice is realizable\nas a sublattice of a powerset lattice."}, {"name": "distrib_lattice.inf_le_right", "description": " A distributive lattice is a lattice that satisfies any of four\nequivalent distributive properties (of `sup` over `inf` or `inf` over `sup`,\non the left or right).\n\nThe definition here chooses `le_sup_inf`: `(x \u2294 y) \u2293 (x \u2294 z) \u2264 x \u2294 (y \u2293 z)`. To prove distributivity\nfrom the dual law, use `distrib_lattice.of_inf_sup_le`.\n\nA classic example of a distributive lattice\nis the lattice of subsets of a set, and in fact this example is\ngeneric in the sense that every distributive lattice is realizable\nas a sublattice of a powerset lattice."}, {"name": "distrib_lattice.le_inf", "description": " A distributive lattice is a lattice that satisfies any of four\nequivalent distributive properties (of `sup` over `inf` or `inf` over `sup`,\non the left or right).\n\nThe definition here chooses `le_sup_inf`: `(x \u2294 y) \u2293 (x \u2294 z) \u2264 x \u2294 (y \u2293 z)`. To prove distributivity\nfrom the dual law, use `distrib_lattice.of_inf_sup_le`.\n\nA classic example of a distributive lattice\nis the lattice of subsets of a set, and in fact this example is\ngeneric in the sense that every distributive lattice is realizable\nas a sublattice of a powerset lattice."}, {"name": "distrib_lattice.le_sup_inf", "description": " A distributive lattice is a lattice that satisfies any of four\nequivalent distributive properties (of `sup` over `inf` or `inf` over `sup`,\non the left or right).\n\nThe definition here chooses `le_sup_inf`: `(x \u2294 y) \u2293 (x \u2294 z) \u2264 x \u2294 (y \u2293 z)`. To prove distributivity\nfrom the dual law, use `distrib_lattice.of_inf_sup_le`.\n\nA classic example of a distributive lattice\nis the lattice of subsets of a set, and in fact this example is\ngeneric in the sense that every distributive lattice is realizable\nas a sublattice of a powerset lattice."}, {"name": "sup_eq_right", "description": ""}, {"name": "semilattice_inf.mk'", "description": "A type with a commutative, associative and idempotent binary `inf` operation has the structure of a\nmeet-semilattice.\n\nThe partial order is defined so that `a \u2264 b` unfolds to `b \u2293 a = a`; cf. `inf_eq_right`."}, {"name": "lattice.mk'", "description": "A type with a pair of commutative and associative binary operations which satisfy two absorption\nlaws relating the two operations has the structure of a lattice.\n\nThe partial order is defined so that `a \u2264 b` unfolds to `a \u2294 b = b`; cf. `sup_eq_right`."}, {"name": "order_dual.distrib_lattice", "description": ""}, {"name": "semilattice_sup_mk'_partial_order_eq_semilattice_inf_mk'_partial_order", "description": " The partial orders from `semilattice_sup_mk'` and `semilattice_inf_mk'` agree\nif `sup` and `inf` satisfy the lattice absorption laws `sup_inf_self` (`a \u2294 a \u2293 b = a`)\nand `inf_sup_self` (`a \u2293 (a \u2294 b) = a`)."}, {"name": "monotone_on.min", "description": "Pointwise minimum of two monotone functions is a monotone function."}, {"name": "sup_eq_max", "description": ""}, {"name": "lt_inf_iff", "description": ""}, {"name": "lattice.to_linear_order", "description": " A lattice with total order is a linear order.\n\nSee note [reducible non-instances]."}, {"name": "lt_sup_of_lt_left", "description": ""}, {"name": "linear_order.to_lattice", "description": ""}, {"name": "to_dual_min", "description": ""}, {"name": "le_sup_iff", "description": ""}, {"name": "monotone.of_map_sup", "description": ""}, {"name": "distrib_lattice.of_inf_sup_le", "description": "Prove distributivity of an existing lattice from the dual distributive law."}, {"name": "sup_eq_max_default", "description": ""}, {"name": "semilattice_inf.to_partial_order", "description": ""}, {"name": "inf_comm", "description": ""}, {"name": "sup_le_iff", "description": ""}, {"name": "lattice", "description": "A lattice is a join-semilattice which is also a meet-semilattice."}, {"name": "lattice.sup", "description": "A lattice is a join-semilattice which is also a meet-semilattice."}, {"name": "lattice.le", "description": "A lattice is a join-semilattice which is also a meet-semilattice."}, {"name": "lattice.lt", "description": "A lattice is a join-semilattice which is also a meet-semilattice."}, {"name": "lattice.le_refl", "description": "A lattice is a join-semilattice which is also a meet-semilattice."}, {"name": "lattice.le_trans", "description": "A lattice is a join-semilattice which is also a meet-semilattice."}, {"name": "lattice.lt_iff_le_not_le", "description": "A lattice is a join-semilattice which is also a meet-semilattice."}, {"name": "lattice.le_antisymm", "description": "A lattice is a join-semilattice which is also a meet-semilattice."}, {"name": "lattice.le_sup_left", "description": "A lattice is a join-semilattice which is also a meet-semilattice."}, {"name": "lattice.le_sup_right", "description": "A lattice is a join-semilattice which is also a meet-semilattice."}, {"name": "lattice.sup_le", "description": "A lattice is a join-semilattice which is also a meet-semilattice."}, {"name": "lattice.inf", "description": "A lattice is a join-semilattice which is also a meet-semilattice."}, {"name": "lattice.inf_le_left", "description": "A lattice is a join-semilattice which is also a meet-semilattice."}, {"name": "lattice.inf_le_right", "description": "A lattice is a join-semilattice which is also a meet-semilattice."}, {"name": "lattice.le_inf", "description": "A lattice is a join-semilattice which is also a meet-semilattice."}, {"name": "antitone_on.inf", "description": "Pointwise infimum of two antitone functions is a antitone function."}, {"name": "monotone.inf", "description": "Pointwise infimum of two monotone functions is a monotone function."}, {"name": "sup_of_le_left", "description": ""}, {"name": "monotone_on.max", "description": "Pointwise maximum of two monotone functions is a monotone function."}, {"name": "pi.semilattice_inf", "description": ""}, {"name": "inf_eq_inf_iff_right", "description": ""}, {"name": "le_sup_left", "description": ""}, {"name": "lattice.ext", "description": ""}, {"name": "inf_left_idem", "description": ""}, {"name": "le_sup_right'", "description": ""}, {"name": "inf_le_iff", "description": ""}, {"name": "semilattice_inf.ext", "description": ""}, {"name": "inf_left_right_swap", "description": ""}, {"name": "inf_is_associative", "description": ""}, {"name": "pi.sup_def", "description": ""}, {"name": "inf_le_sup", "description": ""}, {"name": "sup_idem", "description": ""}, {"name": "inf_idem", "description": ""}, {"name": "inf_le_left", "description": ""}, {"name": "le_sup_of_le_right", "description": ""}, {"name": "sup_right_comm", "description": ""}, {"name": "inf_eq_min_default", "description": ""}, {"name": "subtype.mk_sup_mk", "description": ""}, {"name": "monotone.forall_le_of_antitone", "description": "If `f` is monotone, `g` is antitone, and `f \u2264 g`, then for all `a`, `b` we have `f a \u2264 g b`."}, {"name": "le_of_sup_eq", "description": ""}, {"name": "sup_sup_sup_comm", "description": ""}, {"name": "antitone_on.max", "description": "Pointwise maximum of two antitone functions is a antitone function."}, {"name": "sup_le_sup_left", "description": ""}, {"name": "inf_le_ite", "description": ""}, {"name": "le_sup_right", "description": ""}, {"name": "antitone.sup", "description": "Pointwise supremum of two monotone functions is a monotone function."}, {"name": "eq_of_inf_eq_sup_eq", "description": ""}, {"name": "of_dual_min", "description": ""}, {"name": "inf_lt_sup", "description": ""}, {"name": "sup_left_idem", "description": ""}, {"name": "inf_of_le_left", "description": ""}, {"name": "le_sup_left'", "description": ""}, {"name": "pi.has_sup", "description": ""}, {"name": "antitone.le_map_inf", "description": ""}, {"name": "sup_eq_sup_iff_right", "description": ""}, {"name": "sup_sup_distrib_left", "description": ""}, {"name": "subtype.coe_sup", "description": ""}, {"name": "inf_le_inf", "description": ""}, {"name": "sup_congr_left", "description": ""}, {"name": "inf_eq_inf_iff_left", "description": ""}, {"name": "prod.has_inf", "description": ""}, {"name": "inf_ind", "description": ""}, {"name": "inf_inf_inf_comm", "description": ""}, {"name": "semilattice_inf.dual_dual", "description": ""}, {"name": "semilattice_sup.mk'", "description": "A type with a commutative, associative and idempotent binary `sup` operation has the structure of a\njoin-semilattice.\n\nThe partial order is defined so that `a \u2264 b` unfolds to `a \u2294 b = b`; cf. `sup_eq_right`."}, {"name": "inf_lt_of_left_lt", "description": ""}, {"name": "of_dual_sup", "description": ""}, {"name": "to_dual_inf", "description": ""}, {"name": "ordering.ite_eq_gt_distrib", "description": ""}, {"name": "cmp_using_eq_gt", "description": ""}, {"name": "cmp_using_eq_lt", "description": ""}, {"name": "ordering.ite_eq_eq_distrib", "description": ""}, {"name": "cmp_using_eq_eq", "description": ""}, {"name": "ordering.ite_eq_lt_distrib", "description": ""}, {"name": "set.inj_on_empty", "description": ""}, {"name": "set.bij_on.mk", "description": ""}, {"name": "set.restrict_piecewise_compl", "description": ""}, {"name": "set.maps_to.mono", "description": ""}, {"name": "set.maps_to.piecewise_ite", "description": ""}, {"name": "set.maps_to_image", "description": ""}, {"name": "set.surj_on.bij_on_subset", "description": ""}, {"name": "set.univ_pi_piecewise", "description": ""}, {"name": "function.surjective.surj_on", "description": ""}, {"name": "set.eq_on_comp_right_iff", "description": ""}, {"name": "set.maps_to_preimage", "description": ""}, {"name": "set.left_inv_on", "description": "`g` is a left inverse to `f` on `a` means that `g (f x) = x` for all `x \u2208 a`."}, {"name": "set.eq_on_piecewise", "description": ""}, {"name": "set.apply_piecewise\u2082", "description": ""}, {"name": "strict_anti_on.comp", "description": ""}, {"name": "set.maps_to.surj_on_compl", "description": ""}, {"name": "set.bij_on.inter", "description": ""}, {"name": "function.injective.inj_on", "description": "**Alias** of `set.inj_on_of_injective`."}, {"name": "function.inv_fun_on_eq", "description": ""}, {"name": "monotone_on.monotone", "description": ""}, {"name": "function.inv_fun_on_neg", "description": ""}, {"name": "set.inj_on_union", "description": ""}, {"name": "function.insert_inj_on", "description": ""}, {"name": "set.maps_range_to", "description": ""}, {"name": "strict_mono_on.inj_on", "description": ""}, {"name": "set.subsingleton.inj_on", "description": ""}, {"name": "set.inj_on.injective", "description": "**Alias** of the forward direction of `set.inj_on_iff_injective`."}, {"name": "set.surj_on_iff_exists_bij_on_subset", "description": ""}, {"name": "set.maps_to_inter", "description": ""}, {"name": "set.right_inv_on.congr_left", "description": ""}, {"name": "set.maps_to.iterate", "description": ""}, {"name": "set.inj_on_iff_injective", "description": ""}, {"name": "set.bij_on_empty", "description": ""}, {"name": "set.inj_on.mem_image_iff", "description": ""}, {"name": "set.restrict_piecewise", "description": ""}, {"name": "monotone_on.mono", "description": ""}, {"name": "set.restrict_ite_compl", "description": ""}, {"name": "set.restrict_eq_iff", "description": ""}, {"name": "set.restrict", "description": " Restrict domain of a function `f` to a set `s`. Same as `subtype.restrict` but this version\ntakes an argument `\u21a5s` instead of `subtype s`."}, {"name": "set.maps_to_univ", "description": ""}, {"name": "set.eq_on.congr_strict_mono_on", "description": ""}, {"name": "set.maps_to.union", "description": ""}, {"name": "set.bij_on", "description": "`f` is bijective from `s` to `t` if `f` is injective on `s` and `f '' s = t`."}, {"name": "set.maps_image_to", "description": ""}, {"name": "set.surjective_maps_to_image_restrict", "description": ""}, {"name": "function.semiconj.surj_on_range", "description": ""}, {"name": "function.semiconj.bij_on_image", "description": ""}, {"name": "set.bij_on.maps_to", "description": ""}, {"name": "set.restrict_extend_range", "description": ""}, {"name": "set.maps_to_empty", "description": ""}, {"name": "set.bij_on.inv_on_inv_fun_on", "description": ""}, {"name": "set.maps_to_singleton", "description": ""}, {"name": "set.injective_piecewise_iff", "description": ""}, {"name": "set.eq_on.mono", "description": ""}, {"name": "set.restrict_apply", "description": ""}, {"name": "set.left_inv_on.image_image", "description": ""}, {"name": "set.maps_to.inter", "description": ""}, {"name": "set.left_inv_on.comp", "description": ""}, {"name": "function.update_comp_eq_of_not_mem_range'", "description": ""}, {"name": "function.semiconj.bij_on_range", "description": ""}, {"name": "set.maps_to.comp", "description": ""}, {"name": "set.left_inv_on.eq", "description": ""}, {"name": "strict_mono_on.congr", "description": ""}, {"name": "function.semiconj.inj_on_preimage", "description": ""}, {"name": "strict_anti_on.strict_anti", "description": ""}, {"name": "strict_mono_on.strict_mono", "description": ""}, {"name": "set.eq_restrict_iff", "description": ""}, {"name": "set.restrict_dite", "description": ""}, {"name": "function.inv_fun_on", "description": " Construct the inverse for a function `f` on domain `s`. This function is a right inverse of `f`\non `f '' s`. For a computable version, see `function.injective.inv_of_mem_range`."}, {"name": "function.inv_fun_on_pos", "description": ""}, {"name": "set.pi_piecewise", "description": ""}, {"name": "set.eq_on_refl", "description": ""}, {"name": "set.inj_on_insert", "description": ""}, {"name": "set.left_inv_on.image_inter'", "description": ""}, {"name": "set.left_inv_on.surj_on", "description": ""}, {"name": "set.maps_to", "description": "`maps_to f a b` means that the image of `a` is contained in `b`."}, {"name": "set.eq_on.symm", "description": ""}, {"name": "set.maps_to.union_union", "description": ""}, {"name": "set.surj_on.inv_on_inv_fun_on", "description": ""}, {"name": "set.maps_to.mem_iff", "description": ""}, {"name": "set.piecewise_eq_on", "description": ""}, {"name": "set.piecewise_eq_of_mem", "description": ""}, {"name": "strict_mono_on.comp", "description": ""}, {"name": "set.bij_on.image_eq", "description": ""}, {"name": "antitone_on.mono", "description": ""}, {"name": "set.maps_to.image_subset", "description": ""}, {"name": "function.semiconj.inj_on_range", "description": ""}, {"name": "monotone.restrict", "description": ""}, {"name": "set.eq_on_empty", "description": ""}, {"name": "set.piecewise_insert_of_ne", "description": ""}, {"name": "set.maps_to'", "description": ""}, {"name": "set.inj_on.inv_fun_on_image", "description": ""}, {"name": "set.maps_to.mono_right", "description": ""}, {"name": "set.inj_on_of_injective", "description": ""}, {"name": "set.inj_on_singleton", "description": ""}, {"name": "set.compl.decidable_mem", "description": ""}, {"name": "set.piecewise_singleton", "description": ""}, {"name": "set.left_inv_on.right_inv_on_image", "description": ""}, {"name": "set.left_inv_on.image_image'", "description": ""}, {"name": "set.inv_on", "description": "`g` is an inverse to `f` viewed as a map from `a` to `b`"}, {"name": "set.restrict_ite", "description": ""}, {"name": "function.semiconj.surj_on_image", "description": ""}, {"name": "set.preimage_inv_fun_of_mem", "description": ""}, {"name": "set.image_eq_iff_surj_on_maps_to", "description": ""}, {"name": "set.piecewise_op", "description": ""}, {"name": "set.inj_on.left_inv_on_inv_fun_on", "description": ""}, {"name": "set.coe_cod_restrict_apply", "description": ""}, {"name": "set.surj_on.union_union", "description": ""}, {"name": "function.right_inverse.right_inv_on", "description": ""}, {"name": "set.piecewise_insert", "description": ""}, {"name": "set.piecewise_empty", "description": ""}, {"name": "set.inj_on.preimage_image_inter", "description": ""}, {"name": "set.inv_on.mono", "description": ""}, {"name": "set.piecewise_le", "description": ""}, {"name": "set.inj_on.comp", "description": ""}, {"name": "set.eq_on.congr_antitone_on", "description": ""}, {"name": "set.right_inv_on.surj_on", "description": ""}, {"name": "set.maps_univ_to", "description": ""}, {"name": "set.le_piecewise", "description": ""}, {"name": "set.range_piecewise", "description": ""}, {"name": "set.range_extend", "description": ""}, {"name": "set.maps_to.restrict", "description": " Given a map `f` sending `s : set \u03b1` into `t : set \u03b2`, restrict domain of `f` to `s`\nand the codomain to `t`. Same as `subtype.map`."}, {"name": "set.surj_on.congr", "description": ""}, {"name": "set.surj_on.comp", "description": ""}, {"name": "set.inj_on.right_inv_on_of_left_inv_on", "description": ""}, {"name": "set.image_restrict", "description": ""}, {"name": "set.left_inv_on.maps_to", "description": ""}, {"name": "antitone_on.congr", "description": ""}, {"name": "function.inv_fun_on_mem", "description": ""}, {"name": "set.inj_on.bij_on_image", "description": ""}, {"name": "set.restrict_comp_cod_restrict", "description": ""}, {"name": "set.inj_on.cancel_left", "description": ""}, {"name": "set.range_extend_subset", "description": ""}, {"name": "set.eq_on.inter_preimage_eq", "description": ""}, {"name": "set.bij_on.bijective", "description": ""}, {"name": "set.left_inv_on.congr_right", "description": ""}, {"name": "set.right_inv_on.maps_to", "description": ""}, {"name": "set.bij_on.congr", "description": ""}, {"name": "set.injective_iff_inj_on_univ", "description": ""}, {"name": "set.piecewise_op\u2082", "description": ""}, {"name": "set.surj_on.maps_to_compl", "description": ""}, {"name": "set.left_inv_on.eq_on", "description": ""}, {"name": "set.range_restrict", "description": ""}, {"name": "strict_anti_on.congr", "description": ""}, {"name": "set.inj_on", "description": "`f` is injective on `a` if the restriction of `f` to `a` is injective."}, {"name": "set.eq_on.image_eq", "description": ""}, {"name": "function.semiconj.inj_on_image", "description": ""}, {"name": "set.piecewise_insert_self", "description": ""}, {"name": "function.injective.comp_inj_on", "description": ""}, {"name": "set.surj_on.mono", "description": ""}, {"name": "set.apply_piecewise", "description": ""}, {"name": "set.surj_on.subset_range", "description": ""}, {"name": "set.maps_to_union", "description": ""}, {"name": "set.piecewise_same", "description": ""}, {"name": "monotone_on.congr", "description": ""}, {"name": "set.right_inv_on.eq_on", "description": ""}, {"name": "set.eq_on.cancel_left", "description": ""}, {"name": "set.restrict_eq", "description": ""}, {"name": "set.eq_on.trans", "description": ""}, {"name": "set.inj_on.mono", "description": ""}, {"name": "set.maps_to.iterate_restrict", "description": ""}, {"name": "set.left_inv_on.inj_on", "description": ""}, {"name": "set.piecewise_compl", "description": ""}, {"name": "set.left_inv_on.image_inter", "description": ""}, {"name": "set.eq_on.surj_on_iff", "description": ""}, {"name": "set.surj_on_image", "description": ""}, {"name": "set.eq_on.inj_on_iff", "description": ""}, {"name": "set.preimage_inv_fun_of_not_mem", "description": ""}, {"name": "set.inv_on.bij_on", "description": " If functions `f'` and `f` are inverse on `s` and `t`, `f` maps `s` into `t`, and `f'` maps `t`\ninto `s`, then `f` is a bijection between `s` and `t`. The `maps_to` arguments can be deduced from\n`surj_on` statements using `left_inv_on.maps_to` and `right_inv_on.maps_to`."}, {"name": "set.surj_on.right_inv_on_inv_fun_on", "description": ""}, {"name": "function.semiconj.maps_to_range", "description": ""}, {"name": "set.piecewise_le_piecewise", "description": ""}, {"name": "set.right_inv_on", "description": "`g` is a right inverse to `f` on `b` if `f (g x) = x` for all `x \u2208 b`."}, {"name": "set.surj_on.comap_nonempty", "description": ""}, {"name": "set.eq_on.congr_strict_anti_on", "description": ""}, {"name": "set.maps_to_range", "description": ""}, {"name": "set.bij_on.subset_range", "description": ""}, {"name": "set.inj_on.congr", "description": ""}, {"name": "set.surj_on.inter", "description": ""}, {"name": "function.semiconj.maps_to_preimage", "description": ""}, {"name": "set.maps_to.congr", "description": ""}, {"name": "set.right_inv_on.congr_right", "description": ""}, {"name": "set.bij_on.surj_on", "description": ""}, {"name": "set.bij_on.compl", "description": ""}, {"name": "set.eq_on_of_left_inv_on_of_right_inv_on", "description": ""}, {"name": "set.cod_restrict", "description": " Restrict codomain of a function `f` to a set `s`. Same as `subtype.coind` but this version\nhas codomain `\u21a5s` instead of `subtype s`."}, {"name": "set.inj_on_preimage", "description": ""}, {"name": "set.right_inv_on.comp", "description": ""}, {"name": "set.surj_on_empty", "description": ""}, {"name": "set.maps_to.inter_inter", "description": ""}, {"name": "set.surj_on_iff_surjective", "description": ""}, {"name": "set.inj_on.eq_iff", "description": ""}, {"name": "set.right_inv_on.mono", "description": ""}, {"name": "set.bij_on.comp", "description": ""}, {"name": "set.surj_on_iff_exists_map_subtype", "description": ""}, {"name": "strict_anti_on.inj_on", "description": ""}, {"name": "set.eq_on.bij_on_iff", "description": ""}, {"name": "set.maps_to_iff_exists_map_subtype", "description": ""}, {"name": "set.bij_on.inj_on", "description": ""}, {"name": "set.left_inv_on.mono", "description": ""}, {"name": "set.eq_on.cancel_right", "description": ""}, {"name": "set.maps_to.coe_restrict_apply", "description": ""}, {"name": "set.eq_on.comp_left", "description": ""}, {"name": "set.injective_cod_restrict", "description": ""}, {"name": "set.bijective_iff_bij_on_univ", "description": ""}, {"name": "set.right_inv_on.eq", "description": ""}, {"name": "set.restrict_eq_restrict_iff", "description": ""}, {"name": "set.eq_on.comp_right", "description": ""}, {"name": "function.update_comp_eq_of_not_mem_range", "description": "Non-dependent version of `function.update_comp_eq_of_not_mem_range'`"}, {"name": "set.piecewise_univ", "description": ""}, {"name": "set.eq_on.congr_monotone_on", "description": ""}, {"name": "set.bij_on.union", "description": ""}, {"name": "set.restrict_dite_compl", "description": ""}, {"name": "function.injective.cod_restrict", "description": "**Alias** of the reverse direction of `set.injective_cod_restrict`."}, {"name": "set.surj_on.union", "description": ""}, {"name": "set.surj_on.left_inv_on_of_right_inv_on", "description": ""}, {"name": "set.eq_on.piecewise_ite'", "description": ""}, {"name": "function.left_inverse.right_inv_on_range", "description": ""}, {"name": "antitone_on.monotone", "description": ""}, {"name": "function.semiconj.maps_to_image", "description": ""}, {"name": "strict_mono_on.mono", "description": ""}, {"name": "set.exists_inj_on_iff_injective", "description": ""}, {"name": "strict_mono.cod_restrict", "description": ""}, {"name": "set.left_inv_on.congr_left", "description": ""}, {"name": "set.piecewise_eq_of_not_mem", "description": ""}, {"name": "set.piecewise_mem_pi", "description": ""}, {"name": "strict_anti_on.comp_strict_mono_on", "description": ""}, {"name": "set.surj_on.cancel_right", "description": ""}, {"name": "strict_mono_on.comp_strict_anti_on", "description": ""}, {"name": "set.inj_on.mem_of_mem_image", "description": ""}, {"name": "set.piecewise_range_comp", "description": ""}, {"name": "set.eq_on_comm", "description": ""}, {"name": "set.inv_on.symm", "description": ""}, {"name": "set.eq_on.piecewise_ite", "description": ""}, {"name": "monotone.range_factorization", "description": ""}, {"name": "set.surj_on", "description": "`f` is surjective from `a` to `b` if `b` is contained in the image of `a`."}, {"name": "set.piecewise_preimage", "description": ""}, {"name": "set.eq_on", "description": "Two functions `f\u2081 f\u2082 : \u03b1 \u2192 \u03b2` are equal on `s`\n if `f\u2081 x = f\u2082 x` for all `x \u2208 a`."}, {"name": "set.surj_on.inter_inter", "description": ""}, {"name": "set.surj_on.image_eq_of_maps_to", "description": ""}, {"name": "set.restrict_extend_compl_range", "description": ""}, {"name": "set.maps_to_id", "description": ""}, {"name": "set.piecewise_eq_on_compl", "description": ""}, {"name": "set.eq_on.maps_to_iff", "description": ""}, {"name": "function.left_inverse.left_inv_on", "description": ""}, {"name": "set.surj_on.maps_to_inv_fun_on", "description": ""}, {"name": "strict_anti_on.mono", "description": ""}, {"name": "set.surjective_iff_surj_on_univ", "description": ""}, {"name": "set.maps_to.mono_left", "description": ""}, {"name": "monotone.cod_restrict", "description": ""}, {"name": "set.comp_eq_of_eq_on_range", "description": ""}, {"name": "forall_apply_eq_imp_iff'", "description": ""}, {"name": "iff_not_comm", "description": ""}, {"name": "exists_unique_eq'", "description": ""}, {"name": "and_congr_right'", "description": ""}, {"name": "decidable.not_imp_symm", "description": ""}, {"name": "not_exists", "description": ""}, {"name": "opt_param.out", "description": " If `x : \u03b1 := d` then `x.out : \u03b1`. These are definitionally equal, but this can\nnevertheless be useful for various reasons, e.g. to apply further projection notation or in an\nargument to `simp`."}, {"name": "not_imp_of_and_not", "description": ""}, {"name": "or.rotate", "description": ""}, {"name": "em'", "description": ""}, {"name": "forall_imp", "description": ""}, {"name": "exists_or_eq_right'", "description": ""}, {"name": "decidable.imp_iff_not_or", "description": ""}, {"name": "pempty.elim", "description": "Ex falso, the nondependent eliminator for the `pempty` type."}, {"name": "or_or_distrib_right", "description": ""}, {"name": "ne_of_mem_of_not_mem", "description": ""}, {"name": "imp_or_distrib'", "description": ""}, {"name": "and_imp", "description": ""}, {"name": "coe_sort_coe_base", "description": ""}, {"name": "subtype.subsingleton", "description": ""}, {"name": "imp_iff_right_iff", "description": ""}, {"name": "and_or_distrib_left", "description": "`\u2227` distributes over `\u2228` (on the left)."}, {"name": "forall\u2084_congr", "description": ""}, {"name": "or_and_distrib_right", "description": "`\u2227` distributes over `\u2228` (on the right)."}, {"name": "not_and_of_not_left", "description": ""}, {"name": "and_not_self_iff", "description": ""}, {"name": "forall_prop_of_true", "description": ""}, {"name": "proof_irrel_heq", "description": ""}, {"name": "imp_forall_iff", "description": " We intentionally restrict the type of `\u03b1` in this lemma so that this is a safer to use in simp\nthan `forall_swap`."}, {"name": "dite_eq_ite", "description": "A `dite` whose results do not actually depend on the condition may be reduced to an `ite`."}, {"name": "exists_prop", "description": ""}, {"name": "or_and_distrib_left", "description": "`\u2228` distributes over `\u2227` (on the left)."}, {"name": "ball_true_iff", "description": ""}, {"name": "decidable_of_bool", "description": " Prove that `a` is decidable by constructing a boolean `b` and a proof that `b \u2194 a`.\n(This is sometimes taken as an alternate definition of decidability.)"}, {"name": "coe_fn_coe_trans", "description": ""}, {"name": "decidable.iff_iff_not_or_and_or_not", "description": ""}, {"name": "not_imp", "description": ""}, {"name": "congr_fun_congr_arg", "description": ""}, {"name": "dec_em'", "description": ""}, {"name": "not_exists_of_forall_not", "description": ""}, {"name": "bex.elim", "description": ""}, {"name": "iff.is_refl", "description": ""}, {"name": "forall\u2082_swap", "description": ""}, {"name": "imp_intro", "description": ""}, {"name": "or_self_right", "description": ""}, {"name": "and_rotate", "description": ""}, {"name": "eq_rec_constant", "description": "Transport through trivial families is the identity."}, {"name": "by_contra", "description": ""}, {"name": "congr_arg2", "description": ""}, {"name": "decidable.or_congr_left", "description": ""}, {"name": "or_of_or_of_imp_right", "description": ""}, {"name": "and_iff_left_of_imp", "description": ""}, {"name": "imp_iff_not", "description": ""}, {"name": "bex_def", "description": ""}, {"name": "empty.decidable_eq", "description": ""}, {"name": "ite_eq_or_eq", "description": ""}, {"name": "library_note.decidable arguments", "description": "As mathlib is primarily classical,\nif the type signature of a `def` or `lemma` does not require any `decidable` instances to state,\nit is preferable not to introduce any `decidable` instances that are needed in the proof\nas arguments, but rather to use the `classical` tactic as needed.\n\nIn the other direction, when `decidable` instances do appear in the type signature,\nit is better to use explicitly introduced ones rather than allowing Lean to automatically infer\nclassical ones, as these may cause instance mismatch errors later."}, {"name": "bex_congr", "description": ""}, {"name": "decidable.or_iff_not_imp_right", "description": ""}, {"name": "classical.cases", "description": ""}, {"name": "exists_imp_exists'", "description": ""}, {"name": "eq.congr_left", "description": ""}, {"name": "library_note.function coercion", "description": "Many structures such as bundled morphisms coerce to functions so that you can\ntransparently apply them to arguments. For example, if `e : \u03b1 \u2243 \u03b2` and `a : \u03b1`\nthen you can write `e a` and this is elaborated as `\u21d1e a`. This type of\ncoercion is implemented using the `has_coe_to_fun` type class. There is one\nimportant consideration:\n\nIf a type coerces to another type which in turn coerces to a function,\nthen it **must** implement `has_coe_to_fun` directly:\n```lean\nstructure sparkling_equiv (\u03b1 \u03b2) extends \u03b1 \u2243 \u03b2\n\n-- if we add a `has_coe` instance,\ninstance {\u03b1 \u03b2} : has_coe (sparkling_equiv \u03b1 \u03b2) (\u03b1 \u2243 \u03b2) :=\n\u27e8sparkling_equiv.to_equiv\u27e9\n\n-- then a `has_coe_to_fun` instance **must** be added as well:\ninstance {\u03b1 \u03b2} : has_coe_to_fun (sparkling_equiv \u03b1 \u03b2) :=\n\u27e8\u03bb _, \u03b1 \u2192 \u03b2, \u03bb f, f.to_equiv.to_fun\u27e9\n```\n\n(Rationale: if we do not declare the direct coercion, then `\u21d1e a` is not in\nsimp-normal form. The lemma `coe_fn_coe_base` will unfold it to `\u21d1\u2191e a`. This\noften causes loops in the simplifier.)"}, {"name": "not_iff_not", "description": ""}, {"name": "not.elim", "description": " Ex falso for negation. From `\u00ac a` and `a` anything follows. This is the same as `absurd` with\nthe arguments flipped, but it is in the `not` namespace so that projection notation can be used."}, {"name": "exists_unique.exists2", "description": ""}, {"name": "and_or_imp", "description": ""}, {"name": "peirce'", "description": ""}, {"name": "congr_arg_refl", "description": ""}, {"name": "imp_not_self", "description": ""}, {"name": "dite_ne_right_iff", "description": ""}, {"name": "exists_or_eq_left'", "description": ""}, {"name": "imp_self", "description": ""}, {"name": "eq_or_ne", "description": ""}, {"name": "decidable.not_imp_comm", "description": ""}, {"name": "decidable.imp_or_distrib'", "description": ""}, {"name": "congr_arg_heq", "description": ""}, {"name": "ite_apply", "description": " A 'ite' producing a `Pi` type `\u03a0 a, \u03c3 a`, applied to a value `a : \u03b1` is a `ite` that applies\neither branch to `a`."}, {"name": "iff.or", "description": ""}, {"name": "ne.ite_ne_right_iff", "description": ""}, {"name": "congr_fun\u2082", "description": ""}, {"name": "or_of_or_of_imp_of_imp", "description": ""}, {"name": "classical.some_spec2", "description": ""}, {"name": "forall_eq_or_imp", "description": ""}, {"name": "not_and'", "description": ""}, {"name": "forall_const", "description": ""}, {"name": "and_self_right", "description": ""}, {"name": "decidable.iff_not_comm", "description": ""}, {"name": "xor_false", "description": ""}, {"name": "auto_param.out", "description": " If `x : \u03b1 . tac_name` then `x.out : \u03b1`. These are definitionally equal, but this can\nnevertheless be useful for various reasons, e.g. to apply further projection notation or in an\nargument to `simp`."}, {"name": "Exists.some_spec", "description": "Show that an element extracted from `P : \u2203 a, p a` using `P.some` satisfies `p`."}, {"name": "decidable.not_not", "description": ""}, {"name": "ball.imp_right", "description": ""}, {"name": "not_or_of_imp", "description": ""}, {"name": "ball_congr", "description": ""}, {"name": "library_note.decidable namespace", "description": "In most of mathlib, we use the law of excluded middle (LEM) and the axiom of choice (AC) freely.\nThe `decidable` namespace contains versions of lemmas from the root namespace that explicitly\nattempt to avoid the axiom of choice, usually by adding decidability assumptions on the inputs.\n\nYou can check if a lemma uses the axiom of choice by using `#print axioms foo` and seeing if\n`classical.choice` appears in the list."}, {"name": "not_and_self_iff", "description": ""}, {"name": "apply_dite", "description": "A function applied to a `dite` is a `dite` of that function applied to each of the branches."}, {"name": "iff_true_right", "description": ""}, {"name": "iff_false_right", "description": ""}, {"name": "subsingleton.prod", "description": ""}, {"name": "forall\u2082_congr", "description": ""}, {"name": "false_ne_true", "description": ""}, {"name": "forall_exists_index", "description": ""}, {"name": "dite_apply", "description": " A 'dite' producing a `Pi` type `\u03a0 a, \u03c3 a`, applied to a value `a : \u03b1` is a `dite` that applies\neither branch to `a`."}, {"name": "and_congr_left", "description": ""}, {"name": "coe_fn_coe_trans'", "description": "Non-dependent version of `coe_fn_coe_trans`, helps `rw` figure out the argument."}, {"name": "congr_refl_right", "description": ""}, {"name": "or_congr_left'", "description": ""}, {"name": "not_forall_not", "description": ""}, {"name": "apply_dite2", "description": " A two-argument function applied to two `dite`s is a `dite` of that two-argument function\napplied to each of the branches."}, {"name": "iff_iff_eq", "description": ""}, {"name": "iff_iff_not_or_and_or_not", "description": ""}, {"name": "funext\u2083", "description": ""}, {"name": "or_rotate", "description": ""}, {"name": "and.imp_left", "description": ""}, {"name": "decidable.not_and_not_right", "description": ""}, {"name": "exists_apply_eq_apply'", "description": ""}, {"name": "decidable.not_and_distrib", "description": ""}, {"name": "exists_unique_prop_of_true", "description": ""}, {"name": "iff_and_self", "description": ""}, {"name": "imp_false", "description": ""}, {"name": "not_and_not_right", "description": ""}, {"name": "bex.imp_right", "description": ""}, {"name": "and_congr_left'", "description": ""}, {"name": "iff_mpr_iff_true_intro", "description": ""}, {"name": "Exists.fst", "description": ""}, {"name": "or_self_left", "description": ""}, {"name": "bex_imp_distrib", "description": ""}, {"name": "decidable.peirce", "description": ""}, {"name": "Exists.imp", "description": ""}, {"name": "eq.congr", "description": ""}, {"name": "ne.ite_eq_left_iff", "description": ""}, {"name": "decidable.not_iff_not", "description": ""}, {"name": "and_and_distrib_left", "description": ""}, {"name": "decidable.iff_iff_and_or_not_and_not", "description": ""}, {"name": "imp_iff_right", "description": ""}, {"name": "classical.dec_rel", "description": "Any relation `p` is decidable classically."}, {"name": "exists_eq", "description": ""}, {"name": "function.swap\u2082", "description": "Swaps two pairs of arguments to a function."}, {"name": "ite_ne_right_iff", "description": ""}, {"name": "and_self_left", "description": ""}, {"name": "bex_or_distrib", "description": ""}, {"name": "plift.down_inj", "description": ""}, {"name": "cast_cast", "description": ""}, {"name": "decidable_of_iff'", "description": " Transfer decidability of `b` to decidability of `a`, if the propositions are equivalent.\nThis is the same as `decidable_of_iff` but the iff is flipped."}, {"name": "ne.ite_ne_left_iff", "description": ""}, {"name": "imp_iff_or_not", "description": ""}, {"name": "or_imp_distrib", "description": ""}, {"name": "iff_self_and", "description": ""}, {"name": "decidable.and_or_imp", "description": ""}, {"name": "forall_prop_of_false", "description": ""}, {"name": "or_congr_left", "description": ""}, {"name": "exists_or_distrib", "description": ""}, {"name": "and_and_and_comm", "description": ""}, {"name": "iff.not_right", "description": ""}, {"name": "not_and", "description": ""}, {"name": "ne_comm", "description": ""}, {"name": "or_iff_left", "description": ""}, {"name": "subsingleton_iff_forall_eq", "description": ""}, {"name": "iff_of_true", "description": ""}, {"name": "classical.dec_eq", "description": "Any type `\u03b1` has decidable equality classically."}, {"name": "not_iff", "description": ""}, {"name": "and_iff_right_iff_imp", "description": ""}, {"name": "psum.inhabited_right", "description": ""}, {"name": "classical.not_ball", "description": ""}, {"name": "exists_comm", "description": ""}, {"name": "classical.exists_cases", "description": " Construct a function from a default value `H0`, and a function to use if there exists a value\nsatisfying the predicate."}, {"name": "fact.elim", "description": ""}, {"name": "decidable.of_not_imp", "description": ""}, {"name": "apply_ite", "description": "A function applied to a `ite` is a `ite` of that function applied to each of the branches."}, {"name": "has_mem.mem.ne_of_not_mem'", "description": "**Alias** of `ne_of_mem_of_not_mem'`."}, {"name": "decidable.not_ball", "description": ""}, {"name": "rec_heq_of_heq", "description": ""}, {"name": "forall_of_ball", "description": ""}, {"name": "ne.ite_eq_right_iff", "description": ""}, {"name": "or.elim3", "description": ""}, {"name": "eq_iff_eq_cancel_right", "description": ""}, {"name": "iff.not_left", "description": ""}, {"name": "classical.dec_pred", "description": "Any predicate `p` is decidable classically."}, {"name": "decidable.imp_or_distrib", "description": ""}, {"name": "coe_sort_coe_trans", "description": ""}, {"name": "iff.imp", "description": ""}, {"name": "decidable.and_iff_not_or_not", "description": ""}, {"name": "not.decidable_imp_symm", "description": ""}, {"name": "dite_eq_iff", "description": ""}, {"name": "ne_or_eq", "description": ""}, {"name": "exists_and_distrib_right", "description": ""}, {"name": "ite_and", "description": ""}, {"name": "congr_heq", "description": ""}, {"name": "exists_unique_prop", "description": ""}, {"name": "not_and_distrib", "description": " One of de Morgan's laws: the negation of a conjunction is logically equivalent to the\ndisjunction of the negations."}, {"name": "exists_eq_right_right", "description": ""}, {"name": "forall_imp_iff_exists_imp", "description": ""}, {"name": "decidable.not_iff_comm", "description": ""}, {"name": "not_ball", "description": ""}, {"name": "hidden", "description": " An identity function with its main argument implicit. This will be printed as `hidden` even\nif it is applied to a large term, so it can be used for elision,\nas done in the `elide` and `unelide` tactics."}, {"name": "dec_em", "description": ""}, {"name": "classical.choice_of_by_contradiction'", "description": "`classical.by_contradiction'` is equivalent to lean's axiom `classical.choice`."}, {"name": "xor_self", "description": ""}, {"name": "subsingleton_of_forall_eq", "description": "If all points are equal to a given point `x`, then `\u03b1` is a subsingleton."}, {"name": "decidable.imp_iff_right_iff", "description": ""}, {"name": "forall\u2083_congr", "description": ""}, {"name": "eq_iff_eq_cancel_left", "description": ""}, {"name": "and_and_distrib_right", "description": ""}, {"name": "Exists.snd", "description": ""}, {"name": "decidable.not_forall_not", "description": ""}, {"name": "forall_2_true_iff", "description": ""}, {"name": "ne.dite_ne_left_iff", "description": ""}, {"name": "decidable.not_imp_not", "description": ""}, {"name": "forall_eq", "description": ""}, {"name": "fact_iff", "description": ""}, {"name": "eq_equivalence", "description": ""}, {"name": "exists_eq_left", "description": ""}, {"name": "not_not", "description": " The Double Negation Theorem: `\u00ac \u00ac P` is equivalent to `P`.\nThe left-to-right direction, double negation elimination (DNE),\nis classically true but not constructively."}, {"name": "or_not_of_imp", "description": ""}, {"name": "exists_prop_congr", "description": ""}, {"name": "ball_of_forall", "description": ""}, {"name": "not_iff_comm", "description": ""}, {"name": "not.imp_symm", "description": ""}, {"name": "by_contradiction", "description": ""}, {"name": "cast_eq_iff_heq", "description": ""}, {"name": "ball_mem_comm", "description": ""}, {"name": "ne_of_apply_ne", "description": ""}, {"name": "forall_and_distrib", "description": ""}, {"name": "not_imp_self", "description": ""}, {"name": "ite_eq_iff", "description": ""}, {"name": "decidable.not_or_of_imp", "description": ""}, {"name": "iff_of_eq", "description": ""}, {"name": "decidable_of_iff", "description": " Transfer decidability of `a` to decidability of `b`, if the propositions are equivalent.\n**Important**: this function should be used instead of `rw` on `decidable b`, because the\nkernel will get stuck reducing the usage of `propext` otherwise,\nand `dec_trivial` will not work."}, {"name": "decidable.ne_or_eq", "description": ""}, {"name": "subsingleton_pempty", "description": ""}, {"name": "forall_eq_apply_imp_iff'", "description": ""}, {"name": "exists_false", "description": ""}, {"name": "not_exists_not", "description": ""}, {"name": "of_not_imp", "description": ""}, {"name": "or_iff_not_and_not", "description": ""}, {"name": "apply_ite2", "description": " A two-argument function applied to two `ite`s is a `ite` of that two-argument function\napplied to each of the branches."}, {"name": "imp.swap", "description": ""}, {"name": "forall_apply_eq_imp_iff", "description": ""}, {"name": "exists_prop_congr'", "description": ""}, {"name": "and_forall_ne", "description": ""}, {"name": "ball_or_left_distrib", "description": ""}, {"name": "bex_or_left_distrib", "description": ""}, {"name": "forall_prop_congr'", "description": ""}, {"name": "imp_iff_not_or", "description": ""}, {"name": "peirce", "description": ""}, {"name": "not_xor", "description": ""}, {"name": "ball_cond_comm", "description": ""}, {"name": "iff_iff_and_or_not_and_not", "description": ""}, {"name": "exists_eq_right", "description": ""}, {"name": "Exists.some", "description": "Extract an element from a existential statement, using `classical.some`."}, {"name": "not_forall_of_exists_not", "description": ""}, {"name": "exists_exists_and_eq_and", "description": ""}, {"name": "exists_unique.exists", "description": ""}, {"name": "decidable.or_iff_not_imp_left", "description": ""}, {"name": "and.congr_left_iff", "description": ""}, {"name": "classical.by_contradiction'", "description": "A version of `by_contradiction` that uses types instead of propositions."}, {"name": "congr_refl_left", "description": ""}, {"name": "coe_fn_coe_base", "description": ""}, {"name": "empty.elim", "description": "Ex falso, the nondependent eliminator for the `empty` type."}, {"name": "ne_of_mem_of_not_mem'", "description": ""}, {"name": "decidable.or_not_of_imp", "description": ""}, {"name": "and_or_distrib_right", "description": "`\u2228` distributes over `\u2227` (on the right)."}, {"name": "congr_fun_rfl", "description": ""}, {"name": "and_iff_right_of_imp", "description": ""}, {"name": "decidable.not_and_distrib'", "description": ""}, {"name": "exists_exists_eq_and", "description": ""}, {"name": "congr_fun\u2083", "description": ""}, {"name": "forall\u2082_imp", "description": ""}, {"name": "exists_and_distrib_left", "description": ""}, {"name": "iff_false_left", "description": ""}, {"name": "imp_not_comm", "description": ""}, {"name": "has_mem.mem.ne_of_not_mem", "description": "**Alias** of `ne_of_mem_of_not_mem`."}, {"name": "and_iff_not_or_not", "description": ""}, {"name": "exists_prop_of_true", "description": ""}, {"name": "Exists\u2082.imp", "description": ""}, {"name": "decidable.eq_or_ne", "description": ""}, {"name": "not_and_of_not_or_not", "description": ""}, {"name": "dite_ne_left_iff", "description": ""}, {"name": "imp_or_distrib", "description": ""}, {"name": "exists_or_eq_right", "description": ""}, {"name": "eq_iff_iff", "description": ""}, {"name": "ulift.down_inj", "description": ""}, {"name": "or_iff_left_iff_imp", "description": ""}, {"name": "exists_iff_of_forall", "description": ""}, {"name": "decidable.not_imp_self", "description": ""}, {"name": "or_congr_right", "description": ""}, {"name": "ite_eq_right_iff", "description": ""}, {"name": "iff_def", "description": ""}, {"name": "or_iff_not_imp_right", "description": ""}, {"name": "bex.imp_left", "description": ""}, {"name": "coe_fn_coe_base'", "description": "Non-dependent version of `coe_fn_coe_base`, helps `rw` figure out the argument."}, {"name": "iff.is_trans", "description": ""}, {"name": "iff.and", "description": ""}, {"name": "forall_true_left", "description": "See `is_empty.forall_iff` for the `false` version."}, {"name": "and_iff_left_iff_imp", "description": ""}, {"name": "not_not_of_not_imp", "description": ""}, {"name": "funext\u2082", "description": ""}, {"name": "iff_true_left", "description": ""}, {"name": "decidable.not_iff", "description": ""}, {"name": "exists_prop_of_false", "description": ""}, {"name": "not_imp_not", "description": ""}, {"name": "exists.classical_rec_on", "description": " This function has the same type as `exists.rec_on`, and can be used to case on an equality,\nbut `exists.rec_on` can only eliminate into Prop, while this version eliminates into any universe\nusing the axiom of choice."}, {"name": "and.rotate", "description": ""}, {"name": "forall\u2085_congr", "description": ""}, {"name": "exists_eq_right'", "description": ""}, {"name": "decidable.not_forall", "description": ""}, {"name": "exists_eq_right_right'", "description": ""}, {"name": "ite_ne_left_iff", "description": ""}, {"name": "or_not", "description": ""}, {"name": "forall_or_of_or_forall", "description": ""}, {"name": "exists_unique.intro2", "description": ""}, {"name": "ball_and_distrib", "description": ""}, {"name": "ne.dite_ne_right_iff", "description": ""}, {"name": "and.exists", "description": ""}, {"name": "decidable.not_imp", "description": ""}, {"name": "exists_true_left", "description": "See `is_empty.exists_iff` for the `false` version."}, {"name": "forall_apply_eq_imp_iff\u2082", "description": ""}, {"name": "or_or_distrib_left", "description": ""}, {"name": "bex_of_exists", "description": ""}, {"name": "forall\u2083_imp", "description": ""}, {"name": "eq.congr_right", "description": ""}, {"name": "decidable.forall_or_distrib_left", "description": ""}, {"name": "iff.not", "description": ""}, {"name": "exists_swap", "description": ""}, {"name": "exists_unique.elim2", "description": ""}, {"name": "plift.down_injective", "description": ""}, {"name": "dite_eq_right_iff", "description": ""}, {"name": "forall_forall_const", "description": "For some reason simp doesn't use `forall_const` to simplify in this case."}, {"name": "pi_congr", "description": ""}, {"name": "bex.intro", "description": ""}, {"name": "eq_mpr_eq_cast", "description": ""}, {"name": "heq_iff_eq", "description": ""}, {"name": "library_note.fact non-instances", "description": "In most cases, we should not have global instances of `fact`; typeclass search only reads the head\nsymbol and then tries any instances, which means that adding any such instance will cause slowdowns\neverywhere. We instead make them as lemmata and make them local instances as required."}, {"name": "ulift.down_injective", "description": ""}, {"name": "forall_3_true_iff", "description": ""}, {"name": "exists\u2082_congr", "description": ""}, {"name": "em", "description": ""}, {"name": "classical.subtype_of_exists", "description": "A version of classical.indefinite_description which is definitionally equal to a pair"}, {"name": "decidable.imp_iff_or_not", "description": ""}, {"name": "and.imp_right", "description": ""}, {"name": "heq_of_cast_eq", "description": ""}, {"name": "decidable.or_congr_right", "description": ""}, {"name": "or.right_comm", "description": ""}, {"name": "iff_def'", "description": ""}, {"name": "and.right_comm", "description": ""}, {"name": "imp_true_iff", "description": ""}, {"name": "exists_unique_false", "description": ""}, {"name": "or_iff_right", "description": ""}, {"name": "iff.iff", "description": ""}, {"name": "ne.dite_eq_right_iff", "description": ""}, {"name": "exists_unique_eq", "description": ""}, {"name": "eq_mp_eq_cast", "description": ""}, {"name": "empty.subsingleton", "description": ""}, {"name": "exists_imp_distrib", "description": ""}, {"name": "not_or_distrib", "description": " One of de Morgan's laws: the negation of a disjunction is logically equivalent to the\nconjunction of the negations."}, {"name": "forall_eq'", "description": ""}, {"name": "not_ne_iff", "description": ""}, {"name": "classical.dec", "description": "Any prop `p` is decidable classically. A shorthand for `classical.prop_decidable`."}, {"name": "fact", "description": " Wrapper for adding elementary propositions to the type class systems.\nWarning: this can easily be abused. See the rest of this docstring for details.\n\nCertain propositions should not be treated as a class globally,\nbut sometimes it is very convenient to be able to use the type class system\nin specific circumstances.\n\nFor example, `zmod p` is a field if and only if `p` is a prime number.\nIn order to be able to find this field instance automatically by type class search,\nwe have to turn `p.prime` into an instance implicit assumption.\n\nOn the other hand, making `nat.prime` a class would require a major refactoring of the library,\nand it is questionable whether making `nat.prime` a class is desirable at all.\nThe compromise is to add the assumption `[fact p.prime]` to `zmod.field`.\n\nIn particular, this class is not intended for turning the type class system\ninto an automated theorem prover for first order logic."}, {"name": "fact.out", "description": " Wrapper for adding elementary propositions to the type class systems.\nWarning: this can easily be abused. See the rest of this docstring for details.\n\nCertain propositions should not be treated as a class globally,\nbut sometimes it is very convenient to be able to use the type class system\nin specific circumstances.\n\nFor example, `zmod p` is a field if and only if `p` is a prime number.\nIn order to be able to find this field instance automatically by type class search,\nwe have to turn `p.prime` into an instance implicit assumption.\n\nOn the other hand, making `nat.prime` a class would require a major refactoring of the library,\nand it is questionable whether making `nat.prime` a class is desirable at all.\nThe compromise is to add the assumption `[fact p.prime]` to `zmod.field`.\n\nIn particular, this class is not intended for turning the type class system\ninto an automated theorem prover for first order logic."}, {"name": "or_or_or_comm", "description": ""}, {"name": "Exists\u2083.imp", "description": ""}, {"name": "sort.inhabited", "description": ""}, {"name": "forall_prop_congr", "description": ""}, {"name": "forall_swap", "description": ""}, {"name": "xor_true", "description": ""}, {"name": "decidable_eq_of_subsingleton", "description": ""}, {"name": "iff_of_false", "description": ""}, {"name": "exists\u2082_comm", "description": ""}, {"name": "forall_eq_apply_imp_iff", "description": ""}, {"name": "decidable.or_iff_not_and_not", "description": ""}, {"name": "not_ball_of_bex_not", "description": ""}, {"name": "exists\u2083_congr", "description": ""}, {"name": "xor.is_commutative", "description": ""}, {"name": "not.imp", "description": ""}, {"name": "of_not_not", "description": ""}, {"name": "exists_eq_left'", "description": ""}, {"name": "not_nonempty_pempty", "description": ""}, {"name": "xor_comm", "description": ""}, {"name": "exists_eq'", "description": ""}, {"name": "bex_eq_left", "description": ""}, {"name": "and.congr_right_iff", "description": ""}, {"name": "or_iff_not_imp_left", "description": ""}, {"name": "exists_unique_iff_exists", "description": ""}, {"name": "imp_and_distrib", "description": ""}, {"name": "decidable.not_exists_not", "description": ""}, {"name": "dite_eq_left_iff", "description": ""}, {"name": "or_congr_right'", "description": ""}, {"name": "not_forall", "description": ""}, {"name": "xor_iff_not_iff", "description": ""}, {"name": "not_imp_comm", "description": ""}, {"name": "exists_unique.unique", "description": ""}, {"name": "exists_unique.unique2", "description": ""}, {"name": "pempty", "description": "`pempty` is the universe-polymorphic analogue of `empty`."}, {"name": "coe_coe", "description": "Add an instance to \"undo\" coercion transitivity into a chain of coercions, because\n  most simp lemmas are stated with respect to simple coercions and will not match when\n  part of a chain."}, {"name": "forall_true_iff'", "description": ""}, {"name": "ite_eq_left_iff", "description": ""}, {"name": "ball.imp_left", "description": ""}, {"name": "eq_true_eq_id", "description": ""}, {"name": "psum.inhabited_left", "description": ""}, {"name": "exists_of_bex", "description": ""}, {"name": "not_of_not_imp", "description": ""}, {"name": "pempty.decidable_eq", "description": ""}, {"name": "exists_apply_eq_apply", "description": ""}, {"name": "exists\u2085_congr", "description": ""}, {"name": "forall_or_distrib_left", "description": ""}, {"name": "or_iff_right_iff_imp", "description": ""}, {"name": "ne.dite_eq_left_iff", "description": ""}, {"name": "forall_true_iff", "description": ""}, {"name": "dite_eq_or_eq", "description": ""}, {"name": "sort.inhabited'", "description": ""}, {"name": "not_and_of_not_right", "description": ""}, {"name": "imp_imp_imp", "description": ""}, {"name": "exists\u2084_congr", "description": ""}, {"name": "or_of_or_of_imp_left", "description": ""}, {"name": "dite_not", "description": "Negation of the condition `P : Prop` in a `dite` is the same as swapping the branches."}, {"name": "not_bex", "description": ""}, {"name": "exists_unique_const", "description": ""}, {"name": "ite_not", "description": "Negation of the condition `P : Prop` in a `ite` is the same as swapping the branches."}, {"name": "exists_const", "description": ""}, {"name": "decidable.forall_or_distrib_right", "description": ""}, {"name": "exists_or_eq_left", "description": ""}, {"name": "eq_iff_true_of_subsingleton", "description": ""}, {"name": "forall_or_distrib_right", "description": ""}, {"name": "or.imp3", "description": ""}, {"name": "list.modify_nth_tail_modify_nth_tail", "description": ""}, {"name": "list.repeat_left_inj", "description": ""}, {"name": "list.foldl_join", "description": ""}, {"name": "list.sublist.diff_right", "description": ""}, {"name": "list.tail_drop", "description": ""}, {"name": "list.nth_le_enum_from", "description": ""}, {"name": "list.modify_nth_eq_take_cons_drop", "description": ""}, {"name": "list.append_inj'", "description": ""}, {"name": "list.map\u2082_nil", "description": ""}, {"name": "list.ext_le", "description": ""}, {"name": "list.nthd_eq_nth_le", "description": ""}, {"name": "list.sublist_cons_of_sublist", "description": ""}, {"name": "list.mfoldr_append", "description": ""}, {"name": "list.nth_le_nth", "description": ""}, {"name": "list.map_id'", "description": ""}, {"name": "list.sublist_of_cons_sublist", "description": ""}, {"name": "list.append_eq_cons_iff", "description": ""}, {"name": "list.map_diff", "description": ""}, {"name": "list.insert_nth_remove_nth_of_le", "description": ""}, {"name": "list.foldl1_eq_foldr1", "description": ""}, {"name": "list.foldr_ext", "description": ""}, {"name": "list.cons_ne_self", "description": ""}, {"name": "list.inth_cons_succ", "description": ""}, {"name": "list.bind_ret_eq_map", "description": ""}, {"name": "list.not_exists_mem_nil", "description": ""}, {"name": "list.init_eq_take", "description": ""}, {"name": "list.erase_nil", "description": ""}, {"name": "list.bidirectional_rec", "description": " Bidirectional induction principle for lists: if a property holds for the empty list, the\nsingleton list, and `a :: (l ++ [b])` from `l`, then it holds for all lists. This can be used to\nprove statements about palindromes. The principle is given for a `Sort`-valued predicate, i.e., it\ncan also be used to construct data."}, {"name": "list.foldl_eq_of_comm'", "description": ""}, {"name": "list.filter_eq_foldr", "description": ""}, {"name": "list.singleton_sublist", "description": ""}, {"name": "list.zip_left_eq_zip_left'", "description": ""}, {"name": "list.sublist_append_left", "description": ""}, {"name": "list.filter_map_filter_map", "description": ""}, {"name": "list.ne_of_not_mem_cons", "description": ""}, {"name": "list.scanr_aux_cons", "description": ""}, {"name": "list.some_nth_le_eq", "description": ""}, {"name": "list.span_eq_take_drop", "description": ""}, {"name": "list.zip_right_cons_cons", "description": ""}, {"name": "list.append_ne_nil_of_ne_nil_left", "description": ""}, {"name": "list.intersperse_cons_cons", "description": ""}, {"name": "list.repeat_subset_singleton", "description": ""}, {"name": "list.erasep_cons_of_pos", "description": ""}, {"name": "list.index_of_cons_eq", "description": ""}, {"name": "list.map_injective_iff", "description": ""}, {"name": "list.length_erasep_of_mem", "description": ""}, {"name": "list.take_left", "description": ""}, {"name": "list.filter_map_cons_none", "description": ""}, {"name": "list.map\u2082_right_eq_map\u2082", "description": ""}, {"name": "list.mem_of_mem_cons_of_mem", "description": ""}, {"name": "list.reverse_cons", "description": ""}, {"name": "list.to_chunks_aux_join", "description": ""}, {"name": "list.pmap", "description": "Partial map. If `f : \u03a0 a, p a \u2192 \u03b2` is a partial function defined on\n `a : \u03b1` satisfying `p`, then `pmap f l h` is essentially the same as `map f l`\n but is defined only when all members of `l` satisfy `p`, using the proof\n to apply `f`."}, {"name": "list.lookmap_nil", "description": ""}, {"name": "list.foldr_rec_on", "description": " Induction principle for values produced by a `foldr`: if a property holds\nfor the seed element `b : \u03b2` and for all incremental `op : \u03b1 \u2192 \u03b2 \u2192 \u03b2`\nperformed on the elements `(a : \u03b1) \u2208 l`. The principle is given for\na `Sort`-valued predicate, i.e., it can also be used to construct data."}, {"name": "list.erasep_map", "description": ""}, {"name": "list.filter_filter_map", "description": ""}, {"name": "list.sublist.cons_cons", "description": ""}, {"name": "list.last_reverse", "description": ""}, {"name": "list.reverse_surjective", "description": ""}, {"name": "list.foldr_fixed'", "description": ""}, {"name": "list.nthd_append", "description": ""}, {"name": "list.nth_le_update_nth_of_ne", "description": ""}, {"name": "list.bidirectional_rec_on", "description": "Like `bidirectional_rec`, but with the list parameter placed first."}, {"name": "list.zip_left'_cons_nil", "description": ""}, {"name": "list.zip_right'_nil_cons", "description": ""}, {"name": "list.erase_append_right", "description": ""}, {"name": "list.last_append_singleton", "description": ""}, {"name": "list.take_nil", "description": ""}, {"name": "list.sublist.trans", "description": ""}, {"name": "list.ne_and_not_mem_of_not_mem_cons", "description": ""}, {"name": "list.all\u2082.imp", "description": ""}, {"name": "list.append_subset_of_subset_of_subset", "description": ""}, {"name": "list.nth_update_nth_eq", "description": ""}, {"name": "list.exists_or_eq_self_of_erasep", "description": ""}, {"name": "list.map_reverse", "description": ""}, {"name": "list.mem_repeat", "description": ""}, {"name": "list.update_nth_eq_take_cons_drop", "description": ""}, {"name": "list.map\u2082_left'_nil_right", "description": ""}, {"name": "list.last_singleton", "description": ""}, {"name": "list.range_map_coe", "description": ""}, {"name": "list.init_cons_of_ne_nil", "description": ""}, {"name": "list.mfoldl_append", "description": ""}, {"name": "list.zip_left_cons_cons", "description": ""}, {"name": "list.eq_or_ne_mem_of_mem", "description": ""}, {"name": "list.nth_le_repeat", "description": ""}, {"name": "list.length_erasep_add_one", "description": ""}, {"name": "list.nth_map", "description": ""}, {"name": "list.modify_nth_eq_update_nth", "description": ""}, {"name": "list.lookmap_congr", "description": ""}, {"name": "list.head_cons", "description": ""}, {"name": "list.diff_cons_right", "description": ""}, {"name": "list.nthd_default_eq_inth", "description": ""}, {"name": "list.erase_cons", "description": ""}, {"name": "list.sublist_nil_iff_eq_nil", "description": ""}, {"name": "list.sublist.erasep", "description": ""}, {"name": "list.filter_eq_nil", "description": ""}, {"name": "list.nil.is_right_id", "description": ""}, {"name": "list.erasep_cons", "description": ""}, {"name": "list.nth_le_append_right_aux", "description": ""}, {"name": "list.erasep_append_right", "description": ""}, {"name": "list.take_succ", "description": ""}, {"name": "list.init_append_last'", "description": ""}, {"name": "list.foldl_fixed", "description": ""}, {"name": "list.set_of_mem_cons", "description": ""}, {"name": "list.subset_append_of_subset_right", "description": ""}, {"name": "list.drop_append", "description": " Dropping the elements up to `l\u2081.length + i` in `l\u2081 + l\u2082` is the same as dropping the elements\nup to `i` in `l\u2082`."}, {"name": "list.reduce_option_nil", "description": ""}, {"name": "list.length_insert_nth", "description": ""}, {"name": "list.foldr_rec_on_nil", "description": ""}, {"name": "list.foldr_eta", "description": ""}, {"name": "list.insert_nth_length_self", "description": ""}, {"name": "list.repeat_succ", "description": ""}, {"name": "list.erase_eq_erasep", "description": ""}, {"name": "list.forall_mem_of_forall_mem_cons", "description": ""}, {"name": "list.cons_inj", "description": ""}, {"name": "list.mem_pmap", "description": ""}, {"name": "list.zip_right'_cons_cons", "description": ""}, {"name": "list.drop_add", "description": ""}, {"name": "list.choose_mem", "description": ""}, {"name": "list.map_eq_foldr", "description": ""}, {"name": "list.last_cons", "description": ""}, {"name": "list.nth_modify_nth_eq", "description": ""}, {"name": "list.insert_pos", "description": ""}, {"name": "list.reduce_option_cons_of_some", "description": ""}, {"name": "list.decidable_nthd_nil_ne", "description": " An empty list can always be decidably checked for the presence of an element.\nNot an instance because it would clash with `decidable_eq \u03b1`."}, {"name": "list.inth_eq_nth_le", "description": ""}, {"name": "list.filter_map_append", "description": ""}, {"name": "list.sublist.reverse", "description": ""}, {"name": "list.choose_spec", "description": ""}, {"name": "list.head'_append", "description": ""}, {"name": "list.map_drop", "description": ""}, {"name": "list.map\u2082_right'_nil_cons", "description": ""}, {"name": "list.sublist.subset", "description": ""}, {"name": "list.reverse_eq_nil", "description": ""}, {"name": "list.drop_eq_nil_iff_le", "description": ""}, {"name": "list.foldl_eq_of_comm_of_assoc", "description": ""}, {"name": "list.reduce_option_length_eq_iff", "description": ""}, {"name": "list.append_sublist_append_left", "description": ""}, {"name": "list.eq_repeat'", "description": ""}, {"name": "list.map_subset_iff", "description": ""}, {"name": "list.reduce_option_mem_iff", "description": ""}, {"name": "list.inth_append_right", "description": ""}, {"name": "list.head'_append_of_ne_nil", "description": ""}, {"name": "list.nil_diff", "description": ""}, {"name": "list.map_comp_map", "description": "Composing a `list.map` with another `list.map` is equal to\na single `list.map` of composed functions."}, {"name": "list.erase_subset", "description": ""}, {"name": "list.sizeof_slice_lt", "description": ""}, {"name": "list.drop_one", "description": ""}, {"name": "list.all\u2082_cons", "description": ""}, {"name": "list.scanr_cons", "description": ""}, {"name": "list.mem_singleton_self", "description": ""}, {"name": "list.nth_le_of_eq", "description": " If one has `nth_le L i hi` in a formula and `h : L = L'`, one can not `rw h` in the formula as\n`hi` gives `i < L.length` and not `i < L'.length`. The lemma `nth_le_of_eq` can be used to make\nsuch a rewrite, with `rw (nth_le_of_eq h)`."}, {"name": "list.erase_cons_head", "description": ""}, {"name": "list.lookmap_map_eq", "description": ""}, {"name": "list.forall_mem_cons", "description": ""}, {"name": "list.exists_of_mem_bind", "description": ""}, {"name": "list.take_while_idem", "description": ""}, {"name": "list.nth_take_of_succ", "description": ""}, {"name": "list.index_of_cons", "description": ""}, {"name": "list.find_some", "description": ""}, {"name": "list.index_of_cons_ne", "description": ""}, {"name": "list.drop_drop", "description": ""}, {"name": "list.bind_singleton", "description": ""}, {"name": "list.modify_head_modify_head", "description": ""}, {"name": "list.append_right_inj", "description": ""}, {"name": "list.modify_nth_tail_length", "description": ""}, {"name": "list.length_le_length_insert_nth", "description": ""}, {"name": "list.drop_while_nth_le_zero_not", "description": ""}, {"name": "list.map_id''", "description": ""}, {"name": "list.comp_map", "description": "A single `list.map` of a composition of functions is equal to\ncomposing a `list.map` with another `list.map`, fully applied.\nThis is the reverse direction of `list.map_map`."}, {"name": "list.mem_map_swap", "description": ""}, {"name": "list.bind_congr", "description": ""}, {"name": "list.take_while_append_drop", "description": ""}, {"name": "list.reverse_repeat", "description": ""}, {"name": "list.append_ne_nil_of_ne_nil_right", "description": ""}, {"name": "list.insert_nth_zero", "description": ""}, {"name": "list.repeat_right_inj", "description": ""}, {"name": "list.bind_append", "description": ""}, {"name": "list.concat_append", "description": ""}, {"name": "list.nth_update_nth_ne", "description": ""}, {"name": "list.enum_from_nil", "description": ""}, {"name": "list.nth_length", "description": ""}, {"name": "list.empty_eq", "description": ""}, {"name": "list.nth_le_append_right", "description": ""}, {"name": "list.enum_cons", "description": ""}, {"name": "list.subset_append_of_subset_left", "description": ""}, {"name": "list.init_append_of_ne_nil", "description": ""}, {"name": "list.erasep_nil", "description": ""}, {"name": "list.nth_append_right", "description": ""}, {"name": "list.reverse_take", "description": ""}, {"name": "list.erase_comm", "description": ""}, {"name": "list.nthd_nil", "description": ""}, {"name": "list.last_cons_cons", "description": ""}, {"name": "list.last_eq_nth_le", "description": ""}, {"name": "list.mem_map", "description": ""}, {"name": "list.split_on_p_aux_spec", "description": ""}, {"name": "list.head_eq_head'", "description": ""}, {"name": "list.mem_take_while_imp", "description": ""}, {"name": "list.drop_left'", "description": ""}, {"name": "list.filter_map_nil", "description": ""}, {"name": "list.drop_eq_nth_le_cons", "description": ""}, {"name": "list.nil_sublist", "description": ""}, {"name": "list.zip_right_nil_cons", "description": ""}, {"name": "list.nthd_eq_default", "description": ""}, {"name": "list.erase_append_left", "description": ""}, {"name": "list.filter_singleton", "description": ""}, {"name": "list.reverse_cons'", "description": ""}, {"name": "list.eq_cons_of_length_one", "description": ""}, {"name": "list.map_repeat", "description": ""}, {"name": "list.nth_zero_scanl", "description": ""}, {"name": "list.cons_diff_of_not_mem", "description": ""}, {"name": "list.take_length", "description": ""}, {"name": "list.cons_diff_of_mem", "description": ""}, {"name": "list.mem_filter_map", "description": ""}, {"name": "list.tail_append_of_ne_nil", "description": ""}, {"name": "list.nth_le_take'", "description": " The `i`-th element of a list coincides with the `i`-th element of any of its prefixes of\nlength `> i`. Version designed to rewrite from the small list to the big list."}, {"name": "list.unique_of_is_empty", "description": "There is only one list of an empty type"}, {"name": "list.length_attach", "description": ""}, {"name": "list.slice_eq", "description": ""}, {"name": "list.take_while_take_while", "description": ""}, {"name": "list.foldl_eq_foldr'", "description": ""}, {"name": "list.diff_sublist", "description": ""}, {"name": "list.foldl_append", "description": ""}, {"name": "list.forall_mem_nil", "description": ""}, {"name": "list.append_subset_iff", "description": ""}, {"name": "list.inth_cons_zero", "description": ""}, {"name": "list.mem_or_eq_of_mem_update_nth", "description": ""}, {"name": "list.exists_mem_cons_of_exists", "description": ""}, {"name": "list.nth_zero", "description": ""}, {"name": "list.head_mem_head'", "description": ""}, {"name": "list.reduce_option_length_le", "description": ""}, {"name": "list.nthd_singleton_default_eq", "description": ""}, {"name": "list.nth_drop", "description": ""}, {"name": "list.length_enum_from", "description": ""}, {"name": "list.nth_modify_nth_ne", "description": ""}, {"name": "list.last'_is_none", "description": ""}, {"name": "list.to_chunks_eq_cons", "description": ""}, {"name": "list.bind_map", "description": ""}, {"name": "list.mem_filter", "description": ""}, {"name": "list.erasep_cons_of_neg", "description": ""}, {"name": "list.erasep_of_forall_not", "description": ""}, {"name": "list.erase_sublist", "description": ""}, {"name": "list.inth_zero_eq_head", "description": ""}, {"name": "list.update_nth_eq_nil", "description": ""}, {"name": "list.enum_nth", "description": ""}, {"name": "list.nth_le_take", "description": " The `i`-th element of a list coincides with the `i`-th element of any of its prefixes of\nlength `> i`. Version designed to rewrite from the big list to the small list."}, {"name": "list.nth_le_reverse", "description": ""}, {"name": "list.nth_le_zero_scanl", "description": ""}, {"name": "list.map\u2082_flip", "description": ""}, {"name": "list.foldl_cons", "description": ""}, {"name": "list.map_pmap", "description": ""}, {"name": "list.map_reverse_core", "description": ""}, {"name": "list.decidable_sublist", "description": ""}, {"name": "list.foldr_fixed", "description": ""}, {"name": "list.nth_pmap", "description": ""}, {"name": "list.append_right_injective", "description": ""}, {"name": "list.join_repeat_nil", "description": ""}, {"name": "list.find_cons_of_pos", "description": ""}, {"name": "list.nth_le_map", "description": ""}, {"name": "list.length_eq_three", "description": ""}, {"name": "list.concat_eq_reverse_cons", "description": ""}, {"name": "list.zip_left_nil_right", "description": ""}, {"name": "list.reverse_eq_iff", "description": ""}, {"name": "list.eq_nil_of_subset_nil", "description": ""}, {"name": "list.foldl_map'", "description": ""}, {"name": "list.insert_nth_comm", "description": ""}, {"name": "list.length_pos_of_ne_nil", "description": ""}, {"name": "list.foldr_cons", "description": ""}, {"name": "list.nth_le_eq_iff", "description": ""}, {"name": "list.head_append", "description": ""}, {"name": "list.map_filter_map", "description": ""}, {"name": "list.reduce_option_map", "description": ""}, {"name": "list.reverse_sublist_iff", "description": ""}, {"name": "list.eq_nil_iff_forall_not_mem", "description": ""}, {"name": "list.foldl_assoc_comm_cons", "description": ""}, {"name": "list.append_inj_left'", "description": ""}, {"name": "list.enum_map_snd", "description": ""}, {"name": "list.foldr_map", "description": ""}, {"name": "list.attach_eq_nil", "description": ""}, {"name": "list.filter_map_cons_some", "description": ""}, {"name": "list.mem_iff_nth_le", "description": ""}, {"name": "list.take_eq_nil_iff", "description": ""}, {"name": "list.map\u2082_right_cons_cons", "description": ""}, {"name": "list.enum_nil", "description": ""}, {"name": "list.or_exists_of_exists_mem_cons", "description": ""}, {"name": "list.take_cons", "description": ""}, {"name": "list.ilast'_mem", "description": ""}, {"name": "list.repeat_sublist_repeat", "description": ""}, {"name": "list.reduce_option_nth_iff", "description": ""}, {"name": "list.mem_of_mem_head'", "description": ""}, {"name": "list.split_on_p_ne_nil", "description": ""}, {"name": "list.nth_le_drop'", "description": "  The `i + j`-th element of a list coincides with the `j`-th element of the list obtained by\ndropping the first `i` elements. Version designed to rewrite from the small list to the big list."}, {"name": "list.mem_last'_eq_last", "description": ""}, {"name": "list.erase_cons_tail", "description": ""}, {"name": "list.take_while_eq_nil_iff", "description": ""}, {"name": "list.init_take", "description": ""}, {"name": "list.length_lookmap", "description": ""}, {"name": "list.ilast_eq_last'", "description": ""}, {"name": "list.nth_le_cons_aux", "description": ""}, {"name": "list.drop_take", "description": ""}, {"name": "list.append_eq_has_append", "description": ""}, {"name": "list.mem_reverse", "description": ""}, {"name": "list.append_left_injective", "description": ""}, {"name": "list.reverse_inj", "description": ""}, {"name": "list.modify_nth_eq_take_drop", "description": ""}, {"name": "list.last_congr", "description": ""}, {"name": "list.find_mem", "description": ""}, {"name": "list.split_on_intercalate", "description": "`split_on x` is the left inverse of `intercalate [x]`, on the domain\n consisting of each nonempty list of lists `ls` whose elements do not contain `x`"}, {"name": "list.lookmap_none", "description": ""}, {"name": "list.cons_subset_of_subset_of_mem", "description": ""}, {"name": "list.map_nil", "description": ""}, {"name": "list.monotone_filter_left", "description": ""}, {"name": "list.filter_map_join", "description": ""}, {"name": "list.eq_of_sublist_of_length_eq", "description": ""}, {"name": "list.nil_map\u2082", "description": ""}, {"name": "list.nth_le_tail", "description": ""}, {"name": "decidable.list.eq_or_ne_mem_of_mem", "description": ""}, {"name": "list.split_on_p_nil", "description": ""}, {"name": "list.mfoldr_nil", "description": ""}, {"name": "list.drop_while_eq_nil_iff", "description": ""}, {"name": "list.choose_property", "description": ""}, {"name": "list.length_pos_iff_exists_mem", "description": ""}, {"name": "list.reduce_option_concat", "description": ""}, {"name": "list.zip_left'_nil_right", "description": ""}, {"name": "list.nth_len_le", "description": ""}, {"name": "list.bind_eq_bind", "description": ""}, {"name": "list.enum_append", "description": ""}, {"name": "list.map_bind", "description": ""}, {"name": "list.mem_map_of_injective", "description": ""}, {"name": "list.sublist_append_of_sublist_left", "description": ""}, {"name": "list.reverse_append", "description": ""}, {"name": "list.concat_nil", "description": ""}, {"name": "list.mem_join_of_mem", "description": ""}, {"name": "list.length_reverse", "description": ""}, {"name": "list.ne_nil_of_mem", "description": ""}, {"name": "list.filter_map_some", "description": ""}, {"name": "list.append_eq_nil", "description": ""}, {"name": "list.last_map", "description": ""}, {"name": "list.forall_mem_append", "description": ""}, {"name": "list.mem_erase_of_ne", "description": ""}, {"name": "list.filter_map_cons", "description": ""}, {"name": "list.head'_map", "description": ""}, {"name": "list.zip_left_cons_nil", "description": ""}, {"name": "list.index_of_inj", "description": ""}, {"name": "list.mfoldl_cons", "description": ""}, {"name": "list.drop_eq_nil_of_le", "description": ""}, {"name": "list.foldl_eq_foldr", "description": ""}, {"name": "list.split_on_p_aux'", "description": " An auxiliary definition for proving a specification lemma for `split_on_p`.\n\n`split_on_p_aux' P xs ys` splits the list `ys ++ xs` at every element satisfying `P`,\nwhere `ys` is an accumulating parameter for the initial segment of elements not satisfying `P`."}, {"name": "list.modify_nth_tail_eq_take_drop", "description": ""}, {"name": "list.index_of_nth_le", "description": ""}, {"name": "list.pmap_map", "description": ""}, {"name": "list.eq_nil_of_map_eq_nil", "description": ""}, {"name": "list.exists_mem_of_length_pos", "description": ""}, {"name": "list.append_inj_right", "description": ""}, {"name": "list.map\u2082_right_eq_map\u2082_right'", "description": ""}, {"name": "list.lookmap_id'", "description": ""}, {"name": "list.map\u2082_left_eq_map\u2082", "description": ""}, {"name": "list.mem_of_mem_erasep", "description": ""}, {"name": "list.exists_of_erasep", "description": ""}, {"name": "list.nth_le_insert_nth_of_lt", "description": ""}, {"name": "list.foldr_rec_on_cons", "description": ""}, {"name": "list.nth_le_cons_length", "description": ""}, {"name": "list.drop_nil", "description": ""}, {"name": "list.map_eq_append_split", "description": ""}, {"name": "list.mem_of_ne_of_mem", "description": ""}, {"name": "list.take_all_of_le", "description": ""}, {"name": "list.length_injective", "description": ""}, {"name": "list.exists_mem_of_ne_nil", "description": ""}, {"name": "list.inth_nil", "description": ""}, {"name": "list.map_filter", "description": ""}, {"name": "list.map_filter_map_of_inv", "description": ""}, {"name": "list.eq_nil_of_sublist_nil", "description": ""}, {"name": "list.init_append_last", "description": ""}, {"name": "list.nth_le_reverse'", "description": ""}, {"name": "list.nth_le_insert_nth_self", "description": ""}, {"name": "list.append_concat", "description": ""}, {"name": "list.cons_head'_tail", "description": ""}, {"name": "list.map_fst_add_enum_eq_enum_from", "description": ""}, {"name": "list.foldl_fixed'", "description": ""}, {"name": "list.nthd_repeat_default_eq", "description": ""}, {"name": "list.length_concat", "description": ""}, {"name": "list.doubleton_eq", "description": ""}, {"name": "list.find_nil", "description": ""}, {"name": "list.index_of_le_length", "description": ""}, {"name": "list.index_of_nth", "description": ""}, {"name": "list.insert_nth_injective", "description": ""}, {"name": "list.foldl_reverse", "description": ""}, {"name": "list.scanr_nil", "description": ""}, {"name": "list.map\u2082_right'_nil_left", "description": ""}, {"name": "list.map\u2082_right'_nil_right", "description": ""}, {"name": "list.length_singleton", "description": ""}, {"name": "list.cons_injective", "description": ""}, {"name": "list.nth_le_reverse_aux2", "description": ""}, {"name": "list.take_zero", "description": ""}, {"name": "list.zip_left'_nil_left", "description": ""}, {"name": "list.zip_right'_nil_left", "description": ""}, {"name": "list.last_eq_of_concat_eq", "description": ""}, {"name": "list.split_on_p_eq_single", "description": "If no element satisfies `p` in the list `xs`, then `xs.split_on_p p = [xs]`"}, {"name": "list.split_at_eq_take_drop", "description": ""}, {"name": "list.sublist.erase", "description": ""}, {"name": "list.mem_last'_cons", "description": ""}, {"name": "list.sublist.filter_map", "description": ""}, {"name": "list.foldl_ext", "description": ""}, {"name": "list.nth_le_append", "description": ""}, {"name": "list.sublist_cons", "description": ""}, {"name": "list.enum_from_singleton", "description": ""}, {"name": "list.reduce_option_append", "description": ""}, {"name": "list.all\u2082.decidable_pred", "description": ""}, {"name": "list.exists_erase_eq", "description": ""}, {"name": "list.intersperse_nil", "description": ""}, {"name": "list.last_mem", "description": ""}, {"name": "list.length_enum", "description": ""}, {"name": "list.mem_filter_of_mem", "description": ""}, {"name": "list.map_const", "description": ""}, {"name": "list.can_lift", "description": " If each element of a list can be lifted to some type, then the whole list can be lifted to this\ntype."}, {"name": "list.reverse_singleton", "description": ""}, {"name": "list.nthd_cons_zero", "description": ""}, {"name": "list.init_eq_of_concat_eq", "description": ""}, {"name": "list.foldl_nil", "description": ""}, {"name": "list.pmap_eq_map", "description": ""}, {"name": "list.nthd_append_right", "description": ""}, {"name": "list.reverse_involutive", "description": ""}, {"name": "list.erasep_subset", "description": ""}, {"name": "list.not_mem_cons_of_ne_of_not_mem", "description": ""}, {"name": "list.empty_iff_eq_nil", "description": ""}, {"name": "list.foldr_hom\u2082", "description": ""}, {"name": "list.filter_map_map", "description": ""}, {"name": "list.enum_from_append", "description": ""}, {"name": "list.remove_nth_eq_nth_tail", "description": ""}, {"name": "list.nth_mem", "description": ""}, {"name": "list.nth_le_singleton", "description": ""}, {"name": "list.exists_of_length_succ", "description": ""}, {"name": "list.split_on_p_aux_eq", "description": ""}, {"name": "list.eq_of_mem_singleton", "description": ""}, {"name": "list.sublist.refl", "description": ""}, {"name": "list.diff_append", "description": ""}, {"name": "list.nth_injective", "description": ""}, {"name": "list.nth_succ_scanl", "description": ""}, {"name": "list.range_map", "description": ""}, {"name": "list.repeat_add", "description": ""}, {"name": "list.mfoldr_cons", "description": ""}, {"name": "list.cons_sublist_cons_iff", "description": ""}, {"name": "list.mem_enum_from", "description": ""}, {"name": "list.all\u2082_map_iff", "description": ""}, {"name": "list.map\u2082_left_eq_map\u2082_left'", "description": ""}, {"name": "list.modify_nth_tail_id", "description": ""}, {"name": "list.ext", "description": ""}, {"name": "list.cons_eq_append_iff", "description": ""}, {"name": "list.split_on_p_first", "description": "When a list of the form `[...xs, sep, ...as]` is split on `p`, the first element is `xs`,\n assuming no element in `xs` satisfies `p` but `sep` does satisfy `p`"}, {"name": "list.zip_right'_nil_right", "description": ""}, {"name": "list.zip_left'_cons_cons", "description": ""}, {"name": "list.zip_right_eq_zip_right'", "description": ""}, {"name": "list.cons_nth_le_drop_succ", "description": ""}, {"name": "list.exists_mem_cons_of", "description": ""}, {"name": "list.attach", "description": "\"Attach\" the proof that the elements of `l` are in `l` to produce a new list\n with the same elements but in the type `{x // x \u2208 l}`."}, {"name": "list.take'_nil", "description": ""}, {"name": "list.map\u2082_left_nil_right", "description": ""}, {"name": "list.foldr_eq_of_comm'", "description": ""}, {"name": "list.foldl_rec_on_nil", "description": ""}, {"name": "list.map\u2082_right_nil_left", "description": ""}, {"name": "list.lookmap_some", "description": ""}, {"name": "list.concat_cons", "description": ""}, {"name": "list.filter_map_filter", "description": ""}, {"name": "list.forall_mem_map_iff", "description": ""}, {"name": "list.split_on_p_cons", "description": ""}, {"name": "list.foldl_assoc", "description": ""}, {"name": "list.scanl_cons", "description": ""}, {"name": "list.reverse_injective", "description": ""}, {"name": "list.filter_filter", "description": ""}, {"name": "list.foldr_hom", "description": ""}, {"name": "list.take'_left'", "description": ""}, {"name": "list.reduce_option_length_lt_iff", "description": ""}, {"name": "list.take_left'", "description": ""}, {"name": "list.concat_ne_nil", "description": ""}, {"name": "list.eq_of_sublist_of_length_le", "description": ""}, {"name": "list.remove_nth_insert_nth", "description": ""}, {"name": "list.take_append", "description": " Taking the first `l\u2081.length + i` elements in `l\u2081 ++ l\u2082` is the same as appending the first\n`i` elements of `l\u2082` to `l\u2081`."}, {"name": "list.mfoldl_nil", "description": ""}, {"name": "list.tail_repeat", "description": ""}, {"name": "list.nth_eq_none_iff", "description": ""}, {"name": "list.inth_eq_iget_nth", "description": ""}, {"name": "list.enum_from_nth", "description": ""}, {"name": "list.reduce_option_concat_of_some", "description": ""}, {"name": "list.mem_of_mem_filter", "description": ""}, {"name": "list.index_of_eq_length", "description": ""}, {"name": "list.all\u2082_iff_forall", "description": ""}, {"name": "list.append_left_cancel", "description": ""}, {"name": "list.nth_modify_nth", "description": ""}, {"name": "list.nil_eq_append_iff", "description": ""}, {"name": "list.reverse_bijective", "description": ""}, {"name": "list.foldl_hom\u2082", "description": ""}, {"name": "list.lookmap_cons_some", "description": ""}, {"name": "list.map_concat", "description": ""}, {"name": "list.enum_from_map_snd", "description": ""}, {"name": "list.erase_of_not_mem", "description": ""}, {"name": "list.nth_of_mem", "description": ""}, {"name": "list.mem_attach", "description": ""}, {"name": "list.drop_append_of_le_length", "description": ""}, {"name": "list.nth_update_nth_of_lt", "description": ""}, {"name": "list.mem_bind_of_mem", "description": ""}, {"name": "list.nth_le_cons", "description": ""}, {"name": "list.append_inj_right'", "description": ""}, {"name": "list.filter_true", "description": ""}, {"name": "list.filter_subset", "description": ""}, {"name": "list.intercalate_split_on", "description": "`intercalate [x]` is the left inverse of `split_on x`"}, {"name": "list.last_pmap", "description": ""}, {"name": "list.mem_erasep_of_neg", "description": ""}, {"name": "list.exists_of_mem_join", "description": ""}, {"name": "list.insert_nth_succ_cons", "description": ""}, {"name": "list.reverse_concat", "description": ""}, {"name": "list.exists_of_mem_map", "description": "**Alias** of the forward direction of `list.mem_map`."}, {"name": "list.map_filter_eq_foldr", "description": ""}, {"name": "list.foldr_reverse", "description": ""}, {"name": "list.nth_le_reverse_aux1", "description": ""}, {"name": "list.mem_diff_of_mem", "description": ""}, {"name": "list.mem_of_mem_erase", "description": ""}, {"name": "list.take_append_drop", "description": ""}, {"name": "list.modify_nth_tail_modify_nth_tail_same", "description": ""}, {"name": "list.filter_congr'", "description": ""}, {"name": "list.sublist.append_right", "description": ""}, {"name": "list.map_eq_nil", "description": ""}, {"name": "list.forall_mem_singleton", "description": ""}, {"name": "list.zip_left_nil_left", "description": ""}, {"name": "list.foldr_map'", "description": ""}, {"name": "list.mem_map_of_mem", "description": ""}, {"name": "list.map\u2082_right_nil_cons", "description": ""}, {"name": "list.split_on_nil", "description": ""}, {"name": "list.mem_singleton", "description": ""}, {"name": "list.diff_subset", "description": ""}, {"name": "list.insert_nth_of_length_lt", "description": ""}, {"name": "list.not_mem_of_not_mem_cons", "description": ""}, {"name": "list.filter_eq_self", "description": ""}, {"name": "list.last'_append", "description": ""}, {"name": "list.lookmap_of_forall_not", "description": ""}, {"name": "list.sublist_or_mem_of_sublist", "description": ""}, {"name": "list.append_sublist_append_right", "description": ""}, {"name": "list.repeat_left_inj'", "description": ""}, {"name": "list.pmap_eq_map_attach", "description": ""}, {"name": "list.filter_length_eq_length", "description": ""}, {"name": "list.length_erase_of_mem", "description": ""}, {"name": "list.last'_eq_last_of_ne_nil", "description": ""}, {"name": "list.map_tail", "description": ""}, {"name": "list.pmap_eq_nil", "description": ""}, {"name": "list.eq_repeat", "description": ""}, {"name": "list.take'_left", "description": ""}, {"name": "list.map_erase", "description": ""}, {"name": "list.repeat_left_injective", "description": ""}, {"name": "list.subset_def", "description": ""}, {"name": "list.map_join", "description": ""}, {"name": "list.mem_insert_nth", "description": ""}, {"name": "list.index_of_cons_self", "description": ""}, {"name": "list.enum_singleton", "description": ""}, {"name": "list.map_eq_bind", "description": ""}, {"name": "list.last_concat", "description": ""}, {"name": "list.last'_is_some", "description": ""}, {"name": "list.mem_map_of_involutive", "description": ""}, {"name": "list.nth_le_map'", "description": ""}, {"name": "list.cons_diff", "description": ""}, {"name": "list.update_nth_length", "description": ""}, {"name": "list.index_of_lt_length", "description": ""}, {"name": "list.bind_assoc", "description": ""}, {"name": "list.index_of_of_not_mem", "description": ""}, {"name": "list.cons_subset", "description": ""}, {"name": "list.has_append.append.is_associative", "description": ""}, {"name": "list.modify_nth_tail_modify_nth_tail_le", "description": ""}, {"name": "list.to_chunks_aux_eq", "description": ""}, {"name": "list.nth_append", "description": ""}, {"name": "list.zip_right_nil_right", "description": ""}, {"name": "list.head_mem_self", "description": ""}, {"name": "list.nth_take", "description": ""}, {"name": "list.nth_le_zero", "description": ""}, {"name": "list.repeat_right_injective", "description": ""}, {"name": "list.to_chunks_join", "description": ""}, {"name": "list.reverse_reverse", "description": ""}, {"name": "list.mem_bind", "description": ""}, {"name": "list.split_on_p_aux_nil", "description": ""}, {"name": "list.reduce_option_singleton", "description": ""}, {"name": "list.tail_append_singleton_of_ne_nil", "description": ""}, {"name": "list.drop_length", "description": ""}, {"name": "list.length_eq_zero", "description": ""}, {"name": "list.modify_nth_length", "description": ""}, {"name": "list.enum_from_cons", "description": ""}, {"name": "list.injective_foldl_comp", "description": ""}, {"name": "list.nth_le_map_rev", "description": "A version of `nth_le_map` that can be used for rewriting."}, {"name": "list.nth_le_attach", "description": ""}, {"name": "list.attach_map_val", "description": ""}, {"name": "list.append_inj_left", "description": ""}, {"name": "list.sublist_of_cons_sublist_cons", "description": ""}, {"name": "list.length_init", "description": ""}, {"name": "list.head_eq_of_cons_eq", "description": ""}, {"name": "list.take_take", "description": ""}, {"name": "list.map\u2082_right'_cons_cons", "description": ""}, {"name": "list.nth_le_succ_scanl", "description": ""}, {"name": "list.update_nth_nil", "description": ""}, {"name": "list.erasep_sublist", "description": ""}, {"name": "list.sublist.antisymm", "description": ""}, {"name": "list.reverse_rec_on", "description": " Induction principle from the right for lists: if a property holds for the empty list, and\nfor `l ++ [a]` if it holds for `l`, then it holds for all lists. The principle is given for\na `Sort`-valued predicate, i.e., it can also be used to construct data."}, {"name": "list.index_of_nil", "description": ""}, {"name": "list.length_pos_of_mem", "description": ""}, {"name": "list.insert_nth_remove_nth_of_ge", "description": ""}, {"name": "list.drop_append_eq_append_drop", "description": " Dropping the elements up to `n` in `l\u2081 ++ l\u2082` is the same as dropping the elements up to `n`\nin `l\u2081`, dropping the elements up to `n - l\u2081.length` in `l\u2082`, and appending them."}, {"name": "list.erase_diff_erase_sublist_of_sublist", "description": ""}, {"name": "list.append_left_inj", "description": ""}, {"name": "list.insert_neg", "description": ""}, {"name": "list.nth_concat_length", "description": ""}, {"name": "list.take'_eq_take", "description": ""}, {"name": "list.nth_le_mem", "description": ""}, {"name": "list.drop_left", "description": ""}, {"name": "list.singleton_append", "description": ""}, {"name": "list.sublist_append_of_sublist_right", "description": ""}, {"name": "list.length_injective_iff", "description": ""}, {"name": "list.diff_eq_foldl", "description": ""}, {"name": "list.exists_mem_cons_iff", "description": ""}, {"name": "list.intersperse_singleton", "description": ""}, {"name": "list.map_foldl_erase", "description": ""}, {"name": "list.foldl_hom", "description": ""}, {"name": "list.sublist.append", "description": ""}, {"name": "list.pmap_congr", "description": ""}, {"name": "list.scanl_nil", "description": ""}, {"name": "list.mem_of_mem_last'", "description": ""}, {"name": "list.cons_ne_nil", "description": ""}, {"name": "list.sublist_append_right", "description": ""}, {"name": "list.nthd_cons_succ", "description": ""}, {"name": "list.diff_nil", "description": ""}, {"name": "list.map\u2082_right_nil_right", "description": ""}, {"name": "list.foldr_join", "description": ""}, {"name": "list.foldl_map", "description": ""}, {"name": "list.to_chunks_eq_cons'", "description": ""}, {"name": "list.bind_singleton'", "description": ""}, {"name": "list.update_nth_succ", "description": ""}, {"name": "list.nth_le_of_mem", "description": ""}, {"name": "list.nth_le_update_nth_eq", "description": ""}, {"name": "list.append_inj", "description": ""}, {"name": "list.insert_nth_succ_nil", "description": ""}, {"name": "list.tail_cons", "description": ""}, {"name": "list.nth_le_enum", "description": ""}, {"name": "list.not_mem_append", "description": ""}, {"name": "list.mfoldl_eq_foldl", "description": ""}, {"name": "list.length_eq_two", "description": ""}, {"name": "list.cons_head_tail", "description": ""}, {"name": "list.split_on_p_aux_ne_nil", "description": ""}, {"name": "list.update_nth_eq_modify_nth", "description": ""}, {"name": "list.last'_cons_cons", "description": ""}, {"name": "list.length_scanl", "description": ""}, {"name": "list.last_repeat_succ", "description": ""}, {"name": "list.foldl_rec_on", "description": " Induction principle for values produced by a `foldl`: if a property holds\nfor the seed element `b : \u03b2` and for all incremental `op : \u03b2 \u2192 \u03b1 \u2192 \u03b2`\nperformed on the elements `(a : \u03b1) \u2208 l`. The principle is given for\na `Sort`-valued predicate, i.e., it can also be used to construct data."}, {"name": "list.map_subset", "description": ""}, {"name": "list.erasep_append_left", "description": ""}, {"name": "list.map_fst_add_enum_from_eq_enum_from", "description": ""}, {"name": "list.length_pmap", "description": ""}, {"name": "list.ne_nil_of_length_pos", "description": ""}, {"name": "list.foldl_combinator_K", "description": ""}, {"name": "list.eq_repeat_of_mem", "description": ""}, {"name": "list.exists_cons_of_ne_nil", "description": ""}, {"name": "list.tail_eq_of_cons_eq", "description": ""}, {"name": "list.find_eq_none", "description": ""}, {"name": "list.take_append_of_le_length", "description": ""}, {"name": "list.lookmap_cons_none", "description": ""}, {"name": "list.map_take", "description": ""}, {"name": "list.inth_append", "description": ""}, {"name": "list.find_cons_of_neg", "description": ""}, {"name": "list.of_mem_filter", "description": ""}, {"name": "list.inj_on_insert_nth_index_of_not_mem", "description": ""}, {"name": "list.eq_of_mem_map_const", "description": ""}, {"name": "list.diff_cons", "description": ""}, {"name": "list.sublist.filter", "description": ""}, {"name": "list.reduce_option_cons_of_none", "description": ""}, {"name": "list.sizeof_lt_sizeof_of_mem", "description": ""}, {"name": "list.map_congr", "description": ""}, {"name": "list.reverse_foldl", "description": ""}, {"name": "list.mem_split", "description": ""}, {"name": "list.extractp_eq_find_erasep", "description": ""}, {"name": "list.length_pos_iff_ne_nil", "description": ""}, {"name": "list.take'_length", "description": ""}, {"name": "list.split_on_p_spec", "description": " The original list `L` can be recovered by joining the lists produced by `split_on_p p L`,\ninterspersed with the elements `L.filter p`."}, {"name": "list.append_eq_append_iff", "description": ""}, {"name": "list.length_erase_add_one", "description": ""}, {"name": "list.foldl_op_eq_op_foldr_assoc", "description": ""}, {"name": "function.involutive.exists_mem_and_apply_eq_iff", "description": ""}, {"name": "list.foldr_nil", "description": ""}, {"name": "list.filter_false", "description": ""}, {"name": "list.sublist.map", "description": ""}, {"name": "list.nthd_eq_get_or_else_nth", "description": ""}, {"name": "list.map_eq_map", "description": ""}, {"name": "list.to_chunks_length_le", "description": ""}, {"name": "list.drop_sizeof_le", "description": ""}, {"name": "list.mem_iff_nth", "description": ""}, {"name": "list.nth_le_drop", "description": " The `i + j`-th element of a list coincides with the `j`-th element of the list obtained by\ndropping the first `i` elements. Version designed to rewrite from the big list to the small list."}, {"name": "list.length_eq_one", "description": ""}, {"name": "list.nth_le_insert_nth_add_succ", "description": ""}, {"name": "list.mfoldr_eq_foldr", "description": ""}, {"name": "list.take_while_eq_self_iff", "description": ""}, {"name": "list.foldr_append", "description": ""}, {"name": "list.take_append_eq_append_take", "description": " Taking the first `n` elements in `l\u2081 ++ l\u2082` is the same as appending the first `n` elements\nof `l\u2081` to the first `n - l\u2081.length` elements of `l\u2082`."}, {"name": "list.filter_map_eq_map", "description": ""}, {"name": "list.reverse_core_eq", "description": ""}, {"name": "list.last'_append_of_ne_nil", "description": ""}, {"name": "list.singleton_eq", "description": ""}, {"name": "list.to_chunks_nil", "description": ""}, {"name": "list.append_right_cancel", "description": ""}, {"name": "list.map_eq_map_iff", "description": ""}, {"name": "list.concat_eq_append", "description": ""}, {"name": "list.nil.is_left_id", "description": ""}, {"name": "list.reverse_nil", "description": ""}, {"name": "list.monotone_filter_right", "description": ""}, {"name": "list.length_insert_nth_le_succ", "description": ""}, {"name": "list.update_nth_comm", "description": ""}, {"name": "list.tail_nil", "description": ""}, {"name": "list.take_repeat", "description": ""}, {"name": "list.nth_eq_some", "description": ""}, {"name": "list.mem_join", "description": ""}, {"name": "list.mem_pure", "description": ""}, {"name": "list.eq_of_mem_repeat", "description": ""}, {"name": "list.last_append", "description": ""}, {"name": "list.last'_append_cons", "description": ""}, {"name": "list.zip_right_nil_left", "description": ""}, {"name": "list.nth_le_pmap", "description": ""}, {"name": "list.diff_erase", "description": ""}, {"name": "list.inth_eq_default", "description": ""}, {"name": "list.filter_map_eq_filter", "description": ""}, {"name": "equiv.psigma_equiv_sigma_plift", "description": "A `psigma`-type is equivalent to the corresponding `sigma`-type."}, {"name": "equiv.prod_comm", "description": " Type product is commutative up to an equivalence: `\u03b1 \u00d7 \u03b2 \u2243 \u03b2 \u00d7 \u03b1`. This is `prod.swap` as an\nequivalence."}, {"name": "equiv.perm.subtype_congr.apply", "description": ""}, {"name": "function.injective.map_swap", "description": ""}, {"name": "equiv.symm_apply_eq", "description": ""}, {"name": "equiv.symm_trans_self", "description": ""}, {"name": "equiv.comp_bijective", "description": ""}, {"name": "equiv.psigma_equiv_sigma", "description": "A `psigma`-type is equivalent to the corresponding `sigma`-type."}, {"name": "equiv.sum_congr_refl", "description": ""}, {"name": "equiv.cast_apply", "description": ""}, {"name": "equiv.Pi_comm", "description": " Given `\u03c6 : \u03b1 \u2192 \u03b2 \u2192 Sort*`, we have an equivalence between `\u03a0 a b, \u03c6 a b` and `\u03a0 b a, \u03c6 a b`.\nThis is `function.swap` as an `equiv`."}, {"name": "equiv.conj", "description": "Conjugate a map `f : \u03b1 \u2192 \u03b1` by an equivalence `\u03b1 \u2243 \u03b2`."}, {"name": "equiv.punit_arrow_equiv", "description": "The sort of maps from `punit` is equivalent to the codomain."}, {"name": "equiv.sigma_subtype_equiv_of_subset", "description": " A sigma type over a subtype is equivalent to the sigma set over the original type,\nif the fiber is empty outside of the subset"}, {"name": "equiv.equiv_congr", "description": " If `\u03b1` is equivalent to `\u03b2` and `\u03b3` is equivalent to `\u03b4`, then the type of equivalences `\u03b1 \u2243 \u03b3`\nis equivalent to the type of equivalences `\u03b2 \u2243 \u03b4`."}, {"name": "equiv.sum_empty", "description": "Sum with `empty` is equivalent to the original type."}, {"name": "equiv.perm.sigma_congr_right_refl", "description": ""}, {"name": "equiv.forall_congr_left'", "description": ""}, {"name": "equiv.to_fun_as_coe", "description": ""}, {"name": "function.involutive.to_perm", "description": "Convert an involutive function `f` to a permutation with `to_fun = inv_fun = f`."}, {"name": "equiv.psum_equiv_sum", "description": "`psum` is equivalent to `sum`."}, {"name": "equiv.subtype_equiv_codomain_apply", "description": ""}, {"name": "equiv.perm.prod_extend_right", "description": " `prod_extend_right a e` extends `e : perm \u03b2` to `perm (\u03b1 \u00d7 \u03b2)` by sending `(a, b)` to\n`(a, e b)` and keeping the other `(a', b)` fixed."}, {"name": "equiv.subtype_equiv_symm", "description": ""}, {"name": "equiv.subtype_equiv_codomain_symm_apply", "description": ""}, {"name": "equiv.pi_equiv_pi_subtype_prod", "description": " The type `\u03a0 (i : \u03b1), \u03b2 i` can be split as a product by separating the indices in `\u03b1`\ndepending on whether they satisfy a predicate `p` or not."}, {"name": "equiv.subtype_equiv_of_subtype", "description": " If `\u03b1 \u2243 \u03b2`, then for any predicate `p : \u03b2 \u2192 Prop` the subtype `{a // p (e a)}` is equivalent\nto the subtype `{b // p b}`."}, {"name": "equiv.Pi_comm_apply", "description": ""}, {"name": "equiv.forall_congr'", "description": ""}, {"name": "equiv.curry_symm_apply", "description": ""}, {"name": "equiv.subtype_subtype_equiv_subtype_symm_apply_coe_coe", "description": ""}, {"name": "equiv.sigma_option_equiv_of_some", "description": " A sigma type over an `option` is equivalent to the sigma set over the original type,\nif the fiber is empty at none."}, {"name": "equiv.cast_eq_iff_heq", "description": ""}, {"name": "equiv.of_fiber_equiv_symm_apply", "description": ""}, {"name": "equiv.sum_prod_distrib_apply_right", "description": ""}, {"name": "equiv.exists_congr_left", "description": ""}, {"name": "equiv.coe_subtype_equiv_codomain_symm", "description": ""}, {"name": "equiv.prod_congr_left_trans_prod_comm", "description": ""}, {"name": "equiv.prod_unique", "description": "Any `unique` type is a right identity for type product up to equivalence."}, {"name": "equiv.self_trans_symm", "description": ""}, {"name": "equiv.bool_prod_equiv_sum_symm_apply", "description": ""}, {"name": "equiv.sum_compl_apply_symm_of_pos", "description": ""}, {"name": "function.update_apply_equiv_apply", "description": ""}, {"name": "equiv.congr_fun", "description": ""}, {"name": "equiv.sigma_assoc", "description": "Dependent product of types is associative up to an equivalence."}, {"name": "equiv.subtype_equiv_codomain_symm_apply_ne", "description": ""}, {"name": "function.involutive.to_perm_involutive", "description": ""}, {"name": "equiv.simps.symm_apply", "description": "See Note [custom simps projection]"}, {"name": "equiv.arrow_congr_apply", "description": ""}, {"name": "equiv.prod_empty", "description": "`empty` type is a right absorbing element for type product up to an equivalence."}, {"name": "equiv.arrow_congr'_refl", "description": ""}, {"name": "equiv.prop_equiv_pempty", "description": "The `Sort` of proofs of a false proposition is equivalent to `pempty`."}, {"name": "equiv.swap_apply_self", "description": ""}, {"name": "equiv.conj_symm", "description": ""}, {"name": "equiv.perm.sum_congr_refl", "description": ""}, {"name": "equiv.perm", "description": "`perm \u03b1` is the type of bijections from `\u03b1` to itself."}, {"name": "equiv.equiv_of_is_empty", "description": "Two empty types are equivalent."}, {"name": "equiv.perm.extend_domain_trans", "description": ""}, {"name": "equiv.sigma_equiv_prod", "description": "`sigma` type with a constant fiber is equivalent to the product."}, {"name": "equiv.sigma_congr_right_sigma_equiv_prod", "description": ""}, {"name": "equiv.has_coe_t", "description": ""}, {"name": "equiv.subtype_subtype_equiv_subtype_apply_coe", "description": ""}, {"name": "equiv.subtype_equiv_of_subtype'", "description": " If `\u03b1 \u2243 \u03b2`, then for any predicate `p : \u03b1 \u2192 Prop` the subtype `{a // p a}` is equivalent\nto the subtype `{b // p (e.symm b)}`. This version is used by `equiv_rw`."}, {"name": "equiv.inhabited'", "description": ""}, {"name": "equiv.fun_unique", "description": "If `\u03b1` has a unique term, then the type of function `\u03b1 \u2192 \u03b2` is equivalent to `\u03b2`."}, {"name": "equiv.sum_assoc_apply_inl_inr", "description": ""}, {"name": "equiv.swap_apply_eq_iff", "description": ""}, {"name": "equiv.arrow_prod_equiv_prod_arrow", "description": " The type of functions to a product `\u03b1 \u00d7 \u03b2` is equivalent to the type of pairs of functions\n`\u03b3 \u2192 \u03b1` and `\u03b3 \u2192 \u03b2`."}, {"name": "equiv.subtype_equiv_right_symm_apply_coe", "description": ""}, {"name": "equiv.comp_surjective", "description": ""}, {"name": "equiv.sum_compl_apply_inl", "description": ""}, {"name": "equiv.prod_congr", "description": " Product of two equivalences. If `\u03b1\u2081 \u2243 \u03b1\u2082` and `\u03b2\u2081 \u2243 \u03b2\u2082`, then `\u03b1\u2081 \u00d7 \u03b2\u2081 \u2243 \u03b1\u2082 \u00d7 \u03b2\u2082`. This is\n`prod.map` as an equivalence."}, {"name": "equiv.equiv_congr_trans", "description": ""}, {"name": "equiv.subtype_univ_equiv", "description": " If a proposition holds for all elements, then the subtype is\nequivalent to the original type."}, {"name": "quot.congr_right", "description": " Quotients are congruent on equivalences under equality of their relation.\nAn alternative is just to use rewriting with `eq`, but then computational proofs get stuck."}, {"name": "equiv.symm_symm", "description": ""}, {"name": "equiv.equiv_subsingleton_dom", "description": ""}, {"name": "equiv.of_fiber_equiv_apply", "description": ""}, {"name": "equiv.left_inverse_symm", "description": ""}, {"name": "equiv.coe_subtype_equiv_codomain", "description": ""}, {"name": "equiv.apply_eq_iff_eq_symm_apply", "description": ""}, {"name": "equiv.pprod_equiv_prod_plift_symm_apply", "description": ""}, {"name": "equiv.forall_congr_left", "description": ""}, {"name": "equiv.plift_apply", "description": ""}, {"name": "equiv.curry", "description": "Functions on `\u03b1 \u00d7 \u03b2` are equivalent to functions `\u03b1 \u2192 \u03b2 \u2192 \u03b3`."}, {"name": "equiv.subtype_univ_equiv_symm_apply", "description": ""}, {"name": "equiv.subsingleton_congr", "description": ""}, {"name": "equiv.eq_comp_symm", "description": ""}, {"name": "equiv.sum_arrow_equiv_prod_arrow_symm_apply_inl", "description": ""}, {"name": "equiv.surjective", "description": ""}, {"name": "equiv.subtype_equiv_codomain_symm_apply_eq", "description": ""}, {"name": "equiv.bool_prod_equiv_sum", "description": "The product `bool \u00d7 \u03b1` is equivalent to `\u03b1 \u2295 \u03b1`."}, {"name": "equiv.prod_congr_refl_left", "description": ""}, {"name": "quot.congr_mk", "description": ""}, {"name": "equiv.apply_eq_iff_eq", "description": ""}, {"name": "equiv.punit_prod", "description": "`punit` is a left identity for type product up to an equivalence."}, {"name": "equiv.symm_trans_apply", "description": ""}, {"name": "equiv.semiconj_conj", "description": ""}, {"name": "equiv.pi_option_equiv_prod_apply", "description": ""}, {"name": "equiv.prod_sum_distrib_symm_apply_left", "description": ""}, {"name": "equiv.prod_congr_right_trans_prod_comm", "description": ""}, {"name": "equiv.prod_punit", "description": "`punit` is a right identity for type product up to an equivalence."}, {"name": "function.Pi_congr_left'_symm_update", "description": ""}, {"name": "equiv.prod_shear_symm_apply", "description": ""}, {"name": "equiv.subtype_equiv_trans", "description": ""}, {"name": "equiv.sigma_subtype_fiber_equiv_subtype", "description": " If for each `x` we have `p x \u2194 q (f x)`, then `\u03a3 y : {y // q y}, f \u207b\u00b9' {y}` is equivalent\nto `{x // p x}`."}, {"name": "function.Pi_congr_left'_update", "description": ""}, {"name": "equiv.arrow_congr.is_right_cancel", "description": ""}, {"name": "equiv.cast_symm", "description": ""}, {"name": "equiv.equiv_congr_apply_apply", "description": ""}, {"name": "equiv.coe_fn_mk", "description": ""}, {"name": "equiv.of_bijective_symm_apply_apply", "description": ""}, {"name": "equiv.option_equiv_sum_punit_some", "description": ""}, {"name": "equiv.sigma_prod_distrib", "description": " The product of an indexed sum of types (formally, a `sigma`-type `\u03a3 i, \u03b1 i`) by a type `\u03b2` is\nequivalent to the sum of products `\u03a3 i, (\u03b1 i \u00d7 \u03b2)`."}, {"name": "equiv.sigma_congr_right_refl", "description": ""}, {"name": "equiv.perm.sum_congr_apply", "description": ""}, {"name": "equiv.swap_apply_right", "description": ""}, {"name": "equiv.sum_prod_distrib_symm_apply_left", "description": ""}, {"name": "equiv.subtype_preimage_symm_apply_coe_neg", "description": ""}, {"name": "equiv.prod_pprod", "description": "Combine two equivalences using `pprod` in the codomain and `prod` in the domain."}, {"name": "equiv.nonempty", "description": ""}, {"name": "equiv.subtype_quotient_equiv_quotient_subtype_mk", "description": ""}, {"name": "equiv.perm.subtype_congr.left_apply", "description": ""}, {"name": "equiv.sigma_congr_right_symm", "description": ""}, {"name": "equiv.sum_empty_apply_inl", "description": ""}, {"name": "equiv.Pi_congr_left", "description": "Transporting dependent functions through an equivalence of the base,\nexpressed as a \"simplification\"."}, {"name": "equiv.sigma_sum_distrib_apply", "description": ""}, {"name": "equiv.of_iff", "description": "equivalence of propositions is the same as iff"}, {"name": "equiv.sum_arrow_equiv_prod_arrow_apply_snd", "description": ""}, {"name": "equiv.subtype_subtype_equiv_subtype_inter", "description": "A subtype of a subtype is equivalent to the subtype of elements satisfying both predicates."}, {"name": "equiv.coe_Pi_congr'", "description": ""}, {"name": "equiv.swap_self", "description": ""}, {"name": "quotient.congr_mk", "description": ""}, {"name": "equiv.is_empty", "description": ""}, {"name": "equiv.prod_punit_apply", "description": ""}, {"name": "equiv.fun_unique_symm_apply", "description": ""}, {"name": "equiv.sigma_congr_right_apply", "description": ""}, {"name": "equiv.self_comp_symm", "description": ""}, {"name": "equiv.forall\u2083_congr'", "description": ""}, {"name": "equiv.arrow_congr_symm", "description": ""}, {"name": "equiv.subtype_preimage_symm_apply_coe", "description": ""}, {"name": "equiv.perm.sum_congr_trans", "description": ""}, {"name": "equiv.sum_assoc_apply_inr", "description": ""}, {"name": "equiv.pi_equiv_pi_subtype_prod_symm_apply", "description": ""}, {"name": "equiv.bool_arrow_equiv_prod", "description": "The function type `bool \u2192 \u03b1` is equivalent to `\u03b1 \u00d7 \u03b1`."}, {"name": "equiv.swap_apply_left", "description": ""}, {"name": "equiv.perm.extend_domain_refl", "description": ""}, {"name": "equiv.perm_congr_symm_apply", "description": ""}, {"name": "equiv.pprod_prod_apply", "description": ""}, {"name": "equiv.prop_equiv_punit", "description": "The `Sort` of proofs of a true proposition is equivalent to `punit`."}, {"name": "equiv.prod_congr_left", "description": " A family of equivalences `\u03a0 (a : \u03b1\u2081), \u03b2\u2081 \u2243 \u03b2\u2082` generates an equivalence\nbetween `\u03b2\u2081 \u00d7 \u03b1\u2081` and `\u03b2\u2082 \u00d7 \u03b1\u2081`."}, {"name": "equiv.subtype_equiv_prop", "description": "If two predicates are equal, then the corresponding subtypes are equivalent."}, {"name": "equiv.sigma_congr_left_apply", "description": ""}, {"name": "equiv.fun_unique_apply", "description": ""}, {"name": "function.involutive.coe_to_perm", "description": ""}, {"name": "equiv.perm.subtype_congr.symm", "description": ""}, {"name": "equiv.sum_assoc_symm_apply_inr_inr", "description": ""}, {"name": "equiv.of_bijective", "description": "If `f` is a bijective function, then its domain is equivalent to its codomain."}, {"name": "equiv.eq_symm_comp", "description": ""}, {"name": "equiv.prod_assoc_symm_apply", "description": ""}, {"name": "function.involutive.to_perm_symm", "description": ""}, {"name": "equiv.of_fiber_equiv_map", "description": ""}, {"name": "equiv.psigma_congr_right_trans", "description": ""}, {"name": "equiv.perm.sigma_congr_right", "description": "A family of permutations `\u03a0 a, perm (\u03b2 a)` generates a permuation `perm (\u03a3 a, \u03b2\u2081 a)`."}, {"name": "equiv.symm_symm_apply", "description": ""}, {"name": "equiv.arrow_congr'", "description": "A version of `equiv.arrow_congr` in `Type`, rather than `Sort`.\n\nThe `equiv_rw` tactic is not able to use the default `Sort` level `equiv.arrow_congr`,\nbecause Lean's universe rules will not unify `?l_1` with `imax (1 ?m_1)`."}, {"name": "equiv.comp_injective", "description": ""}, {"name": "equiv.equiv_punit", "description": "If `\u03b1` has a unique element, then it is equivalent to any `punit`."}, {"name": "equiv.psigma_congr_right_refl", "description": ""}, {"name": "equiv.coe_fn_symm_mk", "description": ""}, {"name": "equiv.prod_sum_distrib_symm_apply_right", "description": ""}, {"name": "equiv.perm.sum_congr_swap_refl", "description": ""}, {"name": "equiv.comp_symm_eq", "description": ""}, {"name": "equiv.sum_congr_symm", "description": ""}, {"name": "equiv.perm.subtype_congr.refl", "description": ""}, {"name": "equiv.perm.subtype_congr", "description": " Combining permutations on `\u03b5` that permute only inside or outside the subtype\nsplit induced by `p : \u03b5 \u2192 Prop` constructs a permutation on `\u03b5`."}, {"name": "equiv.prod_congr_symm", "description": ""}, {"name": "equiv.sum_arrow_equiv_prod_arrow", "description": " The type of functions on a sum type `\u03b1 \u2295 \u03b2` is equivalent to the type of pairs of functions\non `\u03b1` and on `\u03b2`."}, {"name": "equiv.equiv_of_unique", "description": "If both `\u03b1` and `\u03b2` have a unique element, then `\u03b1 \u2243 \u03b2`."}, {"name": "equiv.sum_equiv_sigma_bool", "description": " `\u03b1 \u2295 \u03b2` is equivalent to a `sigma`-type over `bool`. Note that this definition assumes `\u03b1` and\n`\u03b2` to be types from the same universe, so it cannot by used directly to transfer theorems about\nsigma types to theorems about sum types. In many cases one can use `ulift` to work around this\ndifficulty."}, {"name": "equiv.sigma_sum_distrib", "description": "An indexed sum of disjoint sums of types is equivalent to the sum of the indexed sums."}, {"name": "equiv.subtype_equiv_codomain", "description": " The type of all functions `X \u2192 Y` with prescribed values for all `x' \u2260 x`\nis equivalent to the codomain `Y`."}, {"name": "equiv.psigma_congr_right_apply", "description": ""}, {"name": "equiv.is_empty_congr", "description": "If `\u03b1` is equivalent to `\u03b2`, then `is_empty \u03b1` is equivalent to `is_empty \u03b2`."}, {"name": "equiv.psigma_equiv_sigma_symm_apply", "description": ""}, {"name": "equiv.option_equiv_sum_punit_none", "description": ""}, {"name": "equiv.Prop_equiv_bool", "description": "`Prop` is noncomputably equivalent to `bool`."}, {"name": "equiv.perm.sum_congr", "description": "Combine a permutation of `\u03b1` and of `\u03b2` into a permutation of `\u03b1 \u2295 \u03b2`."}, {"name": "equiv.swap_core", "description": "A helper function for `equiv.swap`."}, {"name": "equiv.empty_sum_apply_inr", "description": ""}, {"name": "equiv.semiconj\u2082_conj", "description": ""}, {"name": "equiv.perm.prod_extend_right_apply_eq", "description": ""}, {"name": "equiv.prod_congr_right", "description": " A family of equivalences `\u03a0 (a : \u03b1\u2081), \u03b2\u2081 \u2243 \u03b2\u2082` generates an equivalence\nbetween `\u03b1\u2081 \u00d7 \u03b2\u2081` and `\u03b1\u2081 \u00d7 \u03b2\u2082`."}, {"name": "equiv.apply_swap_eq_self", "description": "A function is invariant to a swap if it is equal at both elements"}, {"name": "equiv.psigma_equiv_subtype", "description": "A `psigma` with `Prop` fibers is equivalent to the subtype."}, {"name": "equiv.pprod_equiv_prod_plift", "description": "`pprod \u03b1 \u03b2` is equivalent to `plift \u03b1 \u00d7 plift \u03b2`"}, {"name": "equiv.empty_sum", "description": "The sum of `empty` with any `Sort*` is equivalent to the right summand."}, {"name": "equiv.conj_trans", "description": ""}, {"name": "plift.eq_up_iff_down_eq", "description": ""}, {"name": "equiv.perm.subtype_congr.right_apply", "description": ""}, {"name": "equiv.equiv_congr_refl_right", "description": ""}, {"name": "equiv.pempty_prod", "description": "`pempty` type is a left absorbing element for type product up to an equivalence."}, {"name": "equiv.subtype_preimage_apply", "description": ""}, {"name": "equiv.sum_congr_apply", "description": ""}, {"name": "equiv.arrow_congr.is_left_cancel", "description": ""}, {"name": "equiv.exists_unique_congr_left'", "description": ""}, {"name": "equiv.perm.congr_fun", "description": ""}, {"name": "equiv.congr_arg", "description": ""}, {"name": "equiv.symm_apply_apply", "description": ""}, {"name": "equiv.symm_trans_swap_trans", "description": ""}, {"name": "equiv.arrow_congr_trans", "description": ""}, {"name": "equiv.prod_shear_apply", "description": ""}, {"name": "equiv.forall_congr", "description": ""}, {"name": "equiv.sum_compl_apply_symm_of_neg", "description": ""}, {"name": "equiv.perm.extend_domain_apply_not_subtype", "description": ""}, {"name": "equiv.arrow_congr'_apply", "description": ""}, {"name": "equiv.subsingleton.symm", "description": ""}, {"name": "equiv.equiv_pempty", "description": "If `\u03b1` is an empty type, then it is equivalent to the `pempty` type in any universe."}, {"name": "equiv.perm_congr_symm", "description": ""}, {"name": "equiv.bool_prod_equiv_sum_apply", "description": ""}, {"name": "equiv.plift", "description": "`plift \u03b1` is equivalent to `\u03b1`."}, {"name": "equiv.sigma_congr_right", "description": " A family of equivalences `\u03a0 a, \u03b2\u2081 a \u2243 \u03b2\u2082 a` generates an equivalence between `\u03a3 a, \u03b2\u2081 a` and\n`\u03a3 a, \u03b2\u2082 a`."}, {"name": "quotient.congr", "description": " An equivalence `e : \u03b1 \u2243 \u03b2` generates an equivalence between quotient spaces,\nif `ra a\u2081 a\u2082 \u2194 rb (e a\u2081) (e a\u2082)."}, {"name": "equiv.sum_comm_apply", "description": ""}, {"name": "equiv.injective", "description": ""}, {"name": "equiv.psigma_equiv_sigma_plift_apply", "description": ""}, {"name": "equiv.nat_equiv_nat_sum_punit", "description": "The set of natural numbers is equivalent to `\u2115 \u2295 punit`."}, {"name": "equiv.forall\u2083_congr", "description": ""}, {"name": "equiv.cast_refl", "description": ""}, {"name": "equiv.prod_congr_refl_right", "description": ""}, {"name": "equiv.subsingleton", "description": ""}, {"name": "equiv.Pi_comm_symm", "description": ""}, {"name": "equiv.prod_comm_symm", "description": ""}, {"name": "equiv.pprod_equiv_prod_symm_apply", "description": ""}, {"name": "equiv.sum_psum", "description": "Combine two `equiv`s using `sum` in the domain and `psum` in the codomain."}, {"name": "equiv.psigma_equiv_sigma_apply", "description": ""}, {"name": "equiv_of_subsingleton_of_subsingleton", "description": "To give an equivalence between two subsingleton types, it is sufficient to give any two\n   functions between them."}, {"name": "equiv.refl_trans", "description": ""}, {"name": "equiv.equiv_congr_refl_left", "description": ""}, {"name": "equiv.Pi_congr'_apply", "description": ""}, {"name": "equiv.sum_comm_symm", "description": ""}, {"name": "equiv.prod_shear", "description": "A variation on `equiv.prod_congr` where the equivalence in the second component can depend\n on the first component. A typical example is a shear mapping, explaining the name of this\n declaration."}, {"name": "equiv.swap_apply_of_ne_of_ne", "description": ""}, {"name": "equiv.trans_apply", "description": ""}, {"name": "equiv.sigma_plift_equiv_subtype", "description": "A `sigma` with `plift` fibers is equivalent to the subtype."}, {"name": "equiv.of_bijective_apply_symm_apply", "description": ""}, {"name": "equiv.swap_eq_update", "description": ""}, {"name": "equiv.subtype_subtype_equiv_subtype", "description": " If the outer subtype has more restrictive predicate than the inner one,\nthen we can drop the latter."}, {"name": "equiv.prod_assoc", "description": "Type product is associative up to an equivalence."}, {"name": "equiv.option_equiv_sum_punit_symm_inl", "description": ""}, {"name": "equiv.subtype_subtype_equiv_subtype_inter_apply_coe", "description": ""}, {"name": "equiv.prod_congr_right_apply", "description": ""}, {"name": "equiv.forall\u2082_congr'", "description": ""}, {"name": "equiv.arrow_congr.is_idempotent", "description": ""}, {"name": "function.update_comp_equiv", "description": ""}, {"name": "equiv.equiv_congr_refl", "description": ""}, {"name": "equiv.plift_symm_apply", "description": ""}, {"name": "equiv.equiv_empty_equiv", "description": "`\u03b1` is equivalent to an empty type iff `\u03b1` is empty."}, {"name": "equiv.sum_compl", "description": " For any predicate `p` on `\u03b1`,\nthe sum of the two subtypes `{a // p a}` and its complement `{a // \u00ac p a}`\nis naturally equivalent to `\u03b1`.\n\nSee `subtype_or_equiv` for sum types over subtypes `{x // p x}` and `{x // q x}`\nthat are not necessarily `is_compl p q`."}, {"name": "equiv.prod_pprod_symm_apply", "description": ""}, {"name": "equiv.pi_equiv_pi_subtype_prod_apply", "description": ""}, {"name": "equiv.pprod_equiv_prod_plift_apply", "description": ""}, {"name": "equiv.apply_symm_apply", "description": ""}, {"name": "equiv.pprod_equiv_prod_apply", "description": ""}, {"name": "equiv.option_equiv_sum_punit_coe", "description": ""}, {"name": "unique_unique_equiv", "description": "`unique (unique \u03b1)` is equivalent to `unique \u03b1`."}, {"name": "equiv.cast", "description": "Equivalence between equal types."}, {"name": "equiv.pprod_prod_symm_apply", "description": ""}, {"name": "equiv.bool_equiv_punit_sum_punit", "description": "`bool` is equivalent the sum of two `punit`s."}, {"name": "equiv.set_value_eq", "description": ""}, {"name": "equiv.swap_eq_refl_iff", "description": ""}, {"name": "equiv.exists_unique_congr_left", "description": ""}, {"name": "equiv.perm.subtype_congr.trans", "description": ""}, {"name": "equiv.subtype_equiv_refl", "description": ""}, {"name": "equiv.subtype_pi_equiv_pi", "description": " The set of functions `f : \u03a0 a, \u03b2 a` such that for all `a` we have `p a (f a)` is equivalent\nto the set of functions `\u03a0 a, {b : \u03b2 a // p a b}`."}, {"name": "equiv.subtype_equiv_right", "description": " If two predicates `p` and `q` are pointwise equivalent, then `{x // p x}` is equivalent to\n`{x // q x}`."}, {"name": "equiv.perm.ext", "description": ""}, {"name": "equiv.symm", "description": "Inverse of an equivalence `e : \u03b1 \u2243 \u03b2`."}, {"name": "equiv.pprod_equiv_prod", "description": "`pprod \u03b1 \u03b2` is equivalent to `\u03b1 \u00d7 \u03b2`"}, {"name": "equiv.arrow_congr'_symm", "description": ""}, {"name": "equiv.sigma_congr_left'", "description": "Transporting a sigma type through an equivalence of the base"}, {"name": "equiv.option_is_some_equiv_symm_apply_coe", "description": ""}, {"name": "equiv.ulift_symm_apply", "description": ""}, {"name": "equiv.sum_prod_distrib_symm_apply_right", "description": ""}, {"name": "equiv.list_equiv_of_equiv", "description": "An equivalence between `\u03b1` and `\u03b2` generates an equivalence between `list \u03b1` and `list \u03b2`."}, {"name": "equiv.psum_congr", "description": "If `\u03b1 \u2243 \u03b1'` and `\u03b2 \u2243 \u03b2'`, then `psum \u03b1 \u03b2 \u2243 psum \u03b1' \u03b2'`."}, {"name": "equiv.perm.extend_domain_symm", "description": ""}, {"name": "equiv.sigma_fiber_equiv_apply", "description": ""}, {"name": "equiv.punit_equiv_punit", "description": "`punit` sorts in any two universes are equivalent."}, {"name": "equiv.perm.extend_domain_apply_image", "description": ""}, {"name": "equiv.sum_empty_symm_apply", "description": ""}, {"name": "equiv.option_equiv_sum_punit_symm_inr", "description": ""}, {"name": "equiv.nonempty_congr", "description": ""}, {"name": "equiv.unique_prod", "description": "Any `unique` type is a left identity for type product up to equivalence."}, {"name": "equiv.subtype_equiv_right_apply_coe", "description": ""}, {"name": "equiv.perm_congr_trans", "description": ""}, {"name": "equiv.perm_congr_def", "description": ""}, {"name": "equiv.psigma_equiv_sigma_plift_symm_apply", "description": ""}, {"name": "equiv.perm.extend_domain", "description": "Extend the domain of `e : equiv.perm \u03b1` to one that is over `\u03b2` via `f : \u03b1 \u2192 subtype p`,\nwhere `p : \u03b2 \u2192 Prop`, permuting only the `b : \u03b2` that satisfy `p b`.\nThis can be used to extend the domain across a function `f : \u03b1 \u2192 \u03b2`,\nkeeping everything outside of `set.range f` fixed. For this use-case `equiv` given by `f` can\nbe constructed by `equiv.of_left_inverse'` or `equiv.of_left_inverse` when there is a known\ninverse, or `equiv.of_injective` in the general case.`."}, {"name": "equiv.subtype_quotient_equiv_quotient_subtype", "description": " Subtype of the quotient is equivalent to the quotient of the subtype. Let `\u03b1` be a setoid with\nequivalence relation `~`. Let `p\u2082` be a predicate on the quotient type `\u03b1/~`, and `p\u2081` be the lift\nof this predicate to `\u03b1`: `p\u2081 a \u2194 p\u2082 \u27e6a\u27e7`. Let `~\u2082` be the restriction of `~` to `{x // p\u2081 x}`.\nThen `{x // p\u2082 x}` is equivalent to the quotient of `{x // p\u2081 x}` by `~\u2082`."}, {"name": "equiv.perm_congr_apply", "description": ""}, {"name": "equiv.decidable_eq", "description": "Transfer `decidable_eq` across an equivalence."}, {"name": "equiv.bool_arrow_equiv_prod_apply", "description": ""}, {"name": "equiv.bijective", "description": ""}, {"name": "equiv.swap_core_self", "description": ""}, {"name": "equiv.sum_congr_trans", "description": ""}, {"name": "quot.congr", "description": " An equivalence `e : \u03b1 \u2243 \u03b2` generates an equivalence between quotient spaces,\nif `ra a\u2081 a\u2082 \u2194 rb (e a\u2081) (e a\u2082)."}, {"name": "equiv.ext_iff", "description": ""}, {"name": "equiv.Pi_subsingleton", "description": " If `\u03b1` is `subsingleton` and `a : \u03b1`, then the type of dependent functions `\u03a0 (i : \u03b1), \u03b2\ni` is equivalent to `\u03b2 i`."}, {"name": "equiv.subtype_subtype_equiv_subtype_exists", "description": " A subtype of a subtype is equivalent to the subtype of elements satisfying both predicates. This\nversion allows the \u201cinner\u201d predicate to depend on `h : p a`."}, {"name": "equiv.prod_punit_symm_apply", "description": ""}, {"name": "equiv.arrow_congr.is_associative", "description": ""}, {"name": "equiv.empty_sum_symm_apply", "description": ""}, {"name": "equiv.pi_option_equiv_prod_symm_apply", "description": ""}, {"name": "equiv.prod_comm_apply", "description": ""}, {"name": "equiv.curry_apply", "description": ""}, {"name": "equiv.comp_swap_eq_update", "description": ""}, {"name": "equiv.refl_apply", "description": ""}, {"name": "equiv.arrow_congr", "description": " If `\u03b1\u2081` is equivalent to `\u03b1\u2082` and `\u03b2\u2081` is equivalent to `\u03b2\u2082`, then the type of maps `\u03b1\u2081 \u2192 \u03b2\u2081`\nis equivalent to the type of maps `\u03b1\u2082 \u2192 \u03b2\u2082`."}, {"name": "equiv.pprod_congr", "description": " Product of two equivalences, in terms of `pprod`. If `\u03b1 \u2243 \u03b2` and `\u03b3 \u2243 \u03b4`, then\n`pprod \u03b1 \u03b3 \u2243 pprod \u03b2 \u03b4`."}, {"name": "equiv.equiv_congr_symm", "description": ""}, {"name": "equiv.sigma_ulift_plift_equiv_subtype", "description": "A `sigma` with `\u03bb i, ulift (plift (P i))` fibers is equivalent to `{ x // P x }`.\nVariant of `sigma_plift_equiv_subtype`."}, {"name": "equiv.conj_refl", "description": ""}, {"name": "equiv.prod_congr_apply", "description": ""}, {"name": "equiv.prod_pempty", "description": "`pempty` type is a right absorbing element for type product up to an equivalence."}, {"name": "equiv.nat_sum_punit_equiv_nat", "description": "`\u2115 \u2295 punit` is equivalent to `\u2115`."}, {"name": "equiv.pi_option_equiv_prod", "description": " The product over `option \u03b1` of `\u03b2 a` is the binary product of the\nproduct over `\u03b1` of `\u03b2 (some \u03b1)` and `\u03b2 none`"}, {"name": "equiv.punit_prod_symm_apply", "description": ""}, {"name": "equiv.sigma_equiv_prod_apply", "description": ""}, {"name": "equiv.sigma_nat_succ", "description": "An equivalence that separates out the 0th fiber of `(\u03a3 (n : \u2115), f n)`."}, {"name": "equiv.sum_assoc_symm_apply_inl", "description": ""}, {"name": "equiv.option_is_some_equiv_apply", "description": ""}, {"name": "equiv.perm.fst_prod_extend_right", "description": ""}, {"name": "equiv.forall\u2082_congr", "description": ""}, {"name": "equiv.refl_symm", "description": ""}, {"name": "equiv.perm.extend_domain_apply_subtype", "description": ""}, {"name": "equiv.prod_pprod_apply", "description": ""}, {"name": "equiv.subtype_quotient_equiv_quotient_subtype_symm_mk", "description": ""}, {"name": "equiv.Pi_subsingleton_symm_apply", "description": ""}, {"name": "equiv.perm.subsingleton_eq_refl", "description": ""}, {"name": "equiv.Pi_congr_symm_apply", "description": ""}, {"name": "equiv.Pi_subsingleton_apply", "description": ""}, {"name": "equiv.perm.eq_of_prod_extend_right_ne", "description": ""}, {"name": "equiv.perm.sigma_congr_right_trans", "description": ""}, {"name": "equiv.prod_sum_distrib_apply_right", "description": ""}, {"name": "equiv.false_arrow_equiv_punit", "description": "The sort of maps from `false` is equivalent to `punit`."}, {"name": "equiv.sum_assoc", "description": "Sum of types is associative up to an equivalence."}, {"name": "equiv.arrow_punit_of_is_empty", "description": "The sort of maps from a type that `is_empty` is equivalent to `punit`."}, {"name": "equiv.Pi_congr_left'_apply", "description": ""}, {"name": "equiv.coe_trans", "description": ""}, {"name": "equiv.inhabited", "description": "If `\u03b1 \u2243 \u03b2` and `\u03b2` is inhabited, then so is `\u03b1`."}, {"name": "equiv.unique_congr", "description": "If `\u03b1` is equivalent to `\u03b2`, then `unique \u03b1` is equivalent to `unique \u03b2`."}, {"name": "equiv.psum_sum", "description": "Combine two `equiv`s using `psum` in the domain and `sum` in the codomain."}, {"name": "equiv.perm.prod_extend_right_apply_ne", "description": ""}, {"name": "equiv.sum_compl_apply_inr", "description": ""}, {"name": "equiv.pempty_arrow_equiv_punit", "description": "The sort of maps from `pempty` is equivalent to `punit`."}, {"name": "equiv.pi_equiv_subtype_sigma", "description": " The `pi`-type `\u03a0 i, \u03c0 i` is equivalent to the type of sections `f : \u03b9 \u2192 \u03a3 i, \u03c0 i` of the\n`sigma` type such that for all `i` we have `(f i).fst = i`."}, {"name": "equiv.sum_assoc_apply_inl_inl", "description": ""}, {"name": "equiv.Pi_curry", "description": " Dependent `curry` equivalence: the type of dependent functions on `\u03a3 i, \u03b2 i` is equivalent\nto the type of dependent functions of two arguments (i.e., functions to the space of functions).\n\nThis is `sigma.curry` and `sigma.uncurry` together as an equiv."}, {"name": "equiv.prod_sum_distrib", "description": "Type product is left distributive with respect to type sum up to an equivalence."}, {"name": "equiv.perm_unique", "description": ""}, {"name": "equiv.swap_comp_apply", "description": ""}, {"name": "equiv.subtype_prod_equiv_sigma_subtype", "description": "A subtype of a `prod` is equivalent to a sigma type whose fibers are subtypes."}, {"name": "equiv.arrow_congr'_trans", "description": ""}, {"name": "equiv.symm_comp_self", "description": ""}, {"name": "equiv.sigma_fiber_equiv_symm_apply_snd_coe", "description": ""}, {"name": "equiv.psigma_congr_right_symm", "description": ""}, {"name": "equiv.arrow_punit_equiv_punit", "description": "The sort of maps to `punit.{v}` is equivalent to `punit.{w}`."}, {"name": "equiv.ulift", "description": "`ulift \u03b1` is equivalent to `\u03b1`."}, {"name": "equiv.sum_prod_distrib", "description": "Type product is right distributive with respect to type sum up to an equivalence."}, {"name": "function.injective.swap_apply", "description": ""}, {"name": "equiv.sigma_fiber_equiv_symm_apply_fst", "description": ""}, {"name": "equiv.swap", "description": "`swap a b` is the permutation that swaps `a` and `b` and\n leaves other values as is."}, {"name": "equiv.perm.subtype_congr.left_apply_subtype", "description": ""}, {"name": "subsingleton_prod_self_equiv", "description": "If `\u03b1` is a subsingleton, then it is equivalent to `\u03b1 \u00d7 \u03b1`."}, {"name": "equiv.coe_inj", "description": ""}, {"name": "equiv.sum_congr", "description": "If `\u03b1 \u2243 \u03b1'` and `\u03b2 \u2243 \u03b2'`, then `\u03b1 \u2295 \u03b2 \u2243 \u03b1' \u2295 \u03b2'`. This is `sum.map` as an equivalence."}, {"name": "equiv.surjective_comp", "description": ""}, {"name": "equiv.sum_comm", "description": "Sum of types is commutative up to an equivalence. This is `sum.swap` as an equivalence."}, {"name": "equiv.equiv_empty", "description": "If `\u03b1` is an empty type, then it is equivalent to the `empty` type."}, {"name": "equiv.prod_congr_left_apply", "description": ""}, {"name": "equiv.sigma_sum_distrib_symm_apply", "description": ""}, {"name": "equiv.empty_prod", "description": "`empty` type is a left absorbing element for type product up to an equivalence."}, {"name": "equiv.perm.sum_congr_symm", "description": ""}, {"name": "equiv.Pi_congr_left'", "description": "Transport dependent functions through an equivalence of the base space."}, {"name": "equiv.perm.sum_congr_refl_swap", "description": ""}, {"name": "equiv.injective_comp", "description": ""}, {"name": "equiv.subtype_prod_equiv_prod", "description": " A subtype of a product defined by componentwise conditions\nis equivalent to a product of subtypes."}, {"name": "equiv.Pi_congr'_symm_apply_symm_apply", "description": ""}, {"name": "equiv.trans", "description": "Composition of equivalences `e\u2081 : \u03b1 \u2243 \u03b2` and `e\u2082 : \u03b2 \u2243 \u03b3`."}, {"name": "equiv.coe_fn_injective", "description": "The map `coe_fn : (r \u2243 s) \u2192 (r \u2192 s)` is injective."}, {"name": "quot.congr_left", "description": " An equivalence `e : \u03b1 \u2243 \u03b2` generates an equivalence between the quotient space of `\u03b1`\nby a relation `ra` and the quotient space of `\u03b2` by the image of this relation under `e`."}, {"name": "equiv.option_is_some_equiv", "description": "The set of `x : option \u03b1` such that `is_some x` is equivalent to `\u03b1`."}, {"name": "equiv.subtype_subtype_equiv_subtype_exists_symm_apply_coe_coe", "description": ""}, {"name": "equiv.perm.congr_arg", "description": ""}, {"name": "equiv.punit_of_nonempty_of_subsingleton", "description": "A nonempty subsingleton type is (noncomputably) equivalent to `punit`."}, {"name": "equiv.sum_prod_distrib_apply_left", "description": ""}, {"name": "equiv.subtype_equiv_apply", "description": ""}, {"name": "equiv.option_equiv_sum_punit", "description": "`option \u03b1` is equivalent to `\u03b1 \u2295 punit`"}, {"name": "equiv.subtype_congr", "description": "Combines an `equiv` between two subtypes with an `equiv` between their complements to form a\n permutation."}, {"name": "equiv.sum_arrow_equiv_prod_arrow_symm_apply_inr", "description": ""}, {"name": "equiv.swap_core_comm", "description": ""}, {"name": "equiv.perm_congr_refl", "description": ""}, {"name": "equiv.int_equiv_nat_sum_nat", "description": "The type of integer numbers is equivalent to `\u2115 \u2295 \u2115`."}, {"name": "equiv.perm.subtype_congr.right_apply_subtype", "description": ""}, {"name": "equiv.right_inverse_symm", "description": ""}, {"name": "equiv.symm_swap", "description": ""}, {"name": "equiv.Pi_congr'", "description": "Transport dependent functions through\nan equivalence of the base spaces and a family\nof equivalences of the matching fibres."}, {"name": "equiv.ext", "description": ""}, {"name": "equiv.sigma_congr_left", "description": "An equivalence `f : \u03b1\u2081 \u2243 \u03b1\u2082` generates an equivalence between `\u03a3 a, \u03b2 (f a)` and `\u03a3 a, \u03b2 a`."}, {"name": "equiv.sigma_equiv_prod_symm_apply", "description": ""}, {"name": "equiv.trans_swap_trans_symm", "description": ""}, {"name": "equiv.trans_refl", "description": ""}, {"name": "equiv.refl", "description": "Any type is equivalent to itself."}, {"name": "equiv.of_fiber_equiv", "description": "A family of equivalences between fibers gives an equivalence between domains."}, {"name": "equiv.equiv_subsingleton_cod", "description": ""}, {"name": "equiv.equiv_like", "description": ""}, {"name": "equiv.arrow_congr_comp", "description": ""}, {"name": "equiv.subtype_preimage_symm_apply_coe_pos", "description": ""}, {"name": "equiv.sigma_subtype_fiber_equiv", "description": " If a predicate `p : \u03b2 \u2192 Prop` is true on the range of a map `f : \u03b1 \u2192 \u03b2`, then\n`\u03a3 y : {y // p y}, {x // f x = y}` is equivalent to `\u03b1`."}, {"name": "equiv.ulift_apply", "description": ""}, {"name": "equiv.swap_apply_def", "description": ""}, {"name": "equiv.set_value", "description": "Augment an equivalence with a prescribed mapping `f a = b`"}, {"name": "equiv.sum_arrow_equiv_prod_arrow_apply_fst", "description": ""}, {"name": "equiv.sigma_equiv_prod_of_equiv", "description": " If each fiber of a `sigma` type is equivalent to a fixed type, then the sigma type\nis equivalent to the product."}, {"name": "equiv.subtype_subtype_equiv_subtype_inter_symm_apply_coe_coe", "description": ""}, {"name": "equiv.unique", "description": "If `\u03b1 \u2243 \u03b2` and `\u03b2` is a singleton type, then so is `\u03b1`."}, {"name": "equiv", "description": "`\u03b1 \u2243 \u03b2` is the type of functions from `\u03b1 \u2192 \u03b2` with a two-sided inverse."}, {"name": "equiv.to_fun", "description": "`\u03b1 \u2243 \u03b2` is the type of functions from `\u03b1 \u2192 \u03b2` with a two-sided inverse."}, {"name": "equiv.inv_fun", "description": "`\u03b1 \u2243 \u03b2` is the type of functions from `\u03b1 \u2192 \u03b2` with a two-sided inverse."}, {"name": "equiv.left_inv", "description": "`\u03b1 \u2243 \u03b2` is the type of functions from `\u03b1 \u2192 \u03b2` with a two-sided inverse."}, {"name": "equiv.right_inv", "description": "`\u03b1 \u2243 \u03b2` is the type of functions from `\u03b1 \u2192 \u03b2` with a two-sided inverse."}, {"name": "equiv.subtype_univ_equiv_apply", "description": ""}, {"name": "equiv.psigma_congr_right", "description": " A family of equivalences `\u03a0 a, \u03b2\u2081 a \u2243 \u03b2\u2082 a` generates an equivalence between `\u03a3' a, \u03b2\u2081 a` and\n`\u03a3' a, \u03b2\u2082 a`."}, {"name": "equiv.subtype_sigma_equiv", "description": "A subtype of a sigma-type is a sigma-type over a subtype."}, {"name": "quotient.congr_right", "description": " Quotients are congruent on equivalences under equality of their relation.\nAn alternative is just to use rewriting with `eq`, but then computational proofs get stuck."}, {"name": "equiv.coe_refl", "description": ""}, {"name": "equiv.trans_assoc", "description": ""}, {"name": "equiv.Pi_congr_apply_apply", "description": ""}, {"name": "equiv.symm_comp_eq", "description": ""}, {"name": "equiv.sum_assoc_symm_apply_inr_inl", "description": ""}, {"name": "equiv.swap_comm", "description": ""}, {"name": "equiv.punit_prod_apply", "description": ""}, {"name": "equiv.prod_assoc_apply", "description": ""}, {"name": "equiv.arrow_congr_refl", "description": ""}, {"name": "equiv.cast_trans", "description": ""}, {"name": "equiv.sigma_equiv_prod_sigma_congr_right", "description": ""}, {"name": "equiv.subtype_preimage", "description": " For a fixed function `x\u2080 : {a // p a} \u2192 \u03b2` defined on a subtype of `\u03b1`,\nthe subtype of functions `x : \u03b1 \u2192 \u03b2` that agree with `x\u2080` on the subtype `{a // p a}`\nis naturally equivalent to the type of functions `{a // \u00ac p a} \u2192 \u03b2`."}, {"name": "equiv.subtype_equiv", "description": " If `\u03b1` is equivalent to `\u03b2` and the predicates `p : \u03b1 \u2192 Prop` and `q : \u03b2 \u2192 Prop` are equivalent\nat corresponding points, then `{a // p a}` is equivalent to `{b // q b}`.\nFor the statement where `\u03b1 = \u03b2`, that is, `e : perm \u03b1`, see `perm.subtype_perm`."}, {"name": "equiv.subtype_subtype_equiv_subtype_exists_apply_coe", "description": ""}, {"name": "equiv.sigma_congr", "description": " Transporting a sigma type through an equivalence of the base and a family of equivalences\nof matching fibers"}, {"name": "function.injective.swap_comp", "description": ""}, {"name": "equiv.can_lift", "description": ""}, {"name": "equiv.coe_Pi_congr_symm", "description": ""}, {"name": "equiv.swap_core_swap_core", "description": ""}, {"name": "equiv.Pi_congr_right", "description": " A family of equivalences `\u03a0 a, \u03b2\u2081 a \u2243 \u03b2\u2082 a` generates an equivalence between `\u03a0 a, \u03b2\u2081 a` and\n`\u03a0 a, \u03b2\u2082 a`."}, {"name": "equiv.prod_sum_distrib_apply_left", "description": ""}, {"name": "equiv.perm.ext_iff", "description": ""}, {"name": "equiv.perm_congr", "description": "If `\u03b1` is equivalent to `\u03b2`, then `perm \u03b1` is equivalent to `perm \u03b2`."}, {"name": "equiv.sigma_congr_right_trans", "description": ""}, {"name": "equiv.sigma_fiber_equiv", "description": " `sigma_fiber_equiv f` for `f : \u03b1 \u2192 \u03b2` is the natural equivalence between\nthe type of all fibres of `f` and the total space `\u03b1`."}, {"name": "equiv.inv_fun_as_coe", "description": ""}, {"name": "equiv.swap_swap", "description": ""}, {"name": "equiv.bijective_comp", "description": ""}, {"name": "equiv.pprod_prod", "description": "Combine two equivalences using `pprod` in the domain and `prod` in the codomain."}, {"name": "equiv.swap_apply_ne_self_iff", "description": ""}, {"name": "equiv.eq_symm_apply", "description": ""}, {"name": "equiv.Pi_congr", "description": "Transport dependent functions through\nan equivalence of the base spaces and a family\nof equivalences of the matching fibers."}, {"name": "equiv.conj_comp", "description": ""}, {"name": "equiv.true_arrow_equiv", "description": "The sort of maps from `true` is equivalent to the codomain."}, {"name": "equiv.conj_apply", "description": ""}, {"name": "equiv.has_coe_to_fun", "description": ""}, {"name": "equiv.of_bijective_apply", "description": ""}, {"name": "equiv.bool_arrow_equiv_prod_symm_apply", "description": ""}, {"name": "equiv.Pi_congr_left'_symm_apply", "description": ""}, {"name": "equiv.pprod_congr_apply", "description": ""}, {"name": "equiv.empty_arrow_equiv_punit", "description": "The sort of maps from `empty` is equivalent to `punit`."}, {"name": "equiv.perm.sigma_congr_right_symm", "description": ""}, {"name": "equiv.exists_unique_congr", "description": ""}, {"name": "equiv.perm.coe_subsingleton", "description": " This cannot be a `simp` lemmas as it incorrectly matches against `e : \u03b1 \u2243 synonym \u03b1`, when\n`synonym \u03b1` is semireducible. This makes a mess of `multiplicative.of_add` etc."}, {"name": "eq_compl_iff_is_compl", "description": ""}, {"name": "le_sdiff_iff", "description": ""}, {"name": "punit.compl_eq", "description": ""}, {"name": "compl_inf_eq_bot", "description": ""}, {"name": "punit.inf_eq", "description": ""}, {"name": "sup_inf_inf_compl", "description": ""}, {"name": "compl_eq_iff_is_compl", "description": ""}, {"name": "sdiff_lt_sdiff_right", "description": ""}, {"name": "sdiff_bot", "description": ""}, {"name": "Prop.boolean_algebra", "description": ""}, {"name": "sdiff_eq_self_iff_disjoint", "description": ""}, {"name": "generalized_boolean_algebra.to_has_bot", "description": ""}, {"name": "sdiff_sup_cancel", "description": ""}, {"name": "inf_sdiff_self_left", "description": ""}, {"name": "sdiff_idem", "description": ""}, {"name": "compl_eq_comm", "description": ""}, {"name": "compl_bijective", "description": ""}, {"name": "sdiff_compl", "description": ""}, {"name": "disjoint_compl_left", "description": ""}, {"name": "inf_sdiff_distrib_left", "description": ""}, {"name": "disjoint.disjoint_sdiff_right", "description": ""}, {"name": "le_sup_sdiff", "description": ""}, {"name": "order_dual.boolean_algebra", "description": ""}, {"name": "sdiff_le_sdiff", "description": ""}, {"name": "sdiff_le_iff", "description": ""}, {"name": "sdiff_sdiff_right", "description": ""}, {"name": "of_dual_compl", "description": ""}, {"name": "inf_sdiff_right_comm", "description": ""}, {"name": "bool.compl_eq_bnot", "description": ""}, {"name": "sdiff_le_sdiff_of_sup_le_sup_right", "description": ""}, {"name": "sdiff_sdiff_eq_self", "description": ""}, {"name": "compl_compl", "description": ""}, {"name": "disjoint.le_compl_right", "description": "**Alias** of the reverse direction of `le_compl_iff_disjoint_right`."}, {"name": "inf_sdiff_sup_left", "description": ""}, {"name": "is_compl.compl_eq", "description": ""}, {"name": "eq_compl_comm", "description": ""}, {"name": "compl_eq_bot", "description": ""}, {"name": "compl_surjective", "description": ""}, {"name": "compl_involutive", "description": ""}, {"name": "sdiff_eq_sdiff_iff_inf_eq_inf", "description": ""}, {"name": "is_compl.eq_compl", "description": ""}, {"name": "compl_sup_eq_top", "description": ""}, {"name": "sdiff_sdiff_right_self", "description": ""}, {"name": "inf_sdiff_assoc", "description": ""}, {"name": "disjoint_compl_left_iff", "description": ""}, {"name": "has_le.le.disjoint_compl_left", "description": "**Alias** of the reverse direction of `disjoint_compl_left_iff`."}, {"name": "inf_sdiff_inf", "description": ""}, {"name": "sdiff_eq", "description": ""}, {"name": "bool.boolean_algebra", "description": ""}, {"name": "bool.sup_eq_bor", "description": ""}, {"name": "sdiff_inf_self_left", "description": ""}, {"name": "sdiff_le_sdiff_right", "description": ""}, {"name": "sdiff_eq_bot_iff", "description": ""}, {"name": "eq_of_sdiff_eq_sdiff", "description": ""}, {"name": "le_compl_iff_disjoint_left", "description": ""}, {"name": "inf_sdiff_sup_right", "description": ""}, {"name": "sup_inf_inf_sdiff", "description": ""}, {"name": "sup_sdiff_self_right", "description": ""}, {"name": "disjoint_sdiff_self_right", "description": ""}, {"name": "sup_sdiff_eq_sup", "description": ""}, {"name": "pi.boolean_algebra", "description": ""}, {"name": "disjoint.sdiff_eq_left", "description": ""}, {"name": "sdiff_sdiff_sup_sdiff", "description": ""}, {"name": "bot_sdiff", "description": ""}, {"name": "sdiff_sdiff_sup_sdiff'", "description": ""}, {"name": "compl_le_of_compl_le", "description": ""}, {"name": "compl_inf", "description": ""}, {"name": "disjoint_inf_sdiff", "description": ""}, {"name": "boolean_algebra.to_has_sdiff", "description": ""}, {"name": "sup_inf_sdiff", "description": ""}, {"name": "boolean_algebra.to_is_complemented", "description": ""}, {"name": "disjoint_sdiff_sdiff", "description": ""}, {"name": "le_iff_disjoint_sdiff", "description": ""}, {"name": "disjoint_sdiff_self_left", "description": ""}, {"name": "top_sdiff", "description": ""}, {"name": "compl_le_compl_iff_le", "description": ""}, {"name": "sdiff_le_comm", "description": ""}, {"name": "sdiff_top", "description": ""}, {"name": "le_sdiff_sup", "description": ""}, {"name": "punit.bot_eq", "description": ""}, {"name": "sdiff_sdiff_left'", "description": ""}, {"name": "punit.sup_eq", "description": ""}, {"name": "sdiff_eq_symm", "description": ""}, {"name": "function.injective.boolean_algebra", "description": "Pullback a `boolean_algebra` along an injection."}, {"name": "inf_sdiff_self_right", "description": ""}, {"name": "sdiff_lt", "description": ""}, {"name": "boolean_algebra.to_has_bot", "description": ""}, {"name": "sup_eq_sdiff_sup_sdiff_sup_inf", "description": ""}, {"name": "is_compl.compl_eq_iff", "description": ""}, {"name": "compl_sdiff", "description": ""}, {"name": "generalized_boolean_algebra.to_order_bot", "description": ""}, {"name": "sdiff_sdiff_le", "description": ""}, {"name": "sup_sdiff", "description": ""}, {"name": "disjoint_sdiff_iff_le", "description": ""}, {"name": "le_iff_eq_sup_sdiff", "description": ""}, {"name": "sdiff_inf_self_right", "description": ""}, {"name": "le_compl_of_le_compl", "description": ""}, {"name": "sdiff_sup", "description": ""}, {"name": "boolean_algebra.to_bounded_order", "description": ""}, {"name": "compl_le_compl", "description": ""}, {"name": "sup_sdiff_cancel'", "description": ""}, {"name": "sdiff_sdiff_self", "description": ""}, {"name": "disjoint_compl_right", "description": ""}, {"name": "disjoint_compl_right_iff", "description": ""}, {"name": "sdiff_triangle", "description": ""}, {"name": "sup_sdiff_right_self", "description": ""}, {"name": "boolean_algebra.to_generalized_boolean_algebra", "description": ""}, {"name": "le_compl_iff_disjoint_right", "description": ""}, {"name": "pi.generalized_boolean_algebra", "description": ""}, {"name": "compl_unique", "description": ""}, {"name": "generalized_boolean_algebra.to_boolean_algebra", "description": "A bounded generalized boolean algebra is a boolean algebra."}, {"name": "inf_inf_sdiff", "description": ""}, {"name": "sdiff_inf", "description": ""}, {"name": "compl_injective", "description": ""}, {"name": "inf_sdiff_distrib_right", "description": ""}, {"name": "sup_lt_of_lt_sdiff_right", "description": ""}, {"name": "sdiff_self", "description": ""}, {"name": "sup_sdiff_cancel_right", "description": ""}, {"name": "sdiff_sdiff_right'", "description": ""}, {"name": "sdiff_unique", "description": ""}, {"name": "sup_sdiff_left", "description": ""}, {"name": "compl_sup", "description": ""}, {"name": "sup_compl_eq_top", "description": ""}, {"name": "function.injective.generalized_boolean_algebra", "description": "Pullback a `generalized_boolean_algebra` along an injection."}, {"name": "sup_lt_of_lt_sdiff_left", "description": ""}, {"name": "sdiff_sdiff_left", "description": ""}, {"name": "boolean_algebra.to_has_top", "description": ""}, {"name": "sup_sdiff_left_self", "description": ""}, {"name": "inf_sdiff_right", "description": ""}, {"name": "disjoint.sdiff_eq_right", "description": ""}, {"name": "boolean_algebra.to_has_compl", "description": ""}, {"name": "sup_le_of_le_sdiff_right", "description": ""}, {"name": "sup_le_of_le_sdiff_left", "description": ""}, {"name": "sdiff_le", "description": ""}, {"name": "generalized_boolean_algebra", "description": " A generalized Boolean algebra is a distributive lattice with `\u22a5` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a \u2293 b) \u2294 (a \\ b) = a` and\n`(a \u2293 b) \u2293 (a \\ b) = \u22a5`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `finset \u03b1` for arbitrary\n(not-necessarily-`fintype`) `\u03b1`."}, {"name": "generalized_boolean_algebra.sup", "description": " A generalized Boolean algebra is a distributive lattice with `\u22a5` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a \u2293 b) \u2294 (a \\ b) = a` and\n`(a \u2293 b) \u2293 (a \\ b) = \u22a5`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `finset \u03b1` for arbitrary\n(not-necessarily-`fintype`) `\u03b1`."}, {"name": "generalized_boolean_algebra.le", "description": " A generalized Boolean algebra is a distributive lattice with `\u22a5` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a \u2293 b) \u2294 (a \\ b) = a` and\n`(a \u2293 b) \u2293 (a \\ b) = \u22a5`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `finset \u03b1` for arbitrary\n(not-necessarily-`fintype`) `\u03b1`."}, {"name": "generalized_boolean_algebra.lt", "description": " A generalized Boolean algebra is a distributive lattice with `\u22a5` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a \u2293 b) \u2294 (a \\ b) = a` and\n`(a \u2293 b) \u2293 (a \\ b) = \u22a5`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `finset \u03b1` for arbitrary\n(not-necessarily-`fintype`) `\u03b1`."}, {"name": "generalized_boolean_algebra.le_refl", "description": " A generalized Boolean algebra is a distributive lattice with `\u22a5` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a \u2293 b) \u2294 (a \\ b) = a` and\n`(a \u2293 b) \u2293 (a \\ b) = \u22a5`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `finset \u03b1` for arbitrary\n(not-necessarily-`fintype`) `\u03b1`."}, {"name": "generalized_boolean_algebra.le_trans", "description": " A generalized Boolean algebra is a distributive lattice with `\u22a5` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a \u2293 b) \u2294 (a \\ b) = a` and\n`(a \u2293 b) \u2293 (a \\ b) = \u22a5`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `finset \u03b1` for arbitrary\n(not-necessarily-`fintype`) `\u03b1`."}, {"name": "generalized_boolean_algebra.lt_iff_le_not_le", "description": " A generalized Boolean algebra is a distributive lattice with `\u22a5` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a \u2293 b) \u2294 (a \\ b) = a` and\n`(a \u2293 b) \u2293 (a \\ b) = \u22a5`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `finset \u03b1` for arbitrary\n(not-necessarily-`fintype`) `\u03b1`."}, {"name": "generalized_boolean_algebra.le_antisymm", "description": " A generalized Boolean algebra is a distributive lattice with `\u22a5` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a \u2293 b) \u2294 (a \\ b) = a` and\n`(a \u2293 b) \u2293 (a \\ b) = \u22a5`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `finset \u03b1` for arbitrary\n(not-necessarily-`fintype`) `\u03b1`."}, {"name": "generalized_boolean_algebra.le_sup_left", "description": " A generalized Boolean algebra is a distributive lattice with `\u22a5` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a \u2293 b) \u2294 (a \\ b) = a` and\n`(a \u2293 b) \u2293 (a \\ b) = \u22a5`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `finset \u03b1` for arbitrary\n(not-necessarily-`fintype`) `\u03b1`."}, {"name": "generalized_boolean_algebra.le_sup_right", "description": " A generalized Boolean algebra is a distributive lattice with `\u22a5` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a \u2293 b) \u2294 (a \\ b) = a` and\n`(a \u2293 b) \u2293 (a \\ b) = \u22a5`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `finset \u03b1` for arbitrary\n(not-necessarily-`fintype`) `\u03b1`."}, {"name": "generalized_boolean_algebra.sup_le", "description": " A generalized Boolean algebra is a distributive lattice with `\u22a5` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a \u2293 b) \u2294 (a \\ b) = a` and\n`(a \u2293 b) \u2293 (a \\ b) = \u22a5`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `finset \u03b1` for arbitrary\n(not-necessarily-`fintype`) `\u03b1`."}, {"name": "generalized_boolean_algebra.inf", "description": " A generalized Boolean algebra is a distributive lattice with `\u22a5` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a \u2293 b) \u2294 (a \\ b) = a` and\n`(a \u2293 b) \u2293 (a \\ b) = \u22a5`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `finset \u03b1` for arbitrary\n(not-necessarily-`fintype`) `\u03b1`."}, {"name": "generalized_boolean_algebra.inf_le_left", "description": " A generalized Boolean algebra is a distributive lattice with `\u22a5` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a \u2293 b) \u2294 (a \\ b) = a` and\n`(a \u2293 b) \u2293 (a \\ b) = \u22a5`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `finset \u03b1` for arbitrary\n(not-necessarily-`fintype`) `\u03b1`."}, {"name": "generalized_boolean_algebra.inf_le_right", "description": " A generalized Boolean algebra is a distributive lattice with `\u22a5` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a \u2293 b) \u2294 (a \\ b) = a` and\n`(a \u2293 b) \u2293 (a \\ b) = \u22a5`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `finset \u03b1` for arbitrary\n(not-necessarily-`fintype`) `\u03b1`."}, {"name": "generalized_boolean_algebra.le_inf", "description": " A generalized Boolean algebra is a distributive lattice with `\u22a5` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a \u2293 b) \u2294 (a \\ b) = a` and\n`(a \u2293 b) \u2293 (a \\ b) = \u22a5`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `finset \u03b1` for arbitrary\n(not-necessarily-`fintype`) `\u03b1`."}, {"name": "generalized_boolean_algebra.le_sup_inf", "description": " A generalized Boolean algebra is a distributive lattice with `\u22a5` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a \u2293 b) \u2294 (a \\ b) = a` and\n`(a \u2293 b) \u2293 (a \\ b) = \u22a5`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `finset \u03b1` for arbitrary\n(not-necessarily-`fintype`) `\u03b1`."}, {"name": "generalized_boolean_algebra.sdiff", "description": " A generalized Boolean algebra is a distributive lattice with `\u22a5` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a \u2293 b) \u2294 (a \\ b) = a` and\n`(a \u2293 b) \u2293 (a \\ b) = \u22a5`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `finset \u03b1` for arbitrary\n(not-necessarily-`fintype`) `\u03b1`."}, {"name": "generalized_boolean_algebra.bot", "description": " A generalized Boolean algebra is a distributive lattice with `\u22a5` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a \u2293 b) \u2294 (a \\ b) = a` and\n`(a \u2293 b) \u2293 (a \\ b) = \u22a5`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `finset \u03b1` for arbitrary\n(not-necessarily-`fintype`) `\u03b1`."}, {"name": "generalized_boolean_algebra.sup_inf_sdiff", "description": " A generalized Boolean algebra is a distributive lattice with `\u22a5` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a \u2293 b) \u2294 (a \\ b) = a` and\n`(a \u2293 b) \u2293 (a \\ b) = \u22a5`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `finset \u03b1` for arbitrary\n(not-necessarily-`fintype`) `\u03b1`."}, {"name": "generalized_boolean_algebra.inf_inf_sdiff", "description": " A generalized Boolean algebra is a distributive lattice with `\u22a5` and a relative complement\noperation `\\` (called `sdiff`, after \"set difference\") satisfying `(a \u2293 b) \u2294 (a \\ b) = a` and\n`(a \u2293 b) \u2293 (a \\ b) = \u22a5`, i.e. `a \\ b` is the complement of `b` in `a`.\n\nThis is a generalization of Boolean algebras which applies to `finset \u03b1` for arbitrary\n(not-necessarily-`fintype`) `\u03b1`."}, {"name": "sup_sdiff_self_left", "description": ""}, {"name": "compl_inj_iff", "description": ""}, {"name": "compl_top", "description": ""}, {"name": "disjoint.sdiff_unique", "description": ""}, {"name": "generalized_boolean_algebra.to_distrib_lattice", "description": ""}, {"name": "sup_sdiff_symm", "description": ""}, {"name": "has_le.le.disjoint_compl_right", "description": "**Alias** of the reverse direction of `disjoint_compl_right_iff`."}, {"name": "disjoint.disjoint_sdiff_left", "description": ""}, {"name": "sup_sdiff_inf", "description": ""}, {"name": "inf_sdiff", "description": ""}, {"name": "punit.sdiff_eq", "description": ""}, {"name": "boolean_algebra.to_distrib_lattice", "description": ""}, {"name": "disjoint.sup_sdiff_cancel_left", "description": ""}, {"name": "sdiff_inf_sdiff", "description": ""}, {"name": "is_compl_compl", "description": ""}, {"name": "disjoint.le_compl_left", "description": "**Alias** of the reverse direction of `le_compl_iff_disjoint_left`."}, {"name": "boolean_algebra", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.sup", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.le", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.lt", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.le_refl", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.le_trans", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.lt_iff_le_not_le", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.le_antisymm", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.le_sup_left", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.le_sup_right", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.sup_le", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.inf", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.inf_le_left", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.inf_le_right", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.le_inf", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.le_sup_inf", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.compl", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.sdiff", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.top", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.bot", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.inf_compl_le_bot", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.top_le_sup_compl", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.le_top", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.bot_le", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "boolean_algebra.sdiff_eq", "description": " A Boolean algebra is a bounded distributive lattice with a complement operator `\u1d9c` such that\n`x \u2293 x\u1d9c = \u22a5` and `x \u2294 x\u1d9c = \u22a4`. For convenience, it must also provide a set difference operation `\\`\nsatisfying `x \\ y = x \u2293 y\u1d9c`.\n\nThis is a generalization of (classical) logic of propositions, or the powerset lattice.\n\nSince `bounded_order`, `order_bot`, and `order_top` are mixins that require `has_le`\nto be present at define-time, the `extends` mechanism does not work with them.\nInstead, we extend using the underlying `has_bot` and `has_top` data typeclasses, and replicate the\norder axioms of those classes here. A \"forgetful\" instance back to `bounded_order` is provided."}, {"name": "punit.top_eq", "description": ""}, {"name": "generalized_boolean_algebra.to_has_sdiff", "description": ""}, {"name": "sdiff_sdiff_comm", "description": ""}, {"name": "sdiff_le_sdiff_left", "description": ""}, {"name": "punit.boolean_algebra", "description": ""}, {"name": "sdiff_sdiff_eq_sdiff_sup", "description": ""}, {"name": "disjoint.sup_sdiff_cancel_right", "description": ""}, {"name": "sdiff_le_sdiff_of_sup_le_sup_left", "description": ""}, {"name": "compl_eq_top", "description": ""}, {"name": "sdiff_eq_self_iff_disjoint'", "description": ""}, {"name": "sdiff_eq_comm", "description": ""}, {"name": "sup_sdiff_right", "description": ""}, {"name": "le_compl_iff_le_compl", "description": ""}, {"name": "sdiff_sup_sdiff_cancel", "description": ""}, {"name": "bool.inf_eq_band", "description": ""}, {"name": "inf_sdiff_eq_bot_iff", "description": ""}, {"name": "disjoint.sdiff_eq_of_sup_eq", "description": ""}, {"name": "compl_le_iff_compl_le", "description": ""}, {"name": "inf_compl_eq_bot", "description": ""}, {"name": "to_dual_compl", "description": ""}, {"name": "inf_sdiff_left", "description": ""}, {"name": "compl_bot", "description": ""}, {"name": "compl_comp_compl", "description": ""}, {"name": "partial_order", "description": "A partial order is a reflexive, transitive, antisymmetric relation `\u2264`."}, {"name": "partial_order.le", "description": "A partial order is a reflexive, transitive, antisymmetric relation `\u2264`."}, {"name": "partial_order.lt", "description": "A partial order is a reflexive, transitive, antisymmetric relation `\u2264`."}, {"name": "partial_order.le_refl", "description": "A partial order is a reflexive, transitive, antisymmetric relation `\u2264`."}, {"name": "partial_order.le_trans", "description": "A partial order is a reflexive, transitive, antisymmetric relation `\u2264`."}, {"name": "partial_order.lt_iff_le_not_le", "description": "A partial order is a reflexive, transitive, antisymmetric relation `\u2264`."}, {"name": "partial_order.le_antisymm", "description": "A partial order is a reflexive, transitive, antisymmetric relation `\u2264`."}, {"name": "preorder.to_has_lt", "description": ""}, {"name": "le_iff_lt_or_eq", "description": ""}, {"name": "le_refl", "description": "The relation `\u2264` on a preorder is reflexive."}, {"name": "decidable.eq_or_lt_of_le", "description": ""}, {"name": "le_trans", "description": "The relation `\u2264` on a preorder is transitive."}, {"name": "le_of_eq", "description": ""}, {"name": "lt_by_cases", "description": "Perform a case-split on the ordering of `x` and `y` in a decidable linear order."}, {"name": "lt_or_gt_of_ne", "description": ""}, {"name": "le_of_not_ge", "description": ""}, {"name": "not_lt_of_gt", "description": ""}, {"name": "lt_iff_not_ge", "description": ""}, {"name": "le_or_lt", "description": ""}, {"name": "ge_trans", "description": ""}, {"name": "lt_of_le_of_ne", "description": ""}, {"name": "has_le.le.is_total_preorder", "description": ""}, {"name": "not_le_of_gt", "description": ""}, {"name": "lt_of_not_ge", "description": ""}, {"name": "ne_of_gt", "description": ""}, {"name": "is_strict_weak_order_of_linear_order", "description": ""}, {"name": "eq_or_lt_of_not_lt", "description": ""}, {"name": "gt_of_ge_of_gt", "description": ""}, {"name": "max_default", "description": "Default definition of `max`."}, {"name": "gt_of_gt_of_ge", "description": ""}, {"name": "lt_iff_le_not_le", "description": ""}, {"name": "ne_iff_lt_or_gt", "description": ""}, {"name": "lt_trans", "description": ""}, {"name": "lt_asymm", "description": ""}, {"name": "le_of_eq_or_lt", "description": ""}, {"name": "has_le.le.decidable", "description": ""}, {"name": "gt_irrefl", "description": ""}, {"name": "decidable.lt_or_eq_of_le", "description": ""}, {"name": "not_lt_of_ge", "description": ""}, {"name": "decidable_lt_of_decidable_le", "description": "`<` is decidable if `\u2264` is."}, {"name": "lt_trichotomy", "description": ""}, {"name": "has_lt.lt.decidable", "description": ""}, {"name": "not_lt", "description": ""}, {"name": "decidable_eq_of_decidable_le", "description": "Equality is decidable if `\u2264` is."}, {"name": "le_not_le_of_lt", "description": ""}, {"name": "not_le", "description": ""}, {"name": "decidable.le_iff_lt_or_eq", "description": ""}, {"name": "linear_order", "description": " A linear order is reflexive, transitive, antisymmetric and total relation `\u2264`.\nWe assume that every linear ordered type has decidable `(\u2264)`, `(<)`, and `(=)`."}, {"name": "linear_order.le", "description": " A linear order is reflexive, transitive, antisymmetric and total relation `\u2264`.\nWe assume that every linear ordered type has decidable `(\u2264)`, `(<)`, and `(=)`."}, {"name": "linear_order.lt", "description": " A linear order is reflexive, transitive, antisymmetric and total relation `\u2264`.\nWe assume that every linear ordered type has decidable `(\u2264)`, `(<)`, and `(=)`."}, {"name": "linear_order.le_refl", "description": " A linear order is reflexive, transitive, antisymmetric and total relation `\u2264`.\nWe assume that every linear ordered type has decidable `(\u2264)`, `(<)`, and `(=)`."}, {"name": "linear_order.le_trans", "description": " A linear order is reflexive, transitive, antisymmetric and total relation `\u2264`.\nWe assume that every linear ordered type has decidable `(\u2264)`, `(<)`, and `(=)`."}, {"name": "linear_order.lt_iff_le_not_le", "description": " A linear order is reflexive, transitive, antisymmetric and total relation `\u2264`.\nWe assume that every linear ordered type has decidable `(\u2264)`, `(<)`, and `(=)`."}, {"name": "linear_order.le_antisymm", "description": " A linear order is reflexive, transitive, antisymmetric and total relation `\u2264`.\nWe assume that every linear ordered type has decidable `(\u2264)`, `(<)`, and `(=)`."}, {"name": "linear_order.le_total", "description": " A linear order is reflexive, transitive, antisymmetric and total relation `\u2264`.\nWe assume that every linear ordered type has decidable `(\u2264)`, `(<)`, and `(=)`."}, {"name": "linear_order.decidable_le", "description": " A linear order is reflexive, transitive, antisymmetric and total relation `\u2264`.\nWe assume that every linear ordered type has decidable `(\u2264)`, `(<)`, and `(=)`."}, {"name": "linear_order.decidable_eq", "description": " A linear order is reflexive, transitive, antisymmetric and total relation `\u2264`.\nWe assume that every linear ordered type has decidable `(\u2264)`, `(<)`, and `(=)`."}, {"name": "linear_order.decidable_lt", "description": " A linear order is reflexive, transitive, antisymmetric and total relation `\u2264`.\nWe assume that every linear ordered type has decidable `(\u2264)`, `(<)`, and `(=)`."}, {"name": "linear_order.max", "description": " A linear order is reflexive, transitive, antisymmetric and total relation `\u2264`.\nWe assume that every linear ordered type has decidable `(\u2264)`, `(<)`, and `(=)`."}, {"name": "linear_order.max_def", "description": " A linear order is reflexive, transitive, antisymmetric and total relation `\u2264`.\nWe assume that every linear ordered type has decidable `(\u2264)`, `(<)`, and `(=)`."}, {"name": "linear_order.min", "description": " A linear order is reflexive, transitive, antisymmetric and total relation `\u2264`.\nWe assume that every linear ordered type has decidable `(\u2264)`, `(<)`, and `(=)`."}, {"name": "linear_order.min_def", "description": " A linear order is reflexive, transitive, antisymmetric and total relation `\u2264`.\nWe assume that every linear ordered type has decidable `(\u2264)`, `(<)`, and `(=)`."}, {"name": "linear_order.to_partial_order", "description": ""}, {"name": "le_of_not_gt", "description": ""}, {"name": "le_antisymm", "description": ""}, {"name": "le_of_lt_or_eq", "description": ""}, {"name": "partial_order.to_preorder", "description": ""}, {"name": "le_of_lt", "description": ""}, {"name": "lt_or_ge", "description": ""}, {"name": "lt_irrefl", "description": ""}, {"name": "ne_of_lt", "description": ""}, {"name": "preorder", "description": "A preorder is a reflexive, transitive relation `\u2264` with `a < b` defined in the obvious way."}, {"name": "preorder.le", "description": "A preorder is a reflexive, transitive relation `\u2264` with `a < b` defined in the obvious way."}, {"name": "preorder.lt", "description": "A preorder is a reflexive, transitive relation `\u2264` with `a < b` defined in the obvious way."}, {"name": "preorder.le_refl", "description": "A preorder is a reflexive, transitive relation `\u2264` with `a < b` defined in the obvious way."}, {"name": "preorder.le_trans", "description": "A preorder is a reflexive, transitive relation `\u2264` with `a < b` defined in the obvious way."}, {"name": "preorder.lt_iff_le_not_le", "description": "A preorder is a reflexive, transitive relation `\u2264` with `a < b` defined in the obvious way."}, {"name": "lt_of_le_not_le", "description": ""}, {"name": "lt_or_le", "description": ""}, {"name": "le_total", "description": ""}, {"name": "min_default", "description": "Default definition of `min`."}, {"name": "le_antisymm_iff", "description": ""}, {"name": "eq.decidable", "description": ""}, {"name": "le_of_not_lt", "description": ""}, {"name": "lt_or_eq_of_le", "description": ""}, {"name": "preorder.to_has_le", "description": ""}, {"name": "le_imp_le_of_lt_imp_lt", "description": ""}, {"name": "lt_of_lt_of_le", "description": ""}, {"name": "lt_of_le_of_lt", "description": ""}, {"name": "le_of_not_le", "description": ""}, {"name": "le_or_gt", "description": ""}, {"name": "is_strict_total_order_of_linear_order", "description": ""}, {"name": "gt_trans", "description": ""}, {"name": "has_coe_t_aux", "description": "Auxiliary transitive closure for `has_coe` which does not contain\n  instances such as `coe_option`.\n\n  They would produce non-termination when combined with `coe_fn_trans` and `coe_sort_trans`."}, {"name": "has_coe_t_aux.coe", "description": "Auxiliary transitive closure for `has_coe` which does not contain\n  instances such as `coe_option`.\n\n  They would produce non-termination when combined with `coe_fn_trans` and `coe_sort_trans`."}, {"name": "coe_base_aux", "description": ""}, {"name": "coe_to_lift", "description": "Every coercion is also a lift"}, {"name": "lift_t", "description": ""}, {"name": "coe_b", "description": ""}, {"name": "has_coe", "description": ""}, {"name": "has_coe.coe", "description": ""}, {"name": "lift_fn", "description": "Remark: we can't use `[has_lift_t a\u2082 a\u2081]` since it will produce non-termination whenever a type class resolution\n  problem does not have a solution."}, {"name": "coe_sort_bool", "description": "Tactics such as the simplifier only unfold reducible constants when checking whether two terms are definitionally\n  equal or a term is a proposition. The motivation is performance.\n  In particular, when simplifying `p -> q`, the tactic `simp` only visits `p` if it can establish that it is a proposition.\n  Thus, we mark the following instance as `@[reducible]`, otherwise `simp` will not visit `\u2191p` when simplifying `\u2191p -> q`."}, {"name": "lift_pair\u2081", "description": ""}, {"name": "coe", "description": ""}, {"name": "lift_pair", "description": ""}, {"name": "lift_trans", "description": ""}, {"name": "coe_fn", "description": ""}, {"name": "has_coe_to_sort", "description": ""}, {"name": "has_coe_to_sort.coe", "description": ""}, {"name": "coe_t", "description": ""}, {"name": "coe_sort_trans", "description": ""}, {"name": "coe_decidable_eq", "description": ""}, {"name": "coe_trans", "description": ""}, {"name": "has_coe_to_fun", "description": ""}, {"name": "has_coe_to_fun.coe", "description": ""}, {"name": "lift_fn_dom", "description": ""}, {"name": "coe_subtype", "description": ""}, {"name": "lift_base", "description": ""}, {"name": "lift_pair\u2082", "description": ""}, {"name": "coe_fn_trans", "description": ""}, {"name": "has_coe_t", "description": "Auxiliary class that contains the transitive closure of `has_coe`."}, {"name": "has_coe_t.coe", "description": "Auxiliary class that contains the transitive closure of `has_coe`."}, {"name": "has_lift", "description": "Can perform a lifting operation `\u2191a`."}, {"name": "has_lift.lift", "description": "Can perform a lifting operation `\u2191a`."}, {"name": "coe_fn_b", "description": ""}, {"name": "coe_base", "description": ""}, {"name": "coe_sort", "description": ""}, {"name": "has_lift_t", "description": "Auxiliary class that contains the transitive closure of `has_lift`."}, {"name": "has_lift_t.lift", "description": "Auxiliary class that contains the transitive closure of `has_lift`."}, {"name": "lift_fn_range", "description": ""}, {"name": "lift_pi_range", "description": "A dependent version of `lift_fn_range`."}, {"name": "lift", "description": ""}, {"name": "lift_list", "description": ""}, {"name": "coe_option", "description": "We add this instance directly into `has_coe_t` to avoid non-termination.\n\n  Suppose coe_option had type `(has_coe a (option a))`.\n  Then, we can loop when searching a coercion from `\u03b1` to `\u03b2` `(has_coe_t \u03b1 \u03b2)`\n  1- `coe_trans at (has_coe_t \u03b1 \u03b2)`\n         `(has_coe \u03b1 ?b\u2081) and (has_coe_t ?b\u2081 c)`\n  2- `coe_option at (has_coe \u03b1 ?b\u2081)`\n         `?b\u2081 := option \u03b1`\n  3- `coe_trans at (has_coe_t (option \u03b1) \u03b2)`\n         `(has_coe (option \u03b1) ?b\u2082) and (has_coe_t ?b\u2082 \u03b2)`\n  4- `coe_option at (has_coe (option \u03b1) ?b\u2082)`\n         `?b\u2082 := option (option \u03b1))`\n  ..."}, {"name": "coe_trans_aux", "description": ""}, {"name": "coe_bool_to_Prop", "description": ""}, {"name": "multiset.inf_mono", "description": ""}, {"name": "multiset.inf_dedup", "description": ""}, {"name": "multiset.inf_cons", "description": ""}, {"name": "multiset.sup_dedup", "description": ""}, {"name": "multiset.sup_ndunion", "description": ""}, {"name": "multiset.inf_union", "description": ""}, {"name": "multiset.sup_coe", "description": ""}, {"name": "multiset.sup_mono", "description": ""}, {"name": "multiset.sup_zero", "description": ""}, {"name": "multiset.inf_zero", "description": ""}, {"name": "multiset.le_sup", "description": ""}, {"name": "multiset.sup_union", "description": ""}, {"name": "multiset.inf_ndinsert", "description": ""}, {"name": "multiset.inf_ndunion", "description": ""}, {"name": "multiset.le_inf", "description": ""}, {"name": "multiset.sup", "description": "Supremum of a multiset: `sup {a, b, c} = a \u2294 b \u2294 c`"}, {"name": "multiset.sup_cons", "description": ""}, {"name": "multiset.inf_coe", "description": ""}, {"name": "multiset.inf_add", "description": ""}, {"name": "multiset.sup_le", "description": ""}, {"name": "multiset.sup_ndinsert", "description": ""}, {"name": "multiset.sup_singleton", "description": ""}, {"name": "multiset.sup_add", "description": ""}, {"name": "multiset.inf", "description": "Infimum of a multiset: `inf {a, b, c} = a \u2293 b \u2293 c`"}, {"name": "multiset.nodup_sup_iff", "description": ""}, {"name": "multiset.inf_singleton", "description": ""}, {"name": "multiset.inf_le", "description": ""}, {"name": "list.sum_drop_succ", "description": "Counterpart to `list.sum_take_succ` when we have an negation operation"}, {"name": "list.alternating_prod_cons_cons'", "description": ""}, {"name": "list.sum_take_add_sum_drop", "description": ""}, {"name": "list.sum_nonneg", "description": ""}, {"name": "list.alternating_sum_nil", "description": ""}, {"name": "list.sum_neg", "description": "This is the `list.sum` version of `add_neg`"}, {"name": "list.dvd_prod", "description": ""}, {"name": "add_commute.list_sum_right", "description": ""}, {"name": "list.prod_repeat", "description": ""}, {"name": "map_list_sum", "description": ""}, {"name": "list.length_pos_of_one_lt_prod", "description": "A list with product greater than one must have positive length."}, {"name": "list.prod_drop_succ", "description": "Counterpart to `list.prod_take_succ` when we have an inverse operation"}, {"name": "list.length_pos_of_prod_ne_one", "description": "A list with product not one must have positive length."}, {"name": "list.sum_cons", "description": ""}, {"name": "list.prod_hom\u2082", "description": ""}, {"name": "list.sum_map_mul_left", "description": ""}, {"name": "list.sum_singleton", "description": ""}, {"name": "list.single_le_sum", "description": ""}, {"name": "commute.list_sum_right", "description": ""}, {"name": "list.head_add_tail_sum_of_ne_nil", "description": "Same as `nth_zero_add_tail_sum`, but avoiding the `list.head` garbage complication\nby requiring the list to be nonempty."}, {"name": "list.sum_eq_zero_iff", "description": ""}, {"name": "list.sum_hom", "description": ""}, {"name": "list.alternating_prod_append", "description": ""}, {"name": "list.forall\u2082.sum_le_sum", "description": ""}, {"name": "commute.list_sum_left", "description": ""}, {"name": "list.prod_hom_rel", "description": ""}, {"name": "list.alternating_prod_cons'", "description": ""}, {"name": "list.sum_nil", "description": ""}, {"name": "list.length_pos_of_prod_lt_one", "description": "A list with product less than one must have positive length."}, {"name": "commute.list_prod_right", "description": ""}, {"name": "list.prod_eq_pow_card", "description": ""}, {"name": "list.alternating_prod_reverse", "description": ""}, {"name": "list.alternating_sum_cons'", "description": ""}, {"name": "list.prod_lt_prod'", "description": ""}, {"name": "list.sum_concat", "description": ""}, {"name": "list.all_zero_of_le_zero_le_of_sum_eq_zero", "description": ""}, {"name": "list.length_pos_of_sum_ne_zero", "description": "A list with sum not zero must have positive length."}, {"name": "list.prod_map_mul", "description": ""}, {"name": "list.pow_card_le_prod", "description": ""}, {"name": "list.monotone_sum_take", "description": ""}, {"name": "list.one_le_prod_of_one_le", "description": ""}, {"name": "mul_opposite.unop_list_prod", "description": ""}, {"name": "list.sublist_forall\u2082.sum_le_sum", "description": ""}, {"name": "list.prod_take_mul_prod_drop", "description": ""}, {"name": "list.length_le_sum_of_one_le", "description": " If all elements in a list are bounded below by `1`, then the length of the list is bounded\nby the sum of the elements."}, {"name": "list.sum_lt_sum_of_ne_nil", "description": ""}, {"name": "list.sum_hom\u2082", "description": ""}, {"name": "list.alternating_prod_cons", "description": ""}, {"name": "list.dvd_sum", "description": ""}, {"name": "list.sum_erase", "description": ""}, {"name": "add_commute.list_sum_left", "description": ""}, {"name": "list.alternating_sum_cons_cons'", "description": ""}, {"name": "list.alternating_sum_cons", "description": ""}, {"name": "list.nth_zero_add_tail_sum", "description": "We'd like to state this as `L.head + L.tail.sum = L.sum`, but because `L.head`\nrelies on an inhabited instance to return a garbage value on the empty list, this is not possible.\nInstead, we write the statement in terms of `(L.nth 0).get_or_else 0`."}, {"name": "list.prod_update_nth", "description": ""}, {"name": "monoid_hom.map_list_prod", "description": "Deprecated, use `_root_.map_list_prod` instead."}, {"name": "list.prod_append", "description": ""}, {"name": "list.prod_map_hom", "description": ""}, {"name": "list.length_pos_of_sum_neg", "description": "A list with negative sum must have positive length."}, {"name": "list.eq_of_sum_take_eq", "description": ""}, {"name": "list.sum_hom_rel", "description": ""}, {"name": "list.sum_const_nat", "description": ""}, {"name": "list.sum_eq_zero", "description": "Slightly more general version of `list.sum_eq_zero_iff`\n  for a non-ordered `add_monoid`"}, {"name": "list.prod_inv_reverse", "description": "This is the `list.prod` version of `mul_inv_rev`"}, {"name": "list.sum_map_hom", "description": ""}, {"name": "list.sum_le_foldr_max", "description": ""}, {"name": "list.card_nsmul_le_sum", "description": ""}, {"name": "list.sublist.sum_le_sum", "description": "If `l\u2081` is a sublist of `l\u2082` and all elements of `l\u2082` are nonnegative,\nthen `l\u2081.sum \u2264 l\u2082.sum`. One can prove a stronger version assuming `\u2200 a \u2208 l\u2082.diff l\u2081, 0 \u2264 a` instead\nof `\u2200 a \u2208 l\u2082, 0 \u2264 a` but this lemma is not yet in `mathlib`."}, {"name": "list.sum_join", "description": ""}, {"name": "list.single_le_prod", "description": ""}, {"name": "list.sum_lt_sum", "description": ""}, {"name": "list.sum_take_succ", "description": ""}, {"name": "list.forall\u2082.prod_le_prod'", "description": ""}, {"name": "list.sum_map_add", "description": ""}, {"name": "list.prod_pos", "description": " The product of a list of positive natural numbers is positive,\nand likewise for any nontrivial ordered semiring."}, {"name": "list.alternating_prod_cons_cons", "description": ""}, {"name": "list.prod_le_pow_card", "description": ""}, {"name": "list.sum_le_sum", "description": ""}, {"name": "list.sublist.prod_le_prod'", "description": " If `l\u2081` is a sublist of `l\u2082` and all elements of `l\u2082` are greater than or equal to one, then\n`l\u2081.prod \u2264 l\u2082.prod`. One can prove a stronger version assuming `\u2200 a \u2208 l\u2082.diff l\u2081, 1 \u2264 a` instead\nof `\u2200 a \u2208 l\u2082, 1 \u2264 a` but this lemma is not yet in `mathlib`."}, {"name": "list.sum_eq_foldr", "description": ""}, {"name": "list.exists_le_of_sum_le", "description": ""}, {"name": "list.sum_map_mul_right", "description": ""}, {"name": "list.alternating_prod_singleton", "description": ""}, {"name": "mul_opposite.op_list_prod", "description": ""}, {"name": "list.sum_repeat", "description": ""}, {"name": "list.prod_eq_one_iff", "description": ""}, {"name": "list.prod_ne_zero", "description": ""}, {"name": "list.tail_sum", "description": "This relies on `default \u2115 = 0`."}, {"name": "commute.list_prod_left", "description": ""}, {"name": "list.head_mul_tail_prod_of_ne_nil", "description": " Same as `nth_zero_mul_tail_prod`, but avoiding the `list.head` garbage complication by requiring\nthe list to be nonempty."}, {"name": "list.alternating_prod_nil", "description": ""}, {"name": "list.sum_eq_card_nsmul", "description": ""}, {"name": "list.all_one_of_le_one_le_of_prod_eq_one", "description": ""}, {"name": "list.prod_take_succ", "description": ""}, {"name": "list.one_lt_prod_of_one_lt", "description": ""}, {"name": "list.sum_neg_reverse", "description": "This is the `list.sum` version of `add_neg_rev`"}, {"name": "list.sum_pos", "description": ""}, {"name": "list.prod_update_nth'", "description": "Alternative version of `list.prod_update_nth` when the list is over a group"}, {"name": "list.exists_le_of_prod_le'", "description": ""}, {"name": "list.prod_reverse_noncomm", "description": "A non-commutative variant of `list.prod_reverse`"}, {"name": "list.prod_hom", "description": ""}, {"name": "list.sublist_forall\u2082.prod_le_prod'", "description": ""}, {"name": "list.alternating_sum_singleton", "description": ""}, {"name": "list.prod_cons", "description": ""}, {"name": "list.nth_zero_mul_tail_prod", "description": " We'd like to state this as `L.head * L.tail.prod = L.prod`, but because `L.head` relies on an\ninhabited instance to return a garbage value on the empty list, this is not possible.\nInstead, we write the statement in terms of `(L.nth 0).get_or_else 1`."}, {"name": "list.sum_update_nth'", "description": "Alternative version of `list.sum_update_nth` when the list is over a group"}, {"name": "list.alternating_sum_append", "description": ""}, {"name": "list.sum_append", "description": ""}, {"name": "list.prod_le_prod'", "description": ""}, {"name": "list.head_le_sum", "description": "This relies on `default \u2115 = 0`."}, {"name": "list.sum_is_add_unit", "description": ""}, {"name": "list.exists_lt_of_prod_lt'", "description": ""}, {"name": "list.prod_join", "description": ""}, {"name": "list.prod_eq_zero_iff", "description": " Product of elements of a list `L` equals zero if and only if `0 \u2208 L`. See also\n`list.prod_eq_zero` for an implication that needs weaker typeclass assumptions."}, {"name": "list.sum_update_nth", "description": ""}, {"name": "list.prod_nil", "description": ""}, {"name": "list.eq_of_prod_take_eq", "description": ""}, {"name": "list.monotone_prod_take", "description": ""}, {"name": "list.sum_le_card_nsmul", "description": ""}, {"name": "list.prod_inv", "description": "This is the `list.prod` version of `mul_inv`"}, {"name": "list.prod_map_erase", "description": ""}, {"name": "list.alternating_sum_reverse", "description": ""}, {"name": "list.prod_eq_zero", "description": " If zero is an element of a list `L`, then `list.prod L = 0`. If the domain is a nontrivial\nmonoid with zero with no divisors, then this implication becomes an `iff`, see\n`list.prod_eq_zero_iff`."}, {"name": "list.prod_singleton", "description": ""}, {"name": "list.prod_lt_prod_of_ne_nil", "description": ""}, {"name": "monoid_hom.unop_map_list_prod", "description": " A morphism into the opposite monoid acts on the product by acting on the reversed elements.\n\nDeprecated, use `_root_.unop_map_list_prod` instead."}, {"name": "list.prod_eq_foldr", "description": ""}, {"name": "list.sum_reverse_noncomm", "description": "A non-commutative variant of `list.sum_reverse`"}, {"name": "list.sum_map_erase", "description": ""}, {"name": "list.prod_eq_one", "description": "Slightly more general version of `list.prod_eq_one_iff` for a non-ordered `monoid`"}, {"name": "list.exists_lt_of_sum_lt", "description": ""}, {"name": "list.alternating_sum_cons_cons", "description": ""}, {"name": "list.prod_erase", "description": ""}, {"name": "add_monoid_hom.map_list_sum", "description": "Deprecated, use `_root_.map_list_sum` instead."}, {"name": "list.head_add_tail_sum", "description": "This relies on `default \u2115 = 0`."}, {"name": "list.prod_concat", "description": ""}, {"name": "map_list_prod", "description": ""}, {"name": "unop_map_list_prod", "description": "A morphism into the opposite monoid acts on the product by acting on the reversed elements."}, {"name": "list.prod_is_unit", "description": ""}, {"name": "list.length_pos_of_sum_pos", "description": "A list with positive sum must have positive length."}, {"name": "list.mem_append", "description": ""}, {"name": "list.not_mem_nil", "description": ""}, {"name": "list.ball_nil", "description": ""}, {"name": "list.not_bex_nil", "description": ""}, {"name": "list.subset_cons_of_subset", "description": ""}, {"name": "list.mem_append_eq", "description": ""}, {"name": "list.length_cons", "description": ""}, {"name": "list.map_accumr\u2082", "description": ""}, {"name": "list.length_take_le", "description": ""}, {"name": "list.eq_or_mem_of_mem_cons", "description": ""}, {"name": "list.nil_subset", "description": ""}, {"name": "list.length_le_of_sublist", "description": ""}, {"name": "list.mem_append_left", "description": ""}, {"name": "list.has_subset", "description": ""}, {"name": "list.cons_subset_cons", "description": ""}, {"name": "list.length_append", "description": ""}, {"name": "list.map_append", "description": ""}, {"name": "list.filter_cons_of_neg", "description": ""}, {"name": "list.length_drop", "description": ""}, {"name": "list.ne_nil_of_length_eq_succ", "description": ""}, {"name": "list.subset.trans", "description": ""}, {"name": "list.length_map", "description": ""}, {"name": "list.filter_append", "description": ""}, {"name": "list.filter_nil", "description": ""}, {"name": "list.subset_cons", "description": ""}, {"name": "list.mem_nil_iff", "description": ""}, {"name": "list.mem_cons_iff", "description": ""}, {"name": "list.mem_append_right", "description": ""}, {"name": "list.cons_append", "description": ""}, {"name": "list.map_id", "description": ""}, {"name": "list.map_cons", "description": ""}, {"name": "list.mem_cons_self", "description": ""}, {"name": "list.map_accumr", "description": ""}, {"name": "list.append_nil", "description": ""}, {"name": "list.subset_append_left", "description": ""}, {"name": "list.length_take", "description": ""}, {"name": "list.mem_cons_eq", "description": ""}, {"name": "list.subset_append_right", "description": ""}, {"name": "list.nil_append", "description": ""}, {"name": "list.length_tail", "description": ""}, {"name": "list.bex_cons", "description": ""}, {"name": "list.length_map_accumr", "description": ""}, {"name": "list.sublist", "description": ""}, {"name": "list.sublist.slnil", "description": ""}, {"name": "list.sublist.cons", "description": ""}, {"name": "list.sublist.cons2", "description": ""}, {"name": "list.filter_sublist", "description": ""}, {"name": "list.append_assoc", "description": ""}, {"name": "list.filter_cons_of_pos", "description": ""}, {"name": "list.append_bind", "description": ""}, {"name": "list.nil_bind", "description": ""}, {"name": "list.mem_cons_of_mem", "description": ""}, {"name": "list.subset_of_cons_subset", "description": ""}, {"name": "list.map_singleton", "description": ""}, {"name": "list.length_map\u2082", "description": ""}, {"name": "list.length_map_accumr\u2082", "description": ""}, {"name": "list.subset.refl", "description": ""}, {"name": "list.ball_cons", "description": ""}, {"name": "list.map_map", "description": ""}, {"name": "list.length_repeat", "description": ""}, {"name": "list.subset", "description": ""}, {"name": "list.length_remove_nth", "description": ""}, {"name": "list.partition_eq_filter_filter", "description": ""}, {"name": "list.cons_bind", "description": ""}, {"name": "list.eq_nil_of_length_eq_zero", "description": ""}, {"name": "nat.div_eq_self", "description": ""}, {"name": "nat.bit_lt_bit_iff", "description": ""}, {"name": "nat.bit_add'", "description": ""}, {"name": "nat.succ_le_succ_iff", "description": ""}, {"name": "nat.even_odd_rec_even", "description": ""}, {"name": "nat.pred_sub", "description": ""}, {"name": "nat.succ_eq_one_add", "description": ""}, {"name": "nat.mod_mod_of_dvd", "description": ""}, {"name": "nat.succ_pos'", "description": ""}, {"name": "nat.div_eq_iff_eq_mul_left", "description": ""}, {"name": "nat.semiring", "description": ""}, {"name": "nat.pred_one_add", "description": "This ensures that `simp` succeeds on `pred (n + 1) = n`."}, {"name": "nat.bit1_eq_bit1", "description": ""}, {"name": "nat.mul_ne_mul_left", "description": ""}, {"name": "nat.one_le_div_iff", "description": ""}, {"name": "nat.mul_def", "description": ""}, {"name": "nat.unique_units", "description": ""}, {"name": "nat.pred_le_iff", "description": ""}, {"name": "nat.find_greatest", "description": " `find_greatest P b` is the largest `i \u2264 bound` such that `P i` holds, or `0` if no such `i`\nexists"}, {"name": "nat.not_dvd_of_between_consec_multiples", "description": "`n` is not divisible by `a` if it is between `a * k` and `a * (k + 1)` for some `k`."}, {"name": "nat.max_succ_succ", "description": ""}, {"name": "nat.unique_add_units", "description": ""}, {"name": "nat.bit_cases_on_injective", "description": ""}, {"name": "nat.not_dvd_of_pos_of_lt", "description": ""}, {"name": "nat.linear_ordered_semiring", "description": ""}, {"name": "nat.add_succ_sub_one", "description": ""}, {"name": "nat.le_rec_on_trans", "description": ""}, {"name": "nat.find_greatest_is_greatest", "description": ""}, {"name": "nat.subtype.coe_bot", "description": ""}, {"name": "nat.mul_div_mul_left", "description": "Alias of `nat.mul_div_mul`"}, {"name": "nat.add_succ_lt_add", "description": ""}, {"name": "nat.bit_cases_on_inj", "description": ""}, {"name": "nat.exists_lt_succ", "description": ""}, {"name": "nat.decreasing_induction_succ'", "description": ""}, {"name": "nat.rec_add_one", "description": ""}, {"name": "nat.mul_div_cancel_left'", "description": ""}, {"name": "pos_of_one_lt", "description": ""}, {"name": "nat.sub_mod_eq_zero_of_mod_eq", "description": "If `a` and `b` are equal mod `c`, `a - b` is zero mod `c`."}, {"name": "nat.eq_of_mul_eq_mul_right", "description": ""}, {"name": "nat.find_pos", "description": ""}, {"name": "nat.even_odd_rec", "description": " Recursion principle on even and odd numbers: if we have `P 0`, and for all `i : \u2115` we can\nextend from `P i` to both `P (2 * i)` and `P (2 * i + 1)`, then we have `P n` for all `n : \u2115`.\nThis is nothing more than a wrapper around `nat.binary_rec`, to avoid having to switch to\ndealing with `bit0` and `bit1`."}, {"name": "nat.dvd_add_self_left", "description": "A natural number `m` divides the sum `m + n` if and only if `m` divides `n`."}, {"name": "nat.add_units_eq_zero", "description": ""}, {"name": "nat.find_greatest_of_ne_zero", "description": ""}, {"name": "nat.decreasing_induction_succ", "description": ""}, {"name": "nat.succ_div_of_not_dvd", "description": ""}, {"name": "nat.div_eq_iff_eq_of_dvd_dvd", "description": ""}, {"name": "nat.bit0_mod_two", "description": ""}, {"name": "nat.bit_cases_on_bit", "description": ""}, {"name": "nat.find_mono", "description": ""}, {"name": "nat.div_pos", "description": ""}, {"name": "nat.div2_bit0", "description": ""}, {"name": "nat.decidable_ball_le", "description": ""}, {"name": "nat.succ_mul_pos", "description": ""}, {"name": "nat.dvd_iff_div_mul_eq", "description": ""}, {"name": "nat.two_le_iff", "description": ""}, {"name": "nat.decidable_ball_lt", "description": ""}, {"name": "nat.range_of_succ", "description": ""}, {"name": "nat.two_mul_ne_two_mul_add_one", "description": ""}, {"name": "nat.le_mul_self", "description": ""}, {"name": "nat.linear_ordered_cancel_add_comm_monoid", "description": ""}, {"name": "nat.nsmul_eq_mul", "description": ""}, {"name": "nat.add_comm_monoid", "description": ""}, {"name": "nat.set_induction", "description": "A subset of `\u2115` containing zero and closed under `nat.succ` contains all of `\u2115`."}, {"name": "nat.ordered_comm_semiring", "description": ""}, {"name": "nat.one_le_of_lt", "description": ""}, {"name": "nat.not_dvd_iff_between_consec_multiples", "description": "`n` is not divisible by `a` iff it is between `a * k` and `a * (k + 1)` for some `k`."}, {"name": "nat.add_pos_right", "description": ""}, {"name": "nat.eq_zero_of_le_div", "description": ""}, {"name": "nat.mul_eq_zero", "description": ""}, {"name": "nat.bit1_lt_bit0_iff", "description": ""}, {"name": "nat.one_add_le_iff", "description": ""}, {"name": "nat.set_induction_bounded", "description": "A subset of `\u2115` containing `b : \u2115` and closed under `nat.succ` contains every `n \u2265 b`."}, {"name": "nat.bit1_eq_one", "description": ""}, {"name": "nat.find_greatest_mono_right", "description": ""}, {"name": "nat.eq_of_dvd_of_div_eq_one", "description": ""}, {"name": "nat.mod_mod", "description": ""}, {"name": "nat.mul_div_mul_right", "description": ""}, {"name": "nat.div_le_div_left", "description": ""}, {"name": "nat.find_greatest_succ", "description": ""}, {"name": "nat.le_div_iff_mul_le'", "description": ""}, {"name": "nat.strong_rec_on_beta'", "description": ""}, {"name": "nat.lt_succ_iff", "description": ""}, {"name": "nat.strong_rec_on'", "description": "Recursion principle based on `<` applied to some natural number."}, {"name": "nat.bit_le_bit1_iff", "description": ""}, {"name": "nat.succ_lt_succ_iff", "description": ""}, {"name": "nat.comm_semigroup", "description": ""}, {"name": "nat.le_rec_on'", "description": " Recursion starting at a non-zero number: given a map `C k \u2192 C (k+1)` for each `k \u2265 n`,\nthere is a map from `C n` to each `C m`, `n \u2264 m`."}, {"name": "nat.pred_eq_succ_iff", "description": ""}, {"name": "nat.dvd_one", "description": ""}, {"name": "has_lt.lt.nat_succ_le", "description": ""}, {"name": "nat.ordered_semiring", "description": ""}, {"name": "nat.find_eq_zero", "description": ""}, {"name": "nat.pos_of_bit0_pos", "description": ""}, {"name": "nat.linear_ordered_comm_monoid_with_zero", "description": ""}, {"name": "nat.lt_iff_add_one_le", "description": ""}, {"name": "nat.mul_self_le_mul_self_iff", "description": ""}, {"name": "nat.le_add_one_iff", "description": ""}, {"name": "nat.dvd_add_left", "description": ""}, {"name": "nat.find_lt_iff", "description": ""}, {"name": "nat.add_eq_max_iff", "description": ""}, {"name": "nat.le_mul_of_pos_left", "description": ""}, {"name": "nat.one_lt_succ_succ", "description": ""}, {"name": "nat.mod_div_self", "description": ""}, {"name": "nat.comm_semiring", "description": ""}, {"name": "nat.even_odd_rec_odd", "description": ""}, {"name": "nat.mul_add_mod_of_lt", "description": ""}, {"name": "nat.mod_mul_left_div_self", "description": ""}, {"name": "nat.units_eq_one", "description": ""}, {"name": "nat.eq_zero_of_le_half", "description": ""}, {"name": "nat.strong_sub_recursion", "description": " Given `P : \u2115 \u2192 \u2115 \u2192 Sort*`, if for all `a b : \u2115` we can extend `P` from the rectangle\nstrictly below `(a,b)` to `P a b`, then we have `P n m` for all `n m : \u2115`.\nNote that for non-`Prop` output it is preferable to use the equation compiler directly if possible,\nsince this produces equation lemmas."}, {"name": "nat.le_of_pred_lt", "description": ""}, {"name": "nat.succ_div", "description": ""}, {"name": "nat.bodd_div2_eq", "description": ""}, {"name": "nat.dvd_sub_mod", "description": ""}, {"name": "nat.lt_succ_iff_lt_or_eq", "description": ""}, {"name": "nat.bit1_le", "description": ""}, {"name": "nat.even_odd_rec_zero", "description": ""}, {"name": "nat.div_mul_div_comm", "description": ""}, {"name": "nat.mul_ne_zero", "description": ""}, {"name": "nat.mul_self_lt_mul_self_iff", "description": ""}, {"name": "nat.div_eq_iff_eq_mul_right", "description": ""}, {"name": "nat.mul_mod", "description": ""}, {"name": "nat.le_rec_on_succ_left", "description": ""}, {"name": "nat.find_greatest_eq_iff", "description": ""}, {"name": "nat.le_rec_on", "description": " Recursion starting at a non-zero number: given a map `C k \u2192 C (k+1)` for each `k`,\nthere is a map from `C n` to each `C m`, `n \u2264 m`. For a version where the assumption is only made\nwhen `k \u2265 n`, see `le_rec_on'`."}, {"name": "nat.div_add_mod", "description": ""}, {"name": "nat.le_add_pred_of_pos", "description": ""}, {"name": "nat.pincer_recursion", "description": " Given `P : \u2115 \u2192 \u2115 \u2192 Sort*`, if we have `P i 0` and `P 0 i` for all `i : \u2115`,\nand for any `x y : \u2115` we can extend `P` from `(x,y+1)` and `(x+1,y)` to `(x+1,y+1)`\nthen we have `P n m` for all `n m : \u2115`.\nNote that for non-`Prop` output it is preferable to use the equation compiler directly if possible,\nsince this produces equation lemmas."}, {"name": "nat.find_greatest_eq_zero_iff", "description": ""}, {"name": "nat.le_rec_on_self", "description": ""}, {"name": "nat.add_def", "description": ""}, {"name": "nat.find_le_iff", "description": ""}, {"name": "nat.succ_le_iff", "description": ""}, {"name": "nat.add_mod", "description": ""}, {"name": "nat.mul_self_inj", "description": ""}, {"name": "nat.semigroup", "description": ""}, {"name": "nat.decreasing_induction'", "description": " Decreasing induction: if `P (k+1)` implies `P k` for all `m \u2264 k < n`, then `P n` implies `P m`.\nAlso works for functions to `Sort*`. Weakens the assumptions of `decreasing_induction`."}, {"name": "nat.add_monoid", "description": ""}, {"name": "nat.mul_left_inj", "description": ""}, {"name": "nat.one_eq_bit1", "description": ""}, {"name": "nat.diag_induction", "description": " Given a predicate on two naturals `P : \u2115 \u2192 \u2115 \u2192 Prop`, `P a b` is true for all `a < b` if\n`P (a + 1) (a + 1)` is true for all `a`, `P 0 (b + 1)` is true for all `b` and for all\n`a < b`, `P (a + 1) b` is true and `P a (b + 1)` is true implies `P (a + 1) (b + 1)` is true."}, {"name": "nat.decreasing_induction_self", "description": ""}, {"name": "nat.succ_div_of_dvd", "description": ""}, {"name": "nat.bit_le_bit_iff", "description": ""}, {"name": "nat.le_induction", "description": "Induction principle starting at a non-zero number. For maps to a `Sort*` see `le_rec_on`."}, {"name": "nat.div_lt_div_of_lt_of_dvd", "description": ""}, {"name": "nat.dvd_div_iff", "description": ""}, {"name": "nat.le_and_le_add_one_iff", "description": ""}, {"name": "nat.div_mod_unique", "description": ""}, {"name": "nat.eq_zero_of_dvd_of_div_eq_zero", "description": ""}, {"name": "nat.cancel_comm_monoid_with_zero", "description": ""}, {"name": "nat.bit_lt_bit", "description": ""}, {"name": "nat.eq_zero_of_double_le", "description": ""}, {"name": "nat.not_two_dvd_bit1", "description": ""}, {"name": "nat.bit0_le", "description": ""}, {"name": "nat.bit1_le_bit0_iff", "description": ""}, {"name": "nat.dvd_left_injective", "description": "`dvd` is injective in the left argument"}, {"name": "nat.find_greatest_zero", "description": ""}, {"name": "nat.distrib", "description": ""}, {"name": "nat.bit1_mod_two", "description": ""}, {"name": "nat.pred_eq_self_iff", "description": ""}, {"name": "nat.eq_of_lt_succ_of_not_lt", "description": ""}, {"name": "nat.div_add_mod'", "description": ""}, {"name": "nat.has_ordered_sub", "description": ""}, {"name": "nat.decidable_forall_fin", "description": ""}, {"name": "nat.lt_mul_div_succ", "description": ""}, {"name": "nat.lt_of_div_lt_div", "description": ""}, {"name": "nat.le_rec_on_succ'", "description": ""}, {"name": "nat.div_eq_zero", "description": ""}, {"name": "nat.lt_of_lt_pred", "description": ""}, {"name": "nat.mul_dvd_mul_iff_left", "description": ""}, {"name": "nat.subtype.order_bot", "description": ""}, {"name": "nat.add_mod_eq_ite", "description": ""}, {"name": "nat.range_rec", "description": ""}, {"name": "nat.zero_eq_mul", "description": ""}, {"name": "nat.div_left_inj", "description": ""}, {"name": "nat.succ_add_sub_one", "description": ""}, {"name": "succ_pos''", "description": ""}, {"name": "nat.one_add", "description": ""}, {"name": "nat.mul_self_le_mul_self", "description": ""}, {"name": "nat.strong_rec'", "description": "Recursion principle based on `<`."}, {"name": "nat.dvd_iff_le_div_mul", "description": ""}, {"name": "nat.mul_div_mul_comm_of_dvd_dvd", "description": ""}, {"name": "nat.div_dvd_of_dvd", "description": ""}, {"name": "nat.div_eq_zero_iff", "description": ""}, {"name": "nat.bit_cases_on_bit1", "description": ""}, {"name": "nat.monoid", "description": ""}, {"name": "nat.find_eq_iff", "description": ""}, {"name": "nat.mul_right_inj", "description": ""}, {"name": "nat.decidable_lo_hi_le", "description": ""}, {"name": "nat.dvd_sub'", "description": ""}, {"name": "nat.set_eq_univ", "description": ""}, {"name": "nat.decreasing_induction_succ_left", "description": ""}, {"name": "nat.bodd_bit0", "description": ""}, {"name": "nat.one_lt_bit0_iff", "description": ""}, {"name": "nat.dvd_iff_dvd_dvd", "description": ""}, {"name": "nat.div_le_of_le_mul'", "description": ""}, {"name": "nat.one_lt_iff_ne_zero_and_ne_one", "description": ""}, {"name": "nat.le_zero_iff", "description": ""}, {"name": "nat.div_lt_self'", "description": "A version of `nat.div_lt_self` using successors, rather than additional hypotheses."}, {"name": "nat.find_greatest_mono", "description": ""}, {"name": "nat.exists_eq_add_of_lt", "description": ""}, {"name": "nat.add_eq_min_iff", "description": ""}, {"name": "nat.div_mul_div_le_div", "description": ""}, {"name": "nat.find_greatest_spec", "description": ""}, {"name": "nat.mul_left_injective", "description": ""}, {"name": "nat.eq_zero_of_dvd_of_lt", "description": " If a small natural number is divisible by a larger natural number,\nthe small number is zero."}, {"name": "nat.le_rec_on_injective", "description": ""}, {"name": "nat.bit_cases_on_bit0", "description": ""}, {"name": "nat.one_le_iff_ne_zero", "description": ""}, {"name": "nat.div_le_self'", "description": ""}, {"name": "nat.not_succ_lt_self", "description": ""}, {"name": "nat.eq_of_le_of_lt_succ", "description": ""}, {"name": "nat.forall_lt_succ", "description": ""}, {"name": "nat.decreasing_induction_trans", "description": ""}, {"name": "nat.mod_add_div'", "description": ""}, {"name": "nat.dvd_right_iff_eq", "description": "Two natural numbers are equal if and only if they have the same multiples."}, {"name": "nat.mul_self_lt_mul_self", "description": ""}, {"name": "nat.add_pos_iff_pos_or_pos", "description": ""}, {"name": "nat.decidable_exists_lt", "description": ""}, {"name": "nat.bit0_le_bit", "description": ""}, {"name": "nat.mul_left_eq_self_iff", "description": ""}, {"name": "nat.eq_mul_of_div_eq_right", "description": ""}, {"name": "nat.zero_max", "description": ""}, {"name": "nat.lt_find_iff", "description": ""}, {"name": "nat.mul_right_injective", "description": ""}, {"name": "nat.zero_union_range_succ", "description": ""}, {"name": "nat.add_eq_one_iff", "description": ""}, {"name": "nat.max_eq_zero_iff", "description": ""}, {"name": "nat.add_comm_semigroup", "description": ""}, {"name": "nat.bit0_lt_bit1_iff", "description": ""}, {"name": "nat.canonically_ordered_comm_semiring", "description": ""}, {"name": "nat.div2_bit1", "description": ""}, {"name": "nat.bit_add", "description": ""}, {"name": "nat.two_lt_of_ne", "description": ""}, {"name": "nat.div_div_self", "description": ""}, {"name": "nat.le_find_greatest", "description": ""}, {"name": "nat.div_div_div_eq_div", "description": ""}, {"name": "nat.bit_lt_bit0", "description": ""}, {"name": "nat.mod_mul_right_div_self", "description": ""}, {"name": "nat.succ_ne_succ", "description": ""}, {"name": "nat.range_cases_on", "description": ""}, {"name": "nat.lt_add_one_iff", "description": ""}, {"name": "nat.canonically_linear_ordered_add_monoid", "description": ""}, {"name": "nat.lt_mul_of_div_lt", "description": ""}, {"name": "nat.le_pred_of_lt", "description": ""}, {"name": "nat.succ_injective", "description": ""}, {"name": "nat.two_mul_odd_div_two", "description": ""}, {"name": "nat.le_rec_on_succ", "description": ""}, {"name": "nat.lt_one_iff", "description": ""}, {"name": "nat.lt_one_add_iff", "description": ""}, {"name": "nat.add_pos_left", "description": ""}, {"name": "nat.subtype.semilattice_sup", "description": ""}, {"name": "nat.pred_eq_sub_one", "description": ""}, {"name": "nat.decidable_lo_hi", "description": ""}, {"name": "nat.div_eq_sub_mod_div", "description": ""}, {"name": "nat.bit_le_bit1", "description": ""}, {"name": "nat.dvd_left_iff_eq", "description": "Two natural numbers are equal if and only if they have the same divisors."}, {"name": "nat.find_greatest_mono_left", "description": ""}, {"name": "nat.bit_ne_zero", "description": ""}, {"name": "nat.div_le_iff_le_mul_add_pred", "description": ""}, {"name": "nat.dvd_add_self_right", "description": "A natural number `m` divides the sum `n + m` if and only if `m` divides `n`."}, {"name": "nat.dvd_add_right", "description": ""}, {"name": "nat.sub_succ'", "description": "A version of `nat.sub_succ` in the form `_ - 1` instead of `nat.pred _`."}, {"name": "nat.dvd_div_of_mul_dvd", "description": ""}, {"name": "nat.add_mod_mod", "description": ""}, {"name": "nat.mul_dvd_of_dvd_div", "description": ""}, {"name": "nat.div_lt_of_lt_mul", "description": ""}, {"name": "nat.mul_right_eq_self_iff", "description": ""}, {"name": "nat.one_mod", "description": ""}, {"name": "nat.add_semigroup", "description": ""}, {"name": "nat.decidable_exists_le", "description": ""}, {"name": "nat.mul_dvd_mul_iff_right", "description": ""}, {"name": "nat.find_greatest_of_not", "description": ""}, {"name": "nat.bodd_bit1", "description": ""}, {"name": "nat.find_greatest_le", "description": ""}, {"name": "nat.succ_inj'", "description": ""}, {"name": "nat.add_mod_eq_add_mod_left", "description": ""}, {"name": "nat.order_bot", "description": ""}, {"name": "nat.min_eq_zero_iff", "description": ""}, {"name": "nat.div_lt_iff_lt_mul'", "description": ""}, {"name": "nat.mul_div_le", "description": ""}, {"name": "nat.bit0_eq_bit0", "description": ""}, {"name": "nat.le_or_le_of_add_eq_add_pred", "description": ""}, {"name": "nat.mod_add_mod", "description": ""}, {"name": "nat.le_rec_on_surjective", "description": ""}, {"name": "nat.find_add", "description": ""}, {"name": "nat.bit_le", "description": ""}, {"name": "nat.bit0_le_bit1_iff", "description": ""}, {"name": "nat.exists_eq_add_of_le", "description": ""}, {"name": "nat.eq_one_of_mul_eq_one_left", "description": ""}, {"name": "nat.eq_zero_of_mul_le", "description": ""}, {"name": "nat.lt_iff_le_pred", "description": ""}, {"name": "nat.is_unit_iff", "description": ""}, {"name": "nat.find_comp_succ", "description": ""}, {"name": "nat.find_le", "description": ""}, {"name": "nat.eq_one_of_mul_eq_one_right", "description": ""}, {"name": "nat.mul_ne_mul_right", "description": ""}, {"name": "nat.le_find_iff", "description": ""}, {"name": "nat.find_greatest_eq", "description": ""}, {"name": "nat.lt_pred_iff", "description": ""}, {"name": "nat.of_le_succ", "description": ""}, {"name": "nat.add_mod_eq_add_mod_right", "description": ""}, {"name": "nat.mul_eq_one_iff", "description": ""}, {"name": "nat.lt_div_mul_add", "description": ""}, {"name": "nat.nontrivial", "description": ""}, {"name": "nat.div_lt_one_iff", "description": ""}, {"name": "nat.lt_div_iff_mul_lt", "description": ""}, {"name": "nat.one_le_bit0_iff", "description": ""}, {"name": "nat.le_mul_of_pos_right", "description": ""}, {"name": "nat.add_one_le_iff", "description": ""}, {"name": "nat.pred_eq_of_eq_succ", "description": ""}, {"name": "nat.eq_mul_of_div_eq_left", "description": ""}, {"name": "nat.rec_zero", "description": ""}, {"name": "nat.div_le_div_right", "description": ""}, {"name": "nat.succ_succ_ne_one", "description": ""}, {"name": "nat.decreasing_induction", "description": " Decreasing induction: if `P (k+1)` implies `P k`, then `P n` implies `P m` for all `m \u2264 n`.\nAlso works for functions to `Sort*`. For a version assuming only the assumption for `k < n`, see\n`decreasing_induction'`."}, {"name": "nat.mul_div_le_mul_div_assoc", "description": ""}, {"name": "nat.comm_monoid", "description": ""}, {"name": "nat.mul_add_mod", "description": ""}, {"name": "sub_lt_zero", "description": "**Alias** of `sub_neg`."}, {"name": "div_le_div_iff_left", "description": ""}, {"name": "lt_add_of_sub_right_lt", "description": "**Alias** of the forward direction of `sub_lt_iff_lt_add`."}, {"name": "neg_lt_sub_iff_lt_add", "description": ""}, {"name": "div_le_div_left'", "description": ""}, {"name": "mul_inv_le_one_iff_le", "description": ""}, {"name": "add_neg_lt_add_neg_iff", "description": ""}, {"name": "neg_lt_of_abs_lt", "description": ""}, {"name": "abs_sub_lt_iff", "description": ""}, {"name": "neg_add_neg_iff_lt", "description": ""}, {"name": "ordered_comm_group.to_comm_group", "description": ""}, {"name": "min_neg_neg", "description": ""}, {"name": "div_lt_self_iff", "description": ""}, {"name": "right.one_lt_inv_iff", "description": "Uses `right` co(ntra)variant."}, {"name": "add_lt_of_lt_neg_add", "description": "**Alias** of the forward direction of `lt_inv_mul_iff_mul_lt`."}, {"name": "left.self_le_neg", "description": ""}, {"name": "order_dual.linear_ordered_comm_group", "description": ""}, {"name": "order_iso.add_right_apply", "description": ""}, {"name": "ordered_comm_group.mul_lt_mul_left'", "description": "**Alias** of `mul_lt_mul_left'`."}, {"name": "order_iso.mul_left_to_equiv", "description": ""}, {"name": "lt_inv_mul_iff_lt", "description": ""}, {"name": "neg_le_neg_iff", "description": ""}, {"name": "ordered_add_comm_group.to_ordered_cancel_add_comm_monoid", "description": ""}, {"name": "sub_right_lt_of_lt_add", "description": "**Alias** of the reverse direction of `sub_lt_iff_lt_add`."}, {"name": "monotone.neg", "description": ""}, {"name": "abs_nonpos_iff", "description": ""}, {"name": "left.self_lt_neg", "description": ""}, {"name": "right.neg_nonpos_iff", "description": ""}, {"name": "abs_add_three", "description": ""}, {"name": "sub_lt", "description": ""}, {"name": "le_of_forall_one_lt_div_le", "description": ""}, {"name": "left.inv_lt_self", "description": ""}, {"name": "le_add_of_sub_left_le", "description": "**Alias** of the forward direction of `sub_le_iff_le_add'`."}, {"name": "function.injective.ordered_add_comm_group", "description": "Pullback an `ordered_add_comm_group` under an injective map."}, {"name": "abs_of_pos", "description": ""}, {"name": "order_dual.comm_group_with_zero", "description": ""}, {"name": "linear_ordered_comm_group.mul_lt_mul_left'", "description": ""}, {"name": "inv_lt_one'", "description": "**Alias** of `left.inv_lt_one_iff`."}, {"name": "div_lt_one'", "description": ""}, {"name": "apply_abs_le_add_of_nonneg", "description": ""}, {"name": "add_neg_neg_iff", "description": ""}, {"name": "inv_lt_div_iff_lt_mul", "description": ""}, {"name": "abs_sub_le", "description": ""}, {"name": "neg_add_lt_of_lt_add", "description": "**Alias** of the reverse direction of `inv_mul_lt_iff_lt_mul`."}, {"name": "left.neg_nonpos_iff", "description": ""}, {"name": "order_iso.mul_right_apply", "description": ""}, {"name": "lt_inv_iff_mul_lt_one", "description": ""}, {"name": "ordered_add_comm_group.has_exists_add_of_le", "description": ""}, {"name": "neg_add_nonpos_iff", "description": ""}, {"name": "apply_abs_le_mul_of_one_le'", "description": ""}, {"name": "div_le_div_iff_right", "description": ""}, {"name": "le_inv_mul_of_mul_le", "description": "**Alias** of the reverse direction of `le_inv_mul_iff_mul_le`."}, {"name": "neg_lt_iff_pos_add", "description": ""}, {"name": "le_of_forall_one_lt_le_mul", "description": ""}, {"name": "lt_div''", "description": ""}, {"name": "sub_le_sub_iff_right", "description": ""}, {"name": "monotone_on.inv", "description": ""}, {"name": "min_inv_inv'", "description": ""}, {"name": "inv_lt_one_iff_one_lt", "description": "**Alias** of `left.inv_lt_one_iff`."}, {"name": "sub_le_sub_iff_left", "description": ""}, {"name": "sub_le_self_iff", "description": ""}, {"name": "inv_le_div_iff_le_mul'", "description": ""}, {"name": "order_dual.has_sub", "description": ""}, {"name": "linear_ordered_add_comm_group.add_lt_add_left", "description": ""}, {"name": "mul_inv_lt_iff_le_mul'", "description": ""}, {"name": "neg_le_abs_self", "description": ""}, {"name": "le_of_forall_one_lt_lt_mul", "description": ""}, {"name": "order_dual.has_involutive_neg", "description": ""}, {"name": "left.one_lt_inv_iff", "description": "Uses `left` co(ntra)variant."}, {"name": "order_dual.add_comm_group", "description": ""}, {"name": "le_sub", "description": ""}, {"name": "ordered_add_comm_group.add_lt_add_left", "description": "**Alias** of `mul_lt_mul_left'`."}, {"name": "linear_ordered_comm_group", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.mul", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.mul_assoc", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.one", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.one_mul", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.mul_one", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.npow", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.npow_zero'", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.npow_succ'", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.inv", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.div", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.div_eq_mul_inv", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.zpow", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.zpow_zero'", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.zpow_succ'", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.zpow_neg'", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.mul_left_inv", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.mul_comm", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.le", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.lt", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.le_refl", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.le_trans", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.lt_iff_le_not_le", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.le_antisymm", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.mul_le_mul_left", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.le_total", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.decidable_le", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.decidable_eq", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.decidable_lt", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.max", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.max_def", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.min", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "linear_ordered_comm_group.min_def", "description": " A linearly ordered commutative group is a\ncommutative group with a linear order in which\nmultiplication is monotone."}, {"name": "abs_pos", "description": ""}, {"name": "sub_le_sub_flip", "description": ""}, {"name": "sub_le_sub_left", "description": ""}, {"name": "abs_eq_zero", "description": ""}, {"name": "sub_left_le_of_le_add", "description": "**Alias** of the reverse direction of `sub_le_iff_le_add'`."}, {"name": "order_iso.neg_apply", "description": ""}, {"name": "max_zero_sub_max_neg_zero_eq_self", "description": ""}, {"name": "add_abs_nonneg", "description": ""}, {"name": "le_of_forall_pos_sub_le", "description": ""}, {"name": "le_div_iff_mul_le", "description": ""}, {"name": "div_lt_div_right'", "description": ""}, {"name": "div_lt_div_iff'", "description": ""}, {"name": "ordered_add_comm_group.to_partial_order", "description": ""}, {"name": "exists_one_lt'", "description": ""}, {"name": "max_div_div_right'", "description": ""}, {"name": "lt_add_neg_iff_add_lt", "description": ""}, {"name": "add_le_of_le_neg_add", "description": "**Alias** of the forward direction of `le_inv_mul_iff_mul_le`."}, {"name": "div_lt_div''", "description": ""}, {"name": "le_of_forall_lt_one_mul_le", "description": ""}, {"name": "abs_le'", "description": ""}, {"name": "lt_mul_inv_iff_lt", "description": ""}, {"name": "order_iso.mul_left_symm", "description": ""}, {"name": "sub_le_iff_le_add'", "description": ""}, {"name": "le_neg_of_le_neg", "description": "**Alias** of the forward direction of `le_inv'`."}, {"name": "le_of_neg_le_neg", "description": "**Alias** of the forward direction of `neg_le_neg_iff`."}, {"name": "div_lt_div_iff_left", "description": ""}, {"name": "le_sub_iff_add_le'", "description": ""}, {"name": "inv_mul_le_of_le_mul", "description": "**Alias** of the reverse direction of `inv_mul_le_iff_le_mul`."}, {"name": "sub_le_of_abs_sub_le_left", "description": ""}, {"name": "sub_le_sub_iff", "description": ""}, {"name": "sub_le", "description": ""}, {"name": "abs_le_max_abs_abs", "description": ""}, {"name": "min_div_div_right'", "description": ""}, {"name": "max_div_div_left'", "description": ""}, {"name": "function.injective.linear_ordered_comm_group", "description": " Pullback a `linear_ordered_comm_group` under an injective map.\nSee note [reducible non-instances]."}, {"name": "sub_nonneg", "description": ""}, {"name": "left.self_lt_inv", "description": ""}, {"name": "inv_lt_div_iff_lt_mul'", "description": ""}, {"name": "linear_ordered_add_comm_group.to_linear_order", "description": ""}, {"name": "max_sub_sub_left", "description": ""}, {"name": "right.nonneg_neg_iff", "description": ""}, {"name": "add_units.ordered_add_comm_group", "description": "The units of an ordered commutative additive monoid form an ordered commutative\nadditive group."}, {"name": "left.neg_le_self", "description": ""}, {"name": "inv_lt_of_inv_lt'", "description": "**Alias** of the forward direction of `inv_lt'`."}, {"name": "div_lt''", "description": ""}, {"name": "neg_nonpos", "description": "**Alias** of `left.inv_le_one_iff`."}, {"name": "ordered_add_comm_group", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.add", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.add_assoc", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.zero", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.zero_add", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.add_zero", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.nsmul", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.nsmul_zero'", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.nsmul_succ'", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.neg", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.sub", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.sub_eq_add_neg", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.zsmul", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.zsmul_zero'", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.zsmul_succ'", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.zsmul_neg'", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.add_left_neg", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.add_comm", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.le", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.lt", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.le_refl", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.le_trans", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.lt_iff_le_not_le", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.le_antisymm", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "ordered_add_comm_group.add_le_add_left", "description": " An ordered additive commutative group is an additive commutative group\nwith a partial order in which addition is strictly monotone."}, {"name": "order_dual.has_div", "description": ""}, {"name": "neg_le_of_abs_le", "description": ""}, {"name": "le_iff_forall_pos_le_add", "description": ""}, {"name": "neg_le_sub_iff_le_add", "description": ""}, {"name": "right.self_lt_inv", "description": ""}, {"name": "order_iso.neg_symm_apply", "description": ""}, {"name": "linear_ordered_add_comm_group_with_top.to_sub_neg_monoid", "description": ""}, {"name": "neg_pos", "description": "**Alias** of `left.one_lt_inv_iff`."}, {"name": "abs_eq_max_neg", "description": ""}, {"name": "order_iso.add_left_to_equiv", "description": ""}, {"name": "linear_ordered_comm_group.to_no_min_order", "description": ""}, {"name": "mul_inv_lt_iff_lt_mul", "description": ""}, {"name": "le_mul_inv_iff_mul_le", "description": ""}, {"name": "inv_lt_inv_iff", "description": ""}, {"name": "with_top.coe_neg", "description": ""}, {"name": "inv_lt_iff_one_lt_mul", "description": ""}, {"name": "lt_add_of_neg_add_lt_left", "description": "**Alias** of `lt_mul_of_inv_mul_lt`."}, {"name": "linear_ordered_add_comm_group.to_linear_ordered_cancel_add_comm_monoid", "description": ""}, {"name": "max_sub_min_eq_abs'", "description": ""}, {"name": "ordered_add_comm_group.le_of_add_le_add_left", "description": "**Alias** of `le_of_mul_le_mul_left'`."}, {"name": "add_comm_group.total_positive_cone.to_positive_cone", "description": "Forget that a `total_positive_cone` is total."}, {"name": "neg_lt_neg", "description": ""}, {"name": "mul_inv_lt_inv_mul_iff", "description": ""}, {"name": "sub_lt_iff_lt_add", "description": ""}, {"name": "le_abs", "description": ""}, {"name": "linear_ordered_comm_group.to_ordered_comm_group", "description": ""}, {"name": "le_of_abs_le", "description": ""}, {"name": "lt_inv_mul_iff_mul_lt", "description": ""}, {"name": "sub_lt_of_abs_sub_lt_right", "description": ""}, {"name": "div_le_iff_le_mul'", "description": ""}, {"name": "order_dual.div_inv_monoid", "description": ""}, {"name": "le_iff_forall_pos_lt_add", "description": ""}, {"name": "inv_le_iff_one_le_mul", "description": ""}, {"name": "le_inv_of_le_inv", "description": "**Alias** of the forward direction of `le_inv'`."}, {"name": "inv_le_one_of_one_le", "description": ""}, {"name": "ordered_add_comm_group.to_add_comm_group", "description": ""}, {"name": "sub_neg", "description": ""}, {"name": "neg_lt_sub_iff_lt_add'", "description": ""}, {"name": "inv_le_iff_one_le_mul'", "description": ""}, {"name": "left.neg_neg_iff", "description": ""}, {"name": "lt_neg_add_iff_lt", "description": ""}, {"name": "order_dual.ordered_add_comm_group", "description": ""}, {"name": "div_le_self_iff", "description": ""}, {"name": "order_dual.group_with_zero", "description": ""}, {"name": "abs_lt", "description": ""}, {"name": "sub_lt_sub_iff_right", "description": ""}, {"name": "le_neg_add_iff_le", "description": ""}, {"name": "neg_le_self", "description": "**Alias** of `left.neg_le_self`."}, {"name": "neg_neg_iff_pos", "description": "**Alias** of `left.inv_lt_one_iff`."}, {"name": "le_of_forall_neg_add_le", "description": ""}, {"name": "le_iff_forall_one_lt_lt_mul", "description": ""}, {"name": "inv_lt_iff_one_lt_mul'", "description": ""}, {"name": "abs_add", "description": "The **triangle inequality** in `linear_ordered_add_comm_group`s."}, {"name": "lt_inv_iff_mul_lt_one'", "description": ""}, {"name": "left.nonneg_neg_iff", "description": ""}, {"name": "order_iso.add_left_apply", "description": ""}, {"name": "left.neg_pos_iff", "description": ""}, {"name": "max_zero_sub_eq_self", "description": "**Alias** of `max_zero_sub_max_neg_zero_eq_self`."}, {"name": "ordered_add_comm_group.mk_of_positive_cone", "description": " Construct an `ordered_add_comm_group` by\ndesignating a positive cone in an existing `add_comm_group`."}, {"name": "min_sub_sub_right", "description": ""}, {"name": "strict_anti_on.inv", "description": ""}, {"name": "add_neg_nonpos_iff_le", "description": ""}, {"name": "order_iso.add_right_symm", "description": ""}, {"name": "order_iso.add_left_symm", "description": ""}, {"name": "ordered_comm_group.le_of_mul_le_mul_left", "description": "**Alias** of `le_of_mul_le_mul_left'`."}, {"name": "antitone.inv", "description": ""}, {"name": "abs_nonneg", "description": ""}, {"name": "order_iso.add_left", "description": "`equiv.add_left` as an `order_iso`. See also `order_embedding.add_left`."}, {"name": "order_dual.has_neg", "description": ""}, {"name": "order_dual.linear_ordered_add_comm_group", "description": ""}, {"name": "order_dual.group", "description": ""}, {"name": "neg_le_neg", "description": ""}, {"name": "lt_inv_mul_of_mul_lt", "description": "**Alias** of the reverse direction of `lt_inv_mul_iff_mul_lt`."}, {"name": "ordered_comm_group.lt_of_mul_lt_mul_left", "description": "**Alias** of `lt_of_mul_lt_mul_left'`."}, {"name": "right.neg_pos_iff", "description": "Uses `right` co(ntra)variant."}, {"name": "right.neg_neg_iff", "description": "Uses `right` co(ntra)variant."}, {"name": "mul_inv_le_iff_le_mul", "description": ""}, {"name": "lt_of_inv_lt_inv", "description": "**Alias** of the forward direction of `inv_lt_inv_iff`."}, {"name": "add_le_of_le_sub_left", "description": "**Alias** of the forward direction of `le_sub_iff_add_le'`."}, {"name": "sub_pos", "description": ""}, {"name": "add_le_of_le_sub_right", "description": "**Alias** of the forward direction of `le_sub_iff_add_le`."}, {"name": "lt_neg_iff_add_neg'", "description": ""}, {"name": "abs_of_neg", "description": ""}, {"name": "has_neg.to_has_abs", "description": "`abs a` is the absolute value of `a`"}, {"name": "sub_lt_sub_iff", "description": ""}, {"name": "le_one_of_one_le_inv", "description": "**Alias** of the forward direction of `left.one_le_inv_iff`."}, {"name": "order_iso.mul_right_to_equiv", "description": ""}, {"name": "mul_lt_of_lt_inv_mul", "description": "**Alias** of the forward direction of `lt_inv_mul_iff_mul_lt`."}, {"name": "lt_of_sub_pos", "description": "**Alias** of the forward direction of `sub_pos`."}, {"name": "abs_eq_sup_inv", "description": ""}, {"name": "inv_le_inv_iff", "description": ""}, {"name": "order_iso.inv", "description": "`x \u21a6 x\u207b\u00b9` as an order-reversing equivalence."}, {"name": "prod.ordered_comm_group", "description": ""}, {"name": "order_iso.inv_apply", "description": ""}, {"name": "le_sub_left_of_add_le", "description": "**Alias** of the reverse direction of `le_sub_iff_add_le'`."}, {"name": "linear_ordered_add_comm_group.mk_of_positive_cone", "description": " Construct a `linear_ordered_add_comm_group` by\ndesignating a positive cone in an existing `add_comm_group`\nsuch that for every `a`, either `a` or `-a` is non-negative."}, {"name": "neg_of_neg_pos", "description": "**Alias** of the forward direction of `left.one_lt_inv_iff`."}, {"name": "inv_mul_le_iff_le_mul'", "description": ""}, {"name": "lt_abs", "description": ""}, {"name": "eq_zero_of_neg_eq", "description": ""}, {"name": "sub_lt_self", "description": "**Alias** of the reverse direction of `sub_lt_self_iff`."}, {"name": "le_inv_iff_mul_le_one_left", "description": ""}, {"name": "right.self_le_neg", "description": ""}, {"name": "inv_lt_inv'", "description": ""}, {"name": "order_dual.comm_group", "description": ""}, {"name": "order_iso.mul_left_apply", "description": ""}, {"name": "neg_abs_le_neg", "description": ""}, {"name": "sub_le_sub_right", "description": ""}, {"name": "mul_inv_le_one_iff", "description": ""}, {"name": "abs_neg", "description": ""}, {"name": "right.neg_lt_self", "description": ""}, {"name": "mul_inv_le_inv_mul_iff", "description": ""}, {"name": "sub_le_iff_le_add", "description": ""}, {"name": "inv_lt_one_of_one_lt", "description": ""}, {"name": "inv_mul_lt_one_iff_lt", "description": ""}, {"name": "monotone.inv", "description": ""}, {"name": "neg_nonpos_of_nonneg", "description": ""}, {"name": "sub_lt_of_abs_sub_lt_left", "description": ""}, {"name": "has_inv.to_has_abs", "description": "`abs a` is the absolute value of `a`."}, {"name": "lt_div_iff_mul_lt'", "description": ""}, {"name": "right.self_lt_neg", "description": ""}, {"name": "right.neg_le_self", "description": ""}, {"name": "additive.ordered_add_comm_group", "description": ""}, {"name": "strict_mono_on.neg", "description": ""}, {"name": "abs_eq", "description": ""}, {"name": "one_lt_inv_of_inv", "description": "**Alias** of the reverse direction of `left.one_lt_inv_iff`."}, {"name": "div_le_div_flip", "description": ""}, {"name": "one_lt_of_inv_lt_one", "description": "**Alias** of the forward direction of `left.inv_lt_one_iff`."}, {"name": "add_group.to_has_ordered_sub", "description": ""}, {"name": "linear_ordered_add_comm_group_with_top", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.le", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.lt", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.le_refl", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.le_trans", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.lt_iff_le_not_le", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.le_antisymm", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.le_total", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.decidable_le", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.decidable_eq", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.decidable_lt", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.max", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.max_def", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.min", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.min_def", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.add", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.add_assoc", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.zero", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.zero_add", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.add_zero", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.nsmul", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.nsmul_zero'", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.nsmul_succ'", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.add_comm", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.add_le_add_left", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.top", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.le_top", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.top_add'", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.neg", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.sub", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.sub_eq_add_neg", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.zsmul", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.zsmul_zero'", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.zsmul_succ'", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.zsmul_neg'", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.exists_pair_ne", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.neg_top", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_group_with_top.add_neg_cancel", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "neg_lt", "description": ""}, {"name": "neg_lt_self", "description": "**Alias** of `left.neg_lt_self`."}, {"name": "sub_lt_sub_left", "description": ""}, {"name": "inv_mul_le_iff_le_mul", "description": ""}, {"name": "abs_zero", "description": ""}, {"name": "left.neg_lt_self", "description": ""}, {"name": "inv_le_one'", "description": "**Alias** of `left.inv_le_one_iff`."}, {"name": "strict_mono_on.inv", "description": ""}, {"name": "max_sub_min_eq_abs", "description": ""}, {"name": "antitone_on.neg", "description": ""}, {"name": "with_top.linear_ordered_add_comm_group_with_top", "description": ""}, {"name": "neg_le_sub_iff_le_add'", "description": ""}, {"name": "linear_ordered_add_comm_group.to_no_max_order", "description": ""}, {"name": "left.inv_lt_one_iff", "description": "Uses `left` co(ntra)variant."}, {"name": "lt_add_of_neg_add_lt", "description": "**Alias** of the forward direction of `inv_mul_lt_iff_lt_mul`."}, {"name": "function.injective.linear_ordered_add_comm_group", "description": "Pullback a `linear_ordered_add_comm_group` under an injective map."}, {"name": "le_neg_add_iff_add_le", "description": ""}, {"name": "right.self_le_inv", "description": ""}, {"name": "eq_or_eq_neg_of_abs_eq", "description": ""}, {"name": "order_dual.add_group", "description": ""}, {"name": "left.self_le_inv", "description": ""}, {"name": "le_neg_iff_add_nonpos_right", "description": ""}, {"name": "antitone.neg", "description": ""}, {"name": "mul_le_of_le_inv_mul", "description": "**Alias** of the forward direction of `le_inv_mul_iff_mul_le`."}, {"name": "inv_mul_lt_one_iff", "description": ""}, {"name": "additive.linear_ordered_add_comm_group", "description": ""}, {"name": "lt_sub_iff_add_lt", "description": ""}, {"name": "sub_left_lt_of_lt_add", "description": "**Alias** of the reverse direction of `sub_lt_iff_lt_add'`."}, {"name": "div_lt_div_left'", "description": ""}, {"name": "div_le''", "description": ""}, {"name": "sub_lt_self_iff", "description": ""}, {"name": "right.inv_lt_one_iff", "description": "Uses `right` co(ntra)variant."}, {"name": "lt_mul_inv_iff_mul_lt", "description": ""}, {"name": "neg_pos_of_neg", "description": "**Alias** of the reverse direction of `left.one_lt_inv_iff`."}, {"name": "neg_le", "description": ""}, {"name": "abs_choice", "description": ""}, {"name": "abs_max_sub_max_le_max", "description": ""}, {"name": "strict_anti.neg", "description": ""}, {"name": "max_inv_inv'", "description": ""}, {"name": "order_dual.ordered_comm_group", "description": ""}, {"name": "add_lt_of_lt_sub_right", "description": "**Alias** of the forward direction of `lt_sub_iff_add_lt`."}, {"name": "abs_pos_of_neg", "description": ""}, {"name": "eq_one_of_inv_eq'", "description": ""}, {"name": "min_div_div_left'", "description": ""}, {"name": "le_abs_self", "description": ""}, {"name": "order_dual.division_monoid", "description": ""}, {"name": "abs_add'", "description": ""}, {"name": "mul_inv_lt_one_iff", "description": ""}, {"name": "div_le_one'", "description": ""}, {"name": "sub_lt_sub_iff_left", "description": ""}, {"name": "abs_of_nonneg", "description": ""}, {"name": "add_neg_le_iff_le_add", "description": ""}, {"name": "linear_ordered_add_comm_group.to_ordered_add_comm_group", "description": ""}, {"name": "sub_le_of_abs_sub_le_right", "description": ""}, {"name": "lt_neg_of_lt_neg", "description": "**Alias** of the forward direction of `lt_inv'`."}, {"name": "le_sub_right_of_add_le", "description": "**Alias** of the reverse direction of `le_sub_iff_add_le`."}, {"name": "le_inv_mul_iff_le", "description": ""}, {"name": "add_neg_lt_iff_le_add'", "description": ""}, {"name": "strict_mono.inv", "description": ""}, {"name": "neg_add_lt_iff_lt_add'", "description": ""}, {"name": "le_inv_mul_iff_mul_le", "description": ""}, {"name": "lt_inv'", "description": ""}, {"name": "neg_lt_of_neg_lt", "description": "**Alias** of the forward direction of `inv_lt'`."}, {"name": "ordered_comm_group", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.mul", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.mul_assoc", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.one", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.one_mul", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.mul_one", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.npow", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.npow_zero'", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.npow_succ'", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.inv", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.div", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.div_eq_mul_inv", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.zpow", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.zpow_zero'", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.zpow_succ'", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.zpow_neg'", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.mul_left_inv", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.mul_comm", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.le", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.lt", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.le_refl", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.le_trans", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.lt_iff_le_not_le", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.le_antisymm", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "ordered_comm_group.mul_le_mul_left", "description": " An ordered commutative group is an commutative group\nwith a partial order in which multiplication is strictly monotone."}, {"name": "linear_ordered_comm_group.to_no_max_order", "description": ""}, {"name": "monotone_on.neg", "description": ""}, {"name": "div_lt_iff_lt_mul", "description": ""}, {"name": "abs_by_cases", "description": ""}, {"name": "add_neg_nonpos_iff", "description": ""}, {"name": "one_le_inv'", "description": "**Alias** of `left.one_le_inv_iff`."}, {"name": "neg_lt_zero", "description": "**Alias** of `left.inv_lt_one_iff`."}, {"name": "inv_mul_lt_of_lt_mul", "description": "**Alias** of the reverse direction of `inv_mul_lt_iff_lt_mul`."}, {"name": "le_sub_self_iff", "description": ""}, {"name": "add_comm_group.total_positive_cone", "description": " A positive cone in an `add_comm_group` induces a linear order if\nfor every `a`, either `a` or `-a` is non-negative."}, {"name": "add_comm_group.total_positive_cone.nonneg", "description": " A positive cone in an `add_comm_group` induces a linear order if\nfor every `a`, either `a` or `-a` is non-negative."}, {"name": "add_comm_group.total_positive_cone.pos", "description": " A positive cone in an `add_comm_group` induces a linear order if\nfor every `a`, either `a` or `-a` is non-negative."}, {"name": "add_comm_group.total_positive_cone.pos_iff", "description": " A positive cone in an `add_comm_group` induces a linear order if\nfor every `a`, either `a` or `-a` is non-negative."}, {"name": "add_comm_group.total_positive_cone.zero_nonneg", "description": " A positive cone in an `add_comm_group` induces a linear order if\nfor every `a`, either `a` or `-a` is non-negative."}, {"name": "add_comm_group.total_positive_cone.add_nonneg", "description": " A positive cone in an `add_comm_group` induces a linear order if\nfor every `a`, either `a` or `-a` is non-negative."}, {"name": "add_comm_group.total_positive_cone.nonneg_antisymm", "description": " A positive cone in an `add_comm_group` induces a linear order if\nfor every `a`, either `a` or `-a` is non-negative."}, {"name": "add_comm_group.total_positive_cone.nonneg_decidable", "description": " A positive cone in an `add_comm_group` induces a linear order if\nfor every `a`, either `a` or `-a` is non-negative."}, {"name": "add_comm_group.total_positive_cone.nonneg_total", "description": " A positive cone in an `add_comm_group` induces a linear order if\nfor every `a`, either `a` or `-a` is non-negative."}, {"name": "ordered_add_comm_group.lt_of_add_lt_add_left", "description": "**Alias** of `lt_of_mul_lt_mul_left'`."}, {"name": "exists_zero_lt", "description": ""}, {"name": "ordered_comm_group.to_partial_order", "description": ""}, {"name": "sub_le_neg_add_iff", "description": ""}, {"name": "neg_lt_neg_iff", "description": ""}, {"name": "lt_sub_right_of_add_lt", "description": "**Alias** of the reverse direction of `lt_sub_iff_add_lt`."}, {"name": "le_add_neg_iff_le", "description": ""}, {"name": "lt_mul_of_inv_mul_lt_left", "description": "**Alias** of `lt_mul_of_inv_mul_lt`."}, {"name": "inv_mul_le_one_iff", "description": ""}, {"name": "linear_ordered_add_comm_group_with_top.to_linear_ordered_add_comm_monoid_with_top", "description": ""}, {"name": "linear_ordered_add_comm_group.to_no_min_order", "description": ""}, {"name": "max_one_div_max_inv_one_eq_self", "description": ""}, {"name": "abs_abs", "description": ""}, {"name": "le_iff_forall_neg_add_le", "description": ""}, {"name": "order_iso.mul_left", "description": "`equiv.mul_left` as an `order_iso`. See also `order_embedding.mul_left`."}, {"name": "le_neg", "description": ""}, {"name": "le_div''", "description": ""}, {"name": "le_inv'", "description": ""}, {"name": "abs_pos_of_pos", "description": ""}, {"name": "le_neg_iff_add_nonpos_left", "description": ""}, {"name": "div_le_div''", "description": ""}, {"name": "eq_of_abs_sub_eq_zero", "description": ""}, {"name": "nonpos_of_neg_nonneg", "description": "**Alias** of the forward direction of `left.one_le_inv_iff`."}, {"name": "right.inv_le_one_iff", "description": "Uses `right` co(ntra)variant."}, {"name": "mul_inv_lt_mul_inv_iff'", "description": ""}, {"name": "lt_of_neg_lt_neg", "description": "**Alias** of the forward direction of `inv_lt_inv_iff`."}, {"name": "sub_pos_of_lt", "description": "**Alias** of the reverse direction of `sub_pos`."}, {"name": "inv_le_div_iff_le_mul", "description": ""}, {"name": "left.inv_le_self", "description": ""}, {"name": "one_le_inv_of_le_one", "description": ""}, {"name": "lt_add_neg_iff_lt", "description": ""}, {"name": "le_iff_forall_lt_one_mul_le", "description": ""}, {"name": "le_of_forall_pos_lt_add", "description": ""}, {"name": "lt_div_iff_mul_lt", "description": ""}, {"name": "dist_bdd_within_interval", "description": ""}, {"name": "pos_of_neg_neg", "description": "**Alias** of the forward direction of `left.inv_lt_one_iff`."}, {"name": "one_le_of_inv_le_one", "description": "**Alias** of the forward direction of `left.inv_le_one_iff`."}, {"name": "order_iso.add_right", "description": "`equiv.add_right` as an `order_iso`. See also `order_embedding.add_right`."}, {"name": "lt_neg_add_iff_add_lt", "description": ""}, {"name": "le_sub_iff_add_le", "description": ""}, {"name": "antitone_on.inv", "description": ""}, {"name": "strict_anti_on.neg", "description": ""}, {"name": "sub_nonpos_of_le", "description": "**Alias** of the reverse direction of `sub_nonpos`."}, {"name": "order_iso.mul_right_symm", "description": ""}, {"name": "sub_le_sub", "description": ""}, {"name": "order_dual.has_involutive_inv", "description": ""}, {"name": "lt_neg", "description": ""}, {"name": "max_sub_sub_right", "description": ""}, {"name": "apply_abs_le_add_of_nonneg'", "description": ""}, {"name": "inv_le'", "description": ""}, {"name": "sub_nonpos", "description": ""}, {"name": "sub_le_self", "description": "**Alias** of the reverse direction of `sub_le_self_iff`."}, {"name": "neg_add_neg_iff", "description": ""}, {"name": "lt_of_sub_neg", "description": "**Alias** of the forward direction of `sub_neg`."}, {"name": "inv_mul_lt_iff_lt_mul", "description": ""}, {"name": "add_neg_le_neg_add_iff", "description": ""}, {"name": "div_le_iff_le_mul", "description": ""}, {"name": "lt_inv_of_lt_inv", "description": "**Alias** of the forward direction of `lt_inv'`."}, {"name": "mul_inv_le_iff_le_mul'", "description": ""}, {"name": "ordered_comm_group.has_exists_mul_of_le", "description": ""}, {"name": "abs_sub_comm", "description": ""}, {"name": "div_lt_div_iff_right", "description": ""}, {"name": "order_dual.sub_neg_add_monoid", "description": ""}, {"name": "le_of_sub_nonneg", "description": "**Alias** of the forward direction of `sub_nonneg`."}, {"name": "multiplicative.ordered_comm_group", "description": ""}, {"name": "neg_lt_iff_pos_add'", "description": ""}, {"name": "le_div_iff_mul_le'", "description": ""}, {"name": "add_neg_lt_neg_add_iff", "description": ""}, {"name": "sub_lt_sub_right", "description": ""}, {"name": "apply_abs_le_mul_of_one_le", "description": ""}, {"name": "max_sub_max_le_max", "description": ""}, {"name": "prod.ordered_add_comm_group", "description": ""}, {"name": "linear_ordered_add_comm_group_with_top.to_nontrivial", "description": ""}, {"name": "strict_mono.neg", "description": ""}, {"name": "right.one_le_inv_iff", "description": "Uses `right` co(ntra)variant."}, {"name": "div_le_div_iff'", "description": ""}, {"name": "order_iso.mul_right", "description": "`equiv.mul_right` as an `order_iso`. See also `order_embedding.mul_right`."}, {"name": "abs_sub", "description": ""}, {"name": "le_mul_inv_iff_le", "description": ""}, {"name": "add_neg_lt_iff_lt_add", "description": ""}, {"name": "one_le_div'", "description": ""}, {"name": "order_dual.subtraction_comm_monoid", "description": ""}, {"name": "lt_neg_iff_add_neg", "description": ""}, {"name": "le_of_forall_pos_le_add", "description": ""}, {"name": "neg_le_iff_add_nonneg'", "description": ""}, {"name": "multiplicative.linear_ordered_comm_group", "description": ""}, {"name": "right.inv_le_self", "description": ""}, {"name": "le_abs'", "description": ""}, {"name": "lt_add_of_sub_left_lt", "description": "**Alias** of the forward direction of `sub_lt_iff_lt_add'`."}, {"name": "abs_sub_le_iff", "description": ""}, {"name": "abs_abs_sub_abs_le_abs_sub", "description": ""}, {"name": "abs_eq_sup_neg", "description": ""}, {"name": "abs_le_abs", "description": ""}, {"name": "inv_le_of_inv_le'", "description": "**Alias** of the forward direction of `inv_le'`."}, {"name": "abs_sub_abs_le_abs_sub", "description": ""}, {"name": "nonneg_of_neg_nonpos", "description": "**Alias** of the forward direction of `left.inv_le_one_iff`."}, {"name": "lt_neg_add_of_add_lt", "description": "**Alias** of the reverse direction of `lt_inv_mul_iff_mul_lt`."}, {"name": "sub_lt_sub", "description": ""}, {"name": "order_iso.add_right_to_equiv", "description": ""}, {"name": "strict_anti.inv", "description": ""}, {"name": "neg_nonneg_of_nonpos", "description": ""}, {"name": "order_dual.has_inv", "description": ""}, {"name": "inv_lt'", "description": ""}, {"name": "inv_of_one_lt_inv", "description": "**Alias** of the forward direction of `left.one_lt_inv_iff`."}, {"name": "one_lt_div'", "description": ""}, {"name": "add_neg_le_add_neg_iff", "description": ""}, {"name": "ordered_add_comm_group.to_covariant_class_left_le", "description": ""}, {"name": "abs_min_sub_min_le_max", "description": ""}, {"name": "lt_sub_iff_add_lt'", "description": ""}, {"name": "one_lt_inv'", "description": "**Alias** of `left.one_lt_inv_iff`."}, {"name": "linear_ordered_add_comm_group", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.add", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.add_assoc", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.zero", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.zero_add", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.add_zero", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.nsmul", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.nsmul_zero'", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.nsmul_succ'", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.neg", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.sub", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.sub_eq_add_neg", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.zsmul", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.zsmul_zero'", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.zsmul_succ'", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.zsmul_neg'", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.add_left_neg", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.add_comm", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.le", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.lt", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.le_refl", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.le_trans", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.lt_iff_le_not_le", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.le_antisymm", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.add_le_add_left", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.le_total", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.decidable_le", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.decidable_eq", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.decidable_lt", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.max", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.max_def", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.min", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "linear_ordered_add_comm_group.min_def", "description": " A linearly ordered additive commutative group is an\nadditive commutative group with a linear order in which\naddition is monotone."}, {"name": "add_neg_le_iff_le_add'", "description": ""}, {"name": "abs_max_sub_max_le_abs", "description": ""}, {"name": "order_dual.subtraction_monoid", "description": ""}, {"name": "le_div_self_iff", "description": ""}, {"name": "ordered_comm_group.to_ordered_cancel_comm_monoid", "description": ""}, {"name": "left.one_le_inv_iff", "description": "Uses `left` co(ntra)variant."}, {"name": "div_le_inv_mul_iff", "description": ""}, {"name": "abs_eq_abs", "description": ""}, {"name": "linear_ordered_comm_group.to_linear_ordered_cancel_comm_monoid", "description": ""}, {"name": "neg_abs_le_self", "description": ""}, {"name": "le_of_sub_nonpos", "description": "**Alias** of the forward direction of `sub_nonpos`."}, {"name": "le_add_neg_iff_add_le", "description": ""}, {"name": "add_comm_group.positive_cone", "description": " A collection of elements in an `add_comm_group` designated as \"non-negative\".\nThis is useful for constructing an `ordered_add_commm_group`\nby choosing a positive cone in an exisiting `add_comm_group`."}, {"name": "add_comm_group.positive_cone.nonneg", "description": " A collection of elements in an `add_comm_group` designated as \"non-negative\".\nThis is useful for constructing an `ordered_add_commm_group`\nby choosing a positive cone in an exisiting `add_comm_group`."}, {"name": "add_comm_group.positive_cone.pos", "description": " A collection of elements in an `add_comm_group` designated as \"non-negative\".\nThis is useful for constructing an `ordered_add_commm_group`\nby choosing a positive cone in an exisiting `add_comm_group`."}, {"name": "add_comm_group.positive_cone.pos_iff", "description": " A collection of elements in an `add_comm_group` designated as \"non-negative\".\nThis is useful for constructing an `ordered_add_commm_group`\nby choosing a positive cone in an exisiting `add_comm_group`."}, {"name": "add_comm_group.positive_cone.zero_nonneg", "description": " A collection of elements in an `add_comm_group` designated as \"non-negative\".\nThis is useful for constructing an `ordered_add_commm_group`\nby choosing a positive cone in an exisiting `add_comm_group`."}, {"name": "add_comm_group.positive_cone.add_nonneg", "description": " A collection of elements in an `add_comm_group` designated as \"non-negative\".\nThis is useful for constructing an `ordered_add_commm_group`\nby choosing a positive cone in an exisiting `add_comm_group`."}, {"name": "add_comm_group.positive_cone.nonneg_antisymm", "description": " A collection of elements in an `add_comm_group` designated as \"non-negative\".\nThis is useful for constructing an `ordered_add_commm_group`\nby choosing a positive cone in an exisiting `add_comm_group`."}, {"name": "inv_le_inv'", "description": ""}, {"name": "order_dual.division_comm_monoid", "description": ""}, {"name": "ordered_comm_group.to_covariant_class_left_le", "description": ""}, {"name": "neg_le_iff_add_nonneg", "description": ""}, {"name": "right.inv_lt_self", "description": ""}, {"name": "left.inv_le_one_iff", "description": "Uses `left` co(ntra)variant."}, {"name": "max_neg_neg", "description": ""}, {"name": "inv_mul_lt_iff_lt_mul'", "description": ""}, {"name": "abs_le", "description": ""}, {"name": "le_iff_forall_one_lt_le_mul", "description": ""}, {"name": "div_lt_iff_lt_mul'", "description": ""}, {"name": "sub_neg_of_lt", "description": "**Alias** of the reverse direction of `sub_neg`."}, {"name": "le_neg_add_of_add_le", "description": "**Alias** of the reverse direction of `le_inv_mul_iff_mul_le`."}, {"name": "neg_add_le_iff_le_add", "description": ""}, {"name": "linear_ordered_comm_group.to_linear_order", "description": ""}, {"name": "min_sub_sub_left", "description": ""}, {"name": "le_inv_iff_mul_le_one_right", "description": ""}, {"name": "neg_neg_of_pos", "description": ""}, {"name": "sub_nonneg_of_le", "description": "**Alias** of the reverse direction of `sub_nonneg`."}, {"name": "sub_lt_iff_lt_add'", "description": ""}, {"name": "add_lt_of_lt_sub_left", "description": "**Alias** of the forward direction of `lt_sub_iff_add_lt'`."}, {"name": "lt_sub", "description": ""}, {"name": "units.ordered_comm_group", "description": "The units of an ordered commutative monoid form an ordered commutative group."}, {"name": "order_iso.neg", "description": "`x \u21a6 -x` as an order-reversing equivalence."}, {"name": "div_le_div_right'", "description": ""}, {"name": "neg_add_lt_iff_lt_add", "description": ""}, {"name": "lt_of_abs_lt", "description": ""}, {"name": "neg_add_le_iff_le_add'", "description": ""}, {"name": "order_iso.inv_symm_apply", "description": ""}, {"name": "lt_mul_of_inv_mul_lt", "description": "**Alias** of the forward direction of `inv_mul_lt_iff_lt_mul`."}, {"name": "mul_inv_le_mul_inv_iff'", "description": ""}, {"name": "eq_of_abs_sub_nonpos", "description": ""}, {"name": "abs_of_nonpos", "description": ""}, {"name": "neg_nonneg", "description": "**Alias** of `left.one_le_inv_iff`."}, {"name": "lt_sub_left_of_add_lt", "description": "**Alias** of the reverse direction of `lt_sub_iff_add_lt'`."}, {"name": "neg_le_of_neg_le", "description": "**Alias** of the forward direction of `inv_le'`."}, {"name": "function.injective.ordered_comm_group", "description": " Pullback an `ordered_comm_group` under an injective map.\nSee note [reducible non-instances]."}, {"name": "rbmap.mem", "description": ""}, {"name": "rbmap.fold", "description": ""}, {"name": "rbmap.to_list", "description": ""}, {"name": "rbmap.min", "description": ""}, {"name": "rbmap_of", "description": ""}, {"name": "rbmap", "description": ""}, {"name": "rbmap_lt", "description": ""}, {"name": "rbmap.rev_fold", "description": ""}, {"name": "rbmap.has_repr", "description": ""}, {"name": "rbmap.contains", "description": ""}, {"name": "rbmap.from_list", "description": ""}, {"name": "rbmap.has_mem", "description": ""}, {"name": "mk_rbmap", "description": ""}, {"name": "rbmap.find", "description": ""}, {"name": "rbmap.max", "description": ""}, {"name": "rbmap.find_entry", "description": ""}, {"name": "rbmap.insert", "description": ""}, {"name": "rbmap.to_value", "description": ""}, {"name": "rbmap.rbmap_lt_dec", "description": ""}, {"name": "rbmap.empty", "description": ""}, {"name": "mul_equiv.apply_symm_apply", "description": "`e.symm` is a right inverse of `e`, written as `e (e.symm y) = y`."}, {"name": "add_equiv.apply_eq_iff_symm_apply", "description": ""}, {"name": "mul_equiv.to_equiv_mk", "description": ""}, {"name": "add_equiv.neg", "description": "When the `add_group` is commutative, `equiv.neg` is an `add_equiv`."}, {"name": "add_group.add_right_bijective", "description": ""}, {"name": "add_equiv.refl", "description": "The identity map is an additive isomorphism."}, {"name": "add_monoid_hom.to_add_equiv", "description": "Given a pair of additive monoid homomorphisms `f`, `g` such that `g.comp f = id`\nand `f.comp g = id`, returns an additive equivalence with `to_fun = f` and `inv_fun = g`.  This\nconstructor is useful if the underlying type(s) have specialized `ext` lemmas for additive\nmonoid homomorphisms."}, {"name": "equiv.div_left_eq_inv_trans_mul_left", "description": ""}, {"name": "equiv.sub_left", "description": "A version of `equiv.add_left a (-b)` that is defeq to `a - b`."}, {"name": "add_equiv.symm", "description": "The inverse of an isomorphism is an isomorphism."}, {"name": "mul_equiv.mk_coe", "description": ""}, {"name": "units.mul_left", "description": "Left multiplication by a unit of a monoid is a permutation of the underlying type."}, {"name": "group.is_unit", "description": ""}, {"name": "mul_equiv.to_monoid_hom_injective", "description": ""}, {"name": "add_hom.inverse", "description": "Makes an additive inverse from a bijection which preserves addition."}, {"name": "equiv.neg_apply", "description": ""}, {"name": "mul_equiv.coe_to_mul_hom", "description": ""}, {"name": "mul_right_bijective\u2080", "description": ""}, {"name": "mul_equiv_class.monoid_hom_class", "description": ""}, {"name": "mul_equiv.symm_symm", "description": ""}, {"name": "mul_equiv.eq_symm_comp", "description": ""}, {"name": "add_equiv.to_equiv", "description": "The `equiv` underlying an `add_equiv`."}, {"name": "mul_equiv.eq_symm_apply", "description": ""}, {"name": "mul_equiv.has_coe_t", "description": ""}, {"name": "add_group.is_add_unit", "description": ""}, {"name": "units.mul_right_apply", "description": ""}, {"name": "add_equiv.has_coe_t", "description": ""}, {"name": "add_equiv_class.map_eq_zero_iff", "description": ""}, {"name": "add_equiv.neg_apply", "description": ""}, {"name": "mul_equiv.Pi_congr_right_refl", "description": ""}, {"name": "equiv.neg", "description": "Negation on an `add_group` is a permutation of the underlying type."}, {"name": "add_equiv.map_zero", "description": "An additive isomorphism of additive monoids sends `0` to `0`\n(and is hence an additive monoid isomorphism)."}, {"name": "mul_equiv.inv_fun_eq_symm", "description": ""}, {"name": "mul_equiv.trans_apply", "description": ""}, {"name": "units.mul_left_symm", "description": ""}, {"name": "mul_equiv.coe_to_equiv", "description": ""}, {"name": "group.mul_left_bijective", "description": ""}, {"name": "mul_equiv.coe_to_monoid_hom", "description": ""}, {"name": "equiv.add_left", "description": "Left addition in an `add_group` is a permutation of the underlying type."}, {"name": "add_equiv.arrow_congr_apply", "description": ""}, {"name": "add_equiv.mk'", "description": "Makes an additive isomorphism from a bijection which preserves addition."}, {"name": "equiv.add_right_symm", "description": ""}, {"name": "add_equiv.add_equiv_of_unique", "description": "The `add_equiv` between two add_monoids with a unique element."}, {"name": "mul_equiv.to_additive'", "description": "Reinterpret `G \u2243* multiplicative H` as `additive G \u2243+ H` as."}, {"name": "mul_hom.inverse", "description": "Makes a multiplicative inverse from a bijection which preserves multiplication."}, {"name": "mul_equiv_class.mul_hom_class", "description": ""}, {"name": "add_units.add_left_symm", "description": ""}, {"name": "add_equiv.add_monoid_hom_congr", "description": "An additive analogue of `equiv.arrow_congr`,\nfor additive maps from an additive monoid to a commutative additive monoid."}, {"name": "add_equiv.eq_symm_comp", "description": ""}, {"name": "add_equiv.has_coe_to_fun", "description": ""}, {"name": "mul_equiv.comp_symm_eq", "description": ""}, {"name": "add_equiv.map_add", "description": "An additive isomorphism preserves addition."}, {"name": "add_equiv.add_monoid_hom_congr_apply", "description": ""}, {"name": "to_units", "description": "A group is isomorphic to its group of units."}, {"name": "mul_equiv.surjective", "description": ""}, {"name": "mul_equiv.mk'", "description": "Makes a multiplicative isomorphism from a bijection which preserves multiplication."}, {"name": "add_equiv.coe_to_equiv", "description": ""}, {"name": "mul_equiv_class.map_ne_one_iff", "description": ""}, {"name": "mul_equiv.symm_comp_self", "description": ""}, {"name": "add_equiv.apply_eq_iff_eq", "description": ""}, {"name": "add_equiv.self_comp_symm", "description": ""}, {"name": "to_add_units", "description": "An additive group is isomorphic to its group of additive units"}, {"name": "add_equiv.symm_comp_eq", "description": ""}, {"name": "add_equiv.of_bijective", "description": "A bijective `add_semigroup` homomorphism is an isomorphism"}, {"name": "equiv.div_right_apply", "description": ""}, {"name": "mul_equiv.Pi_subsingleton_apply", "description": ""}, {"name": "mul_equiv.monoid_hom_congr", "description": "A multiplicative analogue of `equiv.arrow_congr`,\nfor multiplicative maps from a monoid to a commutative monoid."}, {"name": "equiv.coe_add_right", "description": ""}, {"name": "mul_equiv.symm_apply_apply", "description": "`e.symm` is a left inverse of `e`, written as `e.symm (e y) = y`."}, {"name": "units.map_equiv", "description": " A multiplicative equivalence of monoids defines a multiplicative equivalence\nof their groups of units."}, {"name": "add_equiv.ext_iff", "description": ""}, {"name": "mul_equiv.symm_bijective", "description": ""}, {"name": "equiv.div_left_symm_apply", "description": ""}, {"name": "equiv.mul_right\u2080_apply", "description": ""}, {"name": "equiv.mul_right_symm", "description": ""}, {"name": "add_equiv.to_multiplicative'", "description": "Reinterpret `additive G \u2243+ H` as `G \u2243* multiplicative H`."}, {"name": "add_units.add_right_apply", "description": ""}, {"name": "add_equiv.unique", "description": "There is a unique additive monoid homomorphism between two additive monoids with\na unique element."}, {"name": "add_equiv.coe_to_add_monoid_hom", "description": ""}, {"name": "add_equiv.to_multiplicative''", "description": "Reinterpret `G \u2243+ additive H` as `multiplicative G \u2243* H`."}, {"name": "add_equiv.map_eq_zero_iff", "description": ""}, {"name": "mul_equiv.to_fun_eq_coe", "description": ""}, {"name": "units.mul_right_symm", "description": ""}, {"name": "mul_equiv.mk_coe'", "description": ""}, {"name": "mul_equiv.injective", "description": ""}, {"name": "equiv.sub_left_eq_neg_trans_add_left", "description": ""}, {"name": "add_equiv", "description": "add_equiv \u03b1 \u03b2 is the type of an equiv \u03b1 \u2243 \u03b2 which preserves addition."}, {"name": "add_equiv.to_fun", "description": "add_equiv \u03b1 \u03b2 is the type of an equiv \u03b1 \u2243 \u03b2 which preserves addition."}, {"name": "add_equiv.inv_fun", "description": "add_equiv \u03b1 \u03b2 is the type of an equiv \u03b1 \u2243 \u03b2 which preserves addition."}, {"name": "add_equiv.left_inv", "description": "add_equiv \u03b1 \u03b2 is the type of an equiv \u03b1 \u2243 \u03b2 which preserves addition."}, {"name": "add_equiv.right_inv", "description": "add_equiv \u03b1 \u03b2 is the type of an equiv \u03b1 \u2243 \u03b2 which preserves addition."}, {"name": "add_equiv.map_add'", "description": "add_equiv \u03b1 \u03b2 is the type of an equiv \u03b1 \u2243 \u03b2 which preserves addition."}, {"name": "add_equiv.symm_apply_eq", "description": ""}, {"name": "add_equiv.symm_trans_apply", "description": ""}, {"name": "add_equiv.injective", "description": ""}, {"name": "mul_equiv.coe_trans", "description": ""}, {"name": "mul_equiv.map_eq_one_iff", "description": ""}, {"name": "add_equiv.comp_symm_eq", "description": ""}, {"name": "add_equiv.refl_symm", "description": ""}, {"name": "mul_equiv.to_mul_hom", "description": "The `mul_hom` underlying a `mul_equiv`."}, {"name": "add_equiv.refl_apply", "description": ""}, {"name": "add_equiv.to_add_monoid_hom", "description": "Extract the forward direction of an additive equivalence\nas an addition-preserving function."}, {"name": "mul_equiv_class", "description": " `mul_equiv_class F A B` states that `F` is a type of multiplication-preserving morphisms.\nYou should extend this class when you extend `mul_equiv`."}, {"name": "mul_equiv_class.coe", "description": " `mul_equiv_class F A B` states that `F` is a type of multiplication-preserving morphisms.\nYou should extend this class when you extend `mul_equiv`."}, {"name": "mul_equiv_class.inv", "description": " `mul_equiv_class F A B` states that `F` is a type of multiplication-preserving morphisms.\nYou should extend this class when you extend `mul_equiv`."}, {"name": "mul_equiv_class.left_inv", "description": " `mul_equiv_class F A B` states that `F` is a type of multiplication-preserving morphisms.\nYou should extend this class when you extend `mul_equiv`."}, {"name": "mul_equiv_class.right_inv", "description": " `mul_equiv_class F A B` states that `F` is a type of multiplication-preserving morphisms.\nYou should extend this class when you extend `mul_equiv`."}, {"name": "mul_equiv_class.coe_injective'", "description": " `mul_equiv_class F A B` states that `F` is a type of multiplication-preserving morphisms.\nYou should extend this class when you extend `mul_equiv`."}, {"name": "mul_equiv_class.map_mul", "description": " `mul_equiv_class F A B` states that `F` is a type of multiplication-preserving morphisms.\nYou should extend this class when you extend `mul_equiv`."}, {"name": "add_equiv.map_sub", "description": "An additive equivalence of additive groups preserves subtractions."}, {"name": "add_equiv.symm_comp_self", "description": ""}, {"name": "equiv.coe_mul_left", "description": ""}, {"name": "equiv.sub_right_eq_add_right_neg", "description": ""}, {"name": "add_equiv.map_ne_zero_iff", "description": ""}, {"name": "mul_equiv.monoid_hom_congr_apply", "description": ""}, {"name": "mul_equiv.inv_symm", "description": ""}, {"name": "mul_equiv.symm_mk", "description": ""}, {"name": "mul_equiv.coe_refl", "description": ""}, {"name": "group.mul_right_bijective", "description": ""}, {"name": "add_equiv.to_add_hom", "description": "The `add_hom` underlying a `add_equiv`."}, {"name": "mul_equiv.coe_mk", "description": ""}, {"name": "add_equiv_class.add_monoid_hom_class", "description": ""}, {"name": "mul_equiv.Pi_subsingleton_symm_apply", "description": ""}, {"name": "monoid_hom.to_mul_equiv_apply", "description": ""}, {"name": "add_units.add_left_apply", "description": ""}, {"name": "add_equiv.coe_trans", "description": ""}, {"name": "add_equiv.neg_fun_eq_symm", "description": ""}, {"name": "equiv.add_right_symm_apply", "description": "Extra simp lemma that `dsimp` can use. `simp` will never use this."}, {"name": "mul_equiv.to_monoid_hom", "description": "Extract the forward direction of a multiplicative equivalence\nas a multiplication-preserving function."}, {"name": "equiv.mul_left\u2080_apply", "description": ""}, {"name": "add_equiv.symm_bijective", "description": ""}, {"name": "mul_equiv.refl_symm", "description": ""}, {"name": "add_equiv.trans_apply", "description": ""}, {"name": "equiv.coe_add_left", "description": ""}, {"name": "equiv.sub_right_symm_apply", "description": ""}, {"name": "equiv.add_left_symm_apply", "description": "Extra simp lemma that `dsimp` can use. `simp` will never use this."}, {"name": "mul_equiv.trans", "description": "Transitivity of multiplication-preserving isomorphisms"}, {"name": "add_equiv.eq_comp_symm", "description": ""}, {"name": "mul_equiv.eq_comp_symm", "description": ""}, {"name": "equiv.coe_mul_right", "description": ""}, {"name": "equiv.mul_left\u2080_symm_apply", "description": ""}, {"name": "add_equiv.to_multiplicative", "description": "Reinterpret `G \u2243+ H` as `multiplicative G \u2243* multiplicative H`."}, {"name": "add_equiv.arrow_congr", "description": "An additive analogue of `equiv.arrow_congr`,\nwhere the equivalence between the targets is additive."}, {"name": "units.mul_right", "description": "Right multiplication by a unit of a monoid is a permutation of the underlying type."}, {"name": "add_equiv.to_fun_eq_coe", "description": ""}, {"name": "mul_equiv.symm_trans_apply", "description": ""}, {"name": "mul_equiv.mul_equiv_class", "description": ""}, {"name": "mul_equiv.Pi_subsingleton", "description": " A family indexed by a nonempty subsingleton type is equivalent to the element at the single\nindex."}, {"name": "add_equiv.to_add_monoid_hom_injective", "description": ""}, {"name": "add_equiv_class.to_equiv_like", "description": ""}, {"name": "add_equiv.inhabited", "description": ""}, {"name": "add_equiv.of_bijective_apply", "description": ""}, {"name": "add_equiv.simps.symm_apply", "description": "See Note custom simps projection"}, {"name": "mul_equiv.map_ne_one_iff", "description": ""}, {"name": "add_equiv.mk_coe'", "description": ""}, {"name": "add_monoid_hom.inverse", "description": "The inverse of a bijective `add_monoid_hom` is an `add_monoid_hom`."}, {"name": "monoid_hom.to_mul_equiv", "description": " Given a pair of monoid homomorphisms `f`, `g` such that `g.comp f = id` and `f.comp g = id`,\nreturns an multiplicative equivalence with `to_fun = f` and `inv_fun = g`.  This constructor is\nuseful if the underlying type(s) have specialized `ext` lemmas for monoid homomorphisms."}, {"name": "add_equiv.Pi_subsingleton", "description": "A family indexed by a nonempty subsingleton type is\nequivalent to the element at the single index."}, {"name": "add_equiv.ext", "description": "Two additive isomorphisms agree if they are defined by the same underlying function."}, {"name": "mul_equiv.apply_eq_iff_symm_apply", "description": ""}, {"name": "mul_equiv.inv", "description": " In a `division_comm_monoid`, `equiv.inv` is a `mul_equiv`. There is a variant of this\n`mul_equiv.inv' G : G \u2243* G\u1d50\u1d52\u1d56` for the non-commutative case."}, {"name": "mul_equiv.arrow_congr", "description": "A multiplicative analogue of `equiv.arrow_congr`,\nwhere the equivalence between the targets is multiplicative."}, {"name": "mul_equiv.ext_iff", "description": ""}, {"name": "add_equiv.coe_refl", "description": ""}, {"name": "mul_equiv.to_additive", "description": "Reinterpret `G \u2243* H` as `additive G \u2243+ additive H`."}, {"name": "add_group.add_left_bijective", "description": ""}, {"name": "equiv.div_left_apply", "description": ""}, {"name": "mul_equiv.has_coe_to_fun", "description": ""}, {"name": "mul_equiv.map_one", "description": "A multiplicative isomorphism of monoids sends `1` to `1` (and is hence a monoid isomorphism)."}, {"name": "monoid_hom.inverse", "description": "The inverse of a bijective `monoid_hom` is a `monoid_hom`."}, {"name": "add_equiv.trans", "description": "Transitivity of addition-preserving isomorphisms"}, {"name": "equiv.inv_apply", "description": ""}, {"name": "mul_equiv.symm", "description": "The inverse of an isomorphism is an isomorphism."}, {"name": "equiv.mul_right", "description": "Right multiplication in a `group` is a permutation of the underlying type."}, {"name": "add_equiv.eq_symm_apply", "description": ""}, {"name": "equiv.mul_right_symm_apply", "description": "Extra simp lemma that `dsimp` can use. `simp` will never use this."}, {"name": "mul_equiv.self_comp_symm", "description": ""}, {"name": "equiv.mul_left_symm_apply", "description": "Extra simp lemma that `dsimp` can use. `simp` will never use this."}, {"name": "mul_equiv.Pi_congr_right_symm", "description": ""}, {"name": "add_equiv.mk_coe", "description": ""}, {"name": "add_equiv.to_equiv_eq_coe", "description": ""}, {"name": "add_equiv.congr_arg", "description": ""}, {"name": "add_equiv.map_neg", "description": "An additive equivalence of additive groups preserves negation."}, {"name": "equiv.inv", "description": "Inversion on a `group` or `group_with_zero` is a permutation of the underlying type."}, {"name": "equiv.sub_right_apply", "description": ""}, {"name": "equiv.mul_left_symm", "description": ""}, {"name": "equiv.sub_left_symm_apply", "description": ""}, {"name": "mul_equiv.map_div", "description": "A multiplicative equivalence of groups preserves division."}, {"name": "add_monoid_hom.to_add_equiv_symm_apply", "description": ""}, {"name": "coe_to_units", "description": ""}, {"name": "mul_equiv.of_bijective", "description": "A bijective `semigroup` homomorphism is an isomorphism"}, {"name": "equiv.mul_right\u2080_symm_apply", "description": ""}, {"name": "units.mul_left_apply", "description": ""}, {"name": "mul_equiv.to_equiv", "description": "The `equiv` underlying a `mul_equiv`."}, {"name": "add_units.add_right", "description": "Right addition of an additive unit is a permutation of the underlying type."}, {"name": "add_equiv.bijective", "description": ""}, {"name": "units.mul_left_bijective", "description": ""}, {"name": "mul_equiv.Pi_congr_right_apply", "description": ""}, {"name": "mul_equiv.ext", "description": "Two multiplicative isomorphisms agree if they are defined by the\n   same underlying function."}, {"name": "add_equiv.apply_symm_apply", "description": "`e.symm` is a right inverse of `e`, written as `e (e.symm y) = y`."}, {"name": "equiv.sub_right", "description": "A version of `equiv.add_right (-a) b` that is defeq to `b - a`."}, {"name": "mul_equiv.of_bijective_apply", "description": ""}, {"name": "add_equiv_class", "description": " `add_equiv_class F A B` states that `F` is a type of addition-preserving morphisms.\nYou should extend this class when you extend `add_equiv`."}, {"name": "add_equiv_class.coe", "description": " `add_equiv_class F A B` states that `F` is a type of addition-preserving morphisms.\nYou should extend this class when you extend `add_equiv`."}, {"name": "add_equiv_class.inv", "description": " `add_equiv_class F A B` states that `F` is a type of addition-preserving morphisms.\nYou should extend this class when you extend `add_equiv`."}, {"name": "add_equiv_class.left_inv", "description": " `add_equiv_class F A B` states that `F` is a type of addition-preserving morphisms.\nYou should extend this class when you extend `add_equiv`."}, {"name": "add_equiv_class.right_inv", "description": " `add_equiv_class F A B` states that `F` is a type of addition-preserving morphisms.\nYou should extend this class when you extend `add_equiv`."}, {"name": "add_equiv_class.coe_injective'", "description": " `add_equiv_class F A B` states that `F` is a type of addition-preserving morphisms.\nYou should extend this class when you extend `add_equiv`."}, {"name": "add_equiv_class.map_add", "description": " `add_equiv_class F A B` states that `F` is a type of addition-preserving morphisms.\nYou should extend this class when you extend `add_equiv`."}, {"name": "mul_equiv.inhabited", "description": ""}, {"name": "add_equiv.Pi_subsingleton_apply", "description": ""}, {"name": "coe_to_add_units", "description": ""}, {"name": "mul_equiv.refl", "description": "The identity map is a multiplicative isomorphism."}, {"name": "mul_equiv.Pi_congr_right_trans", "description": ""}, {"name": "units.mul_right_bijective", "description": ""}, {"name": "mul_equiv.to_equiv_symm", "description": ""}, {"name": "mul_equiv.symm_comp_eq", "description": ""}, {"name": "add_units.add_right_bijective", "description": ""}, {"name": "equiv.neg_symm", "description": ""}, {"name": "add_equiv.Pi_subsingleton_symm_apply", "description": ""}, {"name": "mul_equiv.arrow_congr_apply", "description": ""}, {"name": "mul_equiv.mul_equiv_of_unique", "description": "The `mul_equiv` between two monoids with a unique element."}, {"name": "mul_equiv.to_equiv_eq_coe", "description": ""}, {"name": "equiv.div_right", "description": "A version of `equiv.mul_right a\u207b\u00b9 b` that is defeq to `b / a`."}, {"name": "add_units.add_left_bijective", "description": ""}, {"name": "equiv.add_right", "description": "Right addition in an `add_group` is a permutation of the underlying type."}, {"name": "mul_equiv_class.to_monoid_with_zero_hom_class", "description": ""}, {"name": "mul_equiv.refl_apply", "description": ""}, {"name": "add_equiv.symm_apply_apply", "description": "`e.symm` is a left inverse of `e`, written as `e.symm (e y) = y`."}, {"name": "add_equiv.to_equiv_symm", "description": ""}, {"name": "equiv.div_left", "description": "A version of `equiv.mul_left a b\u207b\u00b9` that is defeq to `a / b`."}, {"name": "mul_equiv_class.map_eq_one_iff", "description": ""}, {"name": "equiv.inv_symm", "description": ""}, {"name": "equiv.div_right_symm_apply", "description": ""}, {"name": "mul_equiv.bijective", "description": ""}, {"name": "add_equiv.coe_to_add_hom", "description": ""}, {"name": "equiv.mul_left\u2080", "description": " Left multiplication by a nonzero element in a `group_with_zero` is a permutation of the\nunderlying type."}, {"name": "mul_equiv.map_inv", "description": "A multiplicative equivalence of groups preserves inversion."}, {"name": "mul_equiv.of_bijective_apply_symm_apply", "description": ""}, {"name": "add_equiv.symm_mk", "description": ""}, {"name": "mul_equiv.to_additive''", "description": "Reinterpret `multiplicative G \u2243* H` as `G \u2243+ additive H` as."}, {"name": "add_units.add_left", "description": "Left addition of an additive unit is a permutation of the underlying type."}, {"name": "add_monoid_hom.to_add_equiv_apply", "description": ""}, {"name": "monoid_hom.to_mul_equiv_symm_apply", "description": ""}, {"name": "mul_equiv.symm_apply_eq", "description": ""}, {"name": "add_monoid_hom.inverse_apply", "description": ""}, {"name": "add_equiv.symm_symm", "description": ""}, {"name": "mul_equiv.apply_eq_iff_eq", "description": ""}, {"name": "mul_equiv.unique", "description": "There is a unique monoid homomorphism between two monoids with a unique element."}, {"name": "mul_equiv.inv_apply", "description": ""}, {"name": "mul_left_bijective\u2080", "description": ""}, {"name": "add_equiv.congr_fun", "description": ""}, {"name": "add_equiv.coe_mk", "description": ""}, {"name": "mul_equiv", "description": "`mul_equiv \u03b1 \u03b2` is the type of an equiv `\u03b1 \u2243 \u03b2` which preserves multiplication."}, {"name": "mul_equiv.to_fun", "description": "`mul_equiv \u03b1 \u03b2` is the type of an equiv `\u03b1 \u2243 \u03b2` which preserves multiplication."}, {"name": "mul_equiv.inv_fun", "description": "`mul_equiv \u03b1 \u03b2` is the type of an equiv `\u03b1 \u2243 \u03b2` which preserves multiplication."}, {"name": "mul_equiv.left_inv", "description": "`mul_equiv \u03b1 \u03b2` is the type of an equiv `\u03b1 \u2243 \u03b2` which preserves multiplication."}, {"name": "mul_equiv.right_inv", "description": "`mul_equiv \u03b1 \u03b2` is the type of an equiv `\u03b1 \u2243 \u03b2` which preserves multiplication."}, {"name": "mul_equiv.map_mul'", "description": "`mul_equiv \u03b1 \u03b2` is the type of an equiv `\u03b1 \u2243 \u03b2` which preserves multiplication."}, {"name": "equiv.div_right_eq_mul_right_inv", "description": ""}, {"name": "mul_equiv.congr_fun", "description": ""}, {"name": "equiv.add_left_symm", "description": ""}, {"name": "add_equiv_class.add_hom_class", "description": ""}, {"name": "mul_equiv.map_mul", "description": "A multiplicative isomorphism preserves multiplication."}, {"name": "monoid_hom.inverse_apply", "description": ""}, {"name": "equiv.mul_right\u2080", "description": " Right multiplication by a nonzero element in a `group_with_zero` is a permutation of the\nunderlying type."}, {"name": "mul_equiv.congr_arg", "description": ""}, {"name": "add_equiv.to_equiv_mk", "description": ""}, {"name": "add_units.add_right_symm", "description": ""}, {"name": "add_equiv.Pi_congr_right_apply", "description": ""}, {"name": "add_equiv.Pi_congr_right", "description": "A family of additive equivalences `\u03a0 j, (Ms j \u2243+ Ns j)`\ngenerates an additive equivalence between `\u03a0 j, Ms j` and `\u03a0 j, Ns j`.\n\nThis is the `add_equiv` version of `equiv.Pi_congr_right`, and the dependent version of\n`add_equiv.arrow_congr`."}, {"name": "add_equiv.surjective", "description": ""}, {"name": "equiv.mul_left", "description": "Left multiplication in a `group` is a permutation of the underlying type."}, {"name": "mul_equiv.simps.symm_apply", "description": "See Note [custom simps projection]"}, {"name": "add_equiv.add_equiv_class", "description": ""}, {"name": "mul_equiv_class.to_equiv_like", "description": ""}, {"name": "add_equiv_class.map_ne_zero_iff", "description": ""}, {"name": "mul_equiv.Pi_congr_right", "description": " A family of multiplicative equivalences `\u03a0 j, (Ms j \u2243* Ns j)` generates a\nmultiplicative equivalence between `\u03a0 j, Ms j` and `\u03a0 j, Ns j`.\n\nThis is the `mul_equiv` version of `equiv.Pi_congr_right`, and the dependent version of\n`mul_equiv.arrow_congr`."}, {"name": "equiv.sub_left_apply", "description": ""}, {"name": "tactic_doc.command.add_tactic_doc", "description": "A command used to add documentation for a tactic, command, hole command, or attribute.\n\nUsage: after defining an interactive tactic, command, or attribute,\nadd its documentation as follows.\n```lean\n/--\ndescribe what the command does here\n-/\nadd_tactic_doc\n{ name := \"display name of the tactic\",\n  category := cat,\n  decl_names := [`dcl_1, `dcl_2],\n  tags := [\"tag_1\", \"tag_2\"] }\n```\n\nThe argument to `add_tactic_doc` is a structure of type `tactic_doc_entry`.\n* `name` refers to the display name of the tactic; it is used as the header of the doc entry.\n* `cat` refers to the category of doc entry.\n  Options: `doc_category.tactic`, `doc_category.cmd`, `doc_category.hole_cmd`, `doc_category.attr`\n* `decl_names` is a list of the declarations associated with this doc. For instance,\n  the entry for `linarith` would set ``decl_names := [`tactic.interactive.linarith]``.\n  Some entries may cover multiple declarations.\n  It is only necessary to list the interactive versions of tactics.\n* `tags` is an optional list of strings used to categorize entries.\n* The doc string is the body of the entry. It can be formatted with markdown.\n  What you are reading now is the description of `add_tactic_doc`.\n\nIf only one related declaration is listed in `decl_names` and if this\ninvocation of `add_tactic_doc` does not have a doc string, the doc string of\nthat declaration will become the body of the tactic doc entry. If there are\nmultiple declarations, you can select the one to be used by passing a name to\nthe `inherit_description_from` field.\n\nIf you prefer a tactic to have a doc string that is different then the doc entry,\nyou should write the doc entry as a doc string for the `add_tactic_doc` invocation.\n\nNote that providing a badly formed `tactic_doc_entry` to the command can result in strange error\nmessages."}, {"name": "tactic_doc_entry.has_to_string", "description": ""}, {"name": "tactic.add_library_note", "description": " If `note_name` and `note` are `pexpr`s representing strings,\n`add_library_note note_name note` adds a declaration of type `string \u00d7 string` and tags it with\nthe `library_note` attribute."}, {"name": "doc_category.has_to_format", "description": ""}, {"name": "tactic.get_library_notes", "description": " Collects all notes in the current environment.\nReturns a list of pairs `(note_id, note_content)`"}, {"name": "mk_reflected_definition", "description": "`mk_reflected_definition name val` constructs a definition declaration by reflection.\n\nExample: ``mk_reflected_definition `foo 17`` constructs the definition\ndeclaration corresponding to `def foo : \u2115 := 17`"}, {"name": "tactic_doc.tactic.simp", "description": "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n\n`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n\n`simp [h\u2081 h\u2082 ... h\u2099]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `h\u1d62`'s, where the `h\u1d62`'s are expressions. If `h\u1d62` is preceded by left arrow (`\u2190` or `<-`), the simplification is performed in the reverse direction. If an `h\u1d62` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n\n`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n\n`simp *` is a shorthand for `simp [*]`.\n\n`simp only [h\u2081 h\u2082 ... h\u2099]` is like `simp [h\u2081 h\u2082 ... h\u2099]` but does not use `[simp]` lemmas\n\n`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `id\u1d62`.\n\n`simp at h\u2081 h\u2082 ... h\u2099` simplifies the non-dependent hypotheses `h\u2081 : T\u2081` ... `h\u2099 : T\u2099`. The tactic fails if the target or another hypothesis depends on one of them. The token `\u22a2` or `|-` can be added to the list to include the target.\n\n`simp at *` simplifies all the hypotheses and the target.\n\n`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.\n\n`simp with attr\u2081 ... attr\u2099` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr\u2081]`, ..., `[attr\u2099]` or `[simp]`."}, {"name": "tactic_doc_entry.has_reflect", "description": ""}, {"name": "string.hash", "description": "A rudimentary hash function on strings."}, {"name": "tactic.copy_doc_string", "description": "`copy_doc_string fr to` copies the docstring from the declaration named `fr`\nto each declaration named in the list `to`."}, {"name": "tactic_doc.tactic.cc (congruence closure)", "description": "The congruence closure tactic `cc` tries to solve the goal by chaining\nequalities from context and applying congruence (i.e. if `a = b`, then `f a = f b`).\nIt is a finishing tactic, i.e. it is meant to close\nthe current goal, not to make some inconclusive progress.\nA mostly trivial example would be:\n\n```lean\nexample (a b c : \u2115) (f : \u2115 \u2192 \u2115) (h: a = b) (h' : b = c) : f a = f c := by cc\n```\n\nAs an example requiring some thinking to do by hand, consider:\n\n```lean\nexample (f : \u2115 \u2192 \u2115) (x : \u2115)\n  (H1 : f (f (f x)) = x) (H2 : f (f (f (f (f x)))) = x) :\n  f x = x :=\nby cc\n```\n\nThe tactic works by building an equality matching graph. It's a graph where\nthe vertices are terms and they are linked by edges if they are known to\nbe equal. Once you've added all the equalities in your context, you take\nthe transitive closure of the graph and, for each connected component\n(i.e. equivalence class) you can elect a term that will represent the\nwhole class and store proofs that the other elements are equal to it.\nYou then take the transitive closure of these equalities under the\ncongruence lemmas.\n\nThe `cc` implementation in Lean does a few more tricks: for example it\nderives `a=b` from `nat.succ a = nat.succ b`, and `nat.succ a !=\nnat.zero` for any `a`.\n\n* The starting reference point is Nelson, Oppen, [Fast decision procedures based on congruence\nclosure](http://www.cs.colorado.edu/~bec/courses/csci5535-s09/reading/nelson-oppen-congruence.pdf),\nJournal of the ACM (1980)\n\n* The congruence lemmas for dependent type theory as used in Lean are described in\n[Congruence closure in intensional type theory](https://leanprover.github.io/papers/congr.pdf)\n(de Moura, Selsam IJCAR 2016)."}, {"name": "tactic_doc_entry.to_json", "description": "Turns a `tactic_doc_entry` into a JSON representation."}, {"name": "tactic_doc.command.library_note", "description": "At various places in mathlib, we leave implementation notes that are referenced from many other\nfiles. To keep track of these notes, we use the command `library_note`. This makes it easy to\nretrieve a list of all notes, e.g. for documentation output.\n\nThese notes can be referenced in mathlib with the syntax `Note [note id]`.\nOften, these references will be made in code comments (`--`) that won't be displayed in docs.\nIf such a reference is made in a doc string or module doc, it will be linked to the corresponding\nnote in the doc display.\n\nSyntax:\n```lean\n/--\nnote message\n-/\nlibrary_note \"note id\"\n```\n\nAn example from `meta.expr`:\n\n```lean\n/--\nSome declarations work with open expressions, i.e. an expr that has free variables.\nTerms will free variables are not well-typed, and one should not use them in tactics like\n`infer_type` or `unify`. You can still do syntactic analysis/manipulation on them.\nThe reason for working with open types is for performance: instantiating variables requires\niterating through the expression. In one performance test `pi_binders` was more than 6x\nquicker than `mk_local_pis` (when applied to the type of all imported declarations 100x).\n-/\nlibrary_note \"open expressions\"\n```\n\nThis note can be referenced near a usage of `pi_binders`:\n\n\n```lean\n-- See Note [open expressions]\n/-- behavior of f -/\ndef f := pi_binders ...\n```"}, {"name": "tactic_doc_entry", "description": "The information used to generate a tactic doc entry"}, {"name": "tactic_doc_entry.name", "description": "The information used to generate a tactic doc entry"}, {"name": "tactic_doc_entry.category", "description": "The information used to generate a tactic doc entry"}, {"name": "tactic_doc_entry.decl_names", "description": "The information used to generate a tactic doc entry"}, {"name": "tactic_doc_entry.tags", "description": "The information used to generate a tactic doc entry"}, {"name": "tactic_doc_entry.inherit_description_from", "description": "The information used to generate a tactic doc entry"}, {"name": "library_note_attr", "description": " A user attribute `library_note` for tagging decls of type `string \u00d7 string` for use in note\noutput."}, {"name": "add_tactic_doc_command", "description": "A command used to add documentation for a tactic, command, hole command, or attribute.\n\nUsage: after defining an interactive tactic, command, or attribute,\nadd its documentation as follows.\n```lean\n/--\ndescribe what the command does here\n-/\nadd_tactic_doc\n{ name := \"display name of the tactic\",\n  category := cat,\n  decl_names := [`dcl_1, `dcl_2],\n  tags := [\"tag_1\", \"tag_2\"] }\n```\n\nThe argument to `add_tactic_doc` is a structure of type `tactic_doc_entry`.\n* `name` refers to the display name of the tactic; it is used as the header of the doc entry.\n* `cat` refers to the category of doc entry.\n  Options: `doc_category.tactic`, `doc_category.cmd`, `doc_category.hole_cmd`, `doc_category.attr`\n* `decl_names` is a list of the declarations associated with this doc. For instance,\n  the entry for `linarith` would set ``decl_names := [`tactic.interactive.linarith]``.\n  Some entries may cover multiple declarations.\n  It is only necessary to list the interactive versions of tactics.\n* `tags` is an optional list of strings used to categorize entries.\n* The doc string is the body of the entry. It can be formatted with markdown.\n  What you are reading now is the description of `add_tactic_doc`.\n\nIf only one related declaration is listed in `decl_names` and if this\ninvocation of `add_tactic_doc` does not have a doc string, the doc string of\nthat declaration will become the body of the tactic doc entry. If there are\nmultiple declarations, you can select the one to be used by passing a name to\nthe `inherit_description_from` field.\n\nIf you prefer a tactic to have a doc string that is different then the doc entry,\nyou should write the doc entry as a doc string for the `add_tactic_doc` invocation.\n\nNote that providing a badly formed `tactic_doc_entry` to the command can result in strange error\nmessages."}, {"name": "copy_doc_string_cmd", "description": "`copy_doc_string source \u2192 target_1 target_2 ... target_n` copies the doc string of the\ndeclaration named `source` to each of `target_1`, `target_2`, ..., `target_n`."}, {"name": "add_decl_doc_command", "description": "The `add_decl_doc` command is used to add a doc string to an existing declaration.\n\n```lean\ndef foo := 5\n\n/--\nDoc string for foo.\n-/\nadd_decl_doc foo\n```"}, {"name": "tactic_doc.command.copy_doc_string", "description": "`copy_doc_string source \u2192 target_1 target_2 ... target_n` copies the doc string of the\ndeclaration named `source` to each of `target_1`, `target_2`, ..., `target_n`."}, {"name": "tactic_doc.command.add_decl_doc", "description": "The `add_decl_doc` command is used to add a doc string to an existing declaration.\n\n```lean\ndef foo := 5\n\n/--\nDoc string for foo.\n-/\nadd_decl_doc foo\n```"}, {"name": "tactic_doc_entry_attr", "description": " A user attribute `tactic_doc` for tagging decls of type `tactic_doc_entry`\nfor use in doc output"}, {"name": "tactic.add_tactic_doc", "description": " `add_tactic_doc tde` adds a declaration to the environment\nwith `tde` as its body and tags it with the `tactic_doc`\nattribute. If `tde.decl_names` has exactly one entry `` `decl`` and\nif `tde.description` is the empty string, `add_tactic_doc` uses the doc\nstring of `decl` as the description."}, {"name": "tactic_doc.tactic.conv", "description": "`conv {...}` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://leanprover-community.github.io/extras/conv.html> for more details.\n\nInside `conv` blocks, mathlib currently additionally provides\n* `erw`,\n* `ring`, `ring2` and `ring_exp`,\n* `norm_num`,\n* `norm_cast`,\n* `apply_congr`, and\n* `conv` (within another `conv`).\n\n`apply_congr` applies congruence lemmas to step further inside expressions,\nand sometimes gives better results than the automatically generated\ncongruence lemmas used by `congr`.\n\nUsing `conv` inside a `conv` block allows the user to return to the previous\nstate of the outer `conv` block after it is finished. Thus you can continue\nediting an expression without having to start a new `conv` block and re-scoping\neverything. For example:\n```lean\nexample (a b c d : \u2115) (h\u2081 : b = c) (h\u2082 : a + c = a + d) : a + b = a + d :=\nby conv\n{ to_lhs,\n  conv\n  { congr, skip,\n    rw h\u2081 },\n  rw h\u2082, }\n```\nWithout `conv`, the above example would need to be proved using two successive\n`conv` blocks, each beginning with `to_lhs`.\n\nAlso, as a shorthand, `conv_lhs` and `conv_rhs` are provided, so that\n```lean\nexample : 0 + 0 = 0 :=\nbegin\n  conv_lhs { simp }\nend\n```\njust means\n```lean\nexample : 0 + 0 = 0 :=\nbegin\n  conv { to_lhs, simp }\nend\n```\nand likewise for `to_rhs`."}, {"name": "doc_category", "description": "The categories of tactic doc entry."}, {"name": "doc_category.tactic", "description": "The categories of tactic doc entry."}, {"name": "doc_category.cmd", "description": "The categories of tactic doc entry."}, {"name": "doc_category.hole_cmd", "description": "The categories of tactic doc entry."}, {"name": "doc_category.attr", "description": "The categories of tactic doc entry."}, {"name": "library_note", "description": "A command to add library notes. Syntax:\n```lean\n/--\nnote message\n-/\nlibrary_note \"note id\"\n```"}, {"name": "tactic_doc.command.#html", "description": "Accepts terms with the type `component tactic_state string` or `html empty` and\nrenders them interactively.\nRequires a compatible version of the vscode extension to view the resulting widget.\n\n### Example:\n\n```lean\n/-- A simple counter that can be incremented or decremented with some buttons. -/\nmeta def counter_widget {\u03c0 \u03b1 : Type} : component \u03c0 \u03b1 :=\ncomponent.ignore_props $ component.mk_simple int int 0 (\u03bb _ x y, (x + y, none)) (\u03bb _ s,\n  h \"div\" [] [\n    button \"+\" (1 : int),\n    html.of_string $ to_string $ s,\n    button \"-\" (-1)\n  ]\n)\n\n#html counter_widget\n```"}, {"name": "doc_category.decidable_eq", "description": ""}, {"name": "doc_category.to_string", "description": "Format a `doc_category`"}, {"name": "tactic.get_tactic_doc_entries", "description": "Collects everything in the environment tagged with the attribute `tactic_doc`."}, {"name": "name.last", "description": "Get the last component of a name, and convert it to a string."}, {"name": "doc_category.has_reflect", "description": ""}, {"name": "euclidean_domain.eq_div_of_mul_eq_left", "description": ""}, {"name": "euclidean_domain.gcd_zero_right", "description": ""}, {"name": "euclidean_domain.xgcd_val", "description": ""}, {"name": "euclidean_domain.dvd_lcm_right", "description": ""}, {"name": "euclidean_domain.mod_self", "description": ""}, {"name": "euclidean_domain.gcd.induction", "description": ""}, {"name": "euclidean_domain.mod_one", "description": ""}, {"name": "euclidean_domain.gcd_eq_zero_iff", "description": ""}, {"name": "euclidean_domain.mul_div_mul_cancel", "description": ""}, {"name": "euclidean_domain.mod_zero", "description": ""}, {"name": "field.to_euclidean_domain", "description": ""}, {"name": "euclidean_domain.mul_div_cancel", "description": ""}, {"name": "euclidean_domain.gcd_val", "description": ""}, {"name": "euclidean_domain.xgcd_aux_rec", "description": ""}, {"name": "euclidean_domain.lcm", "description": "`lcm a b` is a (non-unique) element such that `a \u2223 lcm a b` `b \u2223 lcm a b`, and for\n any element `c` such that `a \u2223 c` and `b \u2223 c`, then `lcm a b \u2223 c`"}, {"name": "euclidean_domain.xgcd_zero_left", "description": ""}, {"name": "euclidean_domain.eq_div_of_mul_eq_right", "description": ""}, {"name": "euclidean_domain.div_add_mod'", "description": ""}, {"name": "euclidean_domain.mod_add_div", "description": ""}, {"name": "euclidean_domain.gcd_a_zero_left", "description": ""}, {"name": "euclidean_domain.div_one", "description": ""}, {"name": "euclidean_domain.gcd", "description": "`gcd a b` is a (non-unique) element such that `gcd a b \u2223 a` `gcd a b \u2223 b`, and for\n any element `c` such that `c \u2223 a` and `c \u2223 b`, then `c \u2223 gcd a b`"}, {"name": "euclidean_domain.zero_div", "description": ""}, {"name": "euclidean_domain.gcd_b_zero_left", "description": ""}, {"name": "euclidean_domain.dvd_mod_iff", "description": ""}, {"name": "euclidean_domain.gcd_mul_lcm", "description": ""}, {"name": "euclidean_domain.mul_div_mul_comm_of_dvd_dvd", "description": ""}, {"name": "euclidean_domain.dvd_lcm_left", "description": ""}, {"name": "euclidean_domain.xgcd_aux_fst", "description": ""}, {"name": "euclidean_domain.lt_one", "description": ""}, {"name": "euclidean_domain.is_domain", "description": ""}, {"name": "euclidean_domain.gcd_eq_left", "description": ""}, {"name": "euclidean_domain.mul_div_cancel_left", "description": ""}, {"name": "euclidean_domain.gcd_zero_left", "description": ""}, {"name": "euclidean_domain.mod_add_div'", "description": ""}, {"name": "euclidean_domain.xgcd_aux_val", "description": ""}, {"name": "euclidean_domain", "description": "A `euclidean_domain` is an non-trivial commutative ring with a division and a remainder,\n satisfying `b * (a / b) + a % b = a`.\n The definition of a euclidean domain usually includes a valuation function `R \u2192 \u2115`.\n This definition is slightly generalised to include a well founded relation\n `r` with the property that `r (a % b) b`, instead of a valuation."}, {"name": "euclidean_domain.to_comm_ring", "description": "A `euclidean_domain` is an non-trivial commutative ring with a division and a remainder,\n satisfying `b * (a / b) + a % b = a`.\n The definition of a euclidean domain usually includes a valuation function `R \u2192 \u2115`.\n This definition is slightly generalised to include a well founded relation\n `r` with the property that `r (a % b) b`, instead of a valuation."}, {"name": "euclidean_domain.to_nontrivial", "description": "A `euclidean_domain` is an non-trivial commutative ring with a division and a remainder,\n satisfying `b * (a / b) + a % b = a`.\n The definition of a euclidean domain usually includes a valuation function `R \u2192 \u2115`.\n This definition is slightly generalised to include a well founded relation\n `r` with the property that `r (a % b) b`, instead of a valuation."}, {"name": "euclidean_domain.quotient", "description": "A `euclidean_domain` is an non-trivial commutative ring with a division and a remainder,\n satisfying `b * (a / b) + a % b = a`.\n The definition of a euclidean domain usually includes a valuation function `R \u2192 \u2115`.\n This definition is slightly generalised to include a well founded relation\n `r` with the property that `r (a % b) b`, instead of a valuation."}, {"name": "euclidean_domain.quotient_zero", "description": "A `euclidean_domain` is an non-trivial commutative ring with a division and a remainder,\n satisfying `b * (a / b) + a % b = a`.\n The definition of a euclidean domain usually includes a valuation function `R \u2192 \u2115`.\n This definition is slightly generalised to include a well founded relation\n `r` with the property that `r (a % b) b`, instead of a valuation."}, {"name": "euclidean_domain.remainder", "description": "A `euclidean_domain` is an non-trivial commutative ring with a division and a remainder,\n satisfying `b * (a / b) + a % b = a`.\n The definition of a euclidean domain usually includes a valuation function `R \u2192 \u2115`.\n This definition is slightly generalised to include a well founded relation\n `r` with the property that `r (a % b) b`, instead of a valuation."}, {"name": "euclidean_domain.quotient_mul_add_remainder_eq", "description": "A `euclidean_domain` is an non-trivial commutative ring with a division and a remainder,\n satisfying `b * (a / b) + a % b = a`.\n The definition of a euclidean domain usually includes a valuation function `R \u2192 \u2115`.\n This definition is slightly generalised to include a well founded relation\n `r` with the property that `r (a % b) b`, instead of a valuation."}, {"name": "euclidean_domain.r", "description": "A `euclidean_domain` is an non-trivial commutative ring with a division and a remainder,\n satisfying `b * (a / b) + a % b = a`.\n The definition of a euclidean domain usually includes a valuation function `R \u2192 \u2115`.\n This definition is slightly generalised to include a well founded relation\n `r` with the property that `r (a % b) b`, instead of a valuation."}, {"name": "euclidean_domain.r_well_founded", "description": "A `euclidean_domain` is an non-trivial commutative ring with a division and a remainder,\n satisfying `b * (a / b) + a % b = a`.\n The definition of a euclidean domain usually includes a valuation function `R \u2192 \u2115`.\n This definition is slightly generalised to include a well founded relation\n `r` with the property that `r (a % b) b`, instead of a valuation."}, {"name": "euclidean_domain.remainder_lt", "description": "A `euclidean_domain` is an non-trivial commutative ring with a division and a remainder,\n satisfying `b * (a / b) + a % b = a`.\n The definition of a euclidean domain usually includes a valuation function `R \u2192 \u2115`.\n This definition is slightly generalised to include a well founded relation\n `r` with the property that `r (a % b) b`, instead of a valuation."}, {"name": "euclidean_domain.mul_left_not_lt", "description": "A `euclidean_domain` is an non-trivial commutative ring with a division and a remainder,\n satisfying `b * (a / b) + a % b = a`.\n The definition of a euclidean domain usually includes a valuation function `R \u2192 \u2115`.\n This definition is slightly generalised to include a well founded relation\n `r` with the property that `r (a % b) b`, instead of a valuation."}, {"name": "euclidean_domain.xgcd_aux", "description": "An implementation of the extended GCD algorithm.\nAt each step we are computing a triple `(r, s, t)`, where `r` is the next value of the GCD\nalgorithm, to compute the greatest common divisor of the input (say `x` and `y`), and `s` and `t`\nare the coefficients in front of `x` and `y` to obtain `r` (i.e. `r = s * x + t * y`).\nThe function `xgcd_aux` takes in two triples, and from these recursively computes the next triple:\n```lean\nxgcd_aux (r, s, t) (r', s', t') = xgcd_aux (r' % r, s' - (r' / r) * s, t' - (r' / r) * t) (r, s, t)\n```"}, {"name": "euclidean_domain.div_self", "description": ""}, {"name": "euclidean_domain.has_div", "description": ""}, {"name": "euclidean_domain.gcd_eq_gcd_ab", "description": "An explicit version of **B\u00e9zout's lemma** for Euclidean domains."}, {"name": "euclidean_domain.div_zero", "description": ""}, {"name": "euclidean_domain.gcd_b", "description": "The extended GCD `b` value in the equation `gcd x y = x * a + y * b`."}, {"name": "euclidean_domain.gcd_dvd", "description": ""}, {"name": "euclidean_domain.xgcd", "description": "Use the extended GCD algorithm to generate the `a` and `b` values\n satisfying `gcd x y = x * a + y * b`."}, {"name": "euclidean_domain.mul_right_not_lt", "description": ""}, {"name": "euclidean_domain.gcd_self", "description": ""}, {"name": "euclidean_domain.gcd_dvd_left", "description": ""}, {"name": "euclidean_domain.xgcd_aux_P", "description": ""}, {"name": "euclidean_domain.zero_mod", "description": ""}, {"name": "euclidean_domain.gcd_a", "description": "The extended GCD `a` value in the equation `gcd x y = x * a + y * b`."}, {"name": "euclidean_domain.val_dvd_le", "description": ""}, {"name": "euclidean_domain.mul_div_assoc", "description": ""}, {"name": "euclidean_domain.lcm_eq_zero_iff", "description": ""}, {"name": "euclidean_domain.has_mod", "description": ""}, {"name": "euclidean_domain.dvd_div_of_mul_dvd", "description": ""}, {"name": "euclidean_domain.div_add_mod", "description": ""}, {"name": "euclidean_domain.mod_lt", "description": ""}, {"name": "euclidean_domain.lcm_zero_left", "description": ""}, {"name": "euclidean_domain.mod_eq_zero", "description": ""}, {"name": "euclidean_domain.lcm_zero_right", "description": ""}, {"name": "euclidean_domain.mod_eq_sub_mul_div", "description": ""}, {"name": "int.euclidean_domain", "description": ""}, {"name": "euclidean_domain.lcm_dvd_iff", "description": ""}, {"name": "euclidean_domain.gcd_one_left", "description": ""}, {"name": "euclidean_domain.lcm_dvd", "description": ""}, {"name": "euclidean_domain.div_dvd_of_dvd", "description": ""}, {"name": "euclidean_domain.gcd_dvd_right", "description": ""}, {"name": "euclidean_domain.dvd_gcd", "description": ""}, {"name": "add_units.is_add_regular", "description": "If `R` is an additive monoid, an element in `add_units R` is add-regular."}, {"name": "is_regular_iff_ne_zero", "description": "In a non-trivial integral domain, an element is regular iff it is non-zero."}, {"name": "is_add_right_regular", "description": "An add-right-regular element is an element `c` such that addition on the right by `c`\nis injective."}, {"name": "add_left_embedding", "description": "The embedding of a left cancellative additive semigroup into itself\n   by left translation by a fixed element."}, {"name": "is_right_regular", "description": " A right-regular element is an element `c` such that multiplication on the right by `c`\nis injective."}, {"name": "is_regular_mul_iff", "description": "A product is regular if and only if the factors are."}, {"name": "is_regular.subsingleton", "description": "The element `0` is regular if and only if `R` is trivial."}, {"name": "mul_is_left_regular_iff", "description": "  An element is left-regular if and only if multiplying it on the left by a left-regular element\nis left-regular."}, {"name": "is_left_regular.of_mul", "description": "  If an element `b` becomes left-regular after multiplying it on the left by a left-regular\nelement, then `b` is left-regular."}, {"name": "is_left_regular_of_mul_eq_one", "description": "An element admitting a left inverse is left-regular."}, {"name": "is_unit.is_regular", "description": "A unit in a monoid is regular."}, {"name": "is_left_regular_zero_iff_subsingleton", "description": "The element `0` is left-regular if and only if `R` is trivial."}, {"name": "not_is_right_regular_zero", "description": "In a non-trivial ring, the element `0` is not right-regular -- with typeclasses."}, {"name": "is_add_left_regular_of_add_eq_zero", "description": "An element admitting a left additive opposite is add-left-regular."}, {"name": "add_right_embedding_apply", "description": ""}, {"name": "not_is_right_regular_zero_iff", "description": "In a non-trivial `mul_zero_class`, the `0` element is not right-regular."}, {"name": "is_add_right_regular.of_add", "description": "If an element `b` becomes add-right-regular after adding to it on the right a\nadd-right-regular element, then `b` is add-right-regular."}, {"name": "is_regular.ne_zero", "description": "A regular element of a `nontrivial` `mul_zero_class` is non-zero."}, {"name": "is_regular_of_cancel_monoid", "description": "Elements of a cancel monoid are regular.  Cancel semigroups do not appear to exist."}, {"name": "is_add_left_regular.of_add", "description": "If an element `b` becomes add-left-regular after adding to it on the left a\nadd-left-regular element, then `b` is add-left-regular."}, {"name": "is_left_regular.mul", "description": "In a semigroup, the product of left-regular elements is left-regular."}, {"name": "is_left_regular_of_left_cancel_semigroup", "description": "Elements of a left cancel semigroup are left regular."}, {"name": "is_left_regular", "description": " A left-regular element is an element `c` such that multiplication on the left by `c`\nis injective."}, {"name": "is_right_regular.subsingleton", "description": "The element `0` is right-regular if and only if `R` is trivial."}, {"name": "is_regular_iff_subsingleton", "description": "The element `0` is regular if and only if `R` is trivial."}, {"name": "is_add_left_regular", "description": "An add-left-regular element is an element `c` such that addition on the left by `c`\nis injective. -/"}, {"name": "is_add_left_regular.add", "description": "In an additive semigroup, the sum of add-left-regular elements is add-left.regular."}, {"name": "add_le_cancellable.is_add_left_regular", "description": ""}, {"name": "mul_right_embedding", "description": "The embedding of a right cancellative semigroup into itself\nby right multiplication by a fixed element."}, {"name": "is_right_regular.ne_zero", "description": "A right-regular element of a `nontrivial` `mul_zero_class` is non-zero."}, {"name": "is_regular_one", "description": "If multiplying by `1` on either side is the identity, `1` is regular."}, {"name": "is_right_regular.mul", "description": "In a semigroup, the product of right-regular elements is right-regular."}, {"name": "is_add_left_regular_of_left_cancel_add_semigroup", "description": "Elements of an add left cancel semigroup are add-left-regular."}, {"name": "mul_left_embedding", "description": "The embedding of a left cancellative semigroup into itself\nby left multiplication by a fixed element."}, {"name": "is_left_regular.right_of_commute", "description": ""}, {"name": "is_add_regular", "description": " An add-regular element is an element `c` such that addition by `c` both on the left and\non the right is injective."}, {"name": "is_add_regular.left", "description": " An add-regular element is an element `c` such that addition by `c` both on the left and\non the right is injective."}, {"name": "is_add_regular.right", "description": " An add-regular element is an element `c` such that addition by `c` both on the left and\non the right is injective."}, {"name": "is_right_regular.of_mul", "description": "  If an element `b` becomes right-regular after multiplying it on the right by a right-regular\nelement, then `b` is right-regular."}, {"name": "is_add_regular_add_and_add_iff", "description": "Two elements `a` and `b` are add-regular if and only if both sums `a + b` and `b + a`\nare add-regular."}, {"name": "add_right_embedding", "description": "The embedding of a right cancellative additive semigroup into itself\n   by right translation by a fixed element."}, {"name": "mul_right_embedding_apply", "description": ""}, {"name": "mul_left_embedding_eq_mul_right_embedding", "description": ""}, {"name": "is_regular", "description": " A regular element is an element `c` such that multiplication by `c` both on the left and\non the right is injective."}, {"name": "is_regular.left", "description": " A regular element is an element `c` such that multiplication by `c` both on the left and\non the right is injective."}, {"name": "is_regular.right", "description": " A regular element is an element `c` such that multiplication by `c` both on the left and\non the right is injective."}, {"name": "commute.is_regular_iff", "description": ""}, {"name": "not_is_left_regular_zero", "description": "In a non-trivial ring, the element `0` is not left-regular -- with typeclasses."}, {"name": "add_left_embedding_apply", "description": ""}, {"name": "mul_is_right_regular_iff", "description": "  An element is right-regular if and only if multiplying it on the right with a right-regular\nelement is right-regular."}, {"name": "is_left_regular.subsingleton", "description": "The element `0` is left-regular if and only if `R` is trivial."}, {"name": "is_regular_of_ne_zero", "description": "Non-zero elements of an integral domain are regular."}, {"name": "is_add_right_regular.add", "description": "In an additive semigroup, the sum of add-right-regular elements is add-right-regular."}, {"name": "is_regular_mul_and_mul_iff", "description": "  Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\nare regular."}, {"name": "is_add_right_regular_of_add_eq_zero", "description": "An element admitting a right additive opposite is add-right-regular."}, {"name": "is_add_regular.and_of_add_of_add", "description": "The \"most used\" implication of `add_and_add_iff`, with split hypotheses,\ninstead of `\u2227`."}, {"name": "add_left_embedding_eq_add_right_embedding", "description": ""}, {"name": "units.is_regular", "description": "If `R` is a monoid, an element in `R\u02e3` is regular."}, {"name": "is_add_unit.is_add_regular", "description": "An additive unit in an additive monoid is add-regular."}, {"name": "is_add_regular_zero", "description": "If adding `0` on either side is the identity, `0` is regular."}, {"name": "not_is_regular_zero", "description": "In a non-trivial ring, the element `0` is not regular -- with typeclasses."}, {"name": "is_add_regular_add_iff", "description": "A sum is add-regular if and only if the summands are."}, {"name": "is_right_regular_of_right_cancel_semigroup", "description": "Elements of a right cancel semigroup are right regular."}, {"name": "is_right_regular_of_mul_eq_one", "description": "An element admitting a right inverse is right-regular."}, {"name": "mul_left_embedding_apply", "description": ""}, {"name": "is_left_regular.ne_zero", "description": "A left-regular element of a `nontrivial` `mul_zero_class` is non-zero."}, {"name": "is_add_regular_of_cancel_add_monoid", "description": "Elements of an add cancel monoid are regular.  Add cancel semigroups do not appear to exist."}, {"name": "is_right_regular_zero_iff_subsingleton", "description": "The element `0` is right-regular if and only if `R` is trivial."}, {"name": "mul_le_cancellable.is_left_regular", "description": ""}, {"name": "add_is_add_left_regular_iff", "description": "An element is add-left-regular if and only if adding to it on the left a\nadd-left-regular element is add-left-regular."}, {"name": "add_is_add_right_regular_iff", "description": "An element is add-right-regular if and only if adding it on the right to a\nadd-right-regular element is add-right-regular."}, {"name": "is_regular.and_of_mul_of_mul", "description": "The \"most used\" implication of `mul_and_mul_iff`, with split hypotheses, instead of `\u2227`."}, {"name": "not_is_left_regular_zero_iff", "description": "In a non-trivial `mul_zero_class`, the `0` element is not left-regular."}, {"name": "is_add_right_regular_of_right_cancel_add_semigroup", "description": "Elements of an add right cancel semigroup are add-right-regular"}, {"name": "multiset.count_univ", "description": ""}, {"name": "fintype.card_quotient_le", "description": ""}, {"name": "finset.card_compl", "description": ""}, {"name": "quotient.fin_choice_aux", "description": " An auxiliary function for `quotient.fin_choice`.  Given a\ncollection of setoids indexed by a type `\u03b9`, a (finite) list `l` of\nindices, and a function that for each `i \u2208 l` gives a term of the\ncorresponding quotient type, then there is a corresponding term in the\nquotient of the product of the setoids indexed by `l`."}, {"name": "fintype.card_unit", "description": ""}, {"name": "fintype.card_units_int", "description": ""}, {"name": "fintype.decidable_eq_ring_hom_fintype", "description": ""}, {"name": "mem_image_univ_iff_mem_range", "description": ""}, {"name": "Prop.fintype", "description": ""}, {"name": "fintype.pi_finset_univ", "description": ""}, {"name": "finset.card_fin", "description": ""}, {"name": "fintype.decidable_bijective_fintype", "description": ""}, {"name": "fintype.decidable_mem_range_fintype", "description": ""}, {"name": "fintype.card_punit", "description": ""}, {"name": "finset.subset_univ", "description": ""}, {"name": "set.to_finset_strict_mono", "description": ""}, {"name": "finset.card_lt_iff_ne_univ", "description": ""}, {"name": "finset.card_eq_iff_eq_univ", "description": ""}, {"name": "bool.fintype", "description": ""}, {"name": "perms_of_finset", "description": "Given a finset, produce the finset of all permutations of its elements."}, {"name": "fintype.card_pempty", "description": ""}, {"name": "order_dual.fintype", "description": ""}, {"name": "fintype.of_multiset", "description": "Construct a proof of `fintype \u03b1` from a universal multiset"}, {"name": "fintype.choose", "description": " Given a fintype `\u03b1` and a predicate `p`, associate to a proof that there is a unique element of\n`\u03b1` satisfying `p` this unique element, as an element of `\u03b1`."}, {"name": "function.injective.inv_of_mem_range", "description": "The inverse of an `hf : injective` function `f : \u03b1 \u2192 \u03b2`, of the type `\u21a5(set.range f) \u2192 \u03b1`.\nThis is the computable version of `function.inv_fun` that requires `fintype \u03b1` and `decidable_eq \u03b2`,\nor the function version of applying `(equiv.of_injective f hf).symm`.\nThis function should not usually be used for actual computation because for most cases,\nan explicit inverse can be stated that has better computational properties.\nThis function computes by checking all terms `a : \u03b1` to find the `f a = b`, so it is O(N) where\n`N = fintype.card \u03b1`."}, {"name": "fintype.card_finset_len", "description": ""}, {"name": "function.embedding.equiv_of_fintype_self_embedding_to_embedding", "description": ""}, {"name": "mem_perms_of_list_of_mem", "description": ""}, {"name": "finset.univ_map_embedding", "description": ""}, {"name": "list.infinite", "description": ""}, {"name": "set.to_finset_eq_empty_iff", "description": ""}, {"name": "finset.compl_union", "description": ""}, {"name": "fintype.subsingleton", "description": ""}, {"name": "fintype.decidable_exists_fintype", "description": ""}, {"name": "infinite.nonempty", "description": ""}, {"name": "fintype.card_fin", "description": ""}, {"name": "finset.compl_eq_univ_sdiff", "description": ""}, {"name": "finset.fintype", "description": ""}, {"name": "set_fintype_card_le_univ", "description": ""}, {"name": "function.embedding.fintype", "description": ""}, {"name": "d_array.fintype", "description": ""}, {"name": "fintype.exists_min", "description": ""}, {"name": "fintype.decidable_eq_one_hom_fintype", "description": ""}, {"name": "units_equiv_ne_zero_apply_coe", "description": ""}, {"name": "finset.univ", "description": "`univ` is the universal finite set of type `finset \u03b1` implied from\n the assumption `fintype \u03b1`."}, {"name": "fintype", "description": "`fintype \u03b1` means that `\u03b1` is finite, i.e. there are only\n finitely many distinct elements of type `\u03b1`. The evidence of this\n is a finset `elems` (a list up to permutation without duplicates),\n together with a proof that everything of type `\u03b1` is in the list."}, {"name": "fintype.elems", "description": "`fintype \u03b1` means that `\u03b1` is finite, i.e. there are only\n finitely many distinct elements of type `\u03b1`. The evidence of this\n is a finset `elems` (a list up to permutation without duplicates),\n together with a proof that everything of type `\u03b1` is in the list."}, {"name": "fintype.complete", "description": "`fintype \u03b1` means that `\u03b1` is finite, i.e. there are only\n finitely many distinct elements of type `\u03b1`. The evidence of this\n is a finset `elems` (a list up to permutation without duplicates),\n together with a proof that everything of type `\u03b1` is in the list."}, {"name": "finset.card_lt_univ_of_not_mem", "description": ""}, {"name": "fintype.decidable_eq_add_monoid_hom_fintype", "description": ""}, {"name": "fintype.univ_empty", "description": ""}, {"name": "set.to_finset_inter", "description": ""}, {"name": "fintype.one_lt_card", "description": ""}, {"name": "finset.powerset_eq_univ", "description": ""}, {"name": "function.injective.inv_of_mem_range_surjective", "description": ""}, {"name": "fintype.preorder.well_founded_lt", "description": ""}, {"name": "fintype.card_subtype_eq'", "description": ""}, {"name": "fintype.finset_equiv_set_apply", "description": ""}, {"name": "set.to_finset_diff", "description": ""}, {"name": "unit.fintype", "description": ""}, {"name": "nodup_perms_of_list", "description": ""}, {"name": "fintype.pi_finset_empty", "description": ""}, {"name": "fintype.card_lex", "description": ""}, {"name": "function.embedding.right_inv_of_inv_of_mem_range", "description": ""}, {"name": "fintype.card_eq_zero_equiv_equiv_empty", "description": "A `fintype` with cardinality zero is equivalent to `empty`."}, {"name": "fintype.equiv_fin_of_card_eq", "description": " If the cardinality of `\u03b1` is `n`, there is noncomputably a bijection between `\u03b1` and `fin n`.\n\nSee `fintype.trunc_equiv_fin_of_card_eq` for the computable definition,\nand `fintype.trunc_equiv_fin` and `fintype.equiv_fin` for the bijection `\u03b1 \u2243 fin (card \u03b1)`."}, {"name": "set.to_finset_compl", "description": ""}, {"name": "length_perms_of_list", "description": ""}, {"name": "fin.image_succ_univ", "description": ""}, {"name": "fintype.linear_order.is_well_order_gt", "description": ""}, {"name": "equiv.of_left_inverse_of_card_le", "description": "Construct an equivalence from functions that are inverse to each other."}, {"name": "fintype.card_equiv", "description": ""}, {"name": "infinite_sum", "description": ""}, {"name": "fintype.card_pos_iff", "description": ""}, {"name": "sum.fintype", "description": ""}, {"name": "fintype.sum_left", "description": " Given that `\u03b1 \u2295 \u03b2` is a fintype, `\u03b1` is also a fintype. This is non-computable as it uses\nthat `sum.inl` is an injection, but there's no clear inverse if `\u03b1` is empty."}, {"name": "set.to_finset", "description": "Construct a finset enumerating a set `s`, given a `fintype` instance."}, {"name": "fintype.card_order_dual", "description": ""}, {"name": "finset.univ_inter", "description": ""}, {"name": "infinite.exists_not_mem_finset", "description": ""}, {"name": "fintype.card_ulift", "description": ""}, {"name": "fintype.card_Prop", "description": ""}, {"name": "set.fintype", "description": ""}, {"name": "finset.eq_univ_of_forall", "description": ""}, {"name": "finset.boolean_algebra", "description": ""}, {"name": "fintype.exists_ne_map_eq_of_card_lt", "description": "The pigeonhole principle for finitely many pigeons and pigeonholes.\nThis is the `fintype` version of `finset.exists_ne_map_eq_of_card_lt_of_maps_to`."}, {"name": "finset.image_univ_of_surjective", "description": ""}, {"name": "fintype.card_eq_zero_iff", "description": ""}, {"name": "fintype.induction_empty_option'", "description": " An induction principle for finite types, analogous to `nat.rec`. It effectively says\nthat every `fintype` is either `empty` or `option \u03b1`, up to an `equiv`."}, {"name": "finset.sup_univ_eq_supr", "description": "A special case of `finset.sup_eq_supr` that omits the useless `x \u2208 univ` binder."}, {"name": "fintype.card_eq_zero", "description": ""}, {"name": "fintype.card_subtype_or_disjoint", "description": ""}, {"name": "vector.fintype", "description": ""}, {"name": "finset.inter_univ", "description": ""}, {"name": "function.right_inverse.left_inverse_of_card_le", "description": ""}, {"name": "finset.univ_filter_exists", "description": ""}, {"name": "fintype.card_bool", "description": ""}, {"name": "mem_perms_of_list_iff", "description": ""}, {"name": "multiset.infinite", "description": ""}, {"name": "finset.univ_sigma_univ", "description": ""}, {"name": "additive.fintype", "description": ""}, {"name": "coe_units_equiv_prod_subtype_symm_apply", "description": ""}, {"name": "psigma.fintype_prop_prop", "description": ""}, {"name": "finset.univ_filter_mem_range", "description": "Note this is a special case of `(finset.image_preimage f univ _).symm`."}, {"name": "units.fintype", "description": ""}, {"name": "fintype.card_empty", "description": ""}, {"name": "fintype.card_le_of_surjective", "description": ""}, {"name": "fintype.card_subtype_mono", "description": ""}, {"name": "finset.univ_eq_empty", "description": ""}, {"name": "set.to_finset_empty", "description": ""}, {"name": "finset.compl_ne_univ_iff_nonempty", "description": ""}, {"name": "fintype.univ_pempty", "description": ""}, {"name": "fintype.card_of_finset'", "description": ""}, {"name": "fintype.card_eq", "description": ""}, {"name": "fintype.decidable_eq_embedding_fintype", "description": ""}, {"name": "fintype.card_prod", "description": ""}, {"name": "units_equiv_prod_subtype_apply_coe", "description": ""}, {"name": "fintype.injective_iff_bijective", "description": ""}, {"name": "finset.mem_univ", "description": ""}, {"name": "fintype_of_fintype_ne", "description": "If the subtype of all-but-one elements is a `fintype` then the type itself is a `fintype`."}, {"name": "fintype.card_finset", "description": ""}, {"name": "set.to_finset_congr", "description": ""}, {"name": "function.embedding.fintype'", "description": ""}, {"name": "fin.univ_cast_succ", "description": "Embed `fin n` into `fin (n + 1)` by appending a new `fin.last n` to the `univ`"}, {"name": "fintype.one_lt_card_iff", "description": ""}, {"name": "fintype.card_units", "description": ""}, {"name": "finset.fold_sup_univ", "description": ""}, {"name": "finset.infinite", "description": ""}, {"name": "finset.piecewise_erase_univ", "description": ""}, {"name": "fintype_of_option_equiv", "description": "A type is a `fintype` if its successor (using `option`) is a `fintype`."}, {"name": "fin.image_cast_succ", "description": ""}, {"name": "finset.compl_filter", "description": ""}, {"name": "fintype.exists_ne_of_one_lt_card", "description": ""}, {"name": "fintype_perm", "description": "The collection of permutations of a fintype is a fintype."}, {"name": "fintype.decidable_eq_mul_hom_fintype", "description": ""}, {"name": "finset.mem_compl", "description": ""}, {"name": "fintype.surjective_iff_bijective", "description": ""}, {"name": "set.to_finset_mono", "description": ""}, {"name": "fintype.subtype_eq", "description": " Short-circuit instance to decrease search for `unique.fintype`,\nsince that relies on a subsingleton elimination for `unique`."}, {"name": "equiv.of_left_inverse_of_card_le_symm_apply", "description": ""}, {"name": "finset.univ_filter_card_eq", "description": ""}, {"name": "fintype.card_option", "description": ""}, {"name": "fintype.card_subtype_le", "description": ""}, {"name": "fintype.of_subsingleton'", "description": "Any subsingleton type is (noncomputably) a fintype (with zero or one term)."}, {"name": "fintype.card_of_bijective", "description": ""}, {"name": "finset.univ_pi_univ", "description": ""}, {"name": "fintype_of_option", "description": "If `option \u03b1` is a `fintype` then so is `\u03b1`"}, {"name": "is_empty_fintype", "description": ""}, {"name": "units_equiv_ne_zero", "description": " In a `group_with_zero` `\u03b1`, the unit group `\u03b1\u02e3` is equivalent to the subtype of nonzero\nelements."}, {"name": "fintype.choose_spec", "description": ""}, {"name": "plift.fintype", "description": ""}, {"name": "function.embedding.exists_of_card_le_finset", "description": ""}, {"name": "multiset.subtype.fintype", "description": ""}, {"name": "set.to_finset_ne_eq_erase", "description": ""}, {"name": "fintype.injective_iff_surjective", "description": ""}, {"name": "function.embedding.nonempty_of_card_le", "description": ""}, {"name": "infinite.of_injective", "description": ""}, {"name": "fintype.bijective_iff_injective_and_card", "description": ""}, {"name": "fintype.univ_punit", "description": ""}, {"name": "finset_coe.fintype", "description": ""}, {"name": "equiv.of_left_inverse_of_card_le_apply", "description": ""}, {"name": "finset.not_mem_compl", "description": ""}, {"name": "fintype.bij_inv", "description": "`bij_inv f` is the unique inverse to a bijection `f`. This acts\n  as a computable alternative to `function.inv_fun`."}, {"name": "fintype.card_of_subtype", "description": ""}, {"name": "list.subtype.fintype", "description": ""}, {"name": "fintype.decidable_eq_add_hom_fintype", "description": ""}, {"name": "function.embedding.is_empty", "description": ""}, {"name": "fintype.of_equiv", "description": "If `f : \u03b1 \u2243 \u03b2` and `\u03b1` is a fintype, then `\u03b2` is also a fintype."}, {"name": "fintype.trunc_fin_bijection", "description": " There is (computably) a bijection between `fin (card \u03b1)` and `\u03b1`.\n\nSince it is not unique and depends on which permutation\nof the universe list is used, the bijection is wrapped in `trunc` to\npreserve computability.\n\nSee `fintype.trunc_equiv_fin` for a version that gives an equivalence\ngiven `[decidable_eq \u03b1]`."}, {"name": "fintype.exists_infinite_fiber", "description": "The strong pigeonhole principle for infinitely many pigeons in\nfinitely many pigeonholes.  If there are infinitely many pigeons in\nfinitely many pigeonholes, then there is a pigeonhole with infinitely\nmany pigeons.\n\nSee also: `fintype.exists_ne_map_eq_of_infinite`"}, {"name": "finset.univ_product_univ", "description": ""}, {"name": "fintype.induction_empty_option", "description": " An induction principle for finite types, analogous to `nat.rec`. It effectively says\nthat every `fintype` is either `empty` or `option \u03b1`, up to an `equiv`."}, {"name": "fintype.pi_finset_disjoint_of_disjoint", "description": ""}, {"name": "fintype.sum_right", "description": " Given that `\u03b1 \u2295 \u03b2` is a fintype, `\u03b2` is also a fintype. This is non-computable as it uses\nthat `sum.inr` is an injection, but there's no clear inverse if `\u03b2` is empty."}, {"name": "fintype.trunc_equiv_fin_of_card_eq", "description": " If the cardinality of `\u03b1` is `n`, there is computably a bijection between `\u03b1` and `fin n`.\n\nSee `fintype.equiv_fin_of_card_eq` for the noncomputable definition,\nand `fintype.trunc_equiv_fin` and `fintype.equiv_fin` for the bijection `\u03b1 \u2243 fin (card \u03b1)`."}, {"name": "function.injective.surjective_of_fintype", "description": "**Alias** of the forward direction of `fintype.injective_iff_surjective_of_equiv`."}, {"name": "set.to_finset_disjoint_iff", "description": ""}, {"name": "sym.fintype", "description": ""}, {"name": "fintype.of_is_empty", "description": ""}, {"name": "finset.subtype.fintype", "description": ""}, {"name": "quotient.fin_choice_aux_eq", "description": ""}, {"name": "fintype.trunc_equiv_of_card_eq", "description": " Two `fintype`s with the same cardinality are (computably) in bijection.\n\nSee `fintype.equiv_of_card_eq` for the noncomputable version,\nand `fintype.trunc_equiv_fin_of_card_eq` and `fintype.equiv_fin_of_card_eq` for\nthe specialization to `fin`."}, {"name": "fintype.card_eq_one_iff_nonempty_unique", "description": ""}, {"name": "fintype.card_unique", "description": ""}, {"name": "fintype.decidable_eq_equiv_fintype", "description": ""}, {"name": "fintype.finset_equiv_set", "description": " Given `fintype \u03b1`, `finset_equiv_set` is the equiv between `finset \u03b1` and `set \u03b1`. (All\nsets on a finite type are finite.)"}, {"name": "fintype.right_inverse_bij_inv", "description": ""}, {"name": "fintype.card_set", "description": ""}, {"name": "sym.sym'.fintype", "description": ""}, {"name": "trunc_of_nonempty_fintype", "description": "A `nonempty` `fintype` constructively contains an element."}, {"name": "fintype.injective_iff_surjective_of_equiv", "description": ""}, {"name": "finset.inter_compl", "description": ""}, {"name": "set.mem_to_finset", "description": ""}, {"name": "fintype.trunc_equiv_fin", "description": " There is (computably) an equivalence between `\u03b1` and `fin (card \u03b1)`.\n\nSince it is not unique and depends on which permutation\nof the universe list is used, the equivalence is wrapped in `trunc` to\npreserve computability.\n\nSee `fintype.equiv_fin` for the noncomputable version,\nand `fintype.trunc_equiv_fin_of_card_eq` and `fintype.equiv_fin_of_card_eq`\nfor an equiv `\u03b1 \u2243 fin n` given `fintype.card \u03b1 = n`.\n\nSee `fintype.trunc_fin_bijection` for a version without `[decidable_eq \u03b1]`."}, {"name": "finset.card_univ", "description": ""}, {"name": "fintype.bijective_iff_surjective_and_card", "description": ""}, {"name": "function.surjective.injective_of_fintype", "description": "**Alias** of the reverse direction of `fintype.injective_iff_surjective_of_equiv`."}, {"name": "fintype.exists_univ_list", "description": ""}, {"name": "function.injective.right_inv_of_inv_of_mem_range", "description": ""}, {"name": "psigma.fintype", "description": ""}, {"name": "fintype.prod_right", "description": "Given that `\u03b1 \u00d7 \u03b2` is a fintype, `\u03b2` is also a fintype."}, {"name": "set.to_finset_univ", "description": ""}, {"name": "multiplicative.fintype", "description": ""}, {"name": "fintype.well_founded_of_trans_of_irrefl", "description": ""}, {"name": "exists_seq_of_forall_finset_exists", "description": " Induction principle to build a sequence, by adding one point at a time satisfying a given\nrelation with respect to all the previously chosen points.\n\nMore precisely, Assume that, for any finite set `s`, one can find another point satisfying\nsome relation `r` with respect to all the points in `s`. Then one may construct a\nfunction `f : \u2115 \u2192 \u03b1` such that `r (f m) (f n)` holds whenever `m < n`.\nWe also ensure that all constructed points satisfy a given predicate `P`."}, {"name": "finset.univ_unique", "description": ""}, {"name": "pfun_fintype", "description": ""}, {"name": "fintype.left_inverse_bij_inv", "description": ""}, {"name": "fintype.of_equiv_card", "description": ""}, {"name": "finite_iff_nonempty_fintype", "description": ""}, {"name": "fintype.card_congr'", "description": ""}, {"name": "array.fintype", "description": ""}, {"name": "univ_sum_type", "description": ""}, {"name": "units_int.fintype", "description": ""}, {"name": "function.embedding.inv_fun_restrict", "description": ""}, {"name": "fintype.card_subtype_lt", "description": ""}, {"name": "fintype.mem_pi_finset", "description": ""}, {"name": "fintype.card_subtype_or", "description": ""}, {"name": "not_surjective_fintype_infinite", "description": ""}, {"name": "psigma.fintype_prop_right", "description": ""}, {"name": "finset.union_compl", "description": ""}, {"name": "finset.card_le_univ", "description": ""}, {"name": "fintype.of_bijective", "description": "If `f : \u03b1 \u2192 \u03b2` is a bijection and `\u03b1` is a fintype, then `\u03b2` is also a fintype."}, {"name": "fintype.decidable_pi_fintype", "description": ""}, {"name": "infinite.nontrivial", "description": ""}, {"name": "fintype.card_subtype_eq", "description": ""}, {"name": "infinite.false", "description": ""}, {"name": "finset.equiv_fin", "description": "Noncomputable equivalence between a finset `s` coerced to a type and `fin s.card`."}, {"name": "punit.fintype", "description": ""}, {"name": "fintype.decidable_eq_zero_hom_fintype", "description": ""}, {"name": "option.infinite", "description": ""}, {"name": "fintype.bijective_bij_inv", "description": ""}, {"name": "fintype.finset_equiv_set_symm_apply", "description": ""}, {"name": "finset.to_finset_coe", "description": ""}, {"name": "nonempty_fintype", "description": ""}, {"name": "fintype.card_pos", "description": ""}, {"name": "finset.mem_powerset_len_univ_iff", "description": ""}, {"name": "fintype.decidable_injective_fintype", "description": ""}, {"name": "fintype.pi_finset_subsingleton", "description": ""}, {"name": "pi.fintype", "description": "A dependent product of fintypes, indexed by a fintype, is a fintype."}, {"name": "fintype.card_eq_one_of_forall_eq", "description": ""}, {"name": "subtype.fintype", "description": ""}, {"name": "fintype.of_finite", "description": " Noncomputably get a `fintype` instance from a `finite` instance. This is not an\ninstance because we want `fintype` instances to be useful for computations."}, {"name": "equiv.fintype", "description": ""}, {"name": "fin.fintype", "description": ""}, {"name": "set_fintype_card_eq_univ_iff", "description": ""}, {"name": "finset.powerset_univ", "description": ""}, {"name": "fin.equiv_iff_eq", "description": ""}, {"name": "finset.equiv_fin_of_card_eq", "description": " Noncomputable equivalence between a finset `s` as a fintype and `fin n`, when there is a\nproof that `s.card = n`."}, {"name": "psigma.fintype_prop_left", "description": ""}, {"name": "finset.compl_singleton", "description": ""}, {"name": "set.to_finset_range", "description": ""}, {"name": "plift.fintype_Prop", "description": ""}, {"name": "prod.fintype", "description": ""}, {"name": "fintype.of_subsingleton", "description": "Any subsingleton type with a witness is a fintype (with one term)."}, {"name": "fintype.of_list", "description": "Construct a proof of `fintype \u03b1` from a universal list"}, {"name": "function.injective.left_inv_of_inv_of_mem_range", "description": ""}, {"name": "set.to_finset_card", "description": ""}, {"name": "ulift.fintype", "description": ""}, {"name": "fintype.induction_subsingleton_or_nontrivial", "description": " A custom induction principle for fintypes. The base case is a subsingleton type,\nand the induction step is for non-trivial types, and one can assume the hypothesis for\nsmaller types (via `fintype.card`).\n\nThe major premise is `fintype \u03b1`, so to use this with the `induction` tactic you have to give a name\nto that instance and use that name."}, {"name": "sum.infinite_of_left", "description": ""}, {"name": "finset.exists_minimal", "description": ""}, {"name": "finset.fold_inf_univ", "description": ""}, {"name": "int.infinite", "description": ""}, {"name": "infinite.nat_embedding", "description": "Embedding of `\u2115` into an infinite type."}, {"name": "fin.cast_eq_cast'", "description": "A reversed version of `fin.cast_eq_cast` that is easier to rewrite with."}, {"name": "quotient.fin_choice_eq", "description": ""}, {"name": "infinite", "description": "A type is said to be infinite if it has no fintype instance.\n Note that `infinite \u03b1` is equivalent to `is_empty (fintype \u03b1)`."}, {"name": "infinite.not_fintype", "description": "A type is said to be infinite if it has no fintype instance.\n Note that `infinite \u03b1` is equivalent to `is_empty (fintype \u03b1)`."}, {"name": "fintype.linear_order.is_well_order_lt", "description": ""}, {"name": "fintype_of_not_infinite", "description": "A non-infinite type is a fintype."}, {"name": "finset.exists_maximal", "description": ""}, {"name": "finset.univ_map_equiv_to_embedding", "description": ""}, {"name": "seq_of_forall_finset_exists_aux", "description": "Auxiliary definition to show `exists_seq_of_forall_finset_exists`."}, {"name": "fintype.pi_finset_singleton", "description": ""}, {"name": "prod.infinite_of_right", "description": ""}, {"name": "function.embedding.is_empty_of_card_lt", "description": " If `\u2016\u03b2\u2016 < \u2016\u03b1\u2016` there are no embeddings `\u03b1 \u21aa \u03b2`.\nThis is a formulation of the pigeonhole principle.\n\nNote this cannot be an instance as it needs `h`."}, {"name": "fintype.of_surjective", "description": "If `f : \u03b1 \u2192 \u03b2` is a surjection and `\u03b1` is a fintype, then `\u03b2` is also a fintype."}, {"name": "finset.compl_erase", "description": ""}, {"name": "fintype.decidable_right_inverse_fintype", "description": ""}, {"name": "set.mem_to_finset_val", "description": ""}, {"name": "coe_inv_units_equiv_prod_subtype_symm_apply", "description": ""}, {"name": "finset.compl_empty", "description": ""}, {"name": "fintype.finite", "description": ""}, {"name": "fintype.of_finset", "description": "Construct a fintype from a finset with the same elements."}, {"name": "fintype.card_perm", "description": ""}, {"name": "set.to_finset_singleton", "description": ""}, {"name": "finset.univ_nonempty_iff", "description": ""}, {"name": "finset.card_compl_lt_iff_nonempty", "description": ""}, {"name": "fintype.choose_x", "description": " Given a fintype `\u03b1` and a predicate `p`, associate to a proof that there is a unique element of\n`\u03b1` satisfying `p` this unique element, as an element of the corresponding subtype."}, {"name": "fintype.of_injective", "description": " Given an injective function to a fintype, the domain is also a\nfintype. This is noncomputable because injectivity alone cannot be\nused to construct preimages."}, {"name": "infinite.exists_subset_card_eq", "description": ""}, {"name": "finset.piecewise_univ", "description": ""}, {"name": "fintype.two_lt_card_iff", "description": ""}, {"name": "fintype.decidable_left_inverse_fintype", "description": ""}, {"name": "finite.of_fintype", "description": " For efficiency reasons, we want `finite` instances to have higher\npriority than ones coming from `fintype` instances."}, {"name": "finset.univ_eq_attach", "description": ""}, {"name": "fintype.card_compl_eq_card_compl", "description": "If two subtypes of a fintype have equal cardinality, so do their complements."}, {"name": "finset.piecewise_compl", "description": ""}, {"name": "fintype.choose_subtype_eq", "description": ""}, {"name": "fintype.exists_pair_of_one_lt_card", "description": ""}, {"name": "finset.mem_univ_val", "description": ""}, {"name": "finset.fintype_coe_sort", "description": ""}, {"name": "fintype.card_le_of_injective", "description": ""}, {"name": "fintype.one_lt_card_iff_nontrivial", "description": ""}, {"name": "fintype.card_eq_one_iff", "description": ""}, {"name": "function.embedding.trunc_of_card_le", "description": "A constructive embedding of a fintype `\u03b1` in another fintype `\u03b2` when `card \u03b1 \u2264 card \u03b2`."}, {"name": "finset.eq_univ_iff_forall", "description": ""}, {"name": "function.embedding.equiv_of_fintype_self_embedding", "description": "An embedding from a `fintype` to itself can be promoted to an equivalence."}, {"name": "not_injective_infinite_fintype", "description": ""}, {"name": "fintype.univ_bool", "description": ""}, {"name": "fintype.subtype_card", "description": ""}, {"name": "finset.compl_insert", "description": ""}, {"name": "fintype.false", "description": ""}, {"name": "unique.fintype", "description": ""}, {"name": "fin_injective", "description": " `fin` as a map from `\u2115` to `Type` is injective. Note that since this is a statement about\nequality of types, using it should be avoided if possible."}, {"name": "prod.infinite_of_left", "description": ""}, {"name": "set.to_finset_insert", "description": ""}, {"name": "fintype.pi_finset_subset", "description": ""}, {"name": "fin.univ_def", "description": ""}, {"name": "finset.coe_univ", "description": ""}, {"name": "sum.infinite_of_right", "description": ""}, {"name": "finset.order_top", "description": ""}, {"name": "equiv.of_right_inverse_of_card_le", "description": "Construct an equivalence from functions that are inverse to each other."}, {"name": "mem_of_mem_perms_of_list", "description": ""}, {"name": "equiv.of_right_inverse_of_card_le_symm_apply", "description": ""}, {"name": "fintype.card_range", "description": ""}, {"name": "quotient.fintype", "description": ""}, {"name": "fintype.subtype_eq'", "description": " Short-circuit instance to decrease search for `unique.fintype`,\nsince that relies on a subsingleton elimination for `unique`."}, {"name": "infinite.of_surjective", "description": ""}, {"name": "fintype.equiv_of_card_eq", "description": " Two `fintype`s with the same cardinality are (noncomputably) in bijection.\n\nSee `fintype.trunc_equiv_of_card_eq` for the computable version,\nand `fintype.trunc_equiv_fin_of_card_eq` and `fintype.equiv_fin_of_card_eq` for\nthe specialization to `fin`."}, {"name": "set.to_finset_inj", "description": ""}, {"name": "fintype.card_lt_of_surjective_not_injective", "description": ""}, {"name": "fintype.card_of_is_empty", "description": " Note: this lemma is specifically about `fintype.of_is_empty`. For a statement about\narbitrary `fintype` instances, use `fintype.card_eq_zero_iff`."}, {"name": "fintype.card_quotient_lt", "description": ""}, {"name": "finset.coe_filter_univ", "description": ""}, {"name": "set.coe_to_finset", "description": ""}, {"name": "fintype.decidable_eq_monoid_hom_fintype", "description": ""}, {"name": "fintype.subtype", "description": " Given a predicate that can be represented by a finset, the subtype\nassociated to the predicate is a fintype."}, {"name": "fintype.pi_finset", "description": " Given for all `a : \u03b1` a finset `t a` of `\u03b4 a`, then one can define the\nfinset `fintype.pi_finset t` of all functions taking values in `t a` for all `a`. This is the\nanalogue of `finset.pi` where the base finset is `univ` (but formally they are not the same, as\nthere is an additional condition `i \u2208 finset.univ` in the `finset.pi` definition)."}, {"name": "fintype.card_le_of_embedding", "description": ""}, {"name": "fin.image_succ_above_univ", "description": ""}, {"name": "finset.univ_eq_empty_iff", "description": ""}, {"name": "fintype.decidable_eq_monoid_with_zero_hom_fintype", "description": ""}, {"name": "infinite_prod", "description": ""}, {"name": "finset.map_univ_equiv", "description": ""}, {"name": "set.to_finset_union", "description": ""}, {"name": "fintype.card_lt_of_injective_not_surjective", "description": ""}, {"name": "set.filter_mem_univ_eq_to_finset", "description": ""}, {"name": "equiv.of_right_inverse_of_card_le_apply", "description": ""}, {"name": "fintype.card_le_one_iff", "description": ""}, {"name": "finset.insert_inj_on'", "description": ""}, {"name": "card_perms_of_finset", "description": ""}, {"name": "infinite.set", "description": ""}, {"name": "finite.of_surjective", "description": ""}, {"name": "fintype.prod_left", "description": "Given that `\u03b1 \u00d7 \u03b2` is a fintype, `\u03b1` is also a fintype."}, {"name": "fintype.exists_ne_map_eq_of_infinite", "description": "The pigeonhole principle for infinitely many pigeons in finitely many pigeonholes. If there are\ninfinitely many pigeons in finitely many pigeonholes, then there are at least two pigeons in the\nsame pigeonhole.\n\nSee also: `fintype.exists_ne_map_eq_of_card_lt`, `fintype.exists_infinite_fiber`."}, {"name": "finset.sdiff_eq_inter_compl", "description": ""}, {"name": "finset.eq_univ_of_card", "description": ""}, {"name": "univ_eq_singleton_of_card_one", "description": ""}, {"name": "function.embedding.inv_of_mem_range_surjective", "description": ""}, {"name": "fintype.card_ne_zero", "description": ""}, {"name": "fintype.exists_max", "description": ""}, {"name": "finset.coe_eq_univ", "description": ""}, {"name": "mem_perms_of_finset_iff", "description": ""}, {"name": "fintype.coe_image_univ", "description": ""}, {"name": "finset.univ_nonempty", "description": ""}, {"name": "units_equiv_ne_zero_symm_apply", "description": ""}, {"name": "finite.of_injective", "description": ""}, {"name": "function.embedding.left_inv_of_inv_of_mem_range", "description": ""}, {"name": "finset.map_univ_of_surjective", "description": ""}, {"name": "fintype.card_subtype", "description": ""}, {"name": "units_equiv_prod_subtype", "description": "The `\u03b1\u02e3` type is equivalent to a subtype of `\u03b1 \u00d7 \u03b1`."}, {"name": "card_finset_fin_le", "description": ""}, {"name": "fin.univ_succ_above", "description": " Embed `fin n` into `fin (n + 1)` by inserting\naround a specified pivot `p : fin (n + 1)` into the `univ`"}, {"name": "fintype.card_le_one_iff_subsingleton", "description": ""}, {"name": "fintype.card_range_le", "description": ""}, {"name": "fintype.card_compl_set", "description": ""}, {"name": "set_fintype", "description": "A set on a fintype, when coerced to a type, is a fintype."}, {"name": "fintype.univ_unit", "description": ""}, {"name": "finset.attach_eq_univ", "description": ""}, {"name": "fintype.decidable_surjective_fintype", "description": ""}, {"name": "finset.inf_univ_eq_infi", "description": "A special case of `finset.inf_eq_infi` that omits the useless `x \u2208 univ` binder."}, {"name": "fintype.decidable_forall_fintype", "description": ""}, {"name": "fintype.card_lt_of_injective_of_not_mem", "description": ""}, {"name": "trunc_of_card_pos", "description": "A `fintype` with positive cardinality constructively contains an element."}, {"name": "lex.fintype", "description": ""}, {"name": "fintype.preorder.well_founded_gt", "description": ""}, {"name": "exists_seq_of_forall_finset_exists'", "description": " Induction principle to build a sequence, by adding one point at a time satisfying a given\nsymmetric relation with respect to all the previously chosen points.\n\nMore precisely, Assume that, for any finite set `s`, one can find another point satisfying\nsome relation `r` with respect to all the points in `s`. Then one may construct a\nfunction `f : \u2115 \u2192 \u03b1` such that `r (f m) (f n)` holds whenever `m \u2260 n`.\nWe also ensure that all constructed points satisfy a given predicate `P`."}, {"name": "fintype.card_sum", "description": ""}, {"name": "quotient.fin_choice", "description": " Given a collection of setoids indexed by a fintype `\u03b9` and a\nfunction that for each `i : \u03b9` gives a term of the corresponding\nquotient type, then there is corresponding term in the quotient of the\nproduct of the setoids."}, {"name": "not_fintype", "description": ""}, {"name": "finset.card_univ_diff", "description": ""}, {"name": "fintype.card_plift", "description": ""}, {"name": "set.decidable_mem_of_fintype", "description": " Membership of a set with a `fintype` instance is decidable.\n\nUsing this as an instance leads to potential loops with `subtype.fintype` under certain decidability\nassumptions, so it should only be declared a local instance."}, {"name": "fintype.equiv_fin", "description": " There is (noncomputably) an equivalence between `\u03b1` and `fin (card \u03b1)`.\n\nSee `fintype.trunc_equiv_fin` for the computable version,\nand `fintype.trunc_equiv_fin_of_card_eq` and `fintype.equiv_fin_of_card_eq`\nfor an equiv `\u03b1 \u2243 fin n` given `fintype.card \u03b1 = n`."}, {"name": "perms_of_list", "description": "Given a list, produce a list of all permutations of its elements."}, {"name": "finset.compl_inter", "description": ""}, {"name": "finset.equiv_of_card_eq", "description": " Noncomputable equivalence between two finsets `s` and `t` as fintypes when there is a proof\nthat `s.card = t.card`."}, {"name": "sigma.fintype", "description": ""}, {"name": "trunc_of_multiset_exists_mem", "description": "For `s : multiset \u03b1`, we can lift the existential statement that `\u2203 x, x \u2208 s` to a `trunc \u03b1`."}, {"name": "function.embedding.inv_of_mem_range", "description": "The inverse of an embedding `f : \u03b1 \u21aa \u03b2`, of the type `\u21a5(set.range f) \u2192 \u03b1`.\nThis is the computable version of `function.inv_fun` that requires `fintype \u03b1` and `decidable_eq \u03b2`,\nor the function version of applying `(equiv.of_injective f f.injective).symm`.\nThis function should not usually be used for actual computation because for most cases,\nan explicit inverse can be stated that has better computational properties.\nThis function computes by checking all terms `a : \u03b1` to find the `f a = b`, so it is O(N) where\n`N = fintype.card \u03b1`."}, {"name": "finset.coe_compl", "description": ""}, {"name": "fintype.card_of_finset", "description": ""}, {"name": "fintype.trunc_rec_empty_option", "description": " A recursor principle for finite types, analogous to `nat.rec`. It effectively says\nthat every `fintype` is either `empty` or `option \u03b1`, up to an `equiv`."}, {"name": "univ_option", "description": ""}, {"name": "fin.univ_succ", "description": "Embed `fin n` into `fin (n + 1)` by prepending zero to the `univ`"}, {"name": "function.left_inverse.right_inverse_of_card_le", "description": ""}, {"name": "fintype.univ_of_is_empty", "description": " Note: this lemma is specifically about `fintype.of_is_empty`. For a statement about\narbitrary `fintype` instances, use `finset.univ_eq_empty`."}, {"name": "nat.infinite", "description": ""}, {"name": "fintype.card_congr", "description": ""}, {"name": "trunc_sigma_of_exists", "description": "By iterating over the elements of a fintype, we can lift an existential statement `\u2203 a, P a`\nto `trunc (\u03a3' a, P a)`, containing data."}, {"name": "fintype_of_finset_card_le", "description": "If every finset in a type has bounded cardinality, that type is finite."}, {"name": "fintype.card", "description": "`card \u03b1` is the number of elements in `\u03b1`, defined when `\u03b1` is a fintype."}, {"name": "finset.insert_compl_self", "description": ""}, {"name": "fintype.card_of_subsingleton", "description": " Note: this lemma is specifically about `fintype.of_subsingleton`. For a statement about\narbitrary `fintype` instances, use either `fintype.card_le_one_iff_subsingleton` or\n`fintype.card_unique`."}, {"name": "fintype.univ_of_subsingleton", "description": ""}, {"name": "fintype.card_coe", "description": ""}, {"name": "fintype.card_subtype_compl", "description": ""}, {"name": "option.fintype", "description": ""}, {"name": "units_int.univ", "description": ""}, {"name": "fintype_or_infinite", "description": "Any type is (classically) either a `fintype`, or `infinite`.\n\nOne can obtain the relevant typeclasses via `cases fintype_or_infinite \u03b1; resetI`."}, {"name": "fintype.coe_pi_finset", "description": ""}, {"name": "function.injective.inv_fun_restrict", "description": ""}, {"name": "fintype.prod_empty", "description": ""}, {"name": "finset.sum_range_sub", "description": "A telescoping sum along `{0, ..., n - 1}` of an additive commutative group valued\nfunction reduces to the difference of the last and first terms."}, {"name": "finset.prod_const_one", "description": ""}, {"name": "nat.cast_prod", "description": ""}, {"name": "finset.sum", "description": "`\u2211 x in s, f x` is the sum of `f x` as `x` ranges over the elements\nof the finite set `s`."}, {"name": "units.coe_prod", "description": ""}, {"name": "library_note.operator precedence of big operators", "description": "There is no established mathematical convention\nfor the operator precedence of big operators like `\u220f` and `\u2211`.\nWe will have to make a choice.\n\nOnline discussions, such as https://math.stackexchange.com/q/185538/30839\nseem to suggest that `\u220f` and `\u2211` should have the same precedence,\nand that this should be somewhere between `*` and `+`.\nThe latter have precedence levels `70` and `65` respectively,\nand we therefore choose the level `67`.\n\nIn practice, this means that parentheses should be placed as follows:\n```lean\n\u2211 k in K, (a k + b k) = \u2211 k in K, a k + \u2211 k in K, b k \u2192\n  \u220f k in K, a k * b k = (\u220f k in K, a k) * (\u220f k in K, b k)\n```\n(Example taken from page 490 of Knuth's *Concrete Mathematics*.)"}, {"name": "finset.sum_finset_product", "description": ""}, {"name": "finset.prod_mul_distrib", "description": ""}, {"name": "finset.prod_attach", "description": ""}, {"name": "finset.prod_subtype_of_mem", "description": " If all elements of a `finset` satisfy the predicate `p`, a product\nover `s.subtype p` equals that product over `s`."}, {"name": "finset.sum_dite_of_true", "description": ""}, {"name": "finset.prod_sigma", "description": " Product over a sigma type equals the product of fiberwise products. For rewriting\nin the reverse direction, use `finset.prod_sigma'`."}, {"name": "finset.prod_to_list", "description": ""}, {"name": "multiset.sum_sum", "description": ""}, {"name": "finset.sum_apply_ite_of_false", "description": ""}, {"name": "multiset.finset_sum_eq_sup_iff_disjoint", "description": ""}, {"name": "equiv.perm.sum_comp'", "description": ""}, {"name": "finset.prod_comm", "description": ""}, {"name": "finset.prod_sdiff", "description": ""}, {"name": "finset.prod_sdiff_div_prod_sdiff", "description": ""}, {"name": "fintype.prod_eq_prod_compl_mul", "description": ""}, {"name": "fintype.prod_equiv", "description": " `fintype.prod_equiv` is a specialization of `finset.prod_bij` that\nautomatically fills in most arguments.\n\nSee `equiv.prod_comp` for a version without `h`."}, {"name": "finset.prod_filter_of_ne", "description": ""}, {"name": "finset.prod_flip", "description": ""}, {"name": "finset.sum_apply_ite_of_true", "description": ""}, {"name": "is_compl.sum_add_sum", "description": ""}, {"name": "finset.prod_update_of_not_mem", "description": ""}, {"name": "finset.prod_eq_prod_diff_singleton_mul", "description": ""}, {"name": "multiset.disjoint_finset_sum_left", "description": ""}, {"name": "fintype.sum_equiv", "description": "`fintype.sum_equiv` is a specialization of `finset.sum_bij` that\nautomatically fills in most arguments.\n\nSee `equiv.sum_comp` for a version without `h`."}, {"name": "finset.sum_subtype_map_embedding", "description": "A sum of a function over a `finset` in a subtype equals a\nsum in the main type of a function that agrees with the first\nfunction on that `finset`."}, {"name": "finset.sum_multiset_count", "description": ""}, {"name": "finset.sum_dite_of_false", "description": ""}, {"name": "finset.add_sum_erase", "description": "Taking a sum over `s : finset \u03b1` is the same as adding the value on a single element\n`f a` to the sum over `s.erase a`.\n\nSee `multiset.sum_map_erase` for the `multiset` version."}, {"name": "multiset.to_finset_prod_dvd_prod", "description": ""}, {"name": "finset.prod_cancels_of_partition_cancels", "description": "If we can partition a product into subsets that cancel out, then the whole product cancels."}, {"name": "finset.prod_eq_single_of_mem", "description": ""}, {"name": "finset.sum_range_tsub", "description": "A telescoping sum along `{0, ..., n-1}` of an `\u2115`-valued function\nreduces to the difference of the last and first terms\nwhen the function we are summing is monotone."}, {"name": "finset.sum_product_right", "description": ""}, {"name": "finset.prod_dite_of_false", "description": ""}, {"name": "finset.sum_comm", "description": ""}, {"name": "finset.sum_cons", "description": ""}, {"name": "finset.prod_apply_ite", "description": ""}, {"name": "finset.sum_range_add_sub_sum_range", "description": ""}, {"name": "finset.prod_finset_product_right", "description": ""}, {"name": "finset.prod_boole", "description": ""}, {"name": "finset.sum_to_list", "description": ""}, {"name": "finset.sum_dite_irrel", "description": ""}, {"name": "finset.sum_partition", "description": "A sum can be partitioned into a sum of sums, each equivalent under a setoid."}, {"name": "finset.sum_list_map_count", "description": ""}, {"name": "finset.prod_range_succ", "description": ""}, {"name": "fintype.prod_eq_mul_prod_compl", "description": ""}, {"name": "finset.prod_singleton", "description": ""}, {"name": "finset.sum_filter_count_eq_countp", "description": ""}, {"name": "int.cast_prod", "description": ""}, {"name": "finset.prod_partition", "description": "A product can be partitioned into a product of products, each equivalent under a setoid."}, {"name": "finset.prod_range_induction", "description": " For any product along `{0, ..., n - 1}` of a commutative-monoid-valued function, we can verify\nthat it's equal to a different function just by checking ratios of adjacent terms.\n\nThis is a multiplicative discrete analogue of the fundamental theorem of calculus."}, {"name": "finset.sum_sdiff", "description": ""}, {"name": "multiset.add_eq_union_left_of_le", "description": ""}, {"name": "finset.prod_finset_product_right'", "description": ""}, {"name": "finset.sum_erase_lt_of_pos", "description": ""}, {"name": "finset.eq_zero_of_sum_eq_zero", "description": "If a sum is 0 and the function is 0 except possibly at one\npoint, it is 0 everywhere on the `finset`."}, {"name": "finset.sum_sub_distrib", "description": ""}, {"name": "finset.prod_erase", "description": " If a function applied at a point is 1, a product is unchanged by\nremoving that point, if present, from a `finset`."}, {"name": "fintype.sum_unique", "description": ""}, {"name": "finset.prod_pair", "description": ""}, {"name": "commute.sum_left", "description": ""}, {"name": "finset.sum_zsmul", "description": ""}, {"name": "finset.card_eq_sum_card_image", "description": ""}, {"name": "finset.sum_insert_of_eq_zero_if_not_mem", "description": "The sum of `f` over `insert a s` is the same as\nthe sum over `s`, as long as `a` is in `s` or `f a = 0`."}, {"name": "finset.prod_insert", "description": ""}, {"name": "finset.prod_mk", "description": ""}, {"name": "finset.sum_hom_rel", "description": ""}, {"name": "finset.sum_ite_irrel", "description": ""}, {"name": "finset.prod_product", "description": ""}, {"name": "nat.cast_multiset_prod", "description": ""}, {"name": "add_monoid_hom.finset_sum_apply", "description": ""}, {"name": "finset.sum_filter_of_ne", "description": ""}, {"name": "finset.sum_const_nat", "description": ""}, {"name": "finset.sum_coe_sort", "description": ""}, {"name": "nat.cast_list_prod", "description": ""}, {"name": "finset.prod_apply_dite", "description": ""}, {"name": "multiset.to_finset_sum_count_eq", "description": ""}, {"name": "multiset.count_sum'", "description": ""}, {"name": "finset.sum_dite_eq", "description": ""}, {"name": "finset.sum_flip", "description": ""}, {"name": "finset.prod_union", "description": ""}, {"name": "finset.prod_ite", "description": ""}, {"name": "finset.sum_sum_elim", "description": ""}, {"name": "finset.sum_bij", "description": "Reorder a sum.\n\nThe difference with `sum_bij'` is that the bijection is specified as a surjective injection,\nrather than by an inverse function."}, {"name": "finset.prod_range_div'", "description": ""}, {"name": "finset.sum_sdiff_sub_sum_sdiff", "description": ""}, {"name": "finset.sum_filter_add_sum_filter_not", "description": ""}, {"name": "nat.cast_multiset_sum", "description": ""}, {"name": "finset.eq_sum_range_sub'", "description": ""}, {"name": "finset.prod_range_add", "description": ""}, {"name": "finset.eq_of_card_le_one_of_sum_eq", "description": "If a sum of a `finset` of size at most 1 has a given\nvalue, so do the terms in that sum."}, {"name": "finset.sum_range_add", "description": ""}, {"name": "int.cast_sum", "description": ""}, {"name": "finset.sum_extend_by_zero", "description": ""}, {"name": "finset.mem_sum", "description": ""}, {"name": "finset.sum_dite", "description": ""}, {"name": "multiset.add_eq_union_right_of_le", "description": ""}, {"name": "finset.sum_cancels_of_partition_cancels", "description": "If we can partition a sum into subsets that cancel out, then the whole sum cancels."}, {"name": "finset.sum_finset_product'", "description": ""}, {"name": "int.cast_multiset_sum", "description": ""}, {"name": "finset.nsmul_eq_sum_const", "description": ""}, {"name": "finset.prod_comp", "description": " The product of the composition of functions `f` and `g`, is the product over `b \u2208 s.image g` of\n`f b` to the power of the cardinality of the fibre of `b`. See also `finset.prod_image`."}, {"name": "finset.dvd_prod_of_mem", "description": ""}, {"name": "finset.prod_unique_nonempty", "description": ""}, {"name": "fintype.sum_eq_sum_compl_add", "description": ""}, {"name": "multiset.disjoint_sum_left", "description": ""}, {"name": "finset.prod_eq_fold", "description": ""}, {"name": "finset.prod_hom_rel", "description": ""}, {"name": "add_monoid_hom.coe_finset_sum", "description": ""}, {"name": "finset.sum_boole", "description": ""}, {"name": "finset.sum_disj_union", "description": ""}, {"name": "finset.eq_one_of_prod_eq_one", "description": " If a product is 1 and the function is 1 except possibly at one\npoint, it is 1 everywhere on the `finset`."}, {"name": "finset.sum_subtype_of_mem", "description": "If all elements of a `finset` satisfy the predicate `p`, a sum\nover `s.subtype p` equals that sum over `s`."}, {"name": "is_compl.prod_mul_prod", "description": ""}, {"name": "finset.sum_pi_single", "description": ""}, {"name": "finset.prod_ite_of_false", "description": ""}, {"name": "finset.prod_involution", "description": ""}, {"name": "finset.prod_multiset_count", "description": ""}, {"name": "finset.sum_range_zero", "description": ""}, {"name": "finset.prod_multiset_map_count", "description": ""}, {"name": "finset.sum_nsmul", "description": ""}, {"name": "finset.sum_ite_index", "description": ""}, {"name": "finset.prod_dvd_prod_of_subset", "description": ""}, {"name": "finset.prod_const", "description": ""}, {"name": "finset.sum_congr_set", "description": "The sum of a function `g` defined only on a set `s` is equal to\nthe sum of a function `f` defined everywhere,\nas long as `f` and `g` agree on `s`, and `f = 0` off `s`."}, {"name": "finset.card_eq_sum_card_fiberwise", "description": ""}, {"name": "finset.sum_union", "description": ""}, {"name": "finset.sum_list_count", "description": ""}, {"name": "finset.prod_range_add_div_prod_range", "description": ""}, {"name": "finset.sum_induction_nonempty", "description": "To prove a property of a sum, it suffices to prove that\nthe property is additive and holds on summands."}, {"name": "finset.prod_induction_nonempty", "description": "To prove a property of a product, it suffices to prove that\nthe property is multiplicative and holds on factors."}, {"name": "finset.prod_update_of_mem", "description": ""}, {"name": "finset.prod_list_map_count", "description": ""}, {"name": "finset.prod_cons", "description": ""}, {"name": "finset.prod_product_right'", "description": "An uncurried version of `finset.prod_product_right`."}, {"name": "finset.sum_apply_ite", "description": ""}, {"name": "finset.sum_empty", "description": ""}, {"name": "ring_hom.map_list_sum", "description": "Deprecated: use `_root_.map_list_sum` instead."}, {"name": "finset.sum_erase_eq_sub", "description": ""}, {"name": "finset.prod_filter_mul_prod_filter_not", "description": ""}, {"name": "finset.sum_range_one", "description": ""}, {"name": "finset.prod_inter_mul_prod_diff", "description": ""}, {"name": "ring_hom.map_list_prod", "description": "Deprecated: use `_root_.map_list_prod` instead."}, {"name": "finset.sum_product'", "description": "An uncurried version of `finset.sum_product`"}, {"name": "multiset.disjoint_sum_right", "description": ""}, {"name": "finset.sum_attach", "description": ""}, {"name": "finset.sum_unique_nonempty", "description": ""}, {"name": "finset.prod_bUnion", "description": ""}, {"name": "finset.sum_const", "description": ""}, {"name": "finset.op_sum", "description": "Moving to the opposite additive commutative monoid commutes with summing."}, {"name": "finset.prod_dite", "description": ""}, {"name": "finset.prod_ne_zero_iff", "description": ""}, {"name": "finset.prod_product_right", "description": ""}, {"name": "add_monoid_hom.map_sum", "description": "Deprecated: use `_root_.map_sum` instead."}, {"name": "fintype.prod_subtype_mul_prod_subtype", "description": ""}, {"name": "finset.sum_erase_add", "description": "A variant of `finset.add_sum_erase` with the addition swapped."}, {"name": "finset.prod_eq_zero_iff", "description": ""}, {"name": "finset.prod_filter", "description": ""}, {"name": "ring_hom.map_multiset_prod", "description": "Deprecated: use `_root_.map_multiset_prod` instead."}, {"name": "finset.prod_fiberwise_of_maps_to", "description": ""}, {"name": "finset.prod_dite_irrel", "description": ""}, {"name": "finset.sum_eq_sum_diff_singleton_add", "description": ""}, {"name": "finset.sum_piecewise", "description": ""}, {"name": "finset.sum_on_sum", "description": ""}, {"name": "add_equiv.map_sum", "description": "Deprecated: use `_root_.map_sum` instead."}, {"name": "finset.prod_ite_of_true", "description": ""}, {"name": "finset.sum_multiset_map_count", "description": ""}, {"name": "finset.prod_product'", "description": "An uncurried version of `finset.prod_product`."}, {"name": "finset.prod_subtype_eq_prod_filter", "description": "A product over `s.subtype p` equals one over `s.filter p`."}, {"name": "finset.prod_image'", "description": ""}, {"name": "finset.prod_eq_zero", "description": ""}, {"name": "finset.sum_pi_single'", "description": ""}, {"name": "ring_hom.map_multiset_sum", "description": "Deprecated: use `_root_.map_multiset_sum` instead."}, {"name": "finset.prod_range_succ_comm", "description": ""}, {"name": "finset.prod_zpow", "description": ""}, {"name": "finset.prod_eq_mul", "description": ""}, {"name": "finset.unop_sum", "description": ""}, {"name": "finset.prod_range_one", "description": ""}, {"name": "finset.sum_eq_single_of_mem", "description": ""}, {"name": "finset.prod_finset_coe", "description": ""}, {"name": "finset.sum_eq_single", "description": ""}, {"name": "finset.sum_sdiff_eq_sub", "description": ""}, {"name": "finset.prod_eq_mul_of_mem", "description": ""}, {"name": "finset.prod_dvd_prod_of_dvd", "description": ""}, {"name": "finset.sum_fiberwise_of_maps_to", "description": ""}, {"name": "finset.sum_ite_eq'", "description": "A sum taken over a conditional whose condition is an equality test on the index\nand whose alternative is `0` has value either the term at that index or `0`.\n\nThe difference with `finset.sum_ite_eq` is that the arguments to `eq` are swapped."}, {"name": "finset.sum_ite_of_true", "description": ""}, {"name": "finset.prod_range_zero", "description": ""}, {"name": "finset.card_bUnion", "description": ""}, {"name": "finset.sum_comm'", "description": "Generalization of `finset.sum_comm` to the case when the inner `finset`s depend on\nthe outer variable."}, {"name": "finset.sum_insert", "description": ""}, {"name": "finset.card_bUnion_le", "description": ""}, {"name": "finset.sum_mem_multiset", "description": ""}, {"name": "monoid_hom.coe_finset_prod", "description": ""}, {"name": "finset.eq_of_card_le_one_of_prod_eq", "description": " If a product of a `finset` of size at most 1 has a given value, so\ndo the terms in that product."}, {"name": "finset.prod_subtype", "description": ""}, {"name": "finset.sum_eq_add", "description": ""}, {"name": "multiset.disjoint_finset_sum_right", "description": ""}, {"name": "finset.sum_eq_fold", "description": ""}, {"name": "finset.sum_bUnion", "description": ""}, {"name": "finset.prod_extend_by_one", "description": ""}, {"name": "map_sum", "description": ""}, {"name": "finset.pow_eq_prod_const", "description": ""}, {"name": "finset.prod_erase_mul", "description": "A variant of `finset.mul_prod_erase` with the multiplication swapped."}, {"name": "finset.prod_congr_set", "description": " The product of a function `g` defined only on a set `s` is equal to\nthe product of a function `f` defined everywhere,\nas long as `f` and `g` agree on `s`, and `f = 1` off `s`."}, {"name": "finset.sum_range_sub'", "description": ""}, {"name": "finset.sum_erase", "description": "If a function applied at a point is 0, a sum is unchanged by\nremoving that point, if present, from a `finset`."}, {"name": "finset.sum_update_of_mem", "description": ""}, {"name": "map_prod", "description": ""}, {"name": "finset.prod_empty", "description": ""}, {"name": "finset.sum_insert_zero", "description": "The sum of `f` over `insert a s` is the same as\nthe sum over `s`, as long as `f a = 0`."}, {"name": "multiset.prod_sum", "description": ""}, {"name": "finset.card_eq_sum_ones", "description": ""}, {"name": "finset.eventually_constant_sum", "description": ""}, {"name": "finset.sum_sigma", "description": "Sum over a sigma type equals the sum of fiberwise sums. For rewriting\nin the reverse direction, use `finset.sum_sigma'`"}, {"name": "finset.prod_sdiff_eq_div", "description": ""}, {"name": "finset.sum_product", "description": ""}, {"name": "finset.prod_insert_of_eq_one_if_not_mem", "description": "The product of `f` over `insert a s` is the same as\nthe product over `s`, as long as `a` is in `s` or `f a = 1`."}, {"name": "finset.sum_map", "description": ""}, {"name": "finset.sum_image", "description": ""}, {"name": "finset.prod_bij", "description": "Reorder a product.\n\nThe difference with `prod_bij'` is that the bijection is specified as a surjective injection,\nrather than by an inverse function."}, {"name": "finset.prod_range_succ'", "description": ""}, {"name": "finset.prod_pow", "description": ""}, {"name": "finset.sum_range_succ_comm", "description": ""}, {"name": "finset.prod_finset_product'", "description": ""}, {"name": "finset.exists_ne_zero_of_sum_ne_zero", "description": ""}, {"name": "fintype.prod_subsingleton", "description": ""}, {"name": "finset.prod_eq_multiset_prod", "description": ""}, {"name": "multiset.disjoint_list_sum_right", "description": ""}, {"name": "monoid_hom.finset_prod_apply", "description": ""}, {"name": "finset.sum_subtype_eq_sum_filter", "description": "A sum over `s.subtype p` equals one over `s.filter p`."}, {"name": "int.cast_list_prod", "description": ""}, {"name": "finset.prod_eq_mul_prod_diff_singleton", "description": ""}, {"name": "finset.prod_ite_irrel", "description": ""}, {"name": "finset.sum_add_distrib", "description": ""}, {"name": "ring_hom.map_sum", "description": "Deprecated: use `_root_.map_sum` instead."}, {"name": "finset.nonempty_of_sum_ne_zero", "description": ""}, {"name": "finset.sum_apply_dite", "description": ""}, {"name": "nat.cast_sum", "description": ""}, {"name": "finset.sum_neg_distrib", "description": ""}, {"name": "finset.sum_inter_add_sum_diff", "description": ""}, {"name": "finset.exists_ne_one_of_prod_ne_one", "description": ""}, {"name": "finset.sum_range_induction", "description": "For any sum along `{0, ..., n - 1}` of a commutative-monoid-valued function, we can\nverify that it's equal to a different function just by checking differences of adjacent terms.\n\nThis is a discrete analogue of the fundamental theorem of calculus."}, {"name": "finset.prod_multiset_count_of_subset", "description": ""}, {"name": "fintype.sum_bijective", "description": "`fintype.sum_equiv` is a variant of `finset.sum_bij` that accepts\n`function.bijective`.\n\nSee `function.bijective.sum_comp` for a version without `h`."}, {"name": "fintype.sum_subtype_add_sum_subtype", "description": ""}, {"name": "finset.sum_sigma'", "description": ""}, {"name": "finset.prod_bij_ne_one", "description": ""}, {"name": "finset.prod_insert_one", "description": "The product of `f` over `insert a s` is the same as the product over `s`, as long as `f a = 1`."}, {"name": "finset.prod_eq_single", "description": ""}, {"name": "finset.sum_coe_sort_eq_attach", "description": ""}, {"name": "finset.sum_val", "description": ""}, {"name": "finset.sum_filter", "description": ""}, {"name": "finset.sum_pair", "description": ""}, {"name": "finset.sum_const_zero", "description": ""}, {"name": "finset.sum_multiset_count_of_subset", "description": ""}, {"name": "finset.prod_ite_eq", "description": ""}, {"name": "finset.prod_dite_eq'", "description": ""}, {"name": "finset.sum_eq_zero", "description": ""}, {"name": "finset.sum_update_of_not_mem", "description": ""}, {"name": "equiv.perm.prod_comp'", "description": ""}, {"name": "finset.prod_dite_of_true", "description": ""}, {"name": "finset.prod_apply_ite_of_true", "description": ""}, {"name": "multiset.exists_smul_of_dvd_count", "description": ""}, {"name": "finset.sum_singleton", "description": ""}, {"name": "finset.prod_congr", "description": ""}, {"name": "finset.prod_range_div", "description": " A telescoping product along `{0, ..., n - 1}` of a commutative group valued function reduces to\nthe ratio of the last and first factors."}, {"name": "fintype.prod_unique", "description": ""}, {"name": "finset.sum_add_sum_compl", "description": "Adding the sums of a function over `s` and over `s\u1d9c` gives the whole sum.\nFor a version expressed with subtypes, see `fintype.sum_subtype_add_sum_subtype`."}, {"name": "equiv.perm.sum_comp", "description": ""}, {"name": "finset.prod_sigma'", "description": ""}, {"name": "finset.sum_union_inter", "description": ""}, {"name": "fintype.sum_empty", "description": ""}, {"name": "equiv.perm.prod_comp", "description": ""}, {"name": "fintype.sum_subsingleton", "description": ""}, {"name": "fintype.sum_eq_add_sum_compl", "description": ""}, {"name": "finset.sum_image'", "description": ""}, {"name": "finset.prod_inv_distrib", "description": ""}, {"name": "finset.prod_comm'", "description": " Generalization of `finset.prod_comm` to the case when the inner `finset`s depend on the outer\nvariable."}, {"name": "finset.prod_div_distrib", "description": ""}, {"name": "finset.prod_list_count_of_subset", "description": ""}, {"name": "finset.prod_subtype_map_embedding", "description": " A product of a function over a `finset` in a subtype equals a\nproduct in the main type of a function that agrees with the first\nfunction on that `finset`."}, {"name": "finset.sum_mk", "description": ""}, {"name": "finset.nonempty_of_prod_ne_one", "description": ""}, {"name": "finset.prod_val", "description": ""}, {"name": "finset.sum_subset", "description": ""}, {"name": "int.cast_multiset_prod", "description": ""}, {"name": "finset.sum_ite", "description": ""}, {"name": "finset.sum_bij'", "description": "Reorder a sum.\n\nThe difference with `sum_bij` is that the bijection is specified with an inverse, rather than\nas a surjective injection."}, {"name": "finset.sum_eq_multiset_sum", "description": ""}, {"name": "finset.prod_mem_multiset", "description": ""}, {"name": "nat_abs_sum_le", "description": ""}, {"name": "finset.prod_map", "description": ""}, {"name": "finset.mul_prod_erase", "description": " Taking a product over `s : finset \u03b1` is the same as multiplying the value on a single element\n`f a` by the product of `s.erase a`.\n\nSee `multiset.prod_map_erase` for the `multiset` version."}, {"name": "finset.prod_ite_eq'", "description": " A product taken over a conditional whose condition is an equality test on the index and whose\nalternative is `1` has value either the term at that index or `1`.\n\nThe difference with `finset.prod_ite_eq` is that the arguments to `eq` are swapped."}, {"name": "commute.sum_right", "description": ""}, {"name": "finset.sum_product_right'", "description": "An uncurried version of `finset.prod_product_right`"}, {"name": "finset.prod_pow_boole", "description": ""}, {"name": "list.sum_to_finset", "description": ""}, {"name": "list.prod_to_finset", "description": ""}, {"name": "finset.prod_induction", "description": "To prove a property of a product, it suffices to prove that\nthe property is multiplicative and holds on factors."}, {"name": "finset.sum_involution", "description": ""}, {"name": "finset.prod_on_sum", "description": ""}, {"name": "units.mk0_prod", "description": ""}, {"name": "finset.sum_subset_zero_on_sdiff", "description": ""}, {"name": "nat.cast_list_sum", "description": ""}, {"name": "ring_hom.unop_map_list_prod", "description": " A morphism into the opposite ring acts on the product by acting on the reversed elements.\n\nDeprecated: use `_root_.unop_map_list_prod` instead."}, {"name": "finset.sum_finset_product_right'", "description": ""}, {"name": "finset.prod_eq_one", "description": ""}, {"name": "finset.prod_of_empty", "description": ""}, {"name": "fintype.prod_bijective", "description": " `fintype.prod_bijective` is a variant of `finset.prod_bij` that accepts `function.bijective`.\n\nSee `function.bijective.prod_comp` for a version without `h`."}, {"name": "finset.prod_finset_product", "description": ""}, {"name": "mul_equiv.map_prod", "description": "Deprecated: use `_root_.map_prod` instead."}, {"name": "finset.sum_of_empty", "description": ""}, {"name": "finset.sum_eq_add_sum_diff_singleton", "description": ""}, {"name": "finset.prod_subset", "description": ""}, {"name": "finset.sum_induction", "description": "To prove a property of a sum, it suffices to prove that\nthe property is additive and holds on summands."}, {"name": "finset.prod_compl_mul_prod", "description": ""}, {"name": "finset.prod_piecewise", "description": ""}, {"name": "finset.prod_union_inter", "description": ""}, {"name": "finset.sum_finset_product_right", "description": ""}, {"name": "finset.prod_filter_ne_one", "description": ""}, {"name": "monoid_hom.map_prod", "description": "Deprecated: use `_root_.map_prod` instead."}, {"name": "finset.prod_coe_sort_eq_attach", "description": ""}, {"name": "finset.sum_eq_add_of_mem", "description": ""}, {"name": "finset.prod", "description": "`\u220f x in s, f x` is the product of `f x`\nas `x` ranges over the elements of the finite set `s`."}, {"name": "finset.prod_subset_one_on_sdiff", "description": ""}, {"name": "finset.sum_congr", "description": ""}, {"name": "finset.prod_image", "description": ""}, {"name": "finset.prod_coe_sort", "description": ""}, {"name": "finset.sum_list_count_of_subset", "description": ""}, {"name": "finset.prod_sum_elim", "description": ""}, {"name": "finset.prod_apply_ite_of_false", "description": ""}, {"name": "finset.sum_finset_coe", "description": ""}, {"name": "finset.prod_add_prod_eq", "description": "If `f = g = h` everywhere but at `i`, where `f i = g i + h i`, then the product of `f` over `s`\n is the sum of the products of `g` and `h`."}, {"name": "finset.eq_sum_range_sub", "description": ""}, {"name": "finset.sum_range_succ", "description": ""}, {"name": "finset.prod_list_count", "description": ""}, {"name": "finset.prod_disj_union", "description": ""}, {"name": "finset.eventually_constant_prod", "description": ""}, {"name": "finset.sum_filter_ne_zero", "description": ""}, {"name": "finset.prod_mul_prod_compl", "description": " Multiplying the products of a function over `s` and over `s\u1d9c` gives the whole product.\nFor a version expressed with subtypes, see `fintype.prod_subtype_mul_prod_subtype`."}, {"name": "finset.prod_erase_eq_div", "description": ""}, {"name": "finset.sum_ite_eq", "description": ""}, {"name": "finset.sum_dite_eq'", "description": ""}, {"name": "finset.prod_bij'", "description": "Reorder a product.\n\nThe difference with `prod_bij` is that the bijection is specified with an inverse, rather than\nas a surjective injection."}, {"name": "multiset.disjoint_list_sum_left", "description": ""}, {"name": "finset.sum_comp", "description": "The sum of the composition of functions `f` and `g`, is the sum over `b \u2208 s.image g`\nof `f b` times of the cardinality of the fibre of `b`. See also `finset.sum_image`."}, {"name": "finset.sum_bij_ne_zero", "description": ""}, {"name": "finset.sum_compl_add_sum", "description": ""}, {"name": "finset.card_sigma", "description": ""}, {"name": "finset.sum_multiset_singleton", "description": ""}, {"name": "int.cast_list_sum", "description": ""}, {"name": "finset.sum_subtype", "description": ""}, {"name": "finset.sum_range_succ'", "description": ""}, {"name": "finset.prod_dite_eq", "description": ""}, {"name": "ring_hom.map_prod", "description": "Deprecated: use `_root_.map_prod` instead."}, {"name": "multiset.to_finset_sum_count_nsmul_eq", "description": ""}, {"name": "finset.prod_ite_index", "description": ""}, {"name": "finset.sum_ite_of_false", "description": ""}, {"name": "monotone.comp", "description": ""}, {"name": "subsingleton.strict_mono", "description": ""}, {"name": "monotone_on", "description": "A function `f` is monotone on `s` if, for all `a, b \u2208 s`, `a \u2264 b` implies `f a \u2264 f b`."}, {"name": "antitone.ne_of_lt_of_lt_int", "description": " If `f` is an antitone function from `\u2124` to a preorder and `x` lies between `f (n + 1)` and\n`f n`, then `x` doesn't lie in the range of `f`."}, {"name": "antitone.comp", "description": ""}, {"name": "strict_mono.maximal_of_maximal_image", "description": ""}, {"name": "subsingleton.antitone", "description": ""}, {"name": "strict_anti.lt_iff_lt", "description": ""}, {"name": "strict_anti.prod_map", "description": ""}, {"name": "strict_mono_on_id", "description": ""}, {"name": "strict_anti.strict_anti_on", "description": ""}, {"name": "strict_mono.is_max_of_apply", "description": ""}, {"name": "antitone.imp", "description": ""}, {"name": "subsingleton.monotone'", "description": ""}, {"name": "list.foldr_strict_mono", "description": ""}, {"name": "strict_anti.antitone", "description": ""}, {"name": "monotone.dual_left", "description": "**Alias** of the reverse direction of `antitone_comp_of_dual_iff`."}, {"name": "strict_mono.iterate", "description": ""}, {"name": "monotone_on.dual_left", "description": "**Alias** of the reverse direction of `antitone_on_comp_of_dual_iff`."}, {"name": "strict_anti_int_of_succ_lt", "description": ""}, {"name": "antitone_on_comp_of_dual_iff", "description": ""}, {"name": "antitone_to_dual_comp_iff", "description": ""}, {"name": "strict_mono_on.dual", "description": ""}, {"name": "nat.exists_strict_mono'", "description": " If `\u03b1` is a preorder with no maximal elements, then there exists a strictly monotone function\n`\u2115 \u2192 \u03b1` with any prescribed value of `f 0`."}, {"name": "strict_mono.comp_strict_mono_on", "description": ""}, {"name": "strict_anti_on.dual", "description": ""}, {"name": "monotone_on.dual", "description": ""}, {"name": "monotone.reflect_lt", "description": ""}, {"name": "antitone.comp_antitone_on", "description": ""}, {"name": "antitone_iff_forall_lt", "description": ""}, {"name": "strict_anti_on.lt_iff_lt", "description": ""}, {"name": "subsingleton.strict_anti", "description": ""}, {"name": "strict_anti.comp", "description": ""}, {"name": "strict_mono.strict_mono_on", "description": ""}, {"name": "monotone.prod_map", "description": ""}, {"name": "strict_anti_on.le_iff_le", "description": ""}, {"name": "monotone.comp_monotone_on", "description": ""}, {"name": "monotone.comp_antitone", "description": ""}, {"name": "strict_mono.monotone", "description": ""}, {"name": "int.exists_strict_anti", "description": " If `\u03b1` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly\nantitone function `f : \u2124 \u2192 \u03b1`."}, {"name": "strict_anti.cmp_map_eq", "description": ""}, {"name": "monotone.monotone_on", "description": ""}, {"name": "monotone_on_id", "description": ""}, {"name": "nat.exists_strict_anti'", "description": " If `\u03b1` is a preorder with no maximal elements, then there exists a strictly antitone function\n`\u2115 \u2192 \u03b1` with any prescribed value of `f 0`."}, {"name": "int.exists_strict_mono", "description": " If `\u03b1` is a nonempty preorder with no minimal or maximal elements, then there exists a strictly\nmonotone function `f : \u2124 \u2192 \u03b1`."}, {"name": "strict_mono_id", "description": ""}, {"name": "monotone_on_comp_of_dual_iff", "description": ""}, {"name": "strict_mono_on.dual_right", "description": "**Alias** of the reverse direction of `strict_anti_on_to_dual_comp_iff`."}, {"name": "strict_mono.id_le", "description": ""}, {"name": "strict_mono.comp_strict_anti_on", "description": ""}, {"name": "nat.rel_of_forall_rel_succ_of_le", "description": ""}, {"name": "antitone_on_univ", "description": ""}, {"name": "strict_mono.imp", "description": ""}, {"name": "strict_mono.ite", "description": ""}, {"name": "injective_of_le_imp_le", "description": ""}, {"name": "antitone.strict_anti_of_injective", "description": ""}, {"name": "strict_anti_nat_of_succ_lt", "description": ""}, {"name": "injective_of_lt_imp_ne", "description": ""}, {"name": "strict_anti_of_le_iff_le", "description": ""}, {"name": "strict_mono.le_iff_le", "description": ""}, {"name": "antitone_on.dual_right", "description": "**Alias** of the reverse direction of `monotone_on_to_dual_comp_iff`."}, {"name": "list.foldl_strict_mono", "description": ""}, {"name": "antitone_nat_of_succ_le", "description": ""}, {"name": "monotone.dual", "description": ""}, {"name": "nat.exists_strict_anti", "description": " If `\u03b1` is a nonempty preorder with no minimal elements, then there exists a strictly antitone\nfunction `\u2115 \u2192 \u03b1`."}, {"name": "monotone_comp_of_dual_iff", "description": ""}, {"name": "antitone.dual_right", "description": "**Alias** of the reverse direction of `monotone_to_dual_comp_iff`."}, {"name": "monotone_const", "description": ""}, {"name": "monotone_fst", "description": ""}, {"name": "strict_anti_on.dual_left", "description": "**Alias** of the reverse direction of `strict_mono_on_comp_of_dual_iff`."}, {"name": "antitone_int_of_succ_le", "description": ""}, {"name": "strict_mono_on_to_dual_comp_iff", "description": ""}, {"name": "subtype.strict_mono_coe", "description": ""}, {"name": "strict_mono.dual", "description": ""}, {"name": "strict_mono.dual_right", "description": "**Alias** of the reverse direction of `strict_anti_to_dual_comp_iff`."}, {"name": "strict_anti_on_to_dual_comp_iff", "description": ""}, {"name": "strict_mono_int_of_lt_succ", "description": ""}, {"name": "antitone.comp_monotone", "description": ""}, {"name": "subsingleton.antitone'", "description": ""}, {"name": "strict_anti_on_univ", "description": ""}, {"name": "antitone_lam", "description": ""}, {"name": "strict_mono.minimal_of_minimal_image", "description": ""}, {"name": "monotone_lam", "description": ""}, {"name": "strict_anti.dual_left", "description": "**Alias** of the reverse direction of `strict_mono_comp_of_dual_iff`."}, {"name": "strict_mono.dual_left", "description": "**Alias** of the reverse direction of `strict_anti_comp_of_dual_iff`."}, {"name": "monotone_on_univ", "description": ""}, {"name": "antitone.dual_left", "description": "**Alias** of the reverse direction of `monotone_comp_of_dual_iff`."}, {"name": "antitone_comp_of_dual_iff", "description": ""}, {"name": "strict_mono", "description": "A function `f` is strictly monotone if `a < b` implies `f a < f b`."}, {"name": "antitone.reflect_lt", "description": ""}, {"name": "strict_mono_comp_of_dual_iff", "description": ""}, {"name": "antitone_app", "description": ""}, {"name": "antitone.strict_anti_iff_injective", "description": ""}, {"name": "monotone_to_dual_comp_iff", "description": ""}, {"name": "strict_anti_to_dual_comp_iff", "description": ""}, {"name": "nat.rel_of_forall_rel_succ_of_lt", "description": ""}, {"name": "strict_mono_on.le_iff_le", "description": ""}, {"name": "strict_mono.compares", "description": ""}, {"name": "strict_mono_on.lt_iff_lt", "description": ""}, {"name": "strict_mono_nat_of_lt_succ", "description": ""}, {"name": "strict_mono_on.dual_left", "description": "**Alias** of the reverse direction of `strict_anti_on_comp_of_dual_iff`."}, {"name": "strict_mono.injective", "description": ""}, {"name": "strict_mono_on.compares", "description": ""}, {"name": "strict_mono_of_le_iff_le", "description": ""}, {"name": "monotone_app", "description": ""}, {"name": "strict_mono.prod_map", "description": ""}, {"name": "strict_mono_on.monotone_on", "description": ""}, {"name": "strict_anti.injective", "description": ""}, {"name": "nat.rel_of_forall_rel_succ_of_le_of_le", "description": ""}, {"name": "strict_mono_to_dual_comp_iff", "description": ""}, {"name": "strict_anti.is_min_of_apply", "description": ""}, {"name": "strict_mono.comp", "description": ""}, {"name": "strict_mono_on.cmp_map_eq", "description": ""}, {"name": "strict_mono_on_univ", "description": ""}, {"name": "monotone.ne_of_lt_of_lt_nat", "description": "If `f` is a monotone function from `\u2115` to a preorder such that `x` lies between `f n` and\n `f (n + 1)`, then `x` doesn't lie in the range of `f`."}, {"name": "monotone.comp_le_comp_left", "description": ""}, {"name": "strict_anti.le_iff_le", "description": ""}, {"name": "antitone.ne_of_lt_of_lt_nat", "description": " If `f` is an antitone function from `\u2115` to a preorder such that `x` lies between `f (n + 1)` and\n`f n`, then `x` doesn't lie in the range of `f`."}, {"name": "antitone_on.dual", "description": ""}, {"name": "strict_anti_on", "description": " A function `f` is strictly antitone on `s` if, for all `a, b \u2208 s`, `a < b` implies\n`f b < f a`."}, {"name": "monotone.imp", "description": ""}, {"name": "strict_anti_on.dual_right", "description": "**Alias** of the reverse direction of `strict_mono_on_to_dual_comp_iff`."}, {"name": "monotone_on.reflect_lt", "description": ""}, {"name": "strict_mono.is_min_of_apply", "description": ""}, {"name": "subtype.mono_coe", "description": ""}, {"name": "antitone_on_to_dual_comp_iff", "description": ""}, {"name": "monotone", "description": "A function `f` is monotone if `a \u2264 b` implies `f a \u2264 f b`."}, {"name": "strict_anti_on_comp_of_dual_iff", "description": ""}, {"name": "monotone_on_const", "description": ""}, {"name": "antitone_on.dual_left", "description": "**Alias** of the reverse direction of `monotone_on_comp_of_dual_iff`."}, {"name": "monotone_on_iff_forall_lt", "description": ""}, {"name": "list.foldl_monotone", "description": ""}, {"name": "subsingleton.monotone", "description": ""}, {"name": "antitone_on_iff_forall_lt", "description": ""}, {"name": "monotone_nat_of_le_succ", "description": ""}, {"name": "antitone_on", "description": "A function `f` is antitone on `s` if, for all `a, b \u2208 s`, `a \u2264 b` implies `f b \u2264 f a`."}, {"name": "strict_anti.comp_strict_mono_on", "description": ""}, {"name": "monotone.strict_mono_iff_injective", "description": ""}, {"name": "strict_anti.comp_strict_mono", "description": ""}, {"name": "strict_anti", "description": "A function `f` is strictly antitone if `a < b` implies `f b < f a`."}, {"name": "monotone_iff_forall_lt", "description": ""}, {"name": "strict_mono.comp_strict_anti", "description": ""}, {"name": "antitone.comp_monotone_on", "description": ""}, {"name": "strict_anti.ite'", "description": ""}, {"name": "list.foldr_monotone", "description": ""}, {"name": "antitone.antitone_on", "description": ""}, {"name": "strict_mono.ite'", "description": ""}, {"name": "function.monotone_eval", "description": ""}, {"name": "strict_mono_on", "description": " A function `f` is strictly monotone on `s` if, for all `a, b \u2208 s`, `a < b` implies\n`f a < f b`."}, {"name": "monotone.iterate", "description": ""}, {"name": "monotone.comp_antitone_on", "description": ""}, {"name": "strict_anti.imp", "description": ""}, {"name": "monotone_snd", "description": ""}, {"name": "monotone_on_to_dual_comp_iff", "description": ""}, {"name": "strict_anti.minimal_of_maximal_image", "description": ""}, {"name": "strict_anti_on.cmp_map_eq", "description": ""}, {"name": "nat.exists_strict_mono", "description": " If `\u03b1` is a nonempty preorder with no maximal elements, then there exists a strictly monotone\nfunction `\u2115 \u2192 \u03b1`."}, {"name": "strict_anti_comp_of_dual_iff", "description": ""}, {"name": "strict_anti.maximal_of_minimal_image", "description": ""}, {"name": "antitone.dual", "description": ""}, {"name": "monotone.dual_right", "description": "**Alias** of the reverse direction of `antitone_to_dual_comp_iff`."}, {"name": "strict_anti.dual_right", "description": "**Alias** of the reverse direction of `strict_mono_to_dual_comp_iff`."}, {"name": "strict_anti.comp_strict_anti_on", "description": ""}, {"name": "strict_anti.is_max_of_apply", "description": ""}, {"name": "monotone_id", "description": ""}, {"name": "monotone.strict_mono_of_injective", "description": ""}, {"name": "antitone_on.reflect_lt", "description": ""}, {"name": "monotone.ne_of_lt_of_lt_int", "description": "If `f` is a monotone function from `\u2124` to a preorder and `x` lies between `f n` and\n `f (n + 1)`, then `x` doesn't lie in the range of `f`."}, {"name": "monotone_on.dual_right", "description": "**Alias** of the reverse direction of `antitone_on_to_dual_comp_iff`."}, {"name": "antitone_on_const", "description": ""}, {"name": "strict_anti.ite", "description": ""}, {"name": "antitone", "description": "A function `f` is antitone if `a \u2264 b` implies `f b \u2264 f a`."}, {"name": "strict_anti.compares", "description": ""}, {"name": "int.rel_of_forall_rel_succ_of_lt", "description": ""}, {"name": "strict_anti.dual", "description": ""}, {"name": "antitone.prod_map", "description": ""}, {"name": "strict_mono.cmp_map_eq", "description": ""}, {"name": "strict_mono.lt_iff_lt", "description": ""}, {"name": "nat.rel_of_forall_rel_succ_of_le_of_lt", "description": ""}, {"name": "monotone_int_of_le_succ", "description": ""}, {"name": "strict_anti_on.antitone_on", "description": ""}, {"name": "strict_anti_on.compares", "description": ""}, {"name": "antitone_const", "description": ""}, {"name": "int.rel_of_forall_rel_succ_of_le", "description": ""}, {"name": "strict_mono_on_comp_of_dual_iff", "description": ""}, {"name": "eq_ff_of_not_eq_tt", "description": ""}, {"name": "bnot_eq_true_eq_eq_ff", "description": ""}, {"name": "tt_band", "description": ""}, {"name": "bnot_eq_ff_eq_eq_tt", "description": ""}, {"name": "eq_ff_eq_not_eq_tt", "description": ""}, {"name": "band_eq_true_eq_eq_tt_and_eq_tt", "description": ""}, {"name": "tt_eq_ff_eq_false", "description": ""}, {"name": "bor_ff", "description": ""}, {"name": "bxor_self", "description": ""}, {"name": "coe_ff", "description": ""}, {"name": "ff_eq_tt_eq_false", "description": ""}, {"name": "bor_eq_false_eq_eq_ff_and_eq_ff", "description": ""}, {"name": "bor_coe_iff", "description": ""}, {"name": "of_to_bool_ff", "description": ""}, {"name": "bor_self", "description": ""}, {"name": "eq_tt_eq_not_eq_ff", "description": ""}, {"name": "to_bool_true", "description": ""}, {"name": "ff_bor", "description": ""}, {"name": "bool_iff_false", "description": ""}, {"name": "to_bool_ff", "description": ""}, {"name": "coe_sort_tt", "description": ""}, {"name": "to_bool_iff", "description": ""}, {"name": "band_self", "description": ""}, {"name": "tt_bor", "description": ""}, {"name": "bor_tt", "description": ""}, {"name": "to_bool_ff_iff", "description": ""}, {"name": "of_to_bool_true", "description": ""}, {"name": "bxor_tt", "description": ""}, {"name": "eq_tt_of_not_eq_ff", "description": ""}, {"name": "bool_eq_false", "description": ""}, {"name": "band_coe_iff", "description": ""}, {"name": "bxor_ff", "description": ""}, {"name": "to_bool_congr", "description": ""}, {"name": "cond_a_a", "description": ""}, {"name": "ff_bxor", "description": ""}, {"name": "to_bool_tt", "description": ""}, {"name": "ite_eq_ff_distrib", "description": ""}, {"name": "band_ff", "description": ""}, {"name": "ite_eq_tt_distrib", "description": ""}, {"name": "ff_band", "description": ""}, {"name": "coe_tt", "description": ""}, {"name": "bxor_coe_iff", "description": ""}, {"name": "bnot_bnot", "description": ""}, {"name": "band_tt", "description": ""}, {"name": "coe_sort_ff", "description": ""}, {"name": "bor_eq_true_eq_eq_tt_or_eq_tt", "description": ""}, {"name": "tt_bxor", "description": ""}, {"name": "band_eq_false_eq_eq_ff_or_eq_ff", "description": ""}, {"name": "category_theory.equivalence.adjointify_\u03b7", "description": " If `\u03b7 : \ud835\udfed C \u2245 F \u22d9 G` is part of a (not necessarily half-adjoint) equivalence, we can upgrade it\nto a refined natural isomorphism `adjointify_\u03b7 \u03b7 : \ud835\udfed C \u2245 F \u22d9 G` which exhibits the properties\nrequired for a half-adjoint equivalence. See `equivalence.mk`."}, {"name": "category_theory.is_equivalence.cancel_comp_right", "description": "If `G` and `F \u22d9 G` are equivalence of categories, then `F` is also an equivalence."}, {"name": "category_theory.is_equivalence.equiv_of_iso", "description": "When `F` and `G` are two isomorphic functors, then `F` is an equivalence iff `G` is."}, {"name": "category_theory.is_equivalence.of_iso", "description": " When a functor `F` is an equivalence of categories, and `G` is isomorphic to `F`, then\n`G` is also an equivalence of categories."}, {"name": "category_theory.equivalence.functor_map_inj_iff", "description": ""}, {"name": "category_theory.equivalence.pow_neg_one", "description": ""}, {"name": "category_theory.equivalence.faithful_of_equivalence", "description": "An equivalence is faithful.\n\nSee <https://stacks.math.columbia.edu/tag/02C3>."}, {"name": "category_theory.equivalence.ess_surj_of_equivalence", "description": "An equivalence is essentially surjective.\n\nSee <https://stacks.math.columbia.edu/tag/02C3>."}, {"name": "category_theory.equivalence.congr_left_counit_iso", "description": ""}, {"name": "category_theory.is_equivalence.functor_unit_iso_comp", "description": ""}, {"name": "category_theory.equivalence.congr_right_counit_iso", "description": ""}, {"name": "category_theory.functor.as_equivalence_functor", "description": ""}, {"name": "category_theory.is_equivalence.inv_fun_map", "description": ""}, {"name": "category_theory.is_equivalence.of_iso_counit_iso", "description": ""}, {"name": "category_theory.equivalence.cancel_counit_right", "description": ""}, {"name": "category_theory.equivalence.counit", "description": "The counit of an equivalence of categories."}, {"name": "category_theory.equivalence.inverse_map_inj_iff", "description": ""}, {"name": "category_theory.is_equivalence.equiv_of_iso_symm_apply", "description": ""}, {"name": "category_theory.equivalence.trans", "description": "Equivalence of categories is transitive."}, {"name": "category_theory.functor.as_equivalence", "description": "Interpret a functor that is an equivalence as an equivalence."}, {"name": "category_theory.is_equivalence.fun_inv_map", "description": ""}, {"name": "category_theory.is_equivalence.functor_unit_iso_comp_assoc", "description": ""}, {"name": "category_theory.equivalence.counit_inv_functor_comp", "description": ""}, {"name": "category_theory.equivalence.unit", "description": "The unit of an equivalence of categories."}, {"name": "category_theory.equivalence.unit_inv", "description": "The inverse of the unit of an equivalence of categories."}, {"name": "category_theory.equivalence.trans_functor", "description": ""}, {"name": "category_theory.functor.as_equivalence_inverse", "description": ""}, {"name": "category_theory.equivalence.inverse_inv", "description": ""}, {"name": "category_theory.functor.is_equivalence_refl", "description": ""}, {"name": "category_theory.equivalence.congr_left_unit_iso", "description": ""}, {"name": "category_theory.equivalence.counit_app_functor", "description": ""}, {"name": "category_theory.equivalence.equivalence_mk'_counit_inv", "description": ""}, {"name": "category_theory.equivalence.adjointify_\u03b7_\u03b5", "description": ""}, {"name": "category_theory.equivalence.ess_surj_induced_functor", "description": ""}, {"name": "category_theory.functor.as_equivalence_unit", "description": ""}, {"name": "category_theory.is_equivalence.of_iso_inverse", "description": ""}, {"name": "category_theory.equivalence.inv_fun_id_assoc", "description": " Composing a functor with both functors of an equivalence yields a naturally isomorphic\nfunctor."}, {"name": "category_theory.equivalence.fun_inv_id_assoc", "description": " Composing a functor with both functors of an equivalence yields a naturally isomorphic\nfunctor."}, {"name": "category_theory.equivalence.congr_left_functor", "description": ""}, {"name": "category_theory.equivalence.refl_counit_iso", "description": ""}, {"name": "category_theory.equivalence.cancel_unit_right_assoc", "description": ""}, {"name": "category_theory.equivalence.inverse_counit_inv_comp", "description": ""}, {"name": "category_theory.is_equivalence.of_iso_trans", "description": "Compatibility of `of_iso` with the composition of isomorphisms of functors"}, {"name": "category_theory.is_equivalence.of_equivalence", "description": ""}, {"name": "category_theory.functor.is_equivalence_inv", "description": ""}, {"name": "category_theory.equivalence.int.has_pow", "description": ""}, {"name": "category_theory.equivalence.trans_counit_iso", "description": ""}, {"name": "category_theory.functor.inv_inv", "description": ""}, {"name": "category_theory.is_equivalence.of_equivalence_inverse", "description": ""}, {"name": "category_theory.equivalence.congr_right", "description": "If `C` is equivalent to `D`, then `E \u2964 C` is equivalent to `E \u2964 D`."}, {"name": "category_theory.functor.as_equivalence_counit", "description": ""}, {"name": "category_theory.is_equivalence.equiv_of_iso_apply", "description": ""}, {"name": "category_theory.equivalence.fun_inv_id_assoc_hom_app", "description": ""}, {"name": "category_theory.equivalence.equivalence_mk'_unit_inv", "description": ""}, {"name": "category_theory.equivalence.congr_right_functor", "description": ""}, {"name": "category_theory.equivalence.inv_fun_id_assoc_inv_app", "description": ""}, {"name": "category_theory.equivalence", "description": " We define an equivalence as a (half)-adjoint equivalence, a pair of functors with\n  a unit and counit which are natural isomorphisms and the triangle law `F\u03b7 \u226b \u03b5F = 1`, or in other\n  words the composite `F \u27f6 FGF \u27f6 F` is the identity.\n\n  In `unit_inverse_comp`, we show that this is actually an adjoint equivalence, i.e., that the\n  composite `G \u27f6 GFG \u27f6 G` is also the identity.\n\n  The triangle equation is written as a family of equalities between morphisms, it is more\n  complicated if we write it as an equality of natural transformations, because then we would have\n  to insert natural transformations like `F \u27f6 F1`.\n\nSee <https://stacks.math.columbia.edu/tag/001J>"}, {"name": "category_theory.equivalence.functor", "description": " We define an equivalence as a (half)-adjoint equivalence, a pair of functors with\n  a unit and counit which are natural isomorphisms and the triangle law `F\u03b7 \u226b \u03b5F = 1`, or in other\n  words the composite `F \u27f6 FGF \u27f6 F` is the identity.\n\n  In `unit_inverse_comp`, we show that this is actually an adjoint equivalence, i.e., that the\n  composite `G \u27f6 GFG \u27f6 G` is also the identity.\n\n  The triangle equation is written as a family of equalities between morphisms, it is more\n  complicated if we write it as an equality of natural transformations, because then we would have\n  to insert natural transformations like `F \u27f6 F1`.\n\nSee <https://stacks.math.columbia.edu/tag/001J>"}, {"name": "category_theory.equivalence.inverse", "description": " We define an equivalence as a (half)-adjoint equivalence, a pair of functors with\n  a unit and counit which are natural isomorphisms and the triangle law `F\u03b7 \u226b \u03b5F = 1`, or in other\n  words the composite `F \u27f6 FGF \u27f6 F` is the identity.\n\n  In `unit_inverse_comp`, we show that this is actually an adjoint equivalence, i.e., that the\n  composite `G \u27f6 GFG \u27f6 G` is also the identity.\n\n  The triangle equation is written as a family of equalities between morphisms, it is more\n  complicated if we write it as an equality of natural transformations, because then we would have\n  to insert natural transformations like `F \u27f6 F1`.\n\nSee <https://stacks.math.columbia.edu/tag/001J>"}, {"name": "category_theory.equivalence.unit_iso", "description": " We define an equivalence as a (half)-adjoint equivalence, a pair of functors with\n  a unit and counit which are natural isomorphisms and the triangle law `F\u03b7 \u226b \u03b5F = 1`, or in other\n  words the composite `F \u27f6 FGF \u27f6 F` is the identity.\n\n  In `unit_inverse_comp`, we show that this is actually an adjoint equivalence, i.e., that the\n  composite `G \u27f6 GFG \u27f6 G` is also the identity.\n\n  The triangle equation is written as a family of equalities between morphisms, it is more\n  complicated if we write it as an equality of natural transformations, because then we would have\n  to insert natural transformations like `F \u27f6 F1`.\n\nSee <https://stacks.math.columbia.edu/tag/001J>"}, {"name": "category_theory.equivalence.counit_iso", "description": " We define an equivalence as a (half)-adjoint equivalence, a pair of functors with\n  a unit and counit which are natural isomorphisms and the triangle law `F\u03b7 \u226b \u03b5F = 1`, or in other\n  words the composite `F \u27f6 FGF \u27f6 F` is the identity.\n\n  In `unit_inverse_comp`, we show that this is actually an adjoint equivalence, i.e., that the\n  composite `G \u27f6 GFG \u27f6 G` is also the identity.\n\n  The triangle equation is written as a family of equalities between morphisms, it is more\n  complicated if we write it as an equality of natural transformations, because then we would have\n  to insert natural transformations like `F \u27f6 F1`.\n\nSee <https://stacks.math.columbia.edu/tag/001J>"}, {"name": "category_theory.equivalence.functor_unit_iso_comp'", "description": " We define an equivalence as a (half)-adjoint equivalence, a pair of functors with\n  a unit and counit which are natural isomorphisms and the triangle law `F\u03b7 \u226b \u03b5F = 1`, or in other\n  words the composite `F \u27f6 FGF \u27f6 F` is the identity.\n\n  In `unit_inverse_comp`, we show that this is actually an adjoint equivalence, i.e., that the\n  composite `G \u27f6 GFG \u27f6 G` is also the identity.\n\n  The triangle equation is written as a family of equalities between morphisms, it is more\n  complicated if we write it as an equality of natural transformations, because then we would have\n  to insert natural transformations like `F \u27f6 F1`.\n\nSee <https://stacks.math.columbia.edu/tag/001J>"}, {"name": "category_theory.equivalence.equivalence_mk'_unit", "description": ""}, {"name": "category_theory.functor.is_equivalence_trans", "description": ""}, {"name": "category_theory.equivalence.fun_inv_id_assoc_inv_app", "description": ""}, {"name": "category_theory.equivalence.refl_inverse", "description": ""}, {"name": "category_theory.equivalence.inhabited", "description": ""}, {"name": "category_theory.equivalence.inv_fun_map", "description": ""}, {"name": "category_theory.equivalence.refl_unit_iso", "description": ""}, {"name": "category_theory.equivalence.fully_faithful_to_ess_image", "description": ""}, {"name": "category_theory.is_equivalence.of_iso_unit_iso", "description": ""}, {"name": "category_theory.equivalence.congr_left", "description": "If `C` is equivalent to `D`, then `C \u2964 E` is equivalent to `D \u2964 E`."}, {"name": "category_theory.equivalence.refl", "description": "Equivalence of categories is reflexive."}, {"name": "category_theory.is_equivalence.of_iso_refl", "description": "Compatibility of `of_iso` with identity isomorphisms of functors"}, {"name": "category_theory.functor.inv", "description": "The inverse functor of a functor that is an equivalence."}, {"name": "category_theory.equivalence.mk", "description": "Every equivalence of categories consisting of functors `F` and `G` such that `F \u22d9 G` and\n   `G \u22d9 F` are naturally isomorphic to identity functors can be transformed into a half-adjoint\n   equivalence without changing `F` or `G`."}, {"name": "category_theory.equivalence.functor_inv", "description": ""}, {"name": "category_theory.equivalence.full_of_equivalence", "description": "An equivalence is full.\n\nSee <https://stacks.math.columbia.edu/tag/02C3>."}, {"name": "category_theory.equivalence.symm_inverse", "description": ""}, {"name": "category_theory.equivalence.symm_functor", "description": ""}, {"name": "category_theory.is_equivalence.mk", "description": "To see that a functor is an equivalence, it suffices to provide an inverse functor `G` such that\n   `F \u22d9 G` and `G \u22d9 F` are naturally isomorphic to identity functors."}, {"name": "category_theory.equivalence.congr_right_unit_iso", "description": ""}, {"name": "category_theory.equivalence.cancel_unit_right_assoc'", "description": ""}, {"name": "category_theory.equivalence.cancel_unit_right", "description": ""}, {"name": "category_theory.equivalence.pow_nat", "description": "Natural number powers of an auto-equivalence.  Use `(^)` instead."}, {"name": "category_theory.equivalence.congr_left_inverse", "description": ""}, {"name": "category_theory.equivalence.pow_one", "description": ""}, {"name": "category_theory.equivalence.counit_inv", "description": "The inverse of the counit of an equivalence of categories."}, {"name": "category_theory.equivalence.cancel_counit_inv_right", "description": ""}, {"name": "category_theory.equivalence.induced_functor_of_equiv", "description": ""}, {"name": "category_theory.equivalence.inv_fun_id_assoc_hom_app", "description": ""}, {"name": "category_theory.equivalence.symm", "description": "Equivalence of categories is symmetric."}, {"name": "category_theory.equivalence.of_fully_faithfully_ess_surj", "description": "A functor which is full, faithful, and essentially surjective is an equivalence.\n\nSee <https://stacks.math.columbia.edu/tag/02C3>."}, {"name": "category_theory.is_equivalence", "description": "A functor that is part of a (half) adjoint equivalence"}, {"name": "category_theory.is_equivalence.inverse", "description": "A functor that is part of a (half) adjoint equivalence"}, {"name": "category_theory.is_equivalence.unit_iso", "description": "A functor that is part of a (half) adjoint equivalence"}, {"name": "category_theory.is_equivalence.counit_iso", "description": "A functor that is part of a (half) adjoint equivalence"}, {"name": "category_theory.is_equivalence.functor_unit_iso_comp'", "description": "A functor that is part of a (half) adjoint equivalence"}, {"name": "category_theory.equivalence.cancel_counit_inv_right_assoc'", "description": ""}, {"name": "category_theory.equivalence.congr_right_inverse", "description": ""}, {"name": "category_theory.equivalence.counit_inv_app_functor", "description": ""}, {"name": "category_theory.equivalence.equivalence_mk'_counit", "description": ""}, {"name": "category_theory.equivalence.unit_app_inverse", "description": ""}, {"name": "category_theory.equivalence.fun_inv_map", "description": ""}, {"name": "category_theory.equivalence.functor_unit_iso_comp", "description": ""}, {"name": "category_theory.equivalence.trans_inverse", "description": ""}, {"name": "category_theory.equivalence.pow_zero", "description": ""}, {"name": "category_theory.equivalence.symm_unit_iso", "description": ""}, {"name": "category_theory.equivalence.pow", "description": "Powers of an auto-equivalence.  Use `(^)` instead."}, {"name": "category_theory.equivalence.refl_functor", "description": ""}, {"name": "category_theory.is_equivalence.cancel_comp_left", "description": "If `F` and `F \u22d9 G` are equivalence of categories, then `G` is also an equivalence."}, {"name": "category_theory.equivalence.unit_inv_app_inverse", "description": ""}, {"name": "category_theory.equivalence.unit_inverse_comp", "description": "The other triangle equality. The proof follows the following proof in Globular:\n http://globular.science/1905.001"}, {"name": "category_theory.equivalence.functor_as_equivalence", "description": ""}, {"name": "category_theory.equivalence.inverse_as_equivalence", "description": ""}, {"name": "category_theory.equivalence.trans_unit_iso", "description": ""}, {"name": "category_theory.equivalence.cancel_counit_inv_right_assoc", "description": ""}, {"name": "category_theory.equivalence.functor_unit_comp", "description": ""}, {"name": "category_theory.equivalence.symm_counit_iso", "description": ""}, {"name": "category_theory.equivalence.cancel_unit_inv_right", "description": ""}, {"name": "expr.is_sort", "description": "Tests whether an expression is a sort."}, {"name": "expr.match_local_const", "description": "Match a local constant."}, {"name": "binder.decidable_eq", "description": ""}, {"name": "environment.is_prefix_of_file", "description": "Checks whether `s` is a prefix of the file where `n` is declared.\n This is used to check whether `n` is declared in mathlib, where `s` is the mathlib directory."}, {"name": "declaration.is_theorem", "description": "Checks whether a declaration is a theorem"}, {"name": "name.append_namespace", "description": " Like `++`, except that if the right argument starts with `_root_` the namespace will be\nignored.\n```lean\nappend_namespace `a.b `c.d = `a.b.c.d\nappend_namespace `a.b `_root_.c.d = `c.d\n```"}, {"name": "expr.to_list", "description": "Turns an expression into a list, assuming it is only built up from `list.nil` and `list.cons`."}, {"name": "expr.match_var", "description": "Match a variable."}, {"name": "environment.mfold", "description": "Fold a monad over all declarations in the environment."}, {"name": "expr.clean", "description": "Clean an expression by removing `id`s listed in `clean_ids`."}, {"name": "expr.replace_subexprs", "description": " `replace_subexprs e mappings` takes an `e : expr` and interprets a `list (expr \u00d7 expr)` as\na collection of rules for variable replacements. A pair `(f, t)` encodes a rule which says \"whenever\n`f` is encountered in `e` verbatim, replace it with `t`\"."}, {"name": "binder", "description": "The type of binders containing a name, the binding info and the binding type"}, {"name": "binder.name", "description": "The type of binders containing a name, the binding info and the binding type"}, {"name": "binder.info", "description": "The type of binders containing a name, the binding info and the binding type"}, {"name": "binder.type", "description": "The type of binders containing a name, the binding info and the binding type"}, {"name": "expr.to_nat", "description": "Turns an expression into a natural number, assuming it is only built up from\n`has_one.one`, `bit0`, `bit1`, `has_zero.zero`, `nat.zero`, and `nat.succ`."}, {"name": "expr.mk_or_lst", "description": "`mk_or_lst [x1, x2, ...]` is defined as `x1 \u2228 (x2 \u2228 ...)`, or `false` if the list is empty."}, {"name": "expr.binding_names", "description": "Get the names of the bound variables by a sequence of pis or lambdas."}, {"name": "expr.local_binding_info", "description": " `local_binding_info e` returns the binding info of `e` if `e` is a local constant.\nOtherwise returns `binder_info.default`."}, {"name": "library_note.likely generated binder names", "description": "In surface Lean, we can write anonymous \u03a0 binders (i.e. binders where the\nargument is not named) using the function arrow notation:\n\n```lean\ninductive test : Type\n| intro : unit \u2192 test\n```\n\nAfter elaboration, however, every binder must have a name, so Lean generates\none. In the example, the binder in the type of `intro` is anonymous, so Lean\ngives it the name `\u1fb0`:\n\n```lean\ntest.intro : \u2200 (\u1fb0 : unit), test\n```\n\nWhen there are multiple anonymous binders, they are named `\u1fb0_1`, `\u1fb0_2` etc.\n\nThus, when we want to know whether the user named a binder, we can check whether\nthe name follows this scheme. Note, however, that this is not reliable. When the\nuser writes (for whatever reason)\n\n```lean\ninductive test : Type\n| intro : \u2200 (\u1fb0 : unit), test\n```\n\nwe cannot tell that the binder was, in fact, named.\n\nThe function `name.is_likely_generated_binder_name` checks if\na name is of the form `\u1fb0`, `\u1fb0_1`, etc."}, {"name": "expr.replace_explicit_args", "description": "  `replace_explicit_args f parg` assumes that `f` is an expression corresponding to a function\napplication.  It replaces the explicit arguments of `f`, in succession, by the elements of `parg`.\nThe implicit arguments of `f` remain unchanged."}, {"name": "expr.match_elet", "description": "Match a let."}, {"name": "expr.reduce_lets", "description": "head-reduce all let expressions"}, {"name": "name.update_last", "description": "Update the last component of a name."}, {"name": "expr.list_meta_vars'", "description": "Returns the set of all meta-variables in an expression."}, {"name": "expr.to_int", "description": "Turns an expression into a integer, assuming it is only built up from\n`has_one.one`, `bit0`, `bit1`, `has_zero.zero` and a optionally a single `has_neg.neg` as head."}, {"name": "expr.list_local_consts", "description": "Returns a list of all local constants in an expression (without duplicates)."}, {"name": "expr.mk_op_lst", "description": "`mk_op_lst op empty [x1, x2, ...]` is defined as `op x1 (op x2 ...)`.\n Returns `empty` if the list is empty."}, {"name": "expr.is_default_local", "description": " `is_default_local e` tests whether `e` is a local constant with binder info\n`binder_info.default`"}, {"name": "expr.match_lam", "description": "Match an abstraction."}, {"name": "expr.clean_ids", "description": "List of names removed by `clean`. All these names must resolve to functions defeq `id`."}, {"name": "binder_info.inhabited", "description": ""}, {"name": "expr.is_implicitly_included_variable", "description": "`is_implicitly_included_variable e vs` accepts `e`, an `expr.local_const`, and a list `vs` of\n   other `expr.local_const`s. It determines whether `e` should be considered \"available in context\"\n   as a variable by virtue of the fact that the variables `vs` have been deemed such.\n\n   For example, given `variables (n : \u2115) [prime n] [ih : even n]`, a reference to `n` implies that\n   the typeclass instance `prime n` should be included, but `ih : even n` should not.\n\n   DANGER: It is possible that for `f : expr` another `expr.local_const`, we have\n   `is_implicitly_included_variable f vs = ff` but\n   `is_implicitly_included_variable f (e :: vs) = tt`. This means that one usually wants to\n   iteratively add a list of local constants (usually, the `variables` declared in the local scope)\n   which satisfy `is_implicitly_included_variable` to an initial `vs`, repeating if any variables\n   were added in a particular iteration. The function `all_implicitly_included_variables` below\n   implements this behaviour.\n\n   Note that if `e \u2208 vs` then `is_implicitly_included_variable e vs = tt`."}, {"name": "expr.substs", "description": "Repeatedly apply `expr.subst`."}, {"name": "int.mk_numeral", "description": "`int.mk_numeral z` embeds `z` as a numeral expression inside a type with 0, 1, +, and -.\n`type`: an expression representing the target type. This must live in Type 0.\n`has_zero`, `has_one`, `has_add`, `has_neg`: expressions of the type `has_zero %%type`, etc."}, {"name": "name.get_nth_prefix", "description": "`get_nth_prefix nm n` removes the last `n` components from `nm`"}, {"name": "expr.get_app_fn_args_aux", "description": "Auxiliary defintion for `get_app_fn_args`."}, {"name": "binder_info.brackets", "description": "The brackets corresponding to a given binder_info."}, {"name": "expr.app_symbol_in", "description": "`app_symbol_in e l` returns true iff `e` is an application of a constant whose name is in `l`."}, {"name": "name.add_prime", "description": "Appends `'` to the end of a name."}, {"name": "nat.to_pexpr", "description": "`nat.to_pexpr n` creates a `pexpr` that will evaluate to `n`.\nThe `pexpr` does not hold any typing information:\n`to_expr ``((%%(nat.to_pexpr 5) : \u2124))` will create a native integer numeral `(5 : \u2124)`."}, {"name": "expr.is_eta_expansion_of", "description": "`is_eta_expansion_of args univs l` checks whether for all elements `(nm, pr)` in `l` we have\n `pr = nm.{univs} args`.\n Used in `is_eta_expansion`, where `l` consists of the projections and the fields of the value we\n want to eta-reduce."}, {"name": "expr.mreplace", "description": "Monadic analogue of `expr.replace`.\n\nThe `mreplace R e` visits each subexpression `s` of `e`, and is called with `R s n`, where\n`n` is the number of binders above `e`.\nIf `R s n` fails, the whole replacement fails.\nIf `R s n` returns `some t`, `s` is replaced with `t` (and `mreplace` does not visit\nits subexpressions).\nIf `R s n` return `none`, then `mreplace` continues visiting subexpressions of `s`.\n\nWARNING: This function performs exponentially worse on large terms than `expr.replace`,\nif a subexpression occurs more than once in an expression, `expr.replace` visits them only once,\nbut this function will visit every occurence of it. Do not use this on large expressions."}, {"name": "environment.decl_filter_map", "description": "For all declarations `d` where `f d = some x` this adds `x` to the returned list."}, {"name": "expr.get_app_fn_args", "description": "A combination of `get_app_fn` and `get_app_args`: lists both the\n function and its arguments of an application"}, {"name": "expr.match_app", "description": "Match an application."}, {"name": "expr.list_local_const_unique_names", "description": "Returns the unique names of all local constants in an expression."}, {"name": "nat.mk_numeral", "description": "`nat.mk_numeral n` embeds `n` as a numeral expression inside a type with 0, 1, and +.\n`type`: an expression representing the target type. This must live in Type 0.\n`has_zero`, `has_one`, `has_add`: expressions of the type `has_zero %%type`, etc."}, {"name": "name.append_suffix", "description": "Append a string to the last component of a name."}, {"name": "name.is_likely_generated_binder_simple_name", "description": "Check whether a simple name was likely generated by Lean to name an anonymous\nbinder. Such names are either `\u1fb0` or `\u1fb0_n` for some natural `n`. See\nnote [likely generated binder names]."}, {"name": "expr.contains_sorry", "description": "Returns true if `e` contains a `sorry`.\nSee also `name.contains_sorry`."}, {"name": "binder_info.has_reflect", "description": ""}, {"name": "expr.is_mvar", "description": "Tests whether an expression is a meta-variable."}, {"name": "expr.head_eta_expand", "description": "`head_eta_expand n e t` eta-expands `e` `n` times, with the binders info and domains obtained\n by its type `t`."}, {"name": "declaration.in_current_file", "description": "Checks whether the declaration is declared in the current file.\n This is a simple wrapper around `environment.in_current_file`\n Use `environment.in_current_file` instead if performance matters."}, {"name": "name.length", "description": "Returns the number of characters used to print all the string components of a name,\n including periods between name segments. Ignores numerical parts of a name."}, {"name": "expr.reduce_let", "description": "head-reduce a single let expression"}, {"name": "expr.all_implicitly_included_variables", "description": "`all_implicitly_included_variables es vs` accepts `es`, a list of `expr.local_const`, and `vs`,\n   another such list. It returns a list of all variables `e` in `es` or `vs` for which an inclusion\n   of the variables in `vs` into the local context implies that `e` should also be included. See\n   `is_implicitly_included_variable e vs` for the details.\n\n   In particular, those elements of `vs` are included automatically."}, {"name": "name.is_private", "description": "Tests whether the first component of a name is `\"_private\"`"}, {"name": "expr.univ_levels", "description": "Get the universe levels of a `const` expression"}, {"name": "expr.list_meta_vars", "description": "Returns a list of all meta-variables in an expression (without duplicates)."}, {"name": "environment.structure_fields_full", "description": "Get the full names of all projections of the structure `n`. Returns `none` if `n` is not a\n structure."}, {"name": "name.from_components", "description": "Build a name from components. For example `from_components [\"foo\",\"bar\"]` becomes\n ``` `foo.bar```"}, {"name": "name.deinternalize_field", "description": " If `nm` is a simple name (having only one string component) starting with `_`, then\n`deinternalize_field nm` removes the underscore. Otherwise, it does nothing."}, {"name": "binder.has_to_string", "description": ""}, {"name": "expr.instantiate_pis", "description": "`instantiate_pis es e` instantiates the pis in `e` with the expressions from `es`.\n Does not check whether the result remains type-correct."}, {"name": "pexpr.decidable_eq", "description": ""}, {"name": "declaration.is_axiom", "description": "Checks whether a declaration is a axiom"}, {"name": "expr.list_local_consts'", "description": "Returns the set of all local constants in an expression."}, {"name": "environment.get_decl_names", "description": "Lists the name of all declarations in the environment"}, {"name": "expr.replace_with", "description": "`replace_with e s s'` replaces ocurrences of `s` with `s'` in `e`."}, {"name": "thunk.has_reflect", "description": ""}, {"name": "expr.instantiate_lambdas_or_apps", "description": " `instantiate_lambdas_or_apps es e` instantiates lambdas in `e` by expressions from `es`.\nIf the length of `es` is larger than the number of lambdas in `e`,\nthen the term is applied to the remaining terms.\nAlso reduces head let-expressions in `e`, including those after instantiating all lambdas.\n\nThis is very similar to `expr.substs`, but this also reduces head let-expressions."}, {"name": "int.to_pexpr", "description": "`int.to_pexpr n` creates a `pexpr` that will evaluate to `n`.\nThe `pexpr` does not hold any typing information:\n`to_expr ``((%%(int.to_pexpr (-5)) : \u211a))` will create a native `\u211a` numeral `(-5 : \u211a)`."}, {"name": "expr.is_eta_expansion_aux", "description": "`is_eta_expansion_aux val l` checks whether `val` can be eta-reduced to an expression `e`.\n Here `l` is intended to consists of the projections and the fields of `val`.\n This tactic calls `is_eta_expansion_test l`, but first removes all proofs from the list `l` and\n afterward checks whether the resulting expression `e` unifies with `val`.\n This last check is necessary, because `val` and `e` might have different types."}, {"name": "expr.list_constant'", "description": "Returns a `list name` containing the constant names of an `expr` in the same order\n that `expr.fold` traverses it."}, {"name": "expr.is_num_eq", "description": "`is_num_eq n1 n2` returns true if `n1` and `n2` are both numerals with the same numeral structure,\nignoring differences in type and type class arguments."}, {"name": "environment.filter", "description": "Filters all declarations in the environment."}, {"name": "environment.get_trusted_decls", "description": "Lists all trusted (non-meta) declarations in the environment"}, {"name": "environment.is_ginductive'", "description": "Tests whether `nm` is a generalized inductive type that is not a normal inductive type.\n Note that `is_ginductive` returns `tt` even on regular inductive types.\n This returns `tt` if `nm` is (part of a) mutually defined inductive type or a nested inductive\n type."}, {"name": "declaration.is_constant", "description": "Checks whether a declaration is a constant"}, {"name": "expr.match_pi", "description": "Match a \u03a0 type."}, {"name": "expr.mk_and_lst", "description": "`mk_and_lst [x1, x2, ...]` is defined as `x1 \u2227 (x2 \u2227 ...)`, or `true` if the list is empty."}, {"name": "binder.to_string", "description": "Turn a binder into a string. Uses expr.to_string for the type."}, {"name": "declaration.is_auto_or_internal", "description": "Returns true iff `d` is an automatically-generated or internal declaration."}, {"name": "expr.match_app_coe_fn", "description": "Match an application of `coe_fn`."}, {"name": "name.append_to_last", "description": "`append_to_last nm s is_prefix` adds `s` to the last component of `nm`,\n either as prefix or as suffix (specified by `is_prefix`), separated by `_`.\n Used by `simps_add_projections`."}, {"name": "name.has_prefix", "description": "Checks whether `nm` has a prefix (including itself) such that P is true"}, {"name": "name.head", "description": "The first component of a name, turning a number to a string"}, {"name": "expr.has_local_constant", "description": "`has_local_constant e l` checks whether local constant `l` occurs in expression `e`"}, {"name": "environment.is_structure", "description": "Tests whether `n` is a structure."}, {"name": "expr.eta_expand", "description": " `e.eta_expand env dict` eta-expands all expressions that have as head a constant `n` in\n`dict`. They are expanded until they are applied to one more argument than the maximum in\n`dict.find n`."}, {"name": "expr.simp", "description": "Simplifies the expression `t` with the specified options.\n The result is `(new_e, pr)` with the new expression `new_e` and a proof\n `pr : e = new_e`."}, {"name": "pexpr.get_app_args", "description": "If `e : pexpr` is a sequence of applications `f e\u2081 e\u2082 ... e\u2099`,\n`e.get_app_args` returns `[e\u2081, ... e\u2099]`.\nSee also `expr.get_app_args`."}, {"name": "expr.dsimp", "description": "Definitionally simplifies the expression `t` with the specified options.\n The result is the simplified expression."}, {"name": "declaration.update_with_fun", "description": "`declaration.update_with_fun f test tgt decl`\nsets the name of the given `decl : declaration` to `tgt`, and applies both `expr.eta_expand` and\n`expr.apply_replacement_fun` to the value and type of `decl`."}, {"name": "expr.simple_infer_type", "description": " Infer the type of an application of the form `f x1 x2 ... xn`, where `f` is an identifier.\nThis also works if `x1, ... xn` contain free variables."}, {"name": "expr.replace_mvars", "description": "Replace any metavariables in the expression with underscores, in preparation for printing\n`refine ...` statements."}, {"name": "binder.inhabited", "description": ""}, {"name": "name.last_string", "description": " `last_string n` returns the rightmost component of `n`, ignoring numeral components.\nFor example, ``last_string `a.b.c.33`` will return `` `c ``."}, {"name": "pexpr.get_app_fn", "description": "If `e : pexpr` is a sequence of applications `f e\u2081 e\u2082 ... e\u2099`,\n`e.get_app_fn` returns `f`.\nSee also `expr.get_app_fn`."}, {"name": "name.map_prefix", "description": " Find the largest prefix `n` of a `name` such that `f n \u2260 none`, then replace this prefix\nwith the value of `f n`."}, {"name": "declaration.is_auto_generated", "description": "Checks whether a declaration is automatically generated in the environment.\n There is no cheap way to check whether a declaration in the namespace of a generalized\n inductive type is automatically generated, so for now we say that all of them are automatically\n generated."}, {"name": "declaration.univ_levels", "description": "Returns the list of universe levels of a declaration."}, {"name": "congr_arg_kind.decidable_eq", "description": ""}, {"name": "name.sanitize_name", "description": "`name`s can contain numeral pieces, which are not legal names\n when typed/passed directly to the parser. We turn an arbitrary\n name into a legal identifier name by turning the numbers to strings."}, {"name": "binder.has_to_tactic_format", "description": ""}, {"name": "expr.get_simp_args", "description": "`get_simp_args e` returns the arguments of `e` that simp can reach via congruence lemmas."}, {"name": "binder.has_to_format", "description": ""}, {"name": "name.from_string", "description": "Constructs a (non-simple) name from a string.\n\nExample: ``name.from_string \"foo.bar\" = `foo.bar``"}, {"name": "expr.list_explicit_args", "description": "Get the list of explicit arguments of a function."}, {"name": "expr.to_binder", "description": "Turns a local constant into a binder"}, {"name": "expr.match_mvar", "description": "Match a metavariable."}, {"name": "name.pop_nth_prefix", "description": "Pops the top `n` prefixes from the given name."}, {"name": "level.fold_mvar", "description": "`l.fold_mvar f` folds a function `f : name \u2192 \u03b1 \u2192 \u03b1`\nover each `n : name` appearing in a `level.mvar n` in `l`."}, {"name": "expr.is_eta_expansion", "description": "`is_eta_expansion val` checks whether there is an expression `e` such that `val` is the\n eta-expansion of `e`.\n With eta-expansion we here mean the eta-expansion of a structure, not of a function.\n For example, the eta-expansion of `x : \u03b1 \u00d7 \u03b2` is `\u27e8x.1, x.2\u27e9`.\n This assumes that `val` is a fully-applied application of the constructor of a structure.\n\n This is useful to reduce expressions generated by the notation\n   `{ field_1 := _, ..other_structure }`\n If `other_structure` is itself a field of the structure, then the elaborator will insert an\n eta-expanded version of `other_structure`."}, {"name": "expr.drop_pis", "description": "`drop_pis es e` instantiates the pis in `e` with the expressions from `es`."}, {"name": "expr.match_sort", "description": "Match a sort."}, {"name": "expr.to_implicit_local_const", "description": "If `e` is a local constant, `to_implicit_local_const e` changes the binder info of `e` to\n`implicit`. See also `to_implicit_binder`, which also changes lambdas and pis."}, {"name": "expr.local_const_set_type", "description": "`local_const_set_type e t` sets the type of `e` to `t`, if `e` is a `local_const`."}, {"name": "pexpr.get_app_fn_args", "description": "If `e : pexpr` is a sequence of applications `f e\u2081 e\u2082 ... e\u2099`,\n`e.get_app_fn_args` returns `(f, [e\u2081, ... e\u2099])`.\nSee also `expr.get_app_fn_args`."}, {"name": "environment.get_decls", "description": "Lists all declarations in the environment"}, {"name": "expr.match_const", "description": "Match a constant."}, {"name": "expr.instantiate_lambdas", "description": "Instantiate lambdas in the second argument by expressions from the first."}, {"name": "environment.mfilter", "description": "Filters all declarations in the environment."}, {"name": "expr.is_eta_expansion_test", "description": "`is_eta_expansion_test l` checks whether there is a list of expresions `args` such that for all\n elements `(nm, pr)` in `l` we have `pr = nm args`. If so, returns the last element of `args`.\n Used in `is_eta_expansion`, where `l` consists of the projections and the fields of the value we\n want to eta-reduce."}, {"name": "expr.apply_replacement_fun", "description": "`e.apply_replacement_fun f test` applies `f` to each identifier\n(inductive type, defined function etc) in an expression, unless\n* The identifier occurs in an application with first argument `arg`; and\n* `test arg` is false.\nHowever, if `f` is in the dictionary `relevant`, then the argument `relevant.find f`\nis tested, instead of the first argument.\n\nReorder contains the information about what arguments to reorder:\ne.g. `g x\u2081 x\u2082 x\u2083 ... x\u2099` becomes `g x\u2082 x\u2081 x\u2083 ... x\u2099` if `reorder.find g = some [1]`.\nWe assume that all functions where we want to reorder arguments are fully applied.\nThis can be done by applying `expr.eta_expand` first."}, {"name": "expr.pi_codomain", "description": "Get the codomain/target of a pi-type.\n This definition doesn't instantiate bound variables, and therefore produces a term that is open.\n See note [open expressions]."}, {"name": "expr.list_constant", "description": "Returns a `name_set` of all constants in an expression."}, {"name": "expr.head_eta_expand_aux", "description": "Auxilliary function for `head_eta_expand`."}, {"name": "library_note.open expressions", "description": "Some declarations work with open expressions, i.e. an expr that has free variables.\nTerms will free variables are not well-typed, and one should not use them in tactics like\n`infer_type` or `unify`. You can still do syntactic analysis/manipulation on them.\nThe reason for working with open types is for performance: instantiating variables requires\niterating through the expression. In one performance test `pi_binders` was more than 6x\nquicker than `mk_local_pis` (when applied to the type of all imported declarations 100x)."}, {"name": "declaration.reducibility_hints", "description": "Returns the `reducibility_hints` field of a `defn`, and `reducibility_hints.opaque` otherwise"}, {"name": "expr.list_names_with_prefix", "description": "Returns a `name_set` of all constants in an expression starting with a certain prefix."}, {"name": "expr.match_macro", "description": "Match a macro."}, {"name": "declaration.to_tactic_format", "description": "pretty-prints a `declaration` object."}, {"name": "level.params", "description": "`l.params` is the set of parameters occuring in `l`.\nFor example if `l = max 1 (max (u+1) (max v w))` then `l.params = {u, v, w}`."}, {"name": "expr.pi_binders", "description": "Get the binders and codomain of a pi-type.\n This definition doesn't instantiate bound variables, and therefore produces a term that is open.\n The.tactic `get_pi_binders` in `tactic.core` does the same, but also instantiates the\n free variables.\n See note [open expressions]."}, {"name": "expr.mreplace_aux", "description": "Implementation of `expr.mreplace`."}, {"name": "pexpr.get_frozen_name", "description": "If `e` is an annotation of `frozen_name` to `expr.const n`,\n`e.get_frozen_name` returns `n`.\nOtherwise, returns `name.anonymous`."}, {"name": "expr.contains_expr_or_mvar", "description": "Test `t` contains the specified subexpression `e`, or a metavariable.\nThis represents the notion that `e` \"may occur\" in `t`,\npossibly after subsequent unification."}, {"name": "expr.lambda_body", "description": "Get the body/value of a lambda-expression.\n This definition doesn't instantiate bound variables, and therefore produces a term that is open.\n See note [open expressions]."}, {"name": "congr_arg_kind.has_reflect", "description": ""}, {"name": "expr.pi_binders_aux", "description": "Auxiliary defintion for `pi_binders`.\n See note [open expressions]."}, {"name": "declaration.has_to_tactic_format", "description": ""}, {"name": "expr.get_local_const_kind", "description": " Strip-away the context-dependent unique id for the given local const and return: its friendly\n`name`, its `binder_info`, and its `type : expr`."}, {"name": "environment.decl_map", "description": "Maps `f` to all declarations in the environment."}, {"name": "name.is_likely_generated_binder_name", "description": "Check whether a name was likely generated by Lean to name an anonymous binder.\nSuch names are either `\u1fb0` or `\u1fb0_n` for some natural `n`. See\nnote [likely generated binder names]."}, {"name": "expr.unsafe_cast", "description": " `unsafe_cast e` freely changes the `elab : bool` parameter of the passed `expr`. Mainly used to\naccess core `expr` manipulation functions for `pexpr`-based use, but which are restricted to\n`expr tt` at the site of definition unnecessarily.\n\nDANGER: Unless you know exactly what you are doing, this is probably not the function you are\nlooking for. For `pexpr \u2192 expr` see `tactic.to_expr`. For `expr \u2192 pexpr` see `to_pexpr`."}, {"name": "level.nonzero", "description": "Tests whether a universe level is non-zero for all assignments of its variables"}, {"name": "name.pop_prefix", "description": "Pop the prefix of a name"}, {"name": "expr.list_univ_meta_vars", "description": "Returns a list of all universe meta-variables in an expression (without duplicates)."}, {"name": "expr.contains_constant", "description": "Returns true if `e` contains a name `n` where `p n` is true.\n Returns `true` if `p name.anonymous` is true."}, {"name": "binder_info.decidable_eq", "description": ""}, {"name": "expr.to_implicit_binder", "description": " If `e` is a local constant, lamda, or pi expression, `to_implicit_binder e` changes the binder\ninfo of `e` to `implicit`. See also `to_implicit_local_const`, which only changes local constants."}, {"name": "distrib_mul_action.to_add_monoid_End_apply", "description": ""}, {"name": "smul_add", "description": ""}, {"name": "distrib_mul_action.to_add_monoid_hom", "description": "Each element of the monoid defines a additive monoid homomorphism."}, {"name": "is_scalar_tower.op_right", "description": ""}, {"name": "mul_distrib_mul_action.ext", "description": ""}, {"name": "distrib_mul_action.ext", "description": ""}, {"name": "function.End.apply_mul_action", "description": " The tautological action by `function.End \u03b1` on `\u03b1`.\n\nThis is generalized to bundled endomorphisms by:\n* `equiv.perm.apply_mul_action`\n* `add_monoid.End.apply_distrib_mul_action`\n* `add_aut.apply_distrib_mul_action`\n* `mul_aut.apply_mul_distrib_mul_action`\n* `ring_hom.apply_distrib_mul_action`\n* `linear_equiv.apply_distrib_mul_action`\n* `linear_map.apply_module`\n* `ring_hom.apply_mul_semiring_action`\n* `alg_equiv.apply_mul_semiring_action`"}, {"name": "mul_distrib_mul_action.ext_iff", "description": ""}, {"name": "has_smul.comp.smul", "description": " Auxiliary definition for `has_smul.comp`, `mul_action.comp_hom`,\n`distrib_mul_action.comp_hom`, `module.comp_hom`, etc."}, {"name": "commute.smul_left", "description": ""}, {"name": "function.surjective.mul_distrib_mul_action", "description": " Pushforward a multiplicative distributive multiplicative action along a surjective monoid\nhomomorphism.\nSee note [reducible non-instances]."}, {"name": "function.surjective.mul_action_left", "description": " Push forward the action of `R` on `M` along a compatible surjective map `f : R \u2192* S`.\n\nSee also `function.surjective.distrib_mul_action_left` and `function.surjective.module_left`."}, {"name": "function.surjective.distrib_mul_action", "description": " Pushforward a distributive multiplicative action along a surjective additive monoid\nhomomorphism.\nSee note [reducible non-instances]."}, {"name": "vadd_left_injective'", "description": ""}, {"name": "function.surjective.add_action", "description": "Pushforward an additive action along a surjective map respecting `+\u1d65`."}, {"name": "distrib_mul_action.to_add_monoid_hom_apply", "description": ""}, {"name": "smul_comm_class.op_left", "description": ""}, {"name": "distrib_mul_action.to_add_monoid_End", "description": "Each element of the monoid defines an additive monoid homomorphism."}, {"name": "smul_smul_smul_comm", "description": ""}, {"name": "smul_mul'", "description": ""}, {"name": "add_monoid.nat_smul_comm_class", "description": ""}, {"name": "function.End.monoid", "description": ""}, {"name": "add_group.int_smul_comm_class'", "description": ""}, {"name": "mul_action.surjective_smul", "description": ""}, {"name": "function.injective.mul_action", "description": " Pullback a multiplicative action along an injective map respecting `\u2022`.\nSee note [reducible non-instances]."}, {"name": "add_action.exists_vadd_eq", "description": ""}, {"name": "vadd_comm_class", "description": "A typeclass mixin saying that two additive actions on the same space commute."}, {"name": "vadd_comm_class.vadd_comm", "description": "A typeclass mixin saying that two additive actions on the same space commute."}, {"name": "is_scalar_tower.left", "description": ""}, {"name": "has_smul.comp", "description": " An action of `M` on `\u03b1` and a function `N \u2192 M` induces an action of `N` on `\u03b1`.\n\nSee note [reducible non-instances]. Since this is reducible, we make sure to go via\n`has_smul.comp.smul` to prevent typeclass inference unfolding too far."}, {"name": "distrib_mul_action", "description": "Typeclass for multiplicative actions on additive structures. This generalizes group modules."}, {"name": "distrib_mul_action.to_mul_action", "description": "Typeclass for multiplicative actions on additive structures. This generalizes group modules."}, {"name": "distrib_mul_action.smul_add", "description": "Typeclass for multiplicative actions on additive structures. This generalizes group modules."}, {"name": "distrib_mul_action.smul_zero", "description": "Typeclass for multiplicative actions on additive structures. This generalizes group modules."}, {"name": "mul_distrib_mul_action.to_monoid_End_apply", "description": ""}, {"name": "mul_action.to_fun_apply", "description": ""}, {"name": "distrib_mul_action.ext_iff", "description": ""}, {"name": "mul_action.is_pretransitive", "description": "`M` acts pretransitively on `\u03b1` if for any `x y` there is `g` such that `g \u2022 x = y`.\n A transitive action should furthermore have `\u03b1` nonempty."}, {"name": "mul_action.is_pretransitive.exists_smul_eq", "description": "`M` acts pretransitively on `\u03b1` if for any `x y` there is `g` such that `g \u2022 x = y`.\n A transitive action should furthermore have `\u03b1` nonempty."}, {"name": "add_monoid.End.apply_has_faithful_smul", "description": "`add_monoid.End.apply_distrib_mul_action` is faithful."}, {"name": "smul_mul_smul", "description": " Note that the `is_scalar_tower M \u03b1 \u03b1` and `smul_comm_class M \u03b1 \u03b1` typeclass arguments are\nusually satisfied by `algebra M \u03b1`."}, {"name": "function.End", "description": " The monoid of endomorphisms.\n\nNote that this is generalized by `category_theory.End` to categories other than `Type u`."}, {"name": "smul_smul", "description": ""}, {"name": "additive.of_mul_vadd", "description": ""}, {"name": "monoid.to_mul_action", "description": " The regular action of a monoid on itself by left multiplication.\n\nThis is promoted to a module by `semiring.to_module`."}, {"name": "has_vadd.comp", "description": "An additive action of `M` on `\u03b1` and a function `N \u2192 M` induces\n an additive action of `N` on `\u03b1`"}, {"name": "function.End.apply_has_faithful_smul", "description": "`function.End.apply_mul_action` is faithful."}, {"name": "is_scalar_tower.op_left", "description": ""}, {"name": "add_action.ext", "description": ""}, {"name": "smul_comm_class.of_mul_smul_one", "description": ""}, {"name": "mul_action.ext", "description": ""}, {"name": "smul_assoc", "description": ""}, {"name": "vadd_comm_class_self", "description": ""}, {"name": "add_action.surjective_vadd", "description": ""}, {"name": "add_group.int_smul_comm_class", "description": ""}, {"name": "library_note.bundled maps over different rings", "description": "Frequently, we find ourselves wanting to express a bilinear map `M \u2192\u2097[R] N \u2192\u2097[R] P` or an\nequivalence between maps `(M \u2192\u2097[R] N) \u2243\u2097[R] (M' \u2192\u2097[R] N')` where the maps have an associated ring\n`R`. Unfortunately, using definitions like these requires that `R` satisfy `comm_semiring R`, and\nnot just `semiring R`. Using `M \u2192\u2097[R] N \u2192+ P` and `(M \u2192\u2097[R] N) \u2243+ (M' \u2192\u2097[R] N')` avoids this\nproblem, but throws away structure that is useful for when we _do_ have a commutative (semi)ring.\n\nTo avoid making this compromise, we instead state these definitions as `M \u2192\u2097[R] N \u2192\u2097[S] P` or\n`(M \u2192\u2097[R] N) \u2243\u2097[S] (M' \u2192\u2097[R] N')` and require `smul_comm_class S R` on the appropriate modules. When\nthe caller has `comm_semiring R`, they can set `S = R` and `smul_comm_class_self` will populate the\ninstance. If the caller only has `semiring R` they can still set either `R = \u2115` or `S = \u2115`, and\n`add_comm_monoid.nat_smul_comm_class` or `add_comm_monoid.nat_smul_comm_class'` will populate\nthe typeclass, which is still sufficient to recover a `\u2243+` or `\u2192+` structure.\n\nAn example of where this is used is `linear_map.prod_equiv`."}, {"name": "smul_one_smul", "description": ""}, {"name": "mul_action.to_End_hom", "description": " The monoid hom representing a monoid action.\n\nWhen `M` is a group, see `mul_action.to_perm_hom`."}, {"name": "mul_action.to_fun", "description": "Embedding of `\u03b1` into functions `M \u2192 \u03b1` induced by a multiplicative action of `M` on `\u03b1`."}, {"name": "add_monoid.to_add_action", "description": " The regular action of a monoid on itself by left addition.\n\nThis is promoted to an `add_torsor` by `add_group_is_add_torsor`."}, {"name": "add_action.is_pretransitive", "description": "`M` acts pretransitively on `\u03b1` if for any `x y` there is `g` such that `g +\u1d65 x = y`.\n A transitive action should furthermore have `\u03b1` nonempty."}, {"name": "add_action.is_pretransitive.exists_vadd_eq", "description": "`M` acts pretransitively on `\u03b1` if for any `x y` there is `g` such that `g +\u1d65 x = y`.\n A transitive action should furthermore have `\u03b1` nonempty."}, {"name": "mul_distrib_mul_action.to_monoid_End", "description": "Each element of the monoid defines a monoid homomorphism."}, {"name": "semigroup.is_scalar_tower", "description": ""}, {"name": "has_vadd.comp.vadd", "description": "Auxiliary definition for `has_vadd.comp`, `add_action.comp_hom`, etc."}, {"name": "smul_comm_class.symm", "description": " Commutativity of actions is a symmetric relation. This lemma can't be an instance because this\nwould cause a loop in the instance search graph."}, {"name": "comp_smul_left", "description": "`has_smul` version of `comp_mul_left`"}, {"name": "add_action.to_fun_apply", "description": ""}, {"name": "vadd_comm_class.symm", "description": " Commutativity of additive actions is a symmetric relation. This lemma can't be an instance\nbecause this would cause a loop in the instance search graph."}, {"name": "mul_distrib_mul_action", "description": " Typeclass for multiplicative actions on multiplicative structures. This generalizes\nconjugation actions."}, {"name": "mul_distrib_mul_action.to_mul_action", "description": " Typeclass for multiplicative actions on multiplicative structures. This generalizes\nconjugation actions."}, {"name": "mul_distrib_mul_action.smul_mul", "description": " Typeclass for multiplicative actions on multiplicative structures. This generalizes\nconjugation actions."}, {"name": "mul_distrib_mul_action.smul_one", "description": " Typeclass for multiplicative actions on multiplicative structures. This generalizes\nconjugation actions."}, {"name": "has_faithful_smul", "description": "Typeclass for faithful actions."}, {"name": "has_faithful_smul.eq_of_smul_eq_smul", "description": "Typeclass for faithful actions."}, {"name": "vadd_eq_add", "description": ""}, {"name": "add_action.regular.is_pretransitive", "description": ""}, {"name": "has_smul.comp.smul_comm_class'", "description": "This cannot be an instance because it can cause infinite loops whenever the `has_smul` arguments\nare still metavariables."}, {"name": "is_central_scalar.unop_smul_eq_smul", "description": ""}, {"name": "one_smul", "description": ""}, {"name": "function.surjective.mul_action", "description": " Pushforward a multiplicative action along a surjective map respecting `\u2022`.\nSee note [reducible non-instances]."}, {"name": "function.injective.distrib_mul_action", "description": " Pullback a distributive multiplicative action along an injective additive monoid\nhomomorphism.\nSee note [reducible non-instances]."}, {"name": "add_vadd_zero", "description": ""}, {"name": "mul_action.regular.is_pretransitive", "description": "The regular action of a group on itself is transitive."}, {"name": "add_vadd_comm", "description": ""}, {"name": "mul_action", "description": "Typeclass for multiplicative actions by monoids. This generalizes group actions."}, {"name": "mul_action.to_has_smul", "description": "Typeclass for multiplicative actions by monoids. This generalizes group actions."}, {"name": "mul_action.one_smul", "description": "Typeclass for multiplicative actions by monoids. This generalizes group actions."}, {"name": "mul_action.mul_smul", "description": "Typeclass for multiplicative actions by monoids. This generalizes group actions."}, {"name": "smul_div'", "description": ""}, {"name": "function.injective.add_action", "description": "Pullback an additive action along an injective map respecting `+\u1d65`."}, {"name": "mul_action.comp_hom", "description": " A multiplicative action of `M` on `\u03b1` and a monoid homomorphism `N \u2192 M` induce\na multiplicative action of `N` on `\u03b1`.\n\nSee note [reducible non-instances]."}, {"name": "add_action.of_End_hom", "description": " The additive action induced by a hom to `additive (function.End \u03b1)`\n\nSee note [reducible non-instances]."}, {"name": "has_smul.comp.is_scalar_tower", "description": " Given a tower of scalar actions `M \u2192 \u03b1 \u2192 \u03b2`, if we use `has_smul.comp`\nto pull back both of `M`'s actions by a map `g : N \u2192 M`, then we obtain a new\ntower of scalar actions `N \u2192 \u03b1 \u2192 \u03b2`.\n\nThis cannot be an instance because it can cause infinite loops whenever the `has_smul` arguments\nare still metavariables."}, {"name": "multiplicative.of_add_smul", "description": ""}, {"name": "one_smul_eq_id", "description": "`has_smul` version of `one_mul_eq_id`"}, {"name": "function.surjective.distrib_mul_action_left", "description": " Push forward the action of `R` on `M` along a compatible surjective map `f : R \u2192* S`.\n\nSee also `function.surjective.mul_action_left` and `function.surjective.module_left`."}, {"name": "smul_neg", "description": ""}, {"name": "smul_comm_class.op_right", "description": ""}, {"name": "function.End.inhabited", "description": ""}, {"name": "mul_smul_one", "description": ""}, {"name": "distrib_mul_action.comp_hom", "description": " Compose a `distrib_mul_action` with a `monoid_hom`, with action `f r' \u2022 m`.\nSee note [reducible non-instances]."}, {"name": "add_action", "description": "Type class for additive monoid actions."}, {"name": "add_action.to_has_vadd", "description": "Type class for additive monoid actions."}, {"name": "add_action.zero_vadd", "description": "Type class for additive monoid actions."}, {"name": "add_action.add_vadd", "description": "Type class for additive monoid actions."}, {"name": "zero_vadd_eq_id", "description": ""}, {"name": "ite_smul", "description": ""}, {"name": "has_smul.comp.smul_comm_class", "description": "This cannot be an instance because it can cause infinite loops whenever the `has_smul` arguments\nare still metavariables."}, {"name": "smul_left_injective'", "description": ""}, {"name": "add_action.to_End_hom", "description": " The additive monoid hom representing an additive monoid action.\n\nWhen `M` is a group, see `add_action.to_perm_hom`."}, {"name": "smul_eq_mul", "description": ""}, {"name": "comp_vadd_left", "description": ""}, {"name": "function.injective.mul_distrib_mul_action", "description": " Pullback a multiplicative distributive multiplicative action along an injective monoid\nhomomorphism.\nSee note [reducible non-instances]."}, {"name": "smul_mul_assoc", "description": "Note that the `is_scalar_tower \u03b1 \u03b2 \u03b2` typeclass argument is usually satisfied by `algebra \u03b1 \u03b2`."}, {"name": "add_monoid.nat_smul_comm_class'", "description": ""}, {"name": "add_monoid.End.smul_def", "description": ""}, {"name": "has_mul.to_has_smul", "description": "See also `monoid.to_mul_action` and `mul_zero_class.to_smul_with_zero`."}, {"name": "mul_action.ext_iff", "description": ""}, {"name": "mul_distrib_mul_action.comp_hom", "description": " Compose a `mul_distrib_mul_action` with a `monoid_hom`, with action `f r' \u2022 m`.\nSee note [reducible non-instances]."}, {"name": "has_add.to_has_vadd", "description": ""}, {"name": "has_faithful_vadd", "description": "Typeclass for faithful actions."}, {"name": "has_faithful_vadd.eq_of_vadd_eq_vadd", "description": "Typeclass for faithful actions."}, {"name": "add_monoid.End.apply_distrib_mul_action", "description": " The tautological action by `add_monoid.End \u03b1` on `\u03b1`.\n\nThis generalizes `function.End.apply_mul_action`."}, {"name": "vadd_vadd", "description": ""}, {"name": "smul_sub", "description": ""}, {"name": "add_action.to_fun", "description": "Embedding of `\u03b1` into functions `M \u2192 \u03b1` induced by an additive action of `M` on `\u03b1`."}, {"name": "smul_ite", "description": ""}, {"name": "add_action.function_End", "description": "The tautological additive action by `additive (function.End \u03b1)` on `\u03b1`."}, {"name": "add_action.comp_hom", "description": " An additive action of `M` on `\u03b1` and an additive monoid homomorphism `N \u2192 M` induce\nan additive action of `N` on `\u03b1`.\n\nSee note [reducible non-instances]."}, {"name": "smul_inv'", "description": ""}, {"name": "is_central_scalar", "description": " A typeclass indicating that the right (aka `mul_opposite`) and left actions by `M` on `\u03b1` are\nequal, that is that `M` acts centrally on `\u03b1`. This can be thought of as a version of commutativity\nfor `\u2022`."}, {"name": "is_central_scalar.op_smul_eq_smul", "description": " A typeclass indicating that the right (aka `mul_opposite`) and left actions by `M` on `\u03b1` are\nequal, that is that `M` acts centrally on `\u03b1`. This can be thought of as a version of commutativity\nfor `\u2022`."}, {"name": "smul_comm_class_self", "description": ""}, {"name": "is_scalar_tower", "description": " An instance of `is_scalar_tower M N \u03b1` states that the multiplicative\naction of `M` on `\u03b1` is determined by the multiplicative actions of `M` on `N`\nand `N` on `\u03b1`."}, {"name": "is_scalar_tower.smul_assoc", "description": " An instance of `is_scalar_tower M N \u03b1` states that the multiplicative\naction of `M` on `\u03b1` is determined by the multiplicative actions of `M` on `N`\nand `N` on `\u03b1`."}, {"name": "mul_action.exists_smul_eq", "description": ""}, {"name": "vadd_ite", "description": ""}, {"name": "smul_zero", "description": ""}, {"name": "commute.smul_right", "description": ""}, {"name": "add_action.ext_iff", "description": ""}, {"name": "mul_action.of_End_hom", "description": " The monoid action induced by a monoid hom to `function.End \u03b1`\n\nSee note [reducible non-instances]."}, {"name": "function.End.smul_def", "description": ""}, {"name": "additive.add_action", "description": ""}, {"name": "zero_vadd", "description": ""}, {"name": "multiplicative.mul_action", "description": ""}, {"name": "mul_distrib_mul_action.to_monoid_hom_apply", "description": ""}, {"name": "mul_distrib_mul_action.to_monoid_hom", "description": "Scalar multiplication by `r` as a `monoid_hom`."}, {"name": "ite_vadd", "description": ""}, {"name": "vadd_comm_class.of_add_vadd_zero", "description": ""}, {"name": "is_scalar_tower.of_smul_one_mul", "description": ""}, {"name": "function.surjective.add_action_left", "description": "Push forward the action of `R` on `M` along a compatible\nsurjective map `f : R \u2192+ S`."}, {"name": "smul_comm_class", "description": "A typeclass mixin saying that two multiplicative actions on the same space commute."}, {"name": "smul_comm_class.smul_comm", "description": "A typeclass mixin saying that two multiplicative actions on the same space commute."}, {"name": "mul_smul_comm", "description": "Note that the `smul_comm_class \u03b1 \u03b2 \u03b2` typeclass argument is usually satisfied by `algebra \u03b1 \u03b2`."}, {"name": "smul_one_mul", "description": ""}, {"name": "finset.sup_id_set_eq_sUnion", "description": ""}, {"name": "finset.min_le_coe_of_mem", "description": ""}, {"name": "finset.sup_eq_Sup_image", "description": ""}, {"name": "finset.sup'_const", "description": ""}, {"name": "finset.inf_product_left", "description": ""}, {"name": "finset.infi_coe", "description": ""}, {"name": "finset.inf_singleton", "description": ""}, {"name": "finset.of_dual_sup'", "description": ""}, {"name": "finset.set_bInter_coe", "description": ""}, {"name": "finset.min_mono", "description": ""}, {"name": "finset.induction_on_min_value", "description": " Induction principle for `finset`s in any type from which a given function `f` maps to a linearly\nordered type : a predicate is true on all `s : finset \u03b1` provided that:\n\n* it is true on the empty `finset`,\n* for every `s : finset \u03b1` and an element `a` such that for elements of `s` denoted by `x` we have\n  `f a \u2264 f x`, `p s` implies `p (insert a s)`."}, {"name": "finset.le_sup'_iff", "description": ""}, {"name": "finset.exists_mem_eq_sup", "description": ""}, {"name": "finset.sup'_mul_le_mul_sup'_of_nonneg", "description": ""}, {"name": "finset.coe_inf'", "description": ""}, {"name": "finset.sup", "description": "Supremum of a finite set: `sup {a, b, c} f = f a \u2294 f b \u2294 f c`"}, {"name": "finset.set_bUnion_coe", "description": ""}, {"name": "finset.min'_eq_inf'", "description": ""}, {"name": "finset.mem_sup", "description": ""}, {"name": "finset.inf'_induction", "description": ""}, {"name": "finset.inf_comm", "description": ""}, {"name": "finset.inf_le", "description": ""}, {"name": "finset.min_insert", "description": ""}, {"name": "finset.lt_sup_iff", "description": ""}, {"name": "finset.inf'_cons", "description": ""}, {"name": "finset.le_min'", "description": ""}, {"name": "infi_eq_infi_finset", "description": " Infimum of `s i`, `i : \u03b9`, is equal to the infimum over `t : finset \u03b9` of infima\n`\u2a05 i \u2208 t, s i`. This version assumes `\u03b9` is a `Type*`. See `infi_eq_infi_finset'` for a version\nthat works for `\u03b9 : Sort*`."}, {"name": "finset.sup_attach", "description": ""}, {"name": "finset.inf_bUnion", "description": ""}, {"name": "finset.sup_cons", "description": ""}, {"name": "finset.min'_mem", "description": ""}, {"name": "finset.set_bInter_insert", "description": ""}, {"name": "finset.supr_insert", "description": ""}, {"name": "finset.sup_union", "description": ""}, {"name": "finset.inf'_lt_iff", "description": ""}, {"name": "finset.inf_inf", "description": ""}, {"name": "finset.sup_product_right", "description": ""}, {"name": "finset.exists_nat_subset_range", "description": ""}, {"name": "finset.disjoint_sup_right", "description": ""}, {"name": "finset.max'_mem", "description": ""}, {"name": "finset.le_max_of_mem", "description": ""}, {"name": "finset.sup_finset_image", "description": ""}, {"name": "multiset.count_finset_sup", "description": ""}, {"name": "finset.sup'_insert", "description": ""}, {"name": "finset.inf_top", "description": ""}, {"name": "finset.inf_lt_iff", "description": ""}, {"name": "finset.sup'_mem", "description": ""}, {"name": "finset.max_empty", "description": ""}, {"name": "finset.sup'_singleton", "description": ""}, {"name": "finset.sup_le", "description": ""}, {"name": "finset.inf_attach", "description": ""}, {"name": "finset.induction_on_max", "description": " Induction principle for `finset`s in a linearly ordered type: a predicate is true on all\n`s : finset \u03b1` provided that:\n\n* it is true on the empty `finset`,\n* for every `s : finset \u03b1` and an element `a` strictly greater than all elements of `s`, `p s`\n  implies `p (insert a s)`."}, {"name": "finset.infi_insert_update", "description": ""}, {"name": "finset.coe_le_max_of_mem", "description": ""}, {"name": "finset.sup_const", "description": ""}, {"name": "finset.inf_of_mem", "description": ""}, {"name": "finset.inf_eq_infi", "description": ""}, {"name": "finset.supr_option_to_finset", "description": ""}, {"name": "finset.inf_congr", "description": ""}, {"name": "finset.max'", "description": " Given a nonempty finset `s` in a linear order `\u03b1 `, then `s.max' h` is its maximum, as an\nelement of `\u03b1`, where `h` is a proof of nonemptiness. Without this assumption, use instead `s.max`,\ntaking values in `with_bot \u03b1`."}, {"name": "finset.min_eq_top", "description": ""}, {"name": "finset.infi_bUnion", "description": ""}, {"name": "finset.sup_of_mem", "description": ""}, {"name": "finset.min'", "description": " Given a nonempty finset `s` in a linear order `\u03b1 `, then `s.min' h` is its minimum, as an\nelement of `\u03b1`, where `h` is a proof of nonemptiness. Without this assumption, use instead `s.min`,\ntaking values in `with_top \u03b1`."}, {"name": "finset.sup_sdiff_right", "description": ""}, {"name": "finset.max_eq_bot", "description": ""}, {"name": "finset.min_le_of_mem", "description": ""}, {"name": "finset.supr_bUnion", "description": ""}, {"name": "finset.lt_inf_iff", "description": ""}, {"name": "finset.exists_min_image", "description": ""}, {"name": "finset.sup'_eq_sup", "description": ""}, {"name": "finset.to_dual_sup'", "description": ""}, {"name": "finset.max'_image", "description": ""}, {"name": "finset.sup_mono_fun", "description": ""}, {"name": "finset.max'_eq_sup'", "description": ""}, {"name": "list.foldr_sup_eq_sup_to_finset", "description": ""}, {"name": "finset.inf'_le_iff", "description": ""}, {"name": "finset.inf_closed_of_inf_closed", "description": ""}, {"name": "finset.inf_le_iff", "description": ""}, {"name": "finset.of_dual_min'", "description": ""}, {"name": "finset.max'_lt_iff", "description": ""}, {"name": "finset.exists_mem_eq_sup'", "description": ""}, {"name": "finset.supr_coe", "description": ""}, {"name": "finset.coe_inf_of_nonempty", "description": ""}, {"name": "finset.sup_image", "description": ""}, {"name": "finset.inf'_insert", "description": ""}, {"name": "finset.comp_sup'_eq_sup'_comp", "description": ""}, {"name": "list.foldr_inf_eq_inf_to_finset", "description": ""}, {"name": "finset.max", "description": " Let `s` be a finset in a linear order. Then `s.max` is the maximum of `s` if `s` is not empty,\nand `\u22a5` otherwise. It belongs to `with_bot \u03b1`. If you want to get an element of `\u03b1`, see\n`s.max'`."}, {"name": "finset.le_inf'", "description": ""}, {"name": "finset.inf_eq_Inf_image", "description": ""}, {"name": "finset.inf_mono_fun", "description": ""}, {"name": "finset.inf_induction", "description": ""}, {"name": "finset.sup_eq_supr", "description": ""}, {"name": "finset.sup_sup", "description": ""}, {"name": "finset.le_inf", "description": ""}, {"name": "multiset.map_finset_sup", "description": ""}, {"name": "finset.sup_singleton''", "description": ""}, {"name": "finset.sup_inf_distrib_right", "description": ""}, {"name": "finset.set_bUnion_finset_image", "description": ""}, {"name": "finset.max_of_nonempty", "description": ""}, {"name": "supr_eq_supr_finset", "description": " Supremum of `s i`, `i : \u03b9`, is equal to the supremum over `t : finset \u03b9` of suprema\n`\u2a06 i \u2208 t, s i`. This version assumes `\u03b9` is a `Type*`. See `supr_eq_supr_finset'` for a version\nthat works for `\u03b9 : Sort*`."}, {"name": "finset.to_dual_max'", "description": ""}, {"name": "finset.sup_empty", "description": ""}, {"name": "finset.sup'_le", "description": ""}, {"name": "finset.sup_le_iff", "description": ""}, {"name": "finset.induction_on_max_value", "description": " Induction principle for `finset`s in any type from which a given function `f` maps to a linearly\nordered type : a predicate is true on all `s : finset \u03b1` provided that:\n\n* it is true on the empty `finset`,\n* for every `s : finset \u03b1` and an element `a` such that for elements of `s` denoted by `x` we have\n  `f x \u2264 f a`, `p s` implies `p (insert a s)`."}, {"name": "finset.le_max'", "description": ""}, {"name": "finset.min'_singleton", "description": "`{a}.min' _` is `a`."}, {"name": "finset.lt_max'_of_mem_erase_max'", "description": ""}, {"name": "finset.min_empty", "description": ""}, {"name": "finset.set_bUnion_option_to_finset", "description": ""}, {"name": "finset.mem_of_max", "description": ""}, {"name": "finset.is_least_min'", "description": ""}, {"name": "finset.inf_const", "description": ""}, {"name": "finset.of_dual_inf'", "description": ""}, {"name": "finset.le_min", "description": ""}, {"name": "finset.to_dual_min'", "description": ""}, {"name": "finset.set_bInter_insert_update", "description": ""}, {"name": "finset.sup'_cons", "description": ""}, {"name": "finset.inf'_singleton", "description": ""}, {"name": "finset.inf_def", "description": ""}, {"name": "finset.le_sup'", "description": ""}, {"name": "finset.inf'_apply", "description": ""}, {"name": "finset.sup_mono", "description": ""}, {"name": "finset.max_eq_sup_coe", "description": ""}, {"name": "finset.sup'_congr", "description": ""}, {"name": "finset.comp_inf_eq_inf_comp", "description": ""}, {"name": "finset.supr_union", "description": ""}, {"name": "finset.inf", "description": "Infimum of a finite set: `inf {a, b, c} f = f a \u2293 f b \u2293 f c`"}, {"name": "finset.subset_range_sup_succ", "description": ""}, {"name": "finset.comp_inf_eq_inf_comp_of_is_total", "description": ""}, {"name": "finset.sup_apply", "description": ""}, {"name": "finset.inf'", "description": " Given nonempty finset `s` then `s.inf' H f` is the infimum of its image under `f` in (possibly\nunbounded) meet-semilattice `\u03b1`, where `H` is a proof of nonemptiness. If `\u03b1` has a top element you\nmay instead use `finset.inf` which does not require `s` nonempty."}, {"name": "supr_eq_supr_finset'", "description": " Supremum of `s i`, `i : \u03b9`, is equal to the supremum over `t : finset \u03b9` of suprema\n`\u2a06 i \u2208 t, s i`. This version works for `\u03b9 : Sort*`. See `supr_eq_supr_finset` for a version\nthat assumes `\u03b9 : Type*` but has no `plift`s."}, {"name": "finset.inf_empty", "description": ""}, {"name": "finset.set_bInter_singleton", "description": ""}, {"name": "finset.sup_def", "description": ""}, {"name": "finset.inf_coe", "description": "Computing `inf` in a subtype (closed under `inf`) is the same as computing it in `\u03b1`."}, {"name": "finset.max_of_mem", "description": ""}, {"name": "finset.map_of_dual_max", "description": ""}, {"name": "finset.max_eq_sup_with_bot", "description": ""}, {"name": "finset.sup'_induction", "description": ""}, {"name": "finset.le_sup", "description": ""}, {"name": "finset.sup_induction", "description": ""}, {"name": "finset.sup'_bUnion", "description": ""}, {"name": "finset.comp_sup_eq_sup_comp_of_is_total", "description": ""}, {"name": "finset.inf'_eq_inf", "description": ""}, {"name": "finset.supr_finset_image", "description": ""}, {"name": "finset.lt_sup'_iff", "description": ""}, {"name": "finset.max_mono", "description": ""}, {"name": "finset.inf_image", "description": ""}, {"name": "finset.inf'_mem", "description": ""}, {"name": "finset.sup_mul_le_mul_sup_of_nonneg", "description": ""}, {"name": "finset.to_dual_inf'", "description": ""}, {"name": "finset.sup_coe", "description": "Computing `sup` in a subtype (closed under `sup`) is the same as computing it in `\u03b1`."}, {"name": "finset.sup_bot", "description": ""}, {"name": "finset.sup_lt_iff", "description": ""}, {"name": "finset.mem_of_min", "description": ""}, {"name": "finset.of_dual_sup", "description": ""}, {"name": "finset.is_greatest_max'", "description": ""}, {"name": "finset.disjoint_sup_left", "description": ""}, {"name": "finset.sup_inf_distrib_left", "description": ""}, {"name": "finset.min_singleton", "description": ""}, {"name": "finset.sup_le_of_le_directed", "description": ""}, {"name": "finset.max_le", "description": ""}, {"name": "finset.lt_min'_iff", "description": ""}, {"name": "finset.coe_sup_of_nonempty", "description": ""}, {"name": "finset.of_dual_inf", "description": ""}, {"name": "finset.lt_inf'_iff", "description": ""}, {"name": "finset.sup_sdiff_left", "description": ""}, {"name": "finset.le_inf_iff", "description": ""}, {"name": "finset.map_to_dual_min", "description": ""}, {"name": "finset.coe_sup'", "description": ""}, {"name": "finset.set_bUnion_union", "description": ""}, {"name": "finset.inf_id_set_eq_sInter", "description": ""}, {"name": "finset.set_bInter_inter", "description": ""}, {"name": "finset.sup'", "description": " Given nonempty finset `s` then `s.sup' H f` is the supremum of its image under `f` in (possibly\nunbounded) join-semilattice `\u03b1`, where `H` is a proof of nonemptiness. If `\u03b1` has a bottom element\nyou may instead use `finset.sup` which does not require `s` nonempty."}, {"name": "finset.infi_insert", "description": ""}, {"name": "finset.infi_option_to_finset", "description": ""}, {"name": "finset.set_bUnion_insert", "description": ""}, {"name": "finset.le_inf'_iff", "description": ""}, {"name": "finset.inf_id_eq_Inf", "description": ""}, {"name": "finset.sup_closed_of_sup_closed", "description": ""}, {"name": "finset.min_of_mem", "description": ""}, {"name": "finset.subset_set_bUnion_of_mem", "description": ""}, {"name": "finset.inf_mem", "description": ""}, {"name": "finset.inf_sup_distrib_right", "description": ""}, {"name": "finset.sup_singleton", "description": ""}, {"name": "finset.inf'_mul_le_mul_inf'_of_nonneg", "description": ""}, {"name": "finset.sup_congr", "description": ""}, {"name": "finset.inf_apply", "description": ""}, {"name": "finset.set_bUnion_preimage_singleton", "description": ""}, {"name": "finset.max_singleton", "description": ""}, {"name": "finset.sup_eq_bot_iff", "description": ""}, {"name": "finset.set_bUnion_insert_update", "description": ""}, {"name": "finset.to_dual_sup", "description": ""}, {"name": "finset.set_bUnion_singleton", "description": ""}, {"name": "finset.exists_max_image", "description": ""}, {"name": "finset.min'_lt_max'_of_card", "description": "If there's more than 1 element, the min' is less than the max'. An alternate version of\n`min'_lt_max'` which is sometimes more convenient."}, {"name": "finset.inf_cons", "description": ""}, {"name": "finset.set_bInter_finset_image", "description": ""}, {"name": "finset.supr_singleton", "description": ""}, {"name": "finset.max'_le", "description": ""}, {"name": "multiset.mem_sup", "description": ""}, {"name": "finset.map_to_dual_max", "description": ""}, {"name": "infi_eq_infi_finset'", "description": " Infimum of `s i`, `i : \u03b9`, is equal to the infimum over `t : finset \u03b9` of infima\n`\u2a05 i \u2208 t, s i`. This version works for `\u03b9 : Sort*`. See `infi_eq_infi_finset` for a version\nthat assumes `\u03b9 : Type*` but has no `plift`s."}, {"name": "finset.inf_union", "description": ""}, {"name": "finset.comp_sup_eq_sup_comp", "description": ""}, {"name": "finset.min'_insert", "description": ""}, {"name": "finset.sup_erase_bot", "description": ""}, {"name": "finset.infi_singleton", "description": ""}, {"name": "finset.sup'_map", "description": ""}, {"name": "finset.supr_insert_update", "description": ""}, {"name": "finset.max'_le_iff", "description": ""}, {"name": "finset.min_of_nonempty", "description": ""}, {"name": "finset.inf_mono", "description": ""}, {"name": "finset.mul_inf_le_inf_mul_of_nonneg", "description": ""}, {"name": "finset.sup_set_eq_bUnion", "description": ""}, {"name": "finset.min'_subset", "description": ""}, {"name": "finset.sup_bUnion", "description": ""}, {"name": "finset.map_of_dual_min", "description": ""}, {"name": "finset.inf'_const", "description": ""}, {"name": "finset.sup_ite", "description": ""}, {"name": "finset.of_dual_max'", "description": ""}, {"name": "finset.min'_lt_max'", "description": ""}, {"name": "finset.sup_to_finset", "description": ""}, {"name": "finset.inf'_congr", "description": ""}, {"name": "finset.set_bUnion_bUnion", "description": ""}, {"name": "finset.min'_le", "description": ""}, {"name": "finset.inf_set_eq_bInter", "description": ""}, {"name": "finset.sup_comm", "description": ""}, {"name": "finset.sup_eq_bUnion", "description": ""}, {"name": "finset.inf_product_right", "description": ""}, {"name": "finset.set_bInter_option_to_finset", "description": ""}, {"name": "finset.inf'_map", "description": ""}, {"name": "finset.sup_insert", "description": ""}, {"name": "finset.exists_mem_eq_inf'", "description": ""}, {"name": "finset.induction_on_min", "description": " Induction principle for `finset`s in a linearly ordered type: a predicate is true on all\n`s : finset \u03b1` provided that:\n\n* it is true on the empty `finset`,\n* for every `s : finset \u03b1` and an element `a` strictly less than all elements of `s`, `p s`\n  implies `p (insert a s)`."}, {"name": "finset.inf_map", "description": ""}, {"name": "finset.inf_sdiff_left", "description": ""}, {"name": "finset.min", "description": " Let `s` be a finset in a linear order. Then `s.min` is the minimum of `s` if `s` is not empty,\nand `\u22a4` otherwise. It belongs to `with_top \u03b1`. If you want to get an element of `\u03b1`, see\n`s.min'`."}, {"name": "finset.inf'_le", "description": ""}, {"name": "finset.infi_union", "description": ""}, {"name": "finset.sup_mem", "description": ""}, {"name": "finset.max'_insert", "description": ""}, {"name": "set.Inter_eq_Inter_finset'", "description": " Intersection of an indexed family of sets `s : \u03b9 \u2192 set \u03b1` is equal to the intersection of the\nintersections of finite subfamilies. This version works for `\u03b9 : Sort*`. See also\n`Inter_eq_Inter_finset` for a version that assumes `\u03b9 : Type*` but avoids `plift`s in the right\nhand side."}, {"name": "finset.max_insert", "description": ""}, {"name": "finset.min'_lt_of_mem_erase_min'", "description": ""}, {"name": "finset.infi_finset_image", "description": ""}, {"name": "finset.inf_erase_top", "description": ""}, {"name": "finset.sup_map", "description": ""}, {"name": "finset.sup_singleton'", "description": ""}, {"name": "finset.max'_singleton", "description": "`{a}.max' _` is `a`."}, {"name": "finset.sup'_lt_iff", "description": ""}, {"name": "finset.comp_inf'_eq_inf'_comp", "description": ""}, {"name": "finset.max'_subset", "description": ""}, {"name": "finset.inf_eq_top_iff", "description": ""}, {"name": "finset.inf'_bUnion", "description": ""}, {"name": "finset.inf_sdiff_right", "description": ""}, {"name": "finset.sup_product_left", "description": "See also `finset.product_bUnion`."}, {"name": "set.Union_eq_Union_finset", "description": " Union of an indexed family of sets `s : \u03b9 \u2192 set \u03b1` is equal to the union of the unions\nof finite subfamilies. This version assumes `\u03b9 : Type*`. See also `Union_eq_Union_finset'` for\na version that works for `\u03b9 : Sort*`."}, {"name": "finset.le_min'_iff", "description": ""}, {"name": "finset.sup_id_eq_Sup", "description": ""}, {"name": "finset.min_eq_inf_with_top", "description": ""}, {"name": "finset.le_sup_iff", "description": ""}, {"name": "finset.exists_mem_eq_inf", "description": ""}, {"name": "set.Inter_eq_Inter_finset", "description": " Intersection of an indexed family of sets `s : \u03b9 \u2192 set \u03b1` is equal to the intersection of the\nintersections of finite subfamilies. This version assumes `\u03b9 : Type*`. See also\n`Inter_eq_Inter_finset'` for a version that works for `\u03b9 : Sort*`."}, {"name": "finset.min'_image", "description": ""}, {"name": "set.Union_eq_Union_finset'", "description": " Union of an indexed family of sets `s : \u03b9 \u2192 set \u03b1` is equal to the union of the unions\nof finite subfamilies. This version works for `\u03b9 : Sort*`. See also `Union_eq_Union_finset` for\na version that assumes `\u03b9 : Type*` but avoids `plift`s in the right hand side."}, {"name": "finset.inf_sup_distrib_left", "description": ""}, {"name": "finset.set_bInter_bUnion", "description": ""}, {"name": "finset.to_dual_inf", "description": ""}, {"name": "finset.sup'_le_iff", "description": ""}, {"name": "finset.sup'_apply", "description": ""}, {"name": "finset.inf_insert", "description": ""}, {"name": "environment", "description": "An __environment__ contains all of the declarations and notation that have been defined so far."}, {"name": "environment.add_ginductive", "description": "Add a new general inductive declaration to the environment.\n This has the same effect as a `inductive` in the file, including generating\n all the auxiliary definitions, as well as triggering mutual/nested inductive\n compilation, by contrast to `environment.add_inductive` which only adds the\n core axioms supported by the kernel.\n\n The `inds` argument should be a list of inductives in the mutual family.\n The first argument is a pair of the name of the type being constructed\n and the type of this inductive family (not including the params).\n The second argument is a list of intro rules, specified by a name, an\n `implicit_infer_kind` giving the implicitness of the params for this constructor,\n and an expression with the type of the constructor (not including the params)."}, {"name": "environment.decl_noncomputable_reason", "description": " `decl_pos env d` returns the name of a declaration that d inherits\nnoncomputability from, or `none` if it is computable.\n\nNote that this also returns `none` on `axiom`s and `constant`s. These can be detected by using\n`environment.get_decl` and `declaration.is_axiom` and `declaration.is_constant`."}, {"name": "environment.is_projection", "description": "See the docstring for `projection_info`."}, {"name": "environment.is_protected", "description": "check if `n` is the name of a protected declaration"}, {"name": "environment.get_namespaces", "description": "Retrieve all registered namespaces"}, {"name": "environment.get_eqn_lemmas_for", "description": "Gets the equation lemmas for the declaration `n`."}, {"name": "environment.fold", "description": "Fold over declarations in the environment."}, {"name": "environment.inductive_dep_elim", "description": "Return tt iff the inductive datatype recursor supports dependent elimination"}, {"name": "environment.unfold_all_macros", "description": ""}, {"name": "environment.is_definition", "description": ""}, {"name": "environment.add_inductive", "description": "Add a new inductive datatype to the environment\n  name, universe parameters, number of parameters, type, constructors (name and type), is_meta"}, {"name": "environment.get_ext_eqn_lemmas_for", "description": "Gets the equation lemmas for the declaration `n`, including lemmas for match statements, etc."}, {"name": "environment.is_namespace", "description": "Return tt iff the given name is a namespace"}, {"name": "environment.is_inductive", "description": "Return tt iff the given name is an inductive datatype"}, {"name": "environment.add_namespace", "description": "Register the given name as a namespace, making it available to the `open` command"}, {"name": "environment.inductive_num_params", "description": "Return the number of parameters of the inductive datatype"}, {"name": "environment.unfold_untrusted_macros", "description": ""}, {"name": "environment.has_repr", "description": ""}, {"name": "environment.inductive_num_indices", "description": "Return the number of indices of the inductive datatype"}, {"name": "environment.in_current_file", "description": "Return true if 'n' has been declared in the current file"}, {"name": "environment.relation_info", "description": "`relation_info env n` returns some value if n is marked as a relation in the given environment.\n  the tuple contains: total number of arguments of the relation, lhs position and rhs position."}, {"name": "environment.is_refl_app", "description": ""}, {"name": "environment.trans_for", "description": "`trans_for env R` returns the name of the transitivity theorem for the relation R"}, {"name": "environment.intro_rule", "description": "One introduction rule in an inductive declaration"}, {"name": "environment.intro_rule.constr", "description": "One introduction rule in an inductive declaration"}, {"name": "environment.intro_rule.type", "description": "One introduction rule in an inductive declaration"}, {"name": "environment.intro_rule.infer", "description": "One introduction rule in an inductive declaration"}, {"name": "environment.is_ginductive", "description": " Functionally equivalent to `is_inductive`.\n\nTechnically, this works by checking if the name is in the ginductive environment\nextension which is outside the kernel, whereas `is_inductive` works by looking at the kernel extension.\nBut there are no `is_inductive`s which are not `is_ginductive`."}, {"name": "environment.recursor_of", "description": "Return the recursor of the given inductive datatype"}, {"name": "environment.fingerprint", "description": "The fingerprint of the environment is a hash formed from all of the declarations in the environment."}, {"name": "environment.decl_olean", "description": "`decl_olean env d` returns the name of the .olean file where d was defined.\n  The result is none if d was not defined in an imported file."}, {"name": "environment.decl_pos", "description": "`decl_pos env d` returns the source location of d if available."}, {"name": "environment.contains", "description": ""}, {"name": "environment.projection_info", "description": "Consider a type `\u03c8` which is an inductive datatype using a single constructor `mk (a : \u03b1) (b : \u03b2) : \u03c8`.\nLean will automatically make two projection functions `a : \u03c8 \u2192 \u03b1`, `b : \u03c8 \u2192 \u03b2`.\nLean tags these declarations as __projections__.\nThis helps the simplifier / rewriter not have to expand projectors.\nEg `a (mk x y)` will automatically reduce to `x`.\nIf you `extend` a structure, all of the projections on the parent will also be created for the child.\nProjections are also treated differently in the VM for efficiency.\n\nNote that projections have nothing to do with the dot `mylist.map` syntax.\n\nYou can find out if a declaration is a projection using `environment.is_projection` which returns `projection_info`.\n\nData for a projection declaration:\n- `cname`    is the name of the constructor associated with the projection.\n- `nparams`  is the number of constructor parameters. Eg `and.intro` has two type parameters.\n- `idx`      is the parameter being projected by this projection.\n- `is_class` is tt iff this is a typeclass projection.\n\n### Examples:\n\n- `and.right` is a projection with ``{cname := `and.intro, nparams := 2, idx := 1, is_class := ff}``\n- `ordered_ring.neg` is a projection with ``{cname := `ordered_ring.mk, nparams := 1, idx := 5, is_class := tt}``."}, {"name": "environment.projection_info.cname", "description": "Consider a type `\u03c8` which is an inductive datatype using a single constructor `mk (a : \u03b1) (b : \u03b2) : \u03c8`.\nLean will automatically make two projection functions `a : \u03c8 \u2192 \u03b1`, `b : \u03c8 \u2192 \u03b2`.\nLean tags these declarations as __projections__.\nThis helps the simplifier / rewriter not have to expand projectors.\nEg `a (mk x y)` will automatically reduce to `x`.\nIf you `extend` a structure, all of the projections on the parent will also be created for the child.\nProjections are also treated differently in the VM for efficiency.\n\nNote that projections have nothing to do with the dot `mylist.map` syntax.\n\nYou can find out if a declaration is a projection using `environment.is_projection` which returns `projection_info`.\n\nData for a projection declaration:\n- `cname`    is the name of the constructor associated with the projection.\n- `nparams`  is the number of constructor parameters. Eg `and.intro` has two type parameters.\n- `idx`      is the parameter being projected by this projection.\n- `is_class` is tt iff this is a typeclass projection.\n\n### Examples:\n\n- `and.right` is a projection with ``{cname := `and.intro, nparams := 2, idx := 1, is_class := ff}``\n- `ordered_ring.neg` is a projection with ``{cname := `ordered_ring.mk, nparams := 1, idx := 5, is_class := tt}``."}, {"name": "environment.projection_info.nparams", "description": "Consider a type `\u03c8` which is an inductive datatype using a single constructor `mk (a : \u03b1) (b : \u03b2) : \u03c8`.\nLean will automatically make two projection functions `a : \u03c8 \u2192 \u03b1`, `b : \u03c8 \u2192 \u03b2`.\nLean tags these declarations as __projections__.\nThis helps the simplifier / rewriter not have to expand projectors.\nEg `a (mk x y)` will automatically reduce to `x`.\nIf you `extend` a structure, all of the projections on the parent will also be created for the child.\nProjections are also treated differently in the VM for efficiency.\n\nNote that projections have nothing to do with the dot `mylist.map` syntax.\n\nYou can find out if a declaration is a projection using `environment.is_projection` which returns `projection_info`.\n\nData for a projection declaration:\n- `cname`    is the name of the constructor associated with the projection.\n- `nparams`  is the number of constructor parameters. Eg `and.intro` has two type parameters.\n- `idx`      is the parameter being projected by this projection.\n- `is_class` is tt iff this is a typeclass projection.\n\n### Examples:\n\n- `and.right` is a projection with ``{cname := `and.intro, nparams := 2, idx := 1, is_class := ff}``\n- `ordered_ring.neg` is a projection with ``{cname := `ordered_ring.mk, nparams := 1, idx := 5, is_class := tt}``."}, {"name": "environment.projection_info.idx", "description": "Consider a type `\u03c8` which is an inductive datatype using a single constructor `mk (a : \u03b1) (b : \u03b2) : \u03c8`.\nLean will automatically make two projection functions `a : \u03c8 \u2192 \u03b1`, `b : \u03c8 \u2192 \u03b2`.\nLean tags these declarations as __projections__.\nThis helps the simplifier / rewriter not have to expand projectors.\nEg `a (mk x y)` will automatically reduce to `x`.\nIf you `extend` a structure, all of the projections on the parent will also be created for the child.\nProjections are also treated differently in the VM for efficiency.\n\nNote that projections have nothing to do with the dot `mylist.map` syntax.\n\nYou can find out if a declaration is a projection using `environment.is_projection` which returns `projection_info`.\n\nData for a projection declaration:\n- `cname`    is the name of the constructor associated with the projection.\n- `nparams`  is the number of constructor parameters. Eg `and.intro` has two type parameters.\n- `idx`      is the parameter being projected by this projection.\n- `is_class` is tt iff this is a typeclass projection.\n\n### Examples:\n\n- `and.right` is a projection with ``{cname := `and.intro, nparams := 2, idx := 1, is_class := ff}``\n- `ordered_ring.neg` is a projection with ``{cname := `ordered_ring.mk, nparams := 1, idx := 5, is_class := tt}``."}, {"name": "environment.projection_info.is_class", "description": "Consider a type `\u03c8` which is an inductive datatype using a single constructor `mk (a : \u03b1) (b : \u03b2) : \u03c8`.\nLean will automatically make two projection functions `a : \u03c8 \u2192 \u03b1`, `b : \u03c8 \u2192 \u03b2`.\nLean tags these declarations as __projections__.\nThis helps the simplifier / rewriter not have to expand projectors.\nEg `a (mk x y)` will automatically reduce to `x`.\nIf you `extend` a structure, all of the projections on the parent will also be created for the child.\nProjections are also treated differently in the VM for efficiency.\n\nNote that projections have nothing to do with the dot `mylist.map` syntax.\n\nYou can find out if a declaration is a projection using `environment.is_projection` which returns `projection_info`.\n\nData for a projection declaration:\n- `cname`    is the name of the constructor associated with the projection.\n- `nparams`  is the number of constructor parameters. Eg `and.intro` has two type parameters.\n- `idx`      is the parameter being projected by this projection.\n- `is_class` is tt iff this is a typeclass projection.\n\n### Examples:\n\n- `and.right` is a projection with ``{cname := `and.intro, nparams := 2, idx := 1, is_class := ff}``\n- `ordered_ring.neg` is a projection with ``{cname := `ordered_ring.mk, nparams := 1, idx := 5, is_class := tt}``."}, {"name": "environment.get", "description": "Retrieve a declaration from the environment"}, {"name": "environment.refl_for", "description": "`refl_for env R` returns the name of the reflexivity theorem for the relation R"}, {"name": "environment.is_recursor", "description": "Return tt iff the given name is a recursor"}, {"name": "environment.mark_namespace_as_open", "description": "Mark a namespace as open"}, {"name": "environment.get_class_attribute_symbols", "description": "`get_class_attribute_symbols env attr_name` return symbols\n  occurring in instances of type classes tagged with the attribute `attr_name`.\n  Example: [algebra]"}, {"name": "environment.structure_fields", "description": "Return the fields of the structure with the given name, or `none` if it is not a structure"}, {"name": "environment.constructors_of", "description": "Return the constructors of the inductive datatype with the given name"}, {"name": "environment.execute_open", "description": "Modify the environment as if `open %%name` had been parsed"}, {"name": "environment.add_protected", "description": "add declaration `d` and make it protected"}, {"name": "environment.add", "description": "Add a new declaration to the environment"}, {"name": "environment.trust_lvl", "description": "Return the trust level of the given environment"}, {"name": "environment.inhabited", "description": ""}, {"name": "environment.implicit_infer_kind", "description": "A marking on the binders of structures and inductives indicating\n  how this constructor should mark its parameters.\n\n      inductive foo\n      | one {} : foo -> foo   -- relaxed_implicit\n      | two ( ) : foo -> foo  -- explicit\n      | two [] : foo -> foo   -- implicit\n      | three : foo -> foo    -- relaxed implicit (default)"}, {"name": "environment.implicit_infer_kind.implicit", "description": "A marking on the binders of structures and inductives indicating\n  how this constructor should mark its parameters.\n\n      inductive foo\n      | one {} : foo -> foo   -- relaxed_implicit\n      | two ( ) : foo -> foo  -- explicit\n      | two [] : foo -> foo   -- implicit\n      | three : foo -> foo    -- relaxed implicit (default)"}, {"name": "environment.implicit_infer_kind.relaxed_implicit", "description": "A marking on the binders of structures and inductives indicating\n  how this constructor should mark its parameters.\n\n      inductive foo\n      | one {} : foo -> foo   -- relaxed_implicit\n      | two ( ) : foo -> foo  -- explicit\n      | two [] : foo -> foo   -- implicit\n      | three : foo -> foo    -- relaxed implicit (default)"}, {"name": "environment.implicit_infer_kind.none", "description": "A marking on the binders of structures and inductives indicating\n  how this constructor should mark its parameters.\n\n      inductive foo\n      | one {} : foo -> foo   -- relaxed_implicit\n      | two ( ) : foo -> foo  -- explicit\n      | two [] : foo -> foo   -- implicit\n      | three : foo -> foo    -- relaxed implicit (default)"}, {"name": "environment.inductive_type_of", "description": "Return the name of the inductive datatype of the given constructor."}, {"name": "environment.is_constructor_app", "description": ""}, {"name": "environment.is_constructor", "description": "Return tt iff the given name is a constructor"}, {"name": "environment.mk_std", "description": "Create a standard environment using the given trust level"}, {"name": "environment.add_defn_eqns", "description": ""}, {"name": "environment.implicit_infer_kind.inhabited", "description": ""}, {"name": "environment.symm_for", "description": "`symm_for env R` returns the name of the symmetry theorem for the relation R"}, {"name": "environment.add_eqn_lemma", "description": "Adds the equation lemma `n`.\nIt is added for the declaration `t.pi_codomain.get_app_fn.const_name` where `t` is the type of the equation lemma."}, {"name": "environment.is_recursive", "description": "Return tt iff the given name is a recursive inductive datatype"}, {"name": "environment.mk_protected", "description": "make declaration `n` protected"}, {"name": "is_cond_left_inv", "description": ""}, {"name": "is_cond_left_inv.left_inv", "description": ""}, {"name": "is_total", "description": " `is_total X r` means that the binary relation `r` on `X` is total, that is, that for any\n`x y : X` we have `r x y` or `r y x`."}, {"name": "is_total.total", "description": " `is_total X r` means that the binary relation `r` on `X` is total, that is, that for any\n`x y : X` we have `r x y` or `r y x`."}, {"name": "is_strict_weak_order_of_is_total_preorder", "description": ""}, {"name": "is_symm_op_of_is_symm", "description": "The opposite of a symmetric relation is symmetric."}, {"name": "eqv_lt_iff_eq", "description": ""}, {"name": "refl", "description": ""}, {"name": "is_cond_right_inv", "description": ""}, {"name": "is_cond_right_inv.right_inv", "description": ""}, {"name": "is_symm_op", "description": ""}, {"name": "is_symm_op.symm_op", "description": ""}, {"name": "irrefl_of", "description": ""}, {"name": "is_preorder", "description": " `is_preorder X r` means that the binary relation `r` on `X` is a pre-order, that is, reflexive\nand transitive."}, {"name": "is_preorder.to_is_refl", "description": " `is_preorder X r` means that the binary relation `r` on `X` is a pre-order, that is, reflexive\nand transitive."}, {"name": "is_preorder.to_is_trans", "description": " `is_preorder X r` means that the binary relation `r` on `X` is a pre-order, that is, reflexive\nand transitive."}, {"name": "antisymm", "description": ""}, {"name": "is_asymm_of_is_trans_of_is_irrefl", "description": ""}, {"name": "is_right_id", "description": ""}, {"name": "is_right_id.right_id", "description": ""}, {"name": "is_distinct", "description": ""}, {"name": "is_distinct.distinct", "description": ""}, {"name": "is_refl", "description": "`is_refl X r` means the binary relation `r` on `X` is reflexive."}, {"name": "is_refl.refl", "description": "`is_refl X r` means the binary relation `r` on `X` is reflexive."}, {"name": "is_left_cancel", "description": ""}, {"name": "is_left_cancel.left_cancel", "description": ""}, {"name": "is_associative", "description": ""}, {"name": "is_associative.assoc", "description": ""}, {"name": "eq_of_incomp", "description": ""}, {"name": "is_trans", "description": "`is_trans X r` means the binary relation `r` on `X` is transitive."}, {"name": "is_trans.trans", "description": "`is_trans X r` means the binary relation `r` on `X` is transitive."}, {"name": "asymm", "description": ""}, {"name": "is_left_null", "description": ""}, {"name": "is_left_null.left_null", "description": ""}, {"name": "is_irrefl", "description": " `is_irrefl X r` means the binary relation `r` on `X` is irreflexive (that is, `r x x` never\nholds)."}, {"name": "is_irrefl.irrefl", "description": " `is_irrefl X r` means the binary relation `r` on `X` is irreflexive (that is, `r x x` never\nholds)."}, {"name": "is_idempotent", "description": ""}, {"name": "is_idempotent.idempotent", "description": ""}, {"name": "strict_weak_order.etrans", "description": ""}, {"name": "lt_of_incomp_of_lt", "description": ""}, {"name": "is_left_id", "description": ""}, {"name": "is_left_id.left_id", "description": ""}, {"name": "is_strict_weak_order", "description": ""}, {"name": "is_strict_weak_order.to_is_strict_order", "description": ""}, {"name": "is_strict_weak_order.to_is_incomp_trans", "description": ""}, {"name": "incomp_trans", "description": ""}, {"name": "trans", "description": ""}, {"name": "asymm_of", "description": ""}, {"name": "is_right_cancel", "description": ""}, {"name": "is_right_cancel.right_cancel", "description": ""}, {"name": "is_commutative", "description": ""}, {"name": "is_commutative.comm", "description": ""}, {"name": "is_linear_order", "description": ""}, {"name": "is_linear_order.to_is_partial_order", "description": ""}, {"name": "is_linear_order.to_is_total", "description": ""}, {"name": "is_left_inv", "description": ""}, {"name": "is_left_inv.left_inv", "description": ""}, {"name": "strict_weak_order.equiv", "description": ""}, {"name": "trichotomous_of", "description": ""}, {"name": "is_right_inv", "description": ""}, {"name": "is_right_inv.right_inv", "description": ""}, {"name": "is_symm", "description": "`is_symm X r` means the binary relation `r` on `X` is symmetric."}, {"name": "is_symm.symm", "description": "`is_symm X r` means the binary relation `r` on `X` is symmetric."}, {"name": "incomp_iff_eq", "description": ""}, {"name": "is_antisymm", "description": "`is_antisymm X r` means the binary relation `r` on `X` is antisymmetric."}, {"name": "is_antisymm.antisymm", "description": "`is_antisymm X r` means the binary relation `r` on `X` is antisymmetric."}, {"name": "symm_of", "description": ""}, {"name": "irrefl", "description": ""}, {"name": "strict_weak_order.is_equiv", "description": ""}, {"name": "not_lt_of_lt", "description": ""}, {"name": "is_per", "description": ""}, {"name": "is_per.to_is_symm", "description": ""}, {"name": "is_per.to_is_trans", "description": ""}, {"name": "symm", "description": ""}, {"name": "strict_weak_order.esymm", "description": ""}, {"name": "is_strict_order", "description": ""}, {"name": "is_strict_order.to_is_irrefl", "description": ""}, {"name": "is_strict_order.to_is_trans", "description": ""}, {"name": "eq_is_equiv", "description": ""}, {"name": "is_symm_op_of_is_commutative", "description": ""}, {"name": "incomp_trans_of", "description": ""}, {"name": "strict_weak_order.erefl", "description": ""}, {"name": "is_strict_total_order", "description": ""}, {"name": "is_strict_total_order.to_is_trichotomous", "description": ""}, {"name": "is_strict_total_order.to_is_strict_weak_order", "description": ""}, {"name": "total_of", "description": ""}, {"name": "is_total_preorder", "description": "`is_total_preorder X r` means that the binary relation `r` on `X` is total and a preorder."}, {"name": "is_total_preorder.to_is_trans", "description": "`is_total_preorder X r` means that the binary relation `r` on `X` is total and a preorder."}, {"name": "is_total_preorder.to_is_total", "description": "`is_total_preorder X r` means that the binary relation `r` on `X` is total and a preorder."}, {"name": "is_asymm", "description": " `is_asymm X r` means that the binary relation `r` on `X` is asymmetric, that is,\n`r a b \u2192 \u00ac r b a`."}, {"name": "is_asymm.asymm", "description": " `is_asymm X r` means that the binary relation `r` on `X` is asymmetric, that is,\n`r a b \u2192 \u00ac r b a`."}, {"name": "is_partial_order", "description": ""}, {"name": "is_partial_order.to_is_preorder", "description": ""}, {"name": "is_partial_order.to_is_antisymm", "description": ""}, {"name": "eq_of_eqv_lt", "description": ""}, {"name": "is_right_null", "description": ""}, {"name": "is_right_null.right_null", "description": ""}, {"name": "lt_of_lt_of_incomp", "description": ""}, {"name": "strict_weak_order.not_lt_of_equiv'", "description": ""}, {"name": "is_right_distrib", "description": ""}, {"name": "is_right_distrib.right_distrib", "description": ""}, {"name": "is_left_distrib", "description": ""}, {"name": "is_left_distrib.left_distrib", "description": ""}, {"name": "trichotomous", "description": ""}, {"name": "strict_weak_order.not_lt_of_equiv", "description": ""}, {"name": "trans_of", "description": ""}, {"name": "refl_of", "description": ""}, {"name": "is_incomp_trans", "description": ""}, {"name": "is_incomp_trans.incomp_trans", "description": ""}, {"name": "is_trichotomous", "description": ""}, {"name": "is_trichotomous.trichotomous", "description": ""}, {"name": "is_equiv", "description": ""}, {"name": "is_equiv.to_is_preorder", "description": ""}, {"name": "is_equiv.to_is_symm", "description": ""}, {"name": "is_total_preorder_is_preorder", "description": "Every total pre-order is a pre-order."}, {"name": "sum.map_inr", "description": ""}, {"name": "sum.elim_comp_inl_inr", "description": ""}, {"name": "sum.get_right", "description": "Check if a sum is `inr` and if so, retrieve its contents."}, {"name": "sum.swap_inr", "description": ""}, {"name": "sum.elim_lam_const_lam_const", "description": ""}, {"name": "function.injective.sum_elim", "description": ""}, {"name": "sum.lex_acc_inr", "description": ""}, {"name": "sum.not_lift_rel_inl_inr", "description": ""}, {"name": "sum.elim_update_right", "description": ""}, {"name": "sum.get_left_eq_none_iff", "description": ""}, {"name": "sum.elim", "description": "Define a function on `\u03b1 \u2295 \u03b2` by giving separate definitions on `\u03b1` and `\u03b2`."}, {"name": "sum.inr_injective", "description": ""}, {"name": "sum.swap_right_inverse", "description": ""}, {"name": "sum.update_elim_inr", "description": ""}, {"name": "sum.swap_inl", "description": ""}, {"name": "sum.update_inr_comp_inl", "description": ""}, {"name": "sum.get_left", "description": "Check if a sum is `inl` and if so, retrieve its contents."}, {"name": "sum.elim_update_left", "description": ""}, {"name": "sum.elim_comp_map", "description": ""}, {"name": "sum.swap", "description": "Swap the factors of a sum type"}, {"name": "sum.map_id_id", "description": ""}, {"name": "function.surjective.sum_map", "description": ""}, {"name": "sum.map_inl", "description": ""}, {"name": "sum.is_right", "description": "Check if a sum is `inr`."}, {"name": "sum.update_inr_apply_inl", "description": ""}, {"name": "sum.comp_elim", "description": ""}, {"name": "sum.map", "description": "Map `\u03b1 \u2295 \u03b2` to `\u03b1' \u2295 \u03b2'` sending `\u03b1` to `\u03b1'` and `\u03b2` to `\u03b2'`."}, {"name": "sum.elim_inl", "description": ""}, {"name": "sum.inl.inj_iff", "description": ""}, {"name": "sum.lift_rel_inr_inr", "description": ""}, {"name": "sum.get_right_eq_none_iff", "description": ""}, {"name": "sum.lex.mono", "description": ""}, {"name": "sum.lex_wf", "description": ""}, {"name": "sum.elim_comp_inl", "description": ""}, {"name": "sum.update_inl_comp_inl", "description": ""}, {"name": "sum.lift_rel.swap", "description": ""}, {"name": "sum3.in\u2080", "description": "The map from the first summand into a ternary sum."}, {"name": "sum.update_inl_apply_inr", "description": ""}, {"name": "sum.is_left", "description": "Check if a sum is `inl`."}, {"name": "sum.lex_inl_inl", "description": ""}, {"name": "sum.elim_comp_inr", "description": ""}, {"name": "sum.lex.decidable_rel", "description": ""}, {"name": "sum.inl_injective", "description": ""}, {"name": "sum.update_inr_apply_inr", "description": ""}, {"name": "sum.lex_acc_inl", "description": ""}, {"name": "sum.lift_rel_inl_inl", "description": ""}, {"name": "sum.lift_rel_subrelation_lex", "description": ""}, {"name": "sum.update_inl_comp_inr", "description": ""}, {"name": "sum.update_elim_inl", "description": ""}, {"name": "sum.map_map", "description": ""}, {"name": "sum.lex", "description": " Lexicographic order for sum. Sort all the `inl a` before the `inr b`, otherwise use the\nrespective order on `\u03b1` or `\u03b2`."}, {"name": "sum.lex.inl", "description": " Lexicographic order for sum. Sort all the `inl a` before the `inr b`, otherwise use the\nrespective order on `\u03b1` or `\u03b2`."}, {"name": "sum.lex.inr", "description": " Lexicographic order for sum. Sort all the `inl a` before the `inr b`, otherwise use the\nrespective order on `\u03b1` or `\u03b2`."}, {"name": "sum.lex.sep", "description": " Lexicographic order for sum. Sort all the `inl a` before the `inr b`, otherwise use the\nrespective order on `\u03b1` or `\u03b2`."}, {"name": "sum.inl_ne_inr", "description": ""}, {"name": "sum.lift_rel.lex", "description": ""}, {"name": "sum.lex_inr_inr", "description": ""}, {"name": "sum.lift_rel.mono_left", "description": ""}, {"name": "sum.lex.mono_left", "description": ""}, {"name": "sum.elim_inr", "description": ""}, {"name": "sum.lex.mono_right", "description": ""}, {"name": "sum.exists", "description": ""}, {"name": "sum.swap_swap_eq", "description": ""}, {"name": "sum.swap_swap", "description": ""}, {"name": "sum.swap_left_inverse", "description": ""}, {"name": "sum.lex_inr_inl", "description": ""}, {"name": "sum.forall", "description": ""}, {"name": "function.injective.sum_map", "description": ""}, {"name": "sum.lift_rel", "description": " Lifts pointwise two relations between `\u03b1` and `\u03b3` and between `\u03b2` and `\u03b4` to a relation between\n`\u03b1 \u2295 \u03b2` and `\u03b3 \u2295 \u03b4`."}, {"name": "sum.lift_rel.inl", "description": " Lifts pointwise two relations between `\u03b1` and `\u03b3` and between `\u03b2` and `\u03b4` to a relation between\n`\u03b1 \u2295 \u03b2` and `\u03b3 \u2295 \u03b4`."}, {"name": "sum.lift_rel.inr", "description": " Lifts pointwise two relations between `\u03b1` and `\u03b3` and between `\u03b2` and `\u03b4` to a relation between\n`\u03b1 \u2295 \u03b2` and `\u03b3 \u2295 \u03b4`."}, {"name": "sum.lift_rel.mono_right", "description": ""}, {"name": "sum.update_inl_apply_inl", "description": ""}, {"name": "sum.inr_ne_inl", "description": ""}, {"name": "sum3.in\u2081", "description": "The map from the second summand into a ternary sum."}, {"name": "sum.decidable_eq", "description": ""}, {"name": "sum.lift_rel_swap_iff", "description": ""}, {"name": "sum.elim_const_const", "description": ""}, {"name": "sum.elim_inl_inr", "description": ""}, {"name": "sum.lift_rel.mono", "description": ""}, {"name": "sum.lift_rel.decidable", "description": ""}, {"name": "sum.map_comp_map", "description": ""}, {"name": "sum.inr.inj_iff", "description": ""}, {"name": "sum3.in\u2082", "description": "The map from the third summand into a ternary sum."}, {"name": "sum.not_lift_rel_inr_inl", "description": ""}, {"name": "sum.update_inr_comp_inr", "description": ""}, {"name": "norm_num.le_bit1_bit0", "description": ""}, {"name": "norm_num.le_one_bit0", "description": ""}, {"name": "norm_num.lt_bit1_bit0", "description": ""}, {"name": "norm_num.rat_cast_bit1", "description": ""}, {"name": "norm_num.inv_one_div", "description": ""}, {"name": "norm_num.int_mod_neg", "description": ""}, {"name": "norm_num.eval_pow", "description": "Evaluates expressions of the form `a ^ b`, `monoid.npow a b` or `nat.pow a b`."}, {"name": "norm_num.int_div", "description": ""}, {"name": "norm_num.prove_succ'", "description": "Given `a` natural numeral, returns `(b, \u22a2 a + 1 = b)`."}, {"name": "norm_num.nat_succ_eq", "description": ""}, {"name": "norm_num.inv_neg", "description": ""}, {"name": "norm_num.neg_succ_of_nat", "description": ""}, {"name": "norm_num.rat_cast_neg", "description": ""}, {"name": "norm_num.lt_one_bit0", "description": ""}, {"name": "norm_num.rat_cast_bit0", "description": ""}, {"name": "norm_num.subst_into_mul", "description": ""}, {"name": "norm_num.int_cast_one", "description": ""}, {"name": "norm_num.prove_inv", "description": "Given `a` a rational numeral, returns `(b, \u22a2 a\u207b\u00b9 = b)`."}, {"name": "norm_num.sle_bit0_bit1", "description": ""}, {"name": "norm_num.prove_div", "description": "Given `a`,`b` rational numerals, returns `(c, \u22a2 a / b = c)`."}, {"name": "norm_num.sub_pos", "description": ""}, {"name": "norm_num.prove_clear_denom", "description": " Given `a` nonnegative rational and `d` a natural number, returns `(b, \u22a2 a * d = b)`.\n(`d` should be a multiple of the denominator of `a`, so that `b` is a natural number.)"}, {"name": "norm_num.div_eq", "description": ""}, {"name": "norm_num.eval_ineq", "description": "Evaluates the inequality operations `=`,`<`,`>`,`\u2264`,`\u2265`,`\u2260` on numerals."}, {"name": "tactic_doc.attribute.norm_num", "description": " An attribute for adding additional extensions to `norm_num`. To use this attribute, put\n`@[norm_num]` on a tactic of type `expr \u2192 tactic (expr \u00d7 expr)`; the tactic will be called on\nsubterms by `norm_num`, and it is responsible for identifying that the expression is a numerical\nfunction applied to numerals, for example `nat.fib 17`, and should return the reduced numerical\nexpression (which must be in `norm_num`-normal form: a natural or rational numeral, i.e. `37`,\n`12 / 7` or `-(2 / 3)`, although this can be an expression in any type), and the proof that the\noriginal expression is equal to the rewritten expression.\n\nFailure is used to indicate that this tactic does not apply to the term. For performance reasons,\nit is best to detect non-applicability as soon as possible so that the next tactic can have a go,\nso generally it will start with a pattern match and then checking that the arguments to the term\nare numerals or of the appropriate form, followed by proof construction, which should not fail.\n\nPropositions are treated like any other term. The normal form for propositions is `true` or\n`false`, so it should produce a proof of the form `p = true` or `p = false`. `eq_true_intro` can be\nused to help here."}, {"name": "norm_num.prove_rat_uncast_nat", "description": " Given `a' : \u03b1` a natural numeral, returns `(a : \u211a, \u22a2 \u2191a = a')`.\n(Note that the returned value is on the left of the equality.)"}, {"name": "norm_num.sub_nat_neg", "description": ""}, {"name": "norm_num.clear_denom_le", "description": ""}, {"name": "norm_num.zpow_pos", "description": ""}, {"name": "norm_num.nat_mod", "description": ""}, {"name": "norm_num.match_numeral_result", "description": " The result type of `match_numeral`, either `0`, `1`, or a top level\ndecomposition of `bit0 e` or `bit1 e`. The `other` case means it is not a numeral."}, {"name": "norm_num.match_numeral_result.zero", "description": " The result type of `match_numeral`, either `0`, `1`, or a top level\ndecomposition of `bit0 e` or `bit1 e`. The `other` case means it is not a numeral."}, {"name": "norm_num.match_numeral_result.one", "description": " The result type of `match_numeral`, either `0`, `1`, or a top level\ndecomposition of `bit0 e` or `bit1 e`. The `other` case means it is not a numeral."}, {"name": "norm_num.match_numeral_result.bit0", "description": " The result type of `match_numeral`, either `0`, `1`, or a top level\ndecomposition of `bit0 e` or `bit1 e`. The `other` case means it is not a numeral."}, {"name": "norm_num.match_numeral_result.bit1", "description": " The result type of `match_numeral`, either `0`, `1`, or a top level\ndecomposition of `bit0 e` or `bit1 e`. The `other` case means it is not a numeral."}, {"name": "norm_num.match_numeral_result.other", "description": " The result type of `match_numeral`, either `0`, `1`, or a top level\ndecomposition of `bit0 e` or `bit1 e`. The `other` case means it is not a numeral."}, {"name": "norm_num.adc_bit1_bit0", "description": ""}, {"name": "tactic.instance_cache.mk_bit1", "description": "Faster version of `mk_app ``bit1 [e]`."}, {"name": "norm_num.mul_neg_pos", "description": ""}, {"name": "norm_num.prove_sle_nat", "description": "Given `a`,`b` natural numerals, proves `\u22a2 a + 1 \u2264 b`."}, {"name": "norm_num.nat_cast_bit1", "description": ""}, {"name": "norm_num.zero_succ", "description": ""}, {"name": "norm_num.lt_bit1_bit1", "description": ""}, {"name": "tactic.interactive.norm_num", "description": " Normalize numerical expressions. Supports the operations\n`+` `-` `*` `/` `^` and `%` over numerical types such as\n`\u2115`, `\u2124`, `\u211a`, `\u211d`, `\u2102` and some general algebraic types,\nand can prove goals of the form `A = B`, `A \u2260 B`, `A < B` and `A \u2264 B`,\nwhere `A` and `B` are numerical expressions.\nIt also has a relatively simple primality prover."}, {"name": "norm_num.clear_denom_mul", "description": ""}, {"name": "norm_num.eval_field", "description": " Evaluates the basic field operations `+`,`neg`,`-`,`*`,`inv`,`/` on numerals.\nAlso handles nat subtraction. Does not do recursive simplification; that is,\n`1 + 1 + 1` will not simplify but `2 + 1` will. This is handled by the top level\n`simp` call in `norm_num.derive`."}, {"name": "norm_num.rat_cast_div", "description": ""}, {"name": "norm_num.clear_denom_lt", "description": ""}, {"name": "norm_num.prove_sub", "description": "Given `a`,`b` rational numerals, returns `(c, \u22a2 a - b = c)`."}, {"name": "norm_num.true_intro", "description": "Given `\u22a2 p`, returns `(true, \u22a2 p = true)`."}, {"name": "norm_num.ne_zero_of_pos", "description": ""}, {"name": "norm_num.prove_pos", "description": "Given `a` a rational numeral, returns `\u22a2 0 < a`."}, {"name": "norm_num.prove_nat_succ", "description": " Evaluates the expression `nat.succ ... (nat.succ n)` where `n` is a natural numeral.\n(We could also just handle `nat.succ n` here and rely on `simp` to work bottom up, but we figure\nthat towers of successors coming from e.g. `induction` are a common case.)"}, {"name": "norm_num.sle_one_bit0", "description": ""}, {"name": "norm_num.adc_bit0_bit0", "description": ""}, {"name": "norm_num.add_neg_pos_neg", "description": ""}, {"name": "norm_num.sub_neg", "description": ""}, {"name": "norm_num.zpow_neg", "description": ""}, {"name": "tactic.norm_num", "description": " Normalize numerical expressions. It uses the provided `step` tactic to simplify the expression;\nuse `get_step` to get the default `norm_num` set and `derive.step` for the basic builtin set of\nsimplifications."}, {"name": "norm_num.derive'", "description": "Simplify an expression bottom-up using `step` to simplify the subexpressions."}, {"name": "norm_num.nat_cast_bit0", "description": ""}, {"name": "norm_num.adc_bit1_one", "description": ""}, {"name": "norm_num.int_cast_neg", "description": ""}, {"name": "norm_num.sle_bit1_bit1", "description": ""}, {"name": "norm_num.prove_add_rat'", "description": "Given `a`,`b` rational numerals, returns `(c, \u22a2 a + b = c)`."}, {"name": "norm_num.lt_one_bit1", "description": ""}, {"name": "tactic.interactive.norm_num1", "description": "Basic version of `norm_num` that does not call `simp`."}, {"name": "norm_num.prove_mul_nat", "description": "Given `a`,`b` natural numerals, returns `(r, \u22a2 a * b = r)`."}, {"name": "norm_num.not_refl_false_intro", "description": ""}, {"name": "norm_num.nonneg_pos", "description": ""}, {"name": "norm_num.prove_le_rat", "description": "Given `a`,`b` rational numerals, proves `\u22a2 a \u2264 b`."}, {"name": "norm_num.lt_neg_pos", "description": ""}, {"name": "norm_num.subst_into_neg", "description": ""}, {"name": "norm_num.match_numeral", "description": "Unfold the top level constructor of the numeral expression."}, {"name": "norm_num.sle_bit0_bit0", "description": ""}, {"name": "norm_num.ne_zero_neg", "description": ""}, {"name": "norm_num.prove_clear_denom_simple", "description": " Given `a` a nonnegative rational numeral, returns `(b, c, \u22a2 a * b = c)`\nwhere `b` and `c` are natural numerals. (`b` will be the denominator of `a`.)"}, {"name": "conv.interactive.norm_num", "description": " Normalize numerical expressions. Supports the operations\n`+` `-` `*` `/` `^` and `%` over numerical types such as\n`\u2115`, `\u2124`, `\u211a`, `\u211d`, `\u2102` and some general algebraic types,\nand can prove goals of the form `A = B`, `A \u2260 B`, `A < B` and `A \u2264 B`,\nwhere `A` and `B` are numerical expressions.\nIt also has a relatively simple primality prover."}, {"name": "tactic.norm_num1", "description": " Basic version of `norm_num` that does not call `simp`. It uses the provided `step` tactic\nto simplify the expression; use `get_step` to get the default `norm_num` set and `derive.step` for\nthe basic builtin set of simplifications."}, {"name": "norm_num.prove_lt_rat", "description": "Given `a`,`b` rational numerals, proves `\u22a2 a < b`."}, {"name": "norm_num.one_succ", "description": ""}, {"name": "norm_num.prove_lt_nonneg_rat", "description": "Given `a`,`b` nonnegative rational numerals, proves `\u22a2 a < b`."}, {"name": "norm_num.get_step", "description": " Look up the `norm_num` extensions in the cache and return a tactic extending `derive.step` with\nadditional reduction procedures."}, {"name": "norm_num.prove_int_uncast_nat", "description": " Given `a' : \u03b1` a natural numeral, returns `(a : \u2124, \u22a2 \u2191a = a')`.\n(Note that the returned value is on the left of the equality.)"}, {"name": "tactic.instance_cache.mk_bit0", "description": "Faster version of `mk_app ``bit0 [e]`."}, {"name": "norm_num.prove_add_nat'", "description": "Given `a`,`b` natural numerals, returns `(r, \u22a2 a + b = r)`."}, {"name": "norm_num.mul_bit1_bit1", "description": ""}, {"name": "norm_num.nat_abs_neg", "description": ""}, {"name": "norm_num.pow_bit0", "description": ""}, {"name": "norm_num.add_bit1_bit1", "description": ""}, {"name": "norm_num.bit0_succ", "description": ""}, {"name": "norm_num.derive.step", "description": "This version of `derive` does not fail when the input is already a numeral"}, {"name": "norm_num.mul_bit0_bit0", "description": ""}, {"name": "norm_num.prove_nat_uncast", "description": " Given `a' : \u03b1` a natural numeral, returns `(a : \u2115, \u22a2 \u2191a = a')`.\n(Note that the returned value is on the left of the equality.)"}, {"name": "norm_num.inv_div_one", "description": ""}, {"name": "norm_num.prove_ne_zero", "description": "Given `a` a rational numeral, returns `\u22a2 a \u2260 0`."}, {"name": "norm_num.adc_bit1_bit1", "description": ""}, {"name": "norm_num.int_cast_ne", "description": ""}, {"name": "norm_num.prove_int_uncast", "description": " Given `a' : \u03b1` an integer numeral, returns `(a : \u2124, \u22a2 \u2191a = a')`.\n(Note that the returned value is on the left of the equality.)"}, {"name": "norm_num.add_neg_pos_pos", "description": ""}, {"name": "norm_num.le_neg_pos", "description": ""}, {"name": "norm_num.prove_clear_denom'", "description": " Given `a` nonnegative rational and `d` a natural number, returns `(b, \u22a2 a * d = b)`.\n(`d` should be a multiple of the denominator of `a`, so that `b` is a natural number.)"}, {"name": "tactic.norm_num_cmd", "description": "The basic usage is `#norm_num e`, where `e` is an expression,\nwhich will print the `norm_num` form of `e`.\n\nSyntax: `#norm_num` (`only`)? (`[` simp lemma list `]`)? (`with` simp sets)? `:`? expression\n\nThis accepts the same options as the `#simp` command.\nYou can specify additional simp lemmas as usual, for example using\n`#norm_num [f, g] : e`, or `#norm_num with attr : e`.\n(The colon is optional but helpful for the parser.)\nThe `only` restricts `norm_num` to using only the provided lemmas, and so\n`#norm_num only : e` behaves similarly to `norm_num1`.\n\nUnlike `norm_num`, this command does not fail when no simplifications are made.\n\n`#norm_num` understands local variables, so you can use them to\nintroduce parameters."}, {"name": "norm_num.prove_div_mod", "description": "Given `a`,`b` numerals in `nat` or `int`,\n * `prove_div_mod ic a b ff` returns `(c, \u22a2 a / b = c)`\n * `prove_div_mod ic a b tt` returns `(c, \u22a2 a % b = c)`"}, {"name": "norm_num.prove_zpow", "description": "Given `a` a rational numeral and `b : \u2124`, returns `(c, \u22a2 a ^ b = c)`."}, {"name": "norm_num.nat_div", "description": ""}, {"name": "tactic.interactive.apply_normed", "description": "Normalizes a numerical expression and tries to close the goal with the result."}, {"name": "norm_num.nat_cast_ne", "description": ""}, {"name": "norm_num.sle_one_bit1", "description": ""}, {"name": "norm_num.prove_ne_rat", "description": " Given `a`,`b` rational numerals, proves `\u22a2 a \u2260 b`. This version tries to prove\n`\u22a2 a < b` or `\u22a2 b < a`, and so is not appropriate for types without an order relation."}, {"name": "norm_num.sub_nat_pos", "description": ""}, {"name": "norm_num.derive", "description": " Simplify an expression bottom-up using the default `norm_num` set to simplify the\nsubexpressions."}, {"name": "norm_num.zero_adc", "description": ""}, {"name": "norm_num.le_bit0_bit1", "description": ""}, {"name": "norm_num.sle_bit1_bit0", "description": ""}, {"name": "norm_num.clear_denom_simple_div", "description": ""}, {"name": "norm_num.adc_one_one", "description": ""}, {"name": "norm_num.dvd_eq_nat", "description": ""}, {"name": "norm_num.bit0_mul", "description": ""}, {"name": "norm_num.subst_into_add", "description": ""}, {"name": "norm_num.le_bit1_bit1", "description": ""}, {"name": "norm_num.nat_cast_one", "description": ""}, {"name": "norm_num.prove_ne_zero'", "description": "Given `a` a rational numeral, returns `\u22a2 a \u2260 0`."}, {"name": "norm_num.pow_bit1", "description": ""}, {"name": "norm_num.lt_bit0_bit0", "description": ""}, {"name": "norm_num.inv_div", "description": ""}, {"name": "norm_num.int_to_nat_neg", "description": ""}, {"name": "norm_num.eval_nat_int_ext", "description": " Evaluates some extra numeric operations on `nat` and `int`, specifically\n`nat.succ`, `/` and `%`, and `\u2223` (divisibility)."}, {"name": "norm_num.prove_pos_nat", "description": "Given `a` a positive natural numeral, returns `\u22a2 0 < a`."}, {"name": "norm_num.adc_bit0_one", "description": ""}, {"name": "norm_num.prove_rat_uncast", "description": " Given `a' : \u03b1` a rational numeral, returns `(a : \u211a, \u22a2 \u2191a = a')`.\n(Note that the returned value is on the left of the equality.)"}, {"name": "norm_num.prove_pow", "description": "Given `a` a rational numeral and `b : nat`, returns `(c, \u22a2 a ^ b = c)`."}, {"name": "norm_num.add_bit0_bit0", "description": ""}, {"name": "norm_num.int_to_nat_cast", "description": ""}, {"name": "norm_num.mul_bit0'", "description": ""}, {"name": "norm_num.le_bit0_bit0", "description": ""}, {"name": "norm_num.prove_ne", "description": " Given `a`,`b` rational numerals, proves `\u22a2 a \u2260 b`. Currently it tries two methods:\n\n  * Prove `\u22a2 a < b` or `\u22a2 b < a`, if the base type has an order\n  * Embed `\u2191(a':\u211a) = a` and `\u2191(b':\u211a) = b`, and then prove `a' \u2260 b'`.\n    This requires that the base type be `char_zero`, and also that it be a `division_ring`\n    so that the coercion from `\u211a` is well defined.\n\nWe may also add coercions to `\u2124` and `\u2115` as well in order to support `char_zero`\nrings and semirings."}, {"name": "norm_num.one_add", "description": ""}, {"name": "norm_num.adc_one_bit0", "description": ""}, {"name": "norm_num.ge_intro", "description": ""}, {"name": "norm_num.adc_bit0_bit1", "description": ""}, {"name": "norm_num.prove_nonneg", "description": "Given `a` a rational numeral, returns `\u22a2 0 \u2264 a`."}, {"name": "norm_num.mul_neg_neg", "description": ""}, {"name": "norm_num.prove_mul_rat", "description": "Given `a`,`b` rational numerals, returns `(c, \u22a2 a * b = c)`."}, {"name": "norm_num.add_pos_neg_pos", "description": ""}, {"name": "norm_num.int_mod", "description": ""}, {"name": "norm_num.prove_mul_nonneg_rat", "description": "Given `a`,`b` nonnegative rational numerals, returns `(c, \u22a2 a * b = c)`."}, {"name": "expr.norm_num", "description": " Carry out similar operations as `tactic.norm_num` but on an `expr` rather than a location.\nGiven an expression `e`, returns `(e', \u22a2 e = e')`.\nThe `no_dflt`, `hs`, and `attr_names` are passed on to `simp`.\nUnlike `norm_num`, this tactic does not fail."}, {"name": "norm_num.nat_abs_pos", "description": ""}, {"name": "norm_num.prove_add_nat", "description": "Given `a`,`b`,`r` natural numerals, proves `\u22a2 a + b = r`."}, {"name": "norm_num.match_sign", "description": "`match_sign (- e) = inl e`, `match_sign 0 = inr ff`, otherwise `inr tt`"}, {"name": "norm_num.prove_neg", "description": "Given `a` a rational numeral, returns `(b, \u22a2 -a = b)`."}, {"name": "norm_num.prove_add_rat", "description": "Given `a`,`b`,`c` rational numerals, returns `\u22a2 a + b = c`."}, {"name": "norm_num.add_pos_neg_neg", "description": ""}, {"name": "tactic_doc.tactic.norm_num", "description": "Normalises numerical expressions. It supports the operations `+` `-` `*` `/` `^` and `%` over\nnumerical types such as `\u2115`, `\u2124`, `\u211a`, `\u211d`, `\u2102`, and can prove goals of the form `A = B`, `A \u2260 B`,\n`A < B` and `A \u2264 B`, where `A` and `B` are numerical expressions.\n\nAdd-on tactics marked as `@[norm_num]` can extend the behavior of `norm_num` to include other\nfunctions. This is used to support several other functions on `nat` like `prime`, `min_fac` and\n`factors`.\n```lean\nimport data.real.basic\n\nexample : (2 : \u211d) + 2 = 4 := by norm_num\nexample : (12345.2 : \u211d) \u2260 12345.3 := by norm_num\nexample : (73 : \u211d) < 789/2 := by norm_num\nexample : 123456789 + 987654321 = 1111111110 := by norm_num\nexample (R : Type*) [ring R] : (2 : R) + 2 = 4 := by norm_num\nexample (F : Type*) [linear_ordered_field F] : (2 : F) + 2 < 5 := by norm_num\nexample : nat.prime (2^13 - 1) := by norm_num\nexample : \u00ac nat.prime (2^11 - 1) := by norm_num\nexample (x : \u211d) (h : x = 123 + 456) : x = 579 := by norm_num at h; assumption\n```\n\nThe variant `norm_num1` does not call `simp`.\n\nBoth `norm_num` and `norm_num1` can be called inside the `conv` tactic.\n\nThe tactic `apply_normed` normalises a numerical expression and tries to close the goal with\nthe result. Compare:\n```lean\ndef a : \u2115 := 2^100\n#print a -- 2 ^ 100\n\ndef normed_a : \u2115 := by apply_normed 2^100\n#print normed_a -- 1267650600228229401496703205376\n```"}, {"name": "norm_num.prove_one_le_nat", "description": "Given `a` a rational numeral, returns `\u22a2 1 \u2264 a`."}, {"name": "norm_num.prove_lt_nat", "description": "Given `a`,`b` natural numerals, proves `\u22a2 a < b`."}, {"name": "norm_num.gt_intro", "description": ""}, {"name": "norm_num.add_neg_neg", "description": ""}, {"name": "norm_num.lt_bit0_bit1", "description": ""}, {"name": "norm_num.prove_succ", "description": " Given `a`, `b` natural numerals, proves `\u22a2 a + 1 = b`, assuming that this is provable.\n(It may prove garbage instead of failing if `a + 1 = b` is false.)"}, {"name": "norm_num.rat_cast_ne", "description": ""}, {"name": "norm_num.int_cast_bit0", "description": ""}, {"name": "norm_num.match_neg", "description": "`match_neg (- e) = some e`, otherwise `none`"}, {"name": "norm_num.clear_denom_div", "description": ""}, {"name": "norm_num.prove_le_nonneg_rat", "description": "Given `a`,`b` nonnegative rational numerals, proves `\u22a2 a \u2264 b`."}, {"name": "norm_num.bit1_succ", "description": ""}, {"name": "norm_num.attr", "description": " An attribute for adding additional extensions to `norm_num`. To use this attribute, put\n`@[norm_num]` on a tactic of type `expr \u2192 tactic (expr \u00d7 expr)`; the tactic will be called on\nsubterms by `norm_num`, and it is responsible for identifying that the expression is a numerical\nfunction applied to numerals, for example `nat.fib 17`, and should return the reduced numerical\nexpression (which must be in `norm_num`-normal form: a natural or rational numeral, i.e. `37`,\n`12 / 7` or `-(2 / 3)`, although this can be an expression in any type), and the proof that the\noriginal expression is equal to the rewritten expression.\n\nFailure is used to indicate that this tactic does not apply to the term. For performance reasons,\nit is best to detect non-applicability as soon as possible so that the next tactic can have a go,\nso generally it will start with a pattern match and then checking that the arguments to the term\nare numerals or of the appropriate form, followed by proof construction, which should not fail.\n\nPropositions are treated like any other term. The normal form for propositions is `true` or\n`false`, so it should produce a proof of the form `p = true` or `p = false`. `eq_true_intro` can be\nused to help here."}, {"name": "norm_num.mul_pos_neg", "description": ""}, {"name": "norm_num.int_cast_zero", "description": ""}, {"name": "norm_num.add_bit1_bit0", "description": ""}, {"name": "norm_num.int_cast_bit1", "description": ""}, {"name": "norm_num.clear_denom_simple_nat", "description": ""}, {"name": "conv.interactive.norm_num1", "description": "Basic version of `norm_num` that does not call `simp`."}, {"name": "norm_num.int_to_nat_pos", "description": ""}, {"name": "norm_num.inv_one", "description": ""}, {"name": "norm_num.int_div_neg", "description": ""}, {"name": "norm_num.prove_sub_nat", "description": "Given `a : nat`,`b : nat` natural numerals, returns `(c, \u22a2 a - b = c)`."}, {"name": "norm_num.eval_cast", "description": "Evaluates the `\u2191n` cast operation from `\u2115`, `\u2124`, `\u211a` to an arbitrary type `\u03b1`."}, {"name": "norm_num.prove_le_nat", "description": "Given `a`,`b` natural numerals, proves `\u22a2 a \u2264 b`."}, {"name": "norm_num.false_intro", "description": "Given `\u22a2 \u00ac p`, returns `(false, \u22a2 p = false)`."}, {"name": "norm_num.prove_adc_nat", "description": "Given `a`,`b`,`r` natural numerals, proves `\u22a2 a + b + 1 = r`."}, {"name": "norm_num.adc_one_bit1", "description": ""}, {"name": "norm_num.adc_zero", "description": ""}, {"name": "norm_num.add_bit0_bit1", "description": ""}, {"name": "norm_num.prove_rat_uncast_nonneg", "description": " Given `a' : \u03b1` a nonnegative rational numeral, returns `(a : \u211a, \u22a2 \u2191a = a')`.\n(Note that the returned value is on the left of the equality.)"}, {"name": "norm_num.nat_cast_zero", "description": ""}, {"name": "norm_num.prove_add_nonneg_rat", "description": "Given `a`,`b`,`c` nonnegative rational numerals, returns `\u22a2 a + b = c`."}, {"name": "norm_num.le_one_bit1", "description": ""}, {"name": "norm_num.dvd_eq_int", "description": ""}, {"name": "tactic_doc.command.#norm_num", "description": "The basic usage is `#norm_num e`, where `e` is an expression,\nwhich will print the `norm_num` form of `e`.\n\nSyntax: `#norm_num` (`only`)? (`[` simp lemma list `]`)? (`with` simp sets)? `:`? expression\n\nThis accepts the same options as the `#simp` command.\nYou can specify additional simp lemmas as usual, for example using\n`#norm_num [f, g] : e`, or `#norm_num with attr : e`.\n(The colon is optional but helpful for the parser.)\nThe `only` restricts `norm_num` to using only the provided lemmas, and so\n`#norm_num only : e` behaves similarly to `norm_num1`.\n\nUnlike `norm_num`, this command does not fail when no simplifications are made.\n\n`#norm_num` understands local variables, so you can use them to\nintroduce parameters."}, {"name": "norm_num.clear_denom_add", "description": ""}, {"name": "quarterround.qr1_difference_is_carried", "description": "`qr1` difference is carried when fed with crafted data."}, {"name": "quarterround.qr1_is_inv", "description": "Inverse of `qr1` given the sequence `a, b, c, d` is `b`."}, {"name": "quarterround.qr1_is_left_invariant'", "description": "`qr1` of `-a, a, -a, a` is `a`."}, {"name": "quarterround.isomorphism_left", "description": "Isomorphism condition 1 : `f \u2218 g = id_f`"}, {"name": "quarterround.qr1_zero", "description": "`qr1` of 4 zeros is zero"}, {"name": "quarterround.qr3_inv_is_inv", "description": "Inverse of `qr3_inv` given the sequence `a, b, c, d` is `d`."}, {"name": "quarterround.rest_of_one_append", "description": " The rest of the bitvector where 1 gets appended with the tail of the bitvector is the tail of the bitvector.\n\n### TODO:\n\nshould be easy to prove ?"}, {"name": "quarterround.qr3_is_left_invariant'", "description": "`qr3` of `-a, a, -a, a` is `a`."}, {"name": "quarterround.qrX_after_quarterround_difference_is_carried", "description": "Proves that any `qrX` applied after `quarterrround` carries the difference."}, {"name": "quarterround.quarterround_is_invertible", "description": "The quarterround operation is fully invertible."}, {"name": "quarterround.id_quarterround", "description": "The identity of a `quarterround` function given a sequence is the sequence."}, {"name": "quarterround.qr2_difference_is_carried", "description": "`qr2` difference is carried when fed with crafted data."}, {"name": "quarterround.qr3_difference_is_carried", "description": "`qr3` difference is carried when fed with crafted data."}, {"name": "quarterround.quarterround_is_left_invariant'", "description": "The full `quarterround` function produces `-a, a, -a, a` when fed with `-a, a, -a, a`"}, {"name": "quarterround.id_quarterround_inv", "description": "The identity of a `quarterround_inv` function given a sequence is the sequence."}, {"name": "quarterround.qr3_inv", "description": "y\u2083 = z\u2083 \u2295 ((z\u2082 + z\u2081) <<< 13)"}, {"name": "quarterround.qr2_inv_is_inv", "description": "Inverse of `qr2_inv` given the sequence `a, b, c, d` is `c`."}, {"name": "quarterround.qr1_inv_is_inv", "description": "Inverse of `qr1_inv` given the sequence `a, b, c, d` is `b`."}, {"name": "quarterround.qr2", "description": "z\u2082 = y\u2082 \u2295 ((z\u2081 + y\u2080) <<< 9)"}, {"name": "quarterround.isomorphism_right", "description": "Isomorphism condition 2 : `g \u2218 f = id_g`"}, {"name": "quarterround.qr2_inv", "description": "y\u2082 = z\u2082 \u2295 ((z\u2081 + y\u2080) <<< 9)"}, {"name": "quarterround.quarterround_is_left_invariant", "description": "The full `quarterround` function produces `a, -a, a, -a` when fed with `a, -a, a, -a`"}, {"name": "quarterround.quarterroundType", "description": "Represents a `quarterround` or `quarterround_inv` where building block operations are\nfields of the structure."}, {"name": "quarterround.quarterroundType.qr1", "description": "Represents a `quarterround` or `quarterround_inv` where building block operations are\nfields of the structure."}, {"name": "quarterround.quarterroundType.qr2", "description": "Represents a `quarterround` or `quarterround_inv` where building block operations are\nfields of the structure."}, {"name": "quarterround.quarterroundType.qr3", "description": "Represents a `quarterround` or `quarterround_inv` where building block operations are\nfields of the structure."}, {"name": "quarterround.quarterroundType.qr0", "description": "Represents a `quarterround` or `quarterround_inv` where building block operations are\nfields of the structure."}, {"name": "quarterround.qr0_is_left_invariant'", "description": "`qr0` of `-a, a, -a, a` is `-a`."}, {"name": "quarterround.qr1", "description": "z\u2081 = y\u2081 \u2295 ((y\u2080 + y\u2083) <<< 7)"}, {"name": "quarterround.qr0_inv_is_inv", "description": "Inverse of `qr0_inv` given the sequence `a, b, c, d` is `a`."}, {"name": "quarterround.quarterround_inv", "description": "Puts the 4 elements that forms a quarterround inverse all together."}, {"name": "quarterround.qr2_zero", "description": "`qr2` of 4 zeros is zero"}, {"name": "quarterround.qr0_inv", "description": "y\u2080 = z\u2080 \u2295 ((z\u2083 + z\u2082) <<< 18)"}, {"name": "quarterround.inverse_exists", "description": "Inverse of quarterround exists."}, {"name": "quarterround.qr3", "description": "z\u2083 = y\u2083 \u2295 ((z\u2082 + z\u2081) <<< 13)"}, {"name": "quarterround.qr_inv_is_inverse_of_qr", "description": "It is easy to see that `cat_quarterround\u207b\u00b9` after `cat_quarterround` produces the original object."}, {"name": "quarterround.msb_of_one_append", "description": "The head (msb) of anything that starts with a 1 and then stuff is appended should be always 1.\n\n### TODO:\n\nShould be easy to prove ?"}, {"name": "quarterround.qr0_is_inv", "description": "Inverse of `qr0` given the sequence `a, b, c, d` is `a`."}, {"name": "quarterround.qr0_is_left_invariant", "description": "`qr0` of `a, -a, a, -a` is `a`."}, {"name": "quarterround.qr1_is_left_invariant", "description": "`qr1` of `a, -a, a, -a` is `-a`."}, {"name": "quarterround.rest", "description": "a shortcut for a vector tail."}, {"name": "quarterround.qr3_is_left_invariant", "description": "`qr3` of `a, -a, a, -a` is `-a`."}, {"name": "quarterround.qr2_is_left_invariant", "description": "`qr2` of `a, -a, a, -a` is `a`."}, {"name": "quarterround.cat_quarterround_inv", "description": "`cat_quarterround_inv` is an instance of `quarterroundType`"}, {"name": "quarterround.qr2_is_left_invariant'", "description": "`qr2` of `-a, a, -a, a` is `-a`."}, {"name": "quarterround.qr0_difference_is_carried", "description": "`qr0` difference is carried when fed with crafted data."}, {"name": "quarterround.quarterround", "description": " Given a sequence of 4 numbers `seq`, use the four equations above to get the quarterround\noutput, which is a 4 numbers sequence too."}, {"name": "quarterround.craft", "description": "Define that x xor 2\u00b3\u00b9 = flip msb bit only, leave the rest as is.\n\n### TODO:\n\nThis could be proved."}, {"name": "quarterround.craft_distrib", "description": "Distributive property of `craft`"}, {"name": "quarterround.qr0_zero", "description": "`qr0` of 4 zeros is zero"}, {"name": "quarterround.quarterround_difference_is_carried", "description": "Full `quarterround` carries the difference when fed with crafted data."}, {"name": "quarterround.qr3_is_inv", "description": "Inverse of `qr3` given the sequence `a, b, c, d` is `d`."}, {"name": "quarterround.qr3_zero", "description": "`qr3` of 4 zeros is zero"}, {"name": "quarterround.qr1_inv", "description": "y\u2081 = z\u2081 \u2295 ((y\u2080 + y\u2083) <<< 7)"}, {"name": "quarterround.qrX_crafted", "description": "Assumes that any qrX function that is feeded with crafted numbers will result in a head of 1\nand the rest or tail equal to the tail of the uncrafted number.\n\n### TODO:\n\nThis needs to be proved."}, {"name": "quarterround.h_msb", "description": "Lets suppose the msb of any uncrafted bitvec that we will send to quarterround is always `ff`.\n\n### TODO:\n\nThis does not need to be the case, everything should work in a very similar way if the head is 1\nas it will gets flipped to 0 but we do this for simplicity by now.\nBasically by restricting the msb to be 0 we are saying that the number is smaller than 2^31."}, {"name": "quarterround.qrX_difference_is_carried", "description": "For any individual qrX function, when feeded with crafted data the difference is carried."}, {"name": "quarterround.msb", "description": "a shortcut to a vector head."}, {"name": "quarterround.qr2_is_inv", "description": "Inverse of `qr2` given the sequence `a, b, c, d` is `c`."}, {"name": "quarterround.quarterround_zero", "description": "`quarterround` of 4 zeros is a sequence of 4 zeros"}, {"name": "quarterround.qr0", "description": "z\u2080 = y\u2080 \u2295 ((z\u2083 + z\u2082) <<< 18)"}, {"name": "quarterround.quarterround_is_isomorphic", "description": "Two categories are isomrphic if `f \u2218 g = id_f` and `g \u2218 f = id_g`."}, {"name": "quarterround.cat_quarterround", "description": "`cat_quarterround` is an instance of `quarterroundType`"}, {"name": "widget_override.filter_local", "description": "Filters a local constant using the given filter."}, {"name": "widget_override.tactic_render", "description": "Renders the current tactic state."}, {"name": "widget_override.group_local_collection", "description": "Groups consecutive local collections by type"}, {"name": "widget_override.interactive_expression.view", "description": "Renders a subexpression as a list of html elements."}, {"name": "widget_override.interactive_expression.sf.flatten", "description": "Flattens an `sf`, i.e. merges adjacent `of_string` constructors."}, {"name": "widget_override.interactive_expression.sf.has_to_format", "description": ""}, {"name": "widget_override.local_collection", "description": "A group of local constants in the context that should be rendered as one line."}, {"name": "widget_override.local_collection.key", "description": "A group of local constants in the context that should be rendered as one line."}, {"name": "widget_override.local_collection.locals", "description": "A group of local constants in the context that should be rendered as one line."}, {"name": "widget_override.local_collection.type", "description": "A group of local constants in the context that should be rendered as one line."}, {"name": "widget_override.local_collection.value", "description": "A group of local constants in the context that should be rendered as one line."}, {"name": "widget_override.interactive_expression.sf.elim_part_apps", "description": "Post-process an `sf` object to eliminate tags for partial applications by\npushing the `app_fn` as far into the expression as possible. The effect is\nthat clicking on a sub-expression always includes the full argument list in\nthe popup.\n\nConsider the expression `id id 0`. We push the `app_fn` for the partial\napplication `id id` inwards and eliminate it.  Before:\n```lean\n(tag_expr [app_fn]\n  `(id.{1} (nat -> nat) (id.{1} nat))\n  (tag_expr [app_fn] `(id.{1} (nat -> nat)) \"id\")\n  \"\\n\"\n  (tag_expr [app_arg] `(id.{1} nat) \"id\"))\n\"\\n\"\n(tag_expr [app_arg] `(has_zero.zero.{0} nat nat.has_zero) \"0\")\n```\nAfter:\n```lean\n\"id\"\n\"\\n\"\n(tag_expr [app_fn, app_arg] `(id.{1} nat) \"id\")\n\"\\n\"\n(tag_expr [app_arg] `(has_zero.zero.{0} nat nat.has_zero) \"0\")\n```"}, {"name": "widget_override.tactic_state_widget", "description": "Component showing the current tactic state."}, {"name": "widget_override.interactive_expression.sf", "description": "eformat but without any of the formatting stuff like highlighting, groups etc."}, {"name": "widget_override.interactive_expression.sf.tag_expr", "description": "eformat but without any of the formatting stuff like highlighting, groups etc."}, {"name": "widget_override.interactive_expression.sf.compose", "description": "eformat but without any of the formatting stuff like highlighting, groups etc."}, {"name": "widget_override.interactive_expression.sf.of_string", "description": "eformat but without any of the formatting stuff like highlighting, groups etc."}, {"name": "widget_override.interactive_expression.sf.highlight", "description": "eformat but without any of the formatting stuff like highlighting, groups etc."}, {"name": "widget_override.interactive_expression.sf.block", "description": "eformat but without any of the formatting stuff like highlighting, groups etc."}, {"name": "widget_override.filter_component", "description": "Component for the filter dropdown."}, {"name": "widget_override.term_goal_widget", "description": "Widget used to display term-proof goals."}, {"name": "widget_override.interactive_expression.type_tooltip", "description": "Component for the type tooltip."}, {"name": "widget_override.interactive_expression.implicit_arg_list", "description": "Render the implicit arguments for an expression in fancy, little pills."}, {"name": "widget_override.show_type_component", "description": "Component that shows a type."}, {"name": "widget_override.local_collection.decidable_eq", "description": ""}, {"name": "widget_override.show_local_collection_component", "description": "Component showing a local collection."}, {"name": "widget_override.interactive_expression.sf.has_to_string", "description": ""}, {"name": "widget_override.filter_type", "description": "Supported tactic state filters."}, {"name": "widget_override.filter_type.none", "description": "Supported tactic state filters."}, {"name": "widget_override.filter_type.no_instances", "description": "Supported tactic state filters."}, {"name": "widget_override.filter_type.only_props", "description": "Supported tactic state filters."}, {"name": "widget_override.tactic_view_goal", "description": "Component that displays the main (first) goal."}, {"name": "widget_override.tactic_view_action", "description": "Actions accepted by the `tactic_view_component`."}, {"name": "widget_override.tactic_view_action.out", "description": "Actions accepted by the `tactic_view_component`."}, {"name": "widget_override.tactic_view_action.filter", "description": "Actions accepted by the `tactic_view_component`."}, {"name": "widget_override.html.of_name", "description": "Converts a name into an html element."}, {"name": "widget_override.interactive_expression.sf.has_repr", "description": ""}, {"name": "widget_override.tactic_view_term_goal", "description": "Component that displays the term-mode goal."}, {"name": "widget_override.interactive_expression.mk", "description": "Make an interactive expression."}, {"name": "widget_override.interactive_expression.goto_def_button", "description": "Render a 'go to definition' button for a given expression.\nIf there is no definition available, then returns an empty list."}, {"name": "widget_override.interactive_expression.get_block_attrs", "description": " Due to a bug in the webview browser, we have to reduce the number of spans in the expression.\nTo do this, we collect the attributes from `sf.block` and `sf.highlight` after an expression\nboundary."}, {"name": "widget_override.goals_accomplished_message", "description": "The \"goals accomplished \ud83c\udf89\" HTML widget. This can be overridden using:\n```lean\nmeta def my_new_msg {\u03b1 : Type} : widget.html \u03b1 := \"my message\"\nattribute [vm_override my_new_msg] widget_override.goals_accomplished_message\n```"}, {"name": "widget_override.interactive_expression.expr.address.has_mem", "description": ""}, {"name": "widget_override.to_local_collection", "description": "Converts a single local constant into a (singleton) `local_collection`"}, {"name": "widget_override.interactive_expression.sf.of_eformat", "description": "Constructs an `sf` from an `eformat` by forgetting grouping, nesting, etc."}, {"name": "widget_override.filter_type.decidable_eq", "description": ""}, {"name": "widget_override.interactive_expression.sf.repr", "description": "Prints a debugging representation of an `sf` object."}, {"name": "widget_override.tactic_view_component", "description": "Component that displays all goals, together with the `$n goals` message."}, {"name": "widget_override.interactive_expression.action", "description": "The actions accepted by an expression widget."}, {"name": "widget_override.interactive_expression.action.on_mouse_enter", "description": "The actions accepted by an expression widget."}, {"name": "widget_override.interactive_expression.action.on_mouse_leave_all", "description": "The actions accepted by an expression widget."}, {"name": "widget_override.interactive_expression.action.on_click", "description": "The actions accepted by an expression widget."}, {"name": "widget_override.interactive_expression.action.on_tooltip_action", "description": "The actions accepted by an expression widget."}, {"name": "widget_override.interactive_expression.action.on_close_tooltip", "description": "The actions accepted by an expression widget."}, {"name": "widget_override.interactive_expression.action.effect", "description": "The actions accepted by an expression widget."}, {"name": "unsigned_sz", "description": ""}, {"name": "unsigned", "description": ""}, {"name": "unsigned.decidable_eq", "description": ""}, {"name": "unsigned.to_nat", "description": ""}, {"name": "unsigned.of_nat'", "description": ""}, {"name": "equiv.of_injective_apply", "description": ""}, {"name": "equiv.set.sum_diff_subset_apply_inr", "description": ""}, {"name": "equiv.set.univ_pi", "description": "The set `set.pi set.univ s` is equivalent to `\u03a0 a, s a`."}, {"name": "equiv.set_prod_equiv_sigma", "description": "A set `s` in `\u03b1 \u00d7 \u03b2` is equivalent to the sigma-type `\u03a3 x, {y | (x, y) \u2208 s}`."}, {"name": "equiv.of_injective", "description": "If `f : \u03b1 \u2192 \u03b2` is an injective function, then domain `\u03b1` is equivalent to the range of `f`."}, {"name": "equiv.set.sum_diff_subset_symm_apply_of_mem", "description": ""}, {"name": "equiv.set.congr_apply", "description": ""}, {"name": "equiv.range_eq_univ", "description": ""}, {"name": "equiv.subset_image", "description": ""}, {"name": "equiv.set.of_eq_apply", "description": ""}, {"name": "equiv.of_preimage_equiv", "description": "A family of equivalences between preimages of points gives an equivalence between domains."}, {"name": "equiv.set.univ_pi_apply_coe", "description": ""}, {"name": "equiv.of_left_inverse_eq_of_injective", "description": ""}, {"name": "equiv.set.sum_compl_apply_inl", "description": ""}, {"name": "equiv.preimage_pi_equiv_pi_subtype_prod_symm_pi", "description": ""}, {"name": "equiv.set.insert_apply_right", "description": ""}, {"name": "equiv.set.union_sum_inter", "description": " If `s` is a set with decidable membership, then the sum of `s \u222a t` and `s \u2229 t` is equivalent\nto `s \u2295 t`."}, {"name": "equiv.set.insert", "description": "If `a \u2209 s`, then `insert a s` is equivalent to `s \u2295 punit`."}, {"name": "equiv.sigma_preimage_equiv_symm_apply_fst", "description": ""}, {"name": "equiv.set.sum_compl_symm_apply_compl", "description": ""}, {"name": "equiv.image_eq_iff_eq", "description": ""}, {"name": "equiv.set.union'", "description": " If sets `s` and `t` are separated by a decidable predicate, then `s \u222a t` is equivalent to\n`s \u2295 t`."}, {"name": "equiv.eq_preimage_iff_image_eq", "description": ""}, {"name": "equiv.set.empty", "description": "An empty set is equivalent to the `empty` type."}, {"name": "equiv.image_compl", "description": ""}, {"name": "equiv.set.image_symm_preimage", "description": ""}, {"name": "equiv.set.sum_compl_symm_apply_of_not_mem", "description": ""}, {"name": "equiv.symm_preimage_preimage", "description": ""}, {"name": "equiv.of_left_inverse_symm_apply", "description": ""}, {"name": "equiv.self_comp_of_injective_symm", "description": ""}, {"name": "equiv.of_preimage_equiv_apply", "description": ""}, {"name": "equiv.image_apply_coe", "description": ""}, {"name": "equiv.set.image_of_inj_on", "description": "If a function `f` is injective on a set `s`, then `s` is equivalent to `f '' s`."}, {"name": "equiv.set.congr", "description": "If `\u03b1` is equivalent to `\u03b2`, then `set \u03b1` is equivalent to `set \u03b2`."}, {"name": "set.image_equiv_eq_preimage_symm", "description": "Alias for `equiv.image_eq_preimage`"}, {"name": "equiv.set.powerset", "description": "The set `\ud835\udcab S := {x | x \u2286 S}` is equivalent to the type `set S`."}, {"name": "equiv.set.insert_symm_apply_inr", "description": ""}, {"name": "equiv.set.singleton", "description": "A singleton set is equivalent to a `punit` type."}, {"name": "equiv.of_injective_symm_apply", "description": ""}, {"name": "equiv.set.congr_symm_apply", "description": ""}, {"name": "equiv.of_preimage_equiv_symm_apply", "description": ""}, {"name": "equiv.sigma_preimage_equiv", "description": " `sigma_fiber_equiv f` for `f : \u03b1 \u2192 \u03b2` is the natural equivalence between\nthe type of all preimages of points under `f` and the total space `\u03b1`."}, {"name": "equiv.image_subset", "description": ""}, {"name": "equiv.set.range_splitting_image_equiv_symm_apply_coe", "description": ""}, {"name": "equiv.of_left_inverse'_eq_of_injective", "description": ""}, {"name": "equiv.set.image", "description": "If `f` is an injective function, then `s` is equivalent to `f '' s`."}, {"name": "equiv.set.range_splitting_image_equiv", "description": "If `s` is a set in `range f`,\nthen its image under `range_splitting f` is in bijection (via `f`) with `s`."}, {"name": "equiv.of_preimage_equiv_map", "description": ""}, {"name": "equiv.set.insert_apply_left", "description": ""}, {"name": "equiv.preimage_eq_iff_eq_image", "description": ""}, {"name": "equiv.set.pempty", "description": "An empty set is equivalent to a `pempty` type."}, {"name": "dite_comp_equiv_update", "description": " The composition of an updated function with an equiv on a subset can be expressed as an\nupdated function."}, {"name": "equiv.set.union_symm_apply_right", "description": ""}, {"name": "equiv.image", "description": "A set is equivalent to its image under an equivalence."}, {"name": "equiv.prod_assoc_image", "description": ""}, {"name": "set.bij_on.equiv", "description": " If a function is a bijection between two sets `s` and `t`, then it induces an\nequivalence between the types `\u21a5s` and `\u21a5t`."}, {"name": "equiv.set.image_symm_apply", "description": ""}, {"name": "equiv.prod_comm_image", "description": ""}, {"name": "equiv.set.univ_symm_apply", "description": ""}, {"name": "equiv.symm_image_image", "description": ""}, {"name": "equiv.set.prod", "description": "The set product of two sets is equivalent to the type product of their coercions to types."}, {"name": "equiv.set.univ", "description": "`univ \u03b1` is equivalent to `\u03b1`."}, {"name": "equiv.sigma_preimage_equiv_apply", "description": ""}, {"name": "equiv.apply_of_injective_symm", "description": ""}, {"name": "equiv.of_left_inverse", "description": " If `f : \u03b1 \u2192 \u03b2` has a left-inverse when `\u03b1` is nonempty, then `\u03b1` is computably equivalent to the\nrange of `f`.\n\nWhile awkward, the `nonempty \u03b1` hypothesis on `f_inv` and `hf` allows this to be used when `\u03b1` is\nempty too. This hypothesis is absent on analogous definitions on stronger `equiv`s like\n`linear_equiv.of_left_inverse` and `ring_equiv.of_left_inverse` as their typeclass assumptions\nare already sufficient to ensure non-emptiness."}, {"name": "equiv.prod_comm_preimage", "description": ""}, {"name": "equiv.preimage_symm_preimage", "description": ""}, {"name": "equiv.set.range_splitting_image_equiv_apply_coe_coe", "description": ""}, {"name": "equiv.set.sum_diff_subset_apply_inl", "description": ""}, {"name": "equiv.set.sum_compl_symm_apply_of_mem", "description": ""}, {"name": "equiv.set.univ_pi_symm_apply_coe", "description": ""}, {"name": "equiv.preimage_image", "description": ""}, {"name": "equiv.set.union_symm_apply_left", "description": ""}, {"name": "equiv.eq_image_iff_symm_image_eq", "description": ""}, {"name": "equiv.prod_assoc_symm_image", "description": ""}, {"name": "equiv.set.union_apply_right", "description": ""}, {"name": "equiv.image_symm_apply_coe", "description": ""}, {"name": "equiv.set.sum_diff_subset_symm_apply_of_not_mem", "description": ""}, {"name": "equiv.image_symm_image", "description": ""}, {"name": "equiv.set_congr", "description": "The subtypes corresponding to equal sets are equivalent."}, {"name": "equiv.set.union_apply_left", "description": ""}, {"name": "equiv.set.sum_compl_apply_inr", "description": ""}, {"name": "set.mem_image_equiv", "description": ""}, {"name": "set.preimage_equiv_eq_image_symm", "description": "Alias for `equiv.image_eq_preimage`"}, {"name": "equiv.set.of_eq", "description": " Equal sets are equivalent.\n\nTODO: this is the same as `equiv.set_congr`!"}, {"name": "equiv.image_preimage", "description": ""}, {"name": "equiv.coe_of_injective_symm", "description": ""}, {"name": "equiv.set_forall_iff", "description": ""}, {"name": "equiv.preimage_subset", "description": ""}, {"name": "equiv.set.of_eq_symm_apply", "description": ""}, {"name": "equiv.of_left_inverse_apply_coe", "description": ""}, {"name": "equiv.set.univ_apply", "description": ""}, {"name": "equiv.sigma_preimage_equiv_symm_apply_snd_coe", "description": ""}, {"name": "equiv.set.sum_compl_symm_apply", "description": ""}, {"name": "equiv.set.union", "description": "If sets `s` and `t` are disjoint, then `s \u222a t` is equivalent to `s \u2295 t`."}, {"name": "equiv.set.sep", "description": "The set `{x \u2208 s | t x}` is equivalent to the set of `x : s` such that `t x`."}, {"name": "equiv.set.sum_diff_subset", "description": " `sum_diff_subset s t` is the natural equivalence between\n`s \u2295 (t \\ s)` and `t`, where `s` and `t` are two sets."}, {"name": "equiv.set.insert_symm_apply_inl", "description": ""}, {"name": "equiv.prod_assoc_preimage", "description": ""}, {"name": "equiv.prod_assoc_symm_preimage", "description": ""}, {"name": "equiv.set_congr_apply", "description": ""}, {"name": "equiv.set.sum_compl", "description": "If `s : set \u03b1` is a set with decidable membership, then `s \u2295 s\u1d9c` is equivalent to `\u03b1`."}, {"name": "equiv.image_eq_preimage", "description": ""}, {"name": "equiv.subset_image'", "description": ""}, {"name": "equiv.set.image_apply", "description": ""}, {"name": "equiv.of_left_inverse'", "description": " If `f : \u03b1 \u2192 \u03b2` has a left-inverse, then `\u03b1` is computably equivalent to the range of `f`.\n\nNote that if `\u03b1` is empty, no such `f_inv` exists and so this definition can't be used, unlike\nthe stronger but less convenient `of_left_inverse`."}, {"name": "equiv.set.compl", "description": " Given an equivalence `e\u2080` between sets `s : set \u03b1` and `t : set \u03b2`, the set of equivalences\n`e : \u03b1 \u2243 \u03b2` such that `e \u2191x = \u2191(e\u2080 x)` for each `x : s` is equivalent to the set of equivalences\nbetween `s\u1d9c` and `t\u1d9c`."}, {"name": "fin.le_cast_succ_iff", "description": ""}, {"name": "fin.succ_cast_succ", "description": ""}, {"name": "fin.pred_lt_pred_iff", "description": ""}, {"name": "fin.lt_succ_above_iff", "description": " Embedding `i : fin n` into `fin (n + 1)` using a pivot `p` that is lesser\nresults in a value that is greater than `p`."}, {"name": "fin.exists_fin_succ", "description": ""}, {"name": "fin.pred_above_above", "description": ""}, {"name": "fin.lt_succ", "description": ""}, {"name": "fin.succ_above", "description": "`succ_above p i` embeds `fin n` into `fin (n + 1)` with a hole around `p`."}, {"name": "fin.order_embedding_eq", "description": "Two order embeddings of `fin n` are equal provided that their ranges are equal."}, {"name": "fin.mk_zero", "description": ""}, {"name": "fin.succ_rec_on_zero", "description": ""}, {"name": "fin.coe_add_one", "description": ""}, {"name": "fin.coe_bit0", "description": ""}, {"name": "fin.zero_le", "description": ""}, {"name": "fin.succ_above_below", "description": " Embedding `i : fin n` into `fin (n + 1)` with a hole around `p : fin (n + 1)`\nembeds `i` by `cast_succ` when the resulting `i.cast_succ < p`."}, {"name": "fin.eq_iff_veq", "description": ""}, {"name": "fin.reverse_induction_last", "description": ""}, {"name": "fin.coe_add_one_of_lt", "description": ""}, {"name": "fin.last_pos", "description": ""}, {"name": "fin.cast_succ_cast_pred", "description": ""}, {"name": "fin.forall_iff", "description": ""}, {"name": "fin.nat_add_cast", "description": "For rewriting in the reverse direction, see `fin.cast_nat_add_right`."}, {"name": "fin.succ_above_right_inj", "description": "Given a fixed pivot `x : fin (n + 1)`, `x.succ_above` is injective"}, {"name": "fin.reverse_induction", "description": "Define `C i` by reverse induction on `i : fin (n + 1)` via induction on the underlying `nat` value.\nThis function has two arguments: `hlast` handles the base case on `C (fin.last n)`,\nand `hs` defines the inductive step using `C i.succ`, inducting downwards."}, {"name": "fin.cast_pred_zero", "description": ""}, {"name": "fin.lt_iff_coe_lt_coe", "description": ""}, {"name": "fin.add_comm_group", "description": "Abelian group structure on `fin (n+1)`."}, {"name": "fin.bot_eq_zero", "description": ""}, {"name": "fin.cast_pred_one", "description": ""}, {"name": "fin.nat_add_mk", "description": ""}, {"name": "order_iso.fin_equiv_apply", "description": ""}, {"name": "fin.is_lt", "description": ""}, {"name": "fin.zero_lt_one", "description": ""}, {"name": "fin.succ_above_cast_lt", "description": ""}, {"name": "fin.add_zero", "description": ""}, {"name": "fin.coe_embedding", "description": "The inclusion map `fin n \u2192 \u2115` is a relation embedding."}, {"name": "fin.one_succ_above_succ", "description": ""}, {"name": "fin.last", "description": "The greatest value of `fin (n+1)`"}, {"name": "fin.val_zero'", "description": ""}, {"name": "fin.add_one_pos", "description": ""}, {"name": "fin.coe_mod_nat", "description": ""}, {"name": "fin.pred_above_succ_above", "description": " Sending `fin n` into `fin (n + 1)` with a gap at `p`\nthen back to `fin n` by subtracting one from anything above `p` is the identity."}, {"name": "fin.cases_zero", "description": ""}, {"name": "fin.nat_add_last", "description": ""}, {"name": "fin.succ_above_aux", "description": ""}, {"name": "fin.cast_lt", "description": "`cast_lt i h` embeds `i` into a `fin` where `h` proves it belongs into."}, {"name": "fin.mk_le_of_le_coe", "description": ""}, {"name": "fin.exists_fin_two", "description": ""}, {"name": "fin.cast_succ_lt_succ", "description": ""}, {"name": "fin.succ_pred", "description": ""}, {"name": "fin.pred_mk_succ", "description": ""}, {"name": "fin.coe_of_injective_cast_le_symm", "description": ""}, {"name": "fin.coe_val_eq_self", "description": " Converting the value of a `fin (n + 1)` to `fin (n + 1)` results\nin the same value."}, {"name": "fin.coe_cast_pred_lt_iff", "description": ""}, {"name": "fin.coe_eq_val", "description": ""}, {"name": "fin.cast_le_mk", "description": ""}, {"name": "fin.pred_above_below", "description": ""}, {"name": "fin.coe_zero", "description": ""}, {"name": "fin.strict_mono_iff_lt_succ", "description": " A function `f` on `fin (n + 1)` is strictly monotone if and only if `f i < f (i + 1)`\nfor all `i`."}, {"name": "fin.zero_mul", "description": ""}, {"name": "fin.cast_pred", "description": " `cast_pred` embeds `i : fin (n + 2)` into `fin (n + 1)`\nby lowering just `last (n + 1)` to `last n`."}, {"name": "fin.coe_strict_mono", "description": ""}, {"name": "fin.cast_add_cast", "description": "For rewriting in the reverse direction, see `fin.cast_cast_add_left`."}, {"name": "fin.pred_above_left_monotone", "description": ""}, {"name": "fin.induction", "description": "Define `C i` by induction on `i : fin (n + 1)` via induction on the underlying `nat` value.\nThis function has two arguments: `h0` handles the base case on `C 0`,\nand `hs` defines the inductive step using `C i.cast_succ`."}, {"name": "fin.sub_nat_mk", "description": ""}, {"name": "fin.coe_eq_cast_succ", "description": ""}, {"name": "fin.last_cases_cast_succ", "description": ""}, {"name": "fin.cast_lt_cast_succ", "description": ""}, {"name": "fin.pos_iff_ne_zero", "description": ""}, {"name": "fin.succ_above_lt_gt", "description": "Embedding `i : fin n` into `fin (n + 1)` is always about some hole `p`."}, {"name": "fin.is_le", "description": ""}, {"name": "fin.cast_succ_one", "description": ""}, {"name": "fin.add_nat_mk", "description": ""}, {"name": "fin.le_coe_last", "description": ""}, {"name": "fin.cast_succ_zero", "description": ""}, {"name": "fin.cast_zero", "description": ""}, {"name": "fin.induction_on", "description": "Define `C i` by induction on `i : fin (n + 1)` via induction on the underlying `nat` value.\nThis function has two arguments: `h0` handles the base case on `C 0`,\nand `hs` defines the inductive step using `C i.cast_succ`.\n\nA version of `fin.induction` taking `i : fin (n + 1)` as the first argument."}, {"name": "fin.order_iso_unique", "description": ""}, {"name": "fin.range_succ_above", "description": "The range of `p.succ_above` is everything except `p`."}, {"name": "fin.cast_add_cast_lt", "description": ""}, {"name": "fin.cast_cast_add_right", "description": ""}, {"name": "fin.pos_iff_nonempty", "description": ""}, {"name": "fin.one_eq_zero_iff", "description": ""}, {"name": "fin.heq_fun_iff", "description": " Assume `k = l`. If two functions defined on `fin k` and `fin l` are equal on each element,\nthen they coincide (in the heq sense)."}, {"name": "fin.cast_pred_cast_succ", "description": ""}, {"name": "fin.lt_last_iff_coe_cast_pred", "description": ""}, {"name": "fin.linear_order", "description": ""}, {"name": "fin.coe_one", "description": ""}, {"name": "fin.top_eq_last", "description": ""}, {"name": "fin.succ_above_ne", "description": " Embedding `i : fin n` into `fin (n + 1)` with a hole around `p : fin (n + 1)`\nnever results in `p` itself"}, {"name": "fin.cast_nat_add_left", "description": ""}, {"name": "fin.cast_add_nat_zero", "description": ""}, {"name": "fin.coe_coe_eq_self", "description": " Converting a `fin (n + 1)` to `\u2115` and back results in the same\nvalue."}, {"name": "fin.coe_add", "description": ""}, {"name": "fin.pred_inj", "description": ""}, {"name": "fin.val_eq_coe", "description": ""}, {"name": "fin.nontrivial_iff_two_le", "description": ""}, {"name": "fin.coe_clamp", "description": ""}, {"name": "fin.pred_mk", "description": ""}, {"name": "fin.coe_mul", "description": ""}, {"name": "fin.coe_last", "description": ""}, {"name": "fin.coe_val_of_lt", "description": " Converting an in-range number to `fin (n + 1)` produces a result\nwhose value is the original number."}, {"name": "fin.one_val", "description": ""}, {"name": "fin.mk_bit1", "description": ""}, {"name": "fin.cast_succ", "description": "`cast_succ i` embeds `i : fin n` in `fin (n+1)`."}, {"name": "fin.exists_fin_one", "description": ""}, {"name": "fin.pred_add_one", "description": ""}, {"name": "fin.cases_succ", "description": ""}, {"name": "fin.succ_one_eq_two", "description": ""}, {"name": "fin.coe_two", "description": ""}, {"name": "fin.succ_above_last_apply", "description": ""}, {"name": "fin.coe_cast_lt", "description": ""}, {"name": "fin.add_monoid_with_one", "description": ""}, {"name": "fin.cast_le_succ", "description": ""}, {"name": "fin.cases", "description": " Define `f : \u03a0 i : fin n.succ, C i` by separately handling the cases `i = 0` and\n`i = j.succ`, `j : fin n`."}, {"name": "fin.pred_above_last", "description": ""}, {"name": "fin.le_iff_coe_le_coe", "description": ""}, {"name": "fin.succ_succ_above_one", "description": " By moving `succ` to the outside of this expression, we create opportunities for further\nsimplification using `succ_above_zero` or `succ_succ_above_zero`."}, {"name": "fin.cast_succ_fin_succ", "description": ""}, {"name": "fin.last_cases", "description": " Define `f : \u03a0 i : fin n.succ, C i` by separately handling the cases `i = fin.last n` and\n`i = j.cast_succ`, `j : fin n`."}, {"name": "fin.cast_nat_add_right", "description": ""}, {"name": "fin.range_cast_le", "description": ""}, {"name": "fin.coe_bit1", "description": ""}, {"name": "fin.coe_fin_le", "description": "`a \u2264 b` as natural numbers if and only if `a \u2264 b` in `fin n`."}, {"name": "fin.cast_refl", "description": ""}, {"name": "fin.add_nat_one", "description": ""}, {"name": "fin.forall_fin_two", "description": ""}, {"name": "order_iso.fin_equiv", "description": "By sending `x` to `last n - x`, `fin n` is order-equivalent to its `order_dual`."}, {"name": "fin.eq_zero_or_eq_succ", "description": ""}, {"name": "fin.lift_fun_iff_succ", "description": ""}, {"name": "fin.sub_nat_add_nat", "description": ""}, {"name": "fin.coe_order_iso_apply", "description": " If `e` is an `order_iso` between `fin n` and `fin m`, then `n = m` and `e` is the identity\nmap. In this lemma we state that for each `i : fin n` we have `(e i : \u2115) = (i : \u2115)`."}, {"name": "fin.coe_succ", "description": ""}, {"name": "fin.zero_eq_one_iff", "description": ""}, {"name": "fin.nat_add_zero", "description": ""}, {"name": "fin.coe_cast_succ", "description": ""}, {"name": "fin.of_nat_eq_coe", "description": ""}, {"name": "fin.coe_pred", "description": ""}, {"name": "fin.cast_add", "description": "`cast_add m i` embeds `i : fin n` in `fin (n+m)`. See also `fin.nat_add` and `fin.add_nat`."}, {"name": "fin.cast_succ_pred_eq_pred_cast_succ", "description": ""}, {"name": "fin.cast_succ_lt_iff_succ_le", "description": ""}, {"name": "fin.succ_le_succ_iff", "description": ""}, {"name": "fin.clamp", "description": "`min n m` as an element of `fin (m + 1)`"}, {"name": "fin.reverse_induction_cast_succ", "description": ""}, {"name": "fin.coe_of_nat_eq_mod", "description": ""}, {"name": "fin.forall_fin_succ", "description": ""}, {"name": "fin.mk_coe", "description": ""}, {"name": "fin.succ_above_pred", "description": ""}, {"name": "fin.coe_fin_lt", "description": "`a < b` as natural numbers if and only if `a < b` in `fin n`."}, {"name": "fin.mk_lt_of_lt_coe", "description": ""}, {"name": "fin.succ_succ_ne_one", "description": ""}, {"name": "fin.succ_mk", "description": ""}, {"name": "fin.succ_rec_on_succ", "description": ""}, {"name": "fin.pred_succ", "description": ""}, {"name": "fin.mk.inj_iff", "description": ""}, {"name": "fin.cast_nat_add_zero", "description": ""}, {"name": "fin.cases_succ'", "description": ""}, {"name": "fin.cast_add_nat", "description": ""}, {"name": "fact.bit1.pos", "description": ""}, {"name": "fin.exists_iff", "description": ""}, {"name": "fin.succ_cast_eq", "description": ""}, {"name": "fin.pred_succ_above", "description": ""}, {"name": "fin.partial_order", "description": ""}, {"name": "fin.add_nat_sub_nat", "description": ""}, {"name": "fin.has_neg", "description": "Negation on `fin n`"}, {"name": "fin.exists_succ_above_eq", "description": ""}, {"name": "fin.add_cases_left", "description": ""}, {"name": "fin.heq_ext_iff", "description": ""}, {"name": "fin.succ_above_eq_zero_iff", "description": ""}, {"name": "order_iso.fin_equiv_symm_apply", "description": ""}, {"name": "fin.pred_above", "description": "`pred_above p i` embeds `i : fin (n+1)` into `fin n` by subtracting one if `p < i`."}, {"name": "fin.cast_pred_monotone", "description": ""}, {"name": "fin.zero_succ_above", "description": ""}, {"name": "fin.coe_injective", "description": ""}, {"name": "fin.cast_nat_add", "description": ""}, {"name": "fin.succ_zero_eq_one", "description": ""}, {"name": "fin.coe_neg", "description": ""}, {"name": "fin.coe_nat_add", "description": ""}, {"name": "fin.coe_cast_le", "description": ""}, {"name": "fin.cast_succ_injective", "description": ""}, {"name": "fin.succ_rec_on", "description": " Define `C n i` by induction on `i : fin n` interpreted as `(0 : fin (n - i)).succ.succ\u2026`.\nThis function has two arguments: `H0 n` defines `0`-th element `C (n+1) 0` of an `(n+1)`-tuple,\nand `Hs n i` defines `(i+1)`-st element of `(n+1)`-tuple based on `n`, `i`, and `i`-th element\nof `n`-tuple.\n\nA version of `fin.succ_rec` taking `i : fin n` as the first argument."}, {"name": "fin.coe_succ_embedding", "description": ""}, {"name": "fin.elim0'", "description": "A non-dependent variant of `elim0`."}, {"name": "fin.reflect", "description": ""}, {"name": "fin.pred_one", "description": ""}, {"name": "fin.succ_above_ne_zero", "description": ""}, {"name": "fin.monotone_iff_le_succ", "description": "A function `f` on `fin (n + 1)` is monotone if and only if `f i \u2264 f (i + 1)` for all `i`."}, {"name": "fin.one_lt_succ_succ", "description": ""}, {"name": "fin.not_lt_zero", "description": ""}, {"name": "fin.zero_ne_one", "description": ""}, {"name": "fin.cast_succ_cast_lt", "description": ""}, {"name": "fin.coe_coe_of_lt", "description": " Coercing an in-range number to `fin (n + 1)`, and converting back\nto `\u2115`, results in that number."}, {"name": "fin.add_nat", "description": "`add_nat m i` adds `m` to `i`, generalizes `fin.succ`."}, {"name": "fin.succ_above_lt_iff", "description": " Embedding `i : fin n` into `fin (n + 1)` using a pivot `p` that is greater\nresults in a value that is less than `p`."}, {"name": "fin.exists_succ_above_eq_iff", "description": ""}, {"name": "fin.mk_eq_subtype_mk", "description": ""}, {"name": "fin.forall_fin_one", "description": ""}, {"name": "fin_zero_elim", "description": "Elimination principle for the empty set `fin 0`, dependent version."}, {"name": "fact.bit0.pos", "description": ""}, {"name": "fin.succ_lt_succ_iff", "description": ""}, {"name": "fin.coe_nat_eq_last", "description": ""}, {"name": "fin.coe_of_injective_cast_succ_symm", "description": ""}, {"name": "fin.nat_add", "description": "`nat_add n i` adds `n` to `i` \"on the left\"."}, {"name": "fact.pow.pos", "description": ""}, {"name": "fin.succ_rec", "description": " Define `C n i` by induction on `i : fin n` interpreted as `(0 : fin (n - i)).succ.succ\u2026`.\nThis function has two arguments: `H0 n` defines `0`-th element `C (n+1) 0` of an `(n+1)`-tuple,\nand `Hs n i` defines `(i+1)`-st element of `(n+1)`-tuple based on `n`, `i`, and `i`-th element\nof `n`-tuple."}, {"name": "fin.strict_anti_iff_succ_lt", "description": " A function `f` on `fin (n + 1)` is strictly antitone if and only if `f (i + 1) < f i`\nfor all `i`."}, {"name": "fin.cast_le", "description": "`cast_le h i` embeds `i` into a larger `fin` type."}, {"name": "fin.succ_succ_above_zero", "description": ""}, {"name": "fin.coe_one'", "description": ""}, {"name": "fin.cast_succ_eq_zero_iff", "description": ""}, {"name": "fin.cast_eq_cast", "description": " While in many cases `fin.cast` is better than `equiv.cast`/`cast`, sometimes we want to apply\na generic theorem about `cast`."}, {"name": "fin.cast_add_nat_left", "description": ""}, {"name": "fin.cast", "description": "`cast eq i` embeds `i` into a equal `fin` type, see also `equiv.fin_congr`."}, {"name": "fin.cast_succ_mk", "description": ""}, {"name": "fin.fin.lt.is_well_order", "description": "The ordering on `fin n` is a well order."}, {"name": "fin.succ_last", "description": ""}, {"name": "fin.last_add_one", "description": ""}, {"name": "fin.succ_above_above", "description": " Embedding `i : fin n` into `fin (n + 1)` with a hole around `p : fin (n + 1)`\nembeds `i` by `succ` when the resulting `p < i.succ`."}, {"name": "fin.coe_succ_eq_succ", "description": ""}, {"name": "fin.add_nat_cast", "description": "For rewriting in the reverse direction, see `fin.cast_add_nat_left`."}, {"name": "fin.fin_two_eq_of_eq_zero_iff", "description": ""}, {"name": "fin.succ_above_lt_ge", "description": "Embedding `i : fin n` into `fin (n + 1)` is always about some hole `p`."}, {"name": "fin.cast_succ_pos", "description": "`cast_succ i` is positive when `i` is positive"}, {"name": "fin.val_mul", "description": ""}, {"name": "fin.cast_succ_eq", "description": " The cast of the successor is the succesor of the cast. See `fin.succ_cast_eq` for rewriting in\nthe reverse direction."}, {"name": "fin.cast_add_zero", "description": ""}, {"name": "fin.cast_le_of_eq", "description": ""}, {"name": "fin.succ_inj", "description": ""}, {"name": "fin.pred_above_zero", "description": ""}, {"name": "fin.cast_lt_mk", "description": ""}, {"name": "fin.coe_div_nat", "description": ""}, {"name": "fin.coe_fin_one", "description": ""}, {"name": "fin.coe_cast", "description": " While `fin.coe_order_iso_apply` is a more general case of this, we mark this `simp` anyway\nas it is eligible for `dsimp`."}, {"name": "fin.cast_last", "description": ""}, {"name": "fin.cast_lt_cast_add", "description": ""}, {"name": "fin.nontrivial", "description": ""}, {"name": "fin.succ_succ_above_succ", "description": ""}, {"name": "fin.order_iso_subsingleton'", "description": ""}, {"name": "fin.val_two", "description": ""}, {"name": "fin.succ_above_right_injective", "description": "Given a fixed pivot `x : fin (n + 1)`, `x.succ_above` is injective"}, {"name": "fin.add_comm_monoid", "description": ""}, {"name": "fin.succ_above_zero", "description": "Embedding `fin n` into `fin (n + 1)` with a hole around zero embeds by `succ`."}, {"name": "fin.mod_nat", "description": "Compute `i % n`, where `n` is a `nat` and inferred the type of `i`."}, {"name": "fin.cast_lt_succ_above", "description": ""}, {"name": "fin.le_coe_nat_add", "description": ""}, {"name": "fin.val_add", "description": ""}, {"name": "fin.mk_succ_pos", "description": ""}, {"name": "fin.subsingleton_iff_le_one", "description": ""}, {"name": "fin.cast_succ_lt_cast_succ_iff", "description": ""}, {"name": "fin.coe_cast_pred_le_self", "description": ""}, {"name": "fin.pred_cast_succ_succ", "description": ""}, {"name": "fin.succ_above_left_inj", "description": "`succ_above` is injective at the pivot"}, {"name": "fin.induction_succ", "description": ""}, {"name": "fin.div_nat", "description": "Compute `i / n`, where `n` is a `nat` and inferred the type of `i`."}, {"name": "fin.eta", "description": ""}, {"name": "fin.succ_above_last", "description": "Embedding `fin n` into `fin (n + 1)` with a hole around `last n` embeds by `cast_succ`."}, {"name": "fin.succ_injective", "description": ""}, {"name": "fin.cast_pred_last", "description": ""}, {"name": "fin.mul_one", "description": ""}, {"name": "fin.of_nat'", "description": "Given a positive `n`, `fin.of_nat' i` is `i % n` as an element of `fin n`."}, {"name": "fin.bounded_order", "description": ""}, {"name": "fin.succ_eq_last_succ", "description": ""}, {"name": "fin.cast_le_cast_le", "description": ""}, {"name": "fin.add_cases", "description": " Define `f : \u03a0 i : fin (m + n), C i` by separately handling the cases `i = cast_add n i`,\n`j : fin m` and `i = nat_add m j`, `j : fin n`."}, {"name": "fin.cast_to_equiv", "description": " While in many cases `fin.cast` is better than `equiv.cast`/`cast`, sometimes we want to apply\na generic theorem about `cast`."}, {"name": "fin.nat_add_sub_nat_cast", "description": ""}, {"name": "fin.le_coe_add_nat", "description": ""}, {"name": "fin.eq_mk_iff_coe_eq", "description": ""}, {"name": "fin.coe_mk", "description": ""}, {"name": "fin.range_cast_succ", "description": ""}, {"name": "fin.one_succ_above_zero", "description": ""}, {"name": "fin.cast_pred_mk", "description": ""}, {"name": "fin.add_cases_right", "description": ""}, {"name": "fin.succ_above_pos", "description": "Embedding a positive `fin n` results in a positive fin (n + 1)`"}, {"name": "fin.succ_above_left_injective", "description": "`succ_above` is injective at the pivot"}, {"name": "fin.coe_sub", "description": ""}, {"name": "fin.order_iso_subsingleton", "description": ""}, {"name": "fin.strict_mono_unique", "description": " Two strictly monotone functions from `fin n` are equal provided that their ranges\nare equal."}, {"name": "fin.cast_cast_add_left", "description": ""}, {"name": "fin.coe_neg_one", "description": ""}, {"name": "fin.coe_sub_one", "description": ""}, {"name": "fin.ne_iff_vne", "description": ""}, {"name": "fin.val_one", "description": ""}, {"name": "fin.pred_succ_above_pred", "description": "`pred` commutes with `succ_above`."}, {"name": "fin.zero_add", "description": ""}, {"name": "fin.last_cases_last", "description": ""}, {"name": "fin.cast_trans", "description": ""}, {"name": "fin.one_mul", "description": ""}, {"name": "fin.cast_cast_succ", "description": ""}, {"name": "fin.mk_one", "description": ""}, {"name": "fin.one_pos", "description": ""}, {"name": "fin.coe_add_eq_ite", "description": ""}, {"name": "fin.succ_pos", "description": ""}, {"name": "fin.succ_ne_zero", "description": ""}, {"name": "fin.mk_bit0", "description": ""}, {"name": "fin.cast_succ_ne_zero_iff", "description": ""}, {"name": "fin.antitone_iff_succ_le", "description": "A function `f` on `fin (n + 1)` is antitone if and only if `f (i + 1) \u2264 f i` for all `i`."}, {"name": "fin.last_val", "description": ""}, {"name": "fin.coe_cast_add", "description": ""}, {"name": "fin.cast_add_mk", "description": ""}, {"name": "fin.ext", "description": ""}, {"name": "fin.cast_le_comp_cast_le", "description": ""}, {"name": "fin.cast_add_lt", "description": ""}, {"name": "fin.lattice", "description": ""}, {"name": "fin.coe_sub_nat", "description": ""}, {"name": "fin.le_last", "description": ""}, {"name": "fin.coe_of_nat_eq_mod'", "description": ""}, {"name": "fin.pred_above_last_apply", "description": ""}, {"name": "fin.succ_embedding", "description": "`fin.succ` as an `order_embedding`"}, {"name": "fin.succ_above_ne_zero_zero", "description": ""}, {"name": "fin.cast_add_nat_right", "description": ""}, {"name": "fin.pred_le_pred_iff", "description": ""}, {"name": "fin.cast_le_zero", "description": ""}, {"name": "fin.nat_add_cast_succ", "description": ""}, {"name": "fin.symm_cast", "description": ""}, {"name": "fin.mul_zero", "description": ""}, {"name": "fin.fin_to_nat", "description": ""}, {"name": "fin.cast_mk", "description": ""}, {"name": "fin.induction_zero", "description": ""}, {"name": "fin.cast_succ_inj", "description": ""}, {"name": "fin.pred_above_right_monotone", "description": ""}, {"name": "fin.succ_above_pred_above", "description": " Sending `fin (n+1)` to `fin n` by subtracting one from anything above `p`\nthen back to `fin (n+1)` with a gap around `p` is the identity away from `p`."}, {"name": "fin.eq_last_of_not_lt", "description": ""}, {"name": "fin.coe_add_nat", "description": ""}, {"name": "fin.has_well_founded", "description": " Use the ordering on `fin n` for checking recursive definitions.\n\nFor example, the following definition is not accepted by the termination checker,\nunless we declare the `has_well_founded` instance:\n```lean\ndef factorial {n : \u2115} : fin n \u2192 \u2115\n| \u27e80, _\u27e9 := 1\n| \u27e8i + 1, hi\u27e9 := (i + 1) * factorial \u27e8i, i.lt_succ_self.trans hi\u27e9\n```"}, {"name": "fin.mk_val", "description": ""}, {"name": "fin.one_succ_above_one", "description": ""}, {"name": "fin.cast_succ_lt_last", "description": ""}, {"name": "fact.succ.pos", "description": ""}, {"name": "fin.ext_iff", "description": ""}, {"name": "fin.sub_nat", "description": "`sub_nat i h` subtracts `m` from `i`, generalizes `fin.pred`."}, {"name": "set.inter_inter_inter_comm", "description": ""}, {"name": "set.union_subset_iff", "description": ""}, {"name": "set.eq_of_subset_of_subset", "description": ""}, {"name": "set.mem_diff_of_mem", "description": ""}, {"name": "set.image_congr", "description": ""}, {"name": "set.ite_empty_left", "description": ""}, {"name": "set.subset_univ", "description": ""}, {"name": "set.union_is_assoc", "description": ""}, {"name": "set.insert_diff_eq_singleton", "description": ""}, {"name": "set.nonempty_diff", "description": ""}, {"name": "set.union_inter_cancel_right", "description": ""}, {"name": "set.diff_singleton_subset_iff", "description": ""}, {"name": "set.image_preimage_eq_inter_range", "description": ""}, {"name": "set.image_eta", "description": ""}, {"name": "set.union_diff_cancel_left", "description": ""}, {"name": "set.nonempty.preimage", "description": ""}, {"name": "set.subset_ite", "description": ""}, {"name": "set.sep_univ", "description": ""}, {"name": "set.compl_compl_image", "description": ""}, {"name": "set.ite_inter_of_inter_eq", "description": ""}, {"name": "set.inter_inter_distrib_left", "description": ""}, {"name": "set.range_inclusion", "description": ""}, {"name": "set.eq_empty_or_nonempty", "description": ""}, {"name": "set.range.nonempty", "description": ""}, {"name": "set.preimage_subset_image_of_inverse", "description": ""}, {"name": "set.image_subset_image2_left", "description": ""}, {"name": "set.union_diff_left", "description": ""}, {"name": "set.inter_eq_left_iff_subset", "description": ""}, {"name": "set.inclusion_inclusion", "description": ""}, {"name": "set.image2_union_right", "description": ""}, {"name": "set.nonempty_of_mem", "description": ""}, {"name": "set.not_mem_empty", "description": ""}, {"name": "set.diff_union_of_subset", "description": ""}, {"name": "set.image_singleton", "description": ""}, {"name": "set.subsingleton.eq_singleton_of_mem", "description": ""}, {"name": "set.ite_inter", "description": ""}, {"name": "set.has_ssubset.ssubset.is_irrefl", "description": ""}, {"name": "set.comp_range_splitting", "description": ""}, {"name": "set.subset_preimage_image", "description": ""}, {"name": "set.image_image2_antidistrib_left", "description": "Symmetric of `set.image2_image_left_anticomm`."}, {"name": "set.eq_empty_of_is_empty", "description": ""}, {"name": "set.image_univ_of_surjective", "description": ""}, {"name": "set.eq_empty_iff_forall_not_mem", "description": ""}, {"name": "set.image_injective", "description": ""}, {"name": "set.subsingleton.image", "description": ""}, {"name": "set.can_lift", "description": ""}, {"name": "set.ssubset_iff_of_subset", "description": ""}, {"name": "set.subsingleton.preimage", "description": "The preimage of a subsingleton under an injective map is a subsingleton."}, {"name": "set.subsingleton_univ_iff", "description": ""}, {"name": "set.eq_univ_iff_forall", "description": ""}, {"name": "subtype.preimage_coe_compl'", "description": ""}, {"name": "set.forall_not_of_sep_empty", "description": ""}, {"name": "set.insert_eq", "description": ""}, {"name": "set.range_factorization", "description": "Any map `f : \u03b9 \u2192 \u03b2` factors through a map `range_factorization f : \u03b9 \u2192 range f`."}, {"name": "set.mem_insert_of_mem", "description": ""}, {"name": "set.nonempty", "description": " The property `s.nonempty` expresses the fact that the set `s` is not empty. It should be used\nin theorem assumptions instead of `\u2203 x, x \u2208 s` or `s \u2260 \u2205` as it gives access to a nice API thanks\nto the dot notation."}, {"name": "set.image2_image2_left", "description": ""}, {"name": "set.inter_distrib_left", "description": ""}, {"name": "set.diff_diff", "description": ""}, {"name": "set.nonempty.of_image", "description": ""}, {"name": "set.image_diff_preimage", "description": ""}, {"name": "set.subsingleton_empty", "description": ""}, {"name": "set.univ_union", "description": ""}, {"name": "set.diff_eq_self", "description": ""}, {"name": "set.compl_univ", "description": ""}, {"name": "set.image_perm", "description": "If the only elements outside `s` are those left fixed by `\u03c3`, then mapping by `\u03c3` has no effect."}, {"name": "set.insert_none_range_some", "description": ""}, {"name": "set.insert_inter_of_not_mem", "description": ""}, {"name": "set.subset_singleton_iff_eq", "description": ""}, {"name": "set.image_eq_image", "description": ""}, {"name": "set.union_diff_cancel", "description": ""}, {"name": "set.preimage_compl", "description": ""}, {"name": "set.image_id", "description": ""}, {"name": "set.insert_inj", "description": ""}, {"name": "set.not_nonempty_iff_eq_empty", "description": ""}, {"name": "set.union_is_comm", "description": ""}, {"name": "set.subset_compl_iff_disjoint_right", "description": ""}, {"name": "set.image_univ", "description": ""}, {"name": "set.subsingleton_is_bot", "description": ""}, {"name": "set.nonempty_compl", "description": ""}, {"name": "set.mem_empty_eq", "description": ""}, {"name": "set.ball_empty_iff", "description": ""}, {"name": "set.insert_def", "description": ""}, {"name": "set.subset_singleton_iff", "description": ""}, {"name": "set.eq_empty_of_forall_not_mem", "description": ""}, {"name": "set.range_splitting", "description": "We can use the axiom of choice to pick a preimage for every element of `range f`."}, {"name": "set.mem_preimage", "description": ""}, {"name": "subtype.image_preimage_val", "description": ""}, {"name": "set.inter_subset_left", "description": ""}, {"name": "set.mem_compl", "description": ""}, {"name": "set.image_eq_range", "description": ""}, {"name": "set.ite_inter_inter", "description": ""}, {"name": "set.nonempty.to_subtype", "description": ""}, {"name": "set.eq_univ_of_univ_subset", "description": ""}, {"name": "set.nonempty.ne_empty", "description": ""}, {"name": "set.exists_mem_of_nonempty", "description": ""}, {"name": "subtype.preimage_coe_inter_self", "description": ""}, {"name": "set.image2_image_left", "description": ""}, {"name": "has_mem.mem.out", "description": " If `h : a \u2208 {x | p x}` then `h.out : p x`. These are definitionally equal, but this can\nnevertheless be useful for various reasons, e.g. to apply further projection notation or in an\nargument to `simp`."}, {"name": "subtype.image_preimage_coe", "description": ""}, {"name": "set.diff_empty", "description": ""}, {"name": "set.nonempty.inl", "description": ""}, {"name": "set.subset_diff_union", "description": ""}, {"name": "set.mem_image2_iff", "description": ""}, {"name": "set.mem_image_elim_on", "description": ""}, {"name": "set.is_empty_coe_sort", "description": ""}, {"name": "option.injective_iff", "description": ""}, {"name": "set.mem_compl_image", "description": ""}, {"name": "set.pi_set_coe.can_lift'", "description": ""}, {"name": "set.inhabited", "description": ""}, {"name": "set.prod_quotient_preimage_eq_image", "description": ""}, {"name": "set.singleton_inter_eq_empty", "description": ""}, {"name": "set.range_ite_subset'", "description": ""}, {"name": "set.surjective_onto_range", "description": ""}, {"name": "set.ext", "description": ""}, {"name": "set.inter_union_compl", "description": ""}, {"name": "set.range_const", "description": ""}, {"name": "set.image_insert_eq", "description": ""}, {"name": "set.compl_ne_univ", "description": ""}, {"name": "function.surjective.range_comp", "description": ""}, {"name": "set.set_compr_eq_eq_singleton", "description": ""}, {"name": "set.image", "description": "The image of `s : set \u03b1` by `f : \u03b1 \u2192 \u03b2`, written `f '' s`,\n is the set of `y : \u03b2` such that `f x = y` for some `x \u2208 s`."}, {"name": "set.union_union_union_comm", "description": ""}, {"name": "set.subset_insert_diff_singleton", "description": ""}, {"name": "set.sep_false", "description": ""}, {"name": "set.insert_diff_of_not_mem", "description": ""}, {"name": "set.preimage_inl_range_inr", "description": ""}, {"name": "set.diff_singleton_eq_self", "description": ""}, {"name": "set.image_subset_iff", "description": "image and preimage are a Galois connection"}, {"name": "set.nonempty.image_const", "description": ""}, {"name": "set.nontrivial", "description": ""}, {"name": "set.mem_insert_iff", "description": ""}, {"name": "set.union_univ", "description": ""}, {"name": "set.image_preimage_eq", "description": ""}, {"name": "set.empty_ne_univ", "description": ""}, {"name": "set.decidable_univ", "description": ""}, {"name": "set.mem_powerset", "description": ""}, {"name": "set.forall_image2_iff", "description": ""}, {"name": "set.default_coe_singleton", "description": ""}, {"name": "set.has_ssubset.ssubset.is_nonstrict_strict_order", "description": ""}, {"name": "set.mem_sep_eq", "description": ""}, {"name": "set.disjoint_compl_right_iff_subset", "description": ""}, {"name": "set.image2_singleton", "description": ""}, {"name": "subtype.preimage_coe_compl", "description": ""}, {"name": "set.subsingleton.antitone_on", "description": ""}, {"name": "set.not_mem_subset", "description": ""}, {"name": "set.ball_image_of_ball", "description": ""}, {"name": "set.image2_congr", "description": ""}, {"name": "set.subsingleton.strict_anti_on", "description": ""}, {"name": "set_coe.exists'", "description": ""}, {"name": "set.strict_mono_on_singleton", "description": ""}, {"name": "set.univ_unique", "description": ""}, {"name": "set.mem_singleton", "description": ""}, {"name": "disjoint.subset_compl_right", "description": "**Alias** of the reverse direction of `set.subset_compl_iff_disjoint_right`."}, {"name": "set.has_emptyc.emptyc.is_empty", "description": ""}, {"name": "set.mem_set_of", "description": ""}, {"name": "set.sum.elim_range", "description": ""}, {"name": "set.mem_range", "description": ""}, {"name": "set.diff_self_inter", "description": ""}, {"name": "set.insert_comm", "description": ""}, {"name": "set.mem_of_eq_of_mem", "description": ""}, {"name": "set.subset_compl_iff_disjoint_left", "description": ""}, {"name": "set.ite_univ", "description": ""}, {"name": "set.apply_range_splitting", "description": ""}, {"name": "set.empty_subset", "description": ""}, {"name": "set.compl_union", "description": ""}, {"name": "set.image2_singleton_right", "description": ""}, {"name": "set.inter_left_comm", "description": ""}, {"name": "set.insert_inter_distrib", "description": ""}, {"name": "set.eq_or_ssubset_of_subset", "description": ""}, {"name": "set.inter_subset_inter_left", "description": ""}, {"name": "set.preimage_id", "description": ""}, {"name": "set.singleton_def", "description": ""}, {"name": "set.union_subset_union_right", "description": ""}, {"name": "set.insert_diff_singleton", "description": ""}, {"name": "set.nonempty.of_diff", "description": ""}, {"name": "set.forall_of_forall_insert", "description": ""}, {"name": "set.ne_univ_iff_exists_not_mem", "description": ""}, {"name": "function.surjective.preimage_subset_preimage_iff", "description": ""}, {"name": "set.bex_image_iff", "description": ""}, {"name": "set.subsingleton_of_subset_singleton", "description": ""}, {"name": "set.subset_image_compl", "description": ""}, {"name": "set.compl_inter_self", "description": ""}, {"name": "set.image_congr'", "description": "A common special case of `image_congr`"}, {"name": "set.nonempty.inr", "description": ""}, {"name": "set.set_of_set", "description": ""}, {"name": "set.set_of_false", "description": ""}, {"name": "set.union_distrib_left", "description": ""}, {"name": "set.union_diff_cancel_right", "description": ""}, {"name": "eq.subset", "description": "Duplicate of `eq.subset'`, which currently has elaboration problems."}, {"name": "set.range_diff_image_subset", "description": ""}, {"name": "set.image_union_image_compl_eq_range", "description": ""}, {"name": "set.union_inter_cancel_left", "description": ""}, {"name": "set.image_inter_subset", "description": ""}, {"name": "set.univ_eq_empty_iff", "description": ""}, {"name": "function.left_inverse.image_image", "description": ""}, {"name": "subtype.coe_image_subset", "description": ""}, {"name": "set.compl_image", "description": ""}, {"name": "set.image_empty", "description": ""}, {"name": "set.powerset_mono", "description": ""}, {"name": "set.preimage_congr", "description": ""}, {"name": "set.subset_compl_singleton_iff", "description": ""}, {"name": "set.univ_inter", "description": ""}, {"name": "set.mem_sep_iff", "description": ""}, {"name": "set.not_subset_iff_exists_mem_not_mem", "description": ""}, {"name": "set_coe.ext_iff", "description": ""}, {"name": "set.nonempty.right", "description": ""}, {"name": "set.singleton_union", "description": ""}, {"name": "set.nontrivial_mono", "description": ""}, {"name": "set.sup_eq_union", "description": ""}, {"name": "set.subset_union_right", "description": ""}, {"name": "set.inter_is_assoc", "description": ""}, {"name": "set.range_eq_empty", "description": ""}, {"name": "set.image_subset_range", "description": ""}, {"name": "set.mem_def", "description": ""}, {"name": "set.nonempty_inter_iff_exists_left", "description": ""}, {"name": "set.mem_image", "description": ""}, {"name": "set.has_subset", "description": ""}, {"name": "set.subset_image_union", "description": ""}, {"name": "set.eq_singleton_iff_nonempty_unique_mem", "description": ""}, {"name": "set.diff_diff_cancel_left", "description": ""}, {"name": "set.preimage_range_splitting", "description": ""}, {"name": "set.nonempty_iff_univ_nonempty", "description": ""}, {"name": "set.forall_insert_of_forall", "description": ""}, {"name": "set.range_some_union_none", "description": ""}, {"name": "set.has_ssubset", "description": ""}, {"name": "set.range_id'", "description": ""}, {"name": "function.injective.mem_set_image", "description": ""}, {"name": "set.preimage_eq_iff_eq_image", "description": ""}, {"name": "set.subset_compl_comm", "description": ""}, {"name": "set.monotone_powerset", "description": ""}, {"name": "set.subset_insert", "description": ""}, {"name": "set.subsingleton.eq_empty_or_singleton", "description": ""}, {"name": "set.powerset_univ", "description": ""}, {"name": "set.ssubset_of_ssubset_of_subset", "description": ""}, {"name": "set.nonempty_of_nonempty_subtype", "description": ""}, {"name": "set.inter_singleton_nonempty", "description": ""}, {"name": "set.compl_subset_iff_union", "description": ""}, {"name": "set.insert_subset", "description": ""}, {"name": "set.mem_singleton_of_eq", "description": ""}, {"name": "set.mem_union_right", "description": ""}, {"name": "set.preimage", "description": "The preimage of `s : set \u03b2` by `f : \u03b1 \u2192 \u03b2`, written `f \u207b\u00b9' s`,\n is the set of `x : \u03b1` such that `f x \u2208 s`."}, {"name": "set.disjoint_compl_left_iff_subset", "description": ""}, {"name": "set.mem_inter_eq", "description": ""}, {"name": "set_coe.exists", "description": ""}, {"name": "set.preimage_subset_iff", "description": ""}, {"name": "set.inclusion_injective", "description": ""}, {"name": "set.union_self", "description": ""}, {"name": "set.decidable_compl", "description": ""}, {"name": "function.injective.compl_image_eq", "description": ""}, {"name": "function.injective.mem_range_iff_exists_unique", "description": ""}, {"name": "set.mem_compl_singleton_iff", "description": ""}, {"name": "set.ite_compl", "description": ""}, {"name": "set.ball_image_iff", "description": ""}, {"name": "set.compl_range_inr", "description": ""}, {"name": "set.compl_ne_eq_singleton", "description": ""}, {"name": "set.compl_subset_comm", "description": ""}, {"name": "set.image2_swap", "description": ""}, {"name": "set.univ_subset_iff", "description": ""}, {"name": "set.ite_subset_union", "description": ""}, {"name": "set.image_compl_eq", "description": ""}, {"name": "set.bot_eq_empty", "description": ""}, {"name": "set.insert_subset_insert", "description": ""}, {"name": "set.ite_left", "description": ""}, {"name": "set.diff_subset", "description": ""}, {"name": "set.image2_right_comm", "description": ""}, {"name": "set.diff_diff_right_self", "description": ""}, {"name": "set.image_compl_preimage", "description": ""}, {"name": "set.decidable_emptyset", "description": ""}, {"name": "set.subsingleton.mono", "description": ""}, {"name": "set.singleton_injective", "description": ""}, {"name": "set.decidable_union", "description": ""}, {"name": "set.image2_eq_empty_iff", "description": ""}, {"name": "set.inter_subset_inter_right", "description": ""}, {"name": "set.pair_comm", "description": ""}, {"name": "set.mem_powerset_iff", "description": ""}, {"name": "set.image_subset_image_iff", "description": ""}, {"name": "set.image2_left_comm", "description": ""}, {"name": "set.insert_inter_of_mem", "description": ""}, {"name": "set.mem_image_eq", "description": ""}, {"name": "set.diff_self", "description": ""}, {"name": "set.subset_diff_singleton", "description": ""}, {"name": "set.inter_diff_self", "description": ""}, {"name": "set.union_empty", "description": ""}, {"name": "set.inter_singleton_eq_empty", "description": ""}, {"name": "disjoint.subset_compl_left", "description": "**Alias** of the reverse direction of `set.subset_compl_iff_disjoint_left`."}, {"name": "set.mem_univ", "description": ""}, {"name": "set.diff_inter_self_eq_diff", "description": ""}, {"name": "set.mem_diff", "description": ""}, {"name": "set.mem_image_elim", "description": ""}, {"name": "set.union_eq_right_iff_subset", "description": ""}, {"name": "set.univ_nonempty", "description": ""}, {"name": "function.surjective.image_preimage", "description": ""}, {"name": "set.union_diff_self", "description": ""}, {"name": "set.range_ite_subset", "description": ""}, {"name": "set.mem_image2_eq", "description": ""}, {"name": "subtype.coe_image_univ", "description": ""}, {"name": "set.subset_union_left", "description": ""}, {"name": "set.subset_eq_empty", "description": ""}, {"name": "set.subset_union_compl_iff_inter_subset", "description": ""}, {"name": "set.image_diff", "description": ""}, {"name": "function.surjective.preimage_injective", "description": ""}, {"name": "set.union_diff_right", "description": ""}, {"name": "set.set_of_subset_set_of", "description": ""}, {"name": "set.union_empty_iff", "description": ""}, {"name": "set.mem_of_subset_of_mem", "description": ""}, {"name": "set.image_eq_preimage_of_inverse", "description": ""}, {"name": "set.diff_inter_self", "description": ""}, {"name": "set.image_inter", "description": ""}, {"name": "set.union_right_comm", "description": ""}, {"name": "set.antitone_on_singleton", "description": ""}, {"name": "set.mem_range_self", "description": ""}, {"name": "set.union_eq_self_of_subset_right", "description": ""}, {"name": "set.image_image2_distrib_right", "description": "Symmetric of `set.image_image2_right_comm`."}, {"name": "set.preimage_mono", "description": ""}, {"name": "set.exists_range_iff", "description": ""}, {"name": "function.surjective.nonempty_preimage", "description": ""}, {"name": "function.commute.set_image", "description": ""}, {"name": "set.has_subset.subset.is_trans", "description": ""}, {"name": "set.not_not_mem", "description": ""}, {"name": "set.image_inter_on", "description": ""}, {"name": "subsingleton.mem_iff_nonempty", "description": ""}, {"name": "set.image_pair", "description": ""}, {"name": "set.diff_eq_compl_inter", "description": ""}, {"name": "set.diff_subset_diff", "description": ""}, {"name": "set.mem_singleton_iff", "description": ""}, {"name": "set.nonempty.mono", "description": ""}, {"name": "set.inter_self", "description": ""}, {"name": "set.range_const_subset", "description": ""}, {"name": "set.union_compl_self", "description": ""}, {"name": "subtype.preimage_val_eq_preimage_val_iff", "description": ""}, {"name": "function.injective.subsingleton_image_iff", "description": ""}, {"name": "subtype.range_val", "description": "A variant of `range_coe`. Try to use `range_coe` if possible.\n This version is useful when defining a new type that is defined as the subtype of something.\n In that case, the coercion doesn't fire anymore."}, {"name": "set.mem_inter", "description": ""}, {"name": "set.ssubset_def", "description": ""}, {"name": "set.eq_univ_of_subset", "description": ""}, {"name": "set.mem_image2_of_mem", "description": ""}, {"name": "set.eq_empty_of_ssubset_singleton", "description": ""}, {"name": "set.nmem_singleton_empty", "description": ""}, {"name": "set.singleton_nonempty", "description": ""}, {"name": "function.injective.image_injective", "description": ""}, {"name": "set.univ.nonempty", "description": ""}, {"name": "set.subset_union_of_subset_left", "description": ""}, {"name": "set.mem_or_mem_of_mem_union", "description": ""}, {"name": "set.union_comm", "description": ""}, {"name": "set.compl_def", "description": ""}, {"name": "set.image_eq_empty", "description": ""}, {"name": "set.nonempty.of_image2_left", "description": ""}, {"name": "set.not_mem_of_mem_diff", "description": ""}, {"name": "set.image_image2_right_anticomm", "description": "Symmetric of `set.image_image2_antidistrib_right`."}, {"name": "set.forall_in_swap", "description": ""}, {"name": "set.insert_diff_of_mem", "description": ""}, {"name": "set.image3", "description": "The image of a ternary function `f : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4` as a function\n `set \u03b1 \u2192 set \u03b2 \u2192 set \u03b3 \u2192 set \u03b4`. Mathematically this should be thought of as the image of the\n corresponding function `\u03b1 \u00d7 \u03b2 \u00d7 \u03b3 \u2192 \u03b4`."}, {"name": "set.singleton_inter_nonempty", "description": ""}, {"name": "set.image_preimage_eq_of_subset", "description": ""}, {"name": "set.set_of_eq_eq_singleton'", "description": ""}, {"name": "set.image_comm", "description": ""}, {"name": "set.empty_def", "description": ""}, {"name": "set.range_comp", "description": ""}, {"name": "set.ssubset_of_subset_of_ssubset", "description": ""}, {"name": "set.image_subset_image2_right", "description": ""}, {"name": "set.inter_subset", "description": ""}, {"name": "set.inter_eq_self_of_subset_left", "description": ""}, {"name": "set.nonempty.subset_singleton_iff", "description": ""}, {"name": "set.preimage_const", "description": ""}, {"name": "set.image_preimage_eq_iff", "description": ""}, {"name": "set.inter_is_comm", "description": ""}, {"name": "set.ne_empty_iff_nonempty", "description": ""}, {"name": "set.inter_diff_assoc", "description": ""}, {"name": "set.subset_inter_iff", "description": ""}, {"name": "set.union_union_distrib_left", "description": ""}, {"name": "set.range_splitting_injective", "description": ""}, {"name": "function.left_inverse.preimage_preimage", "description": ""}, {"name": "set.range_comp_subset_range", "description": ""}, {"name": "set.range_subset_singleton", "description": ""}, {"name": "set.ite_empty", "description": ""}, {"name": "set.unique_singleton", "description": ""}, {"name": "set.eq_singleton_iff_unique_mem", "description": ""}, {"name": "set.forall_range_iff", "description": ""}, {"name": "set.diff_subset_diff_left", "description": ""}, {"name": "set.not_nonempty_empty", "description": ""}, {"name": "set.nonempty_of_not_subset", "description": ""}, {"name": "set.mem_of_mem_inter_left", "description": ""}, {"name": "set.not_subset", "description": ""}, {"name": "set.union_preimage_subset", "description": ""}, {"name": "set.inclusion_right", "description": ""}, {"name": "set.range", "description": " Range of a function.\n\nThis function is more flexible than `f '' univ`, as the image requires that the domain is in Type\nand not an arbitrary Sort."}, {"name": "set.nonempty.left", "description": ""}, {"name": "set.image_swap_eq_preimage_swap", "description": ""}, {"name": "set.ite", "description": " `ite` for sets: `set.ite t s s' \u2229 t = s \u2229 t`, `set.ite t s s' \u2229 t\u1d9c = s' \u2229 t\u1d9c`.\nDefined as `s \u2229 t \u222a s' \\ t`."}, {"name": "set.has_subset.subset.is_refl", "description": ""}, {"name": "set.eq_of_mem_singleton", "description": ""}, {"name": "set.diff_inter_diff", "description": ""}, {"name": "set.empty_not_nonempty", "description": ""}, {"name": "set.inter_eq_compl_compl_union_compl", "description": ""}, {"name": "set.set_of_true", "description": ""}, {"name": "set.powerset", "description": "`\ud835\udcab s = set.powerset s` is the set of all subsets of `s`."}, {"name": "subtype.coe_preimage_self", "description": ""}, {"name": "has_subset.subset.disjoint_compl_left", "description": "**Alias** of the reverse direction of `set.disjoint_compl_left_iff_subset`."}, {"name": "set.preimage_inr_image_inl", "description": ""}, {"name": "set.nonempty_def", "description": ""}, {"name": "set.inter_insert_of_mem", "description": ""}, {"name": "set.set_of_and", "description": ""}, {"name": "set.union_congr_right", "description": ""}, {"name": "set.subsingleton_of_subsingleton", "description": ""}, {"name": "set.forall_subtype_range_iff", "description": ""}, {"name": "set.image3_mono", "description": ""}, {"name": "set.inter_subset_right", "description": ""}, {"name": "set.set_of_eq_eq_singleton", "description": ""}, {"name": "set.image_image2", "description": ""}, {"name": "set.ite_right", "description": ""}, {"name": "set.mem_insert", "description": ""}, {"name": "set.ext_iff", "description": ""}, {"name": "set.ne_insert_of_not_mem", "description": ""}, {"name": "set.range_unique", "description": " The range of a function from a `unique` type contains just the\nfunction applied to its single value."}, {"name": "set.inter_compl_self", "description": ""}, {"name": "set.eq_or_mem_of_mem_insert", "description": ""}, {"name": "set.image2_singleton_left", "description": ""}, {"name": "set.image_subset_preimage_of_inverse", "description": ""}, {"name": "set.set_of_or", "description": ""}, {"name": "set.insert_union", "description": ""}, {"name": "set.nonempty.image", "description": ""}, {"name": "set.mem_image_iff_bex", "description": ""}, {"name": "set.set_of_bijective", "description": ""}, {"name": "set.has_coe_to_sort", "description": "Coercion from a set to the corresponding subtype."}, {"name": "set.preimage_preimage", "description": ""}, {"name": "set.eq_preimage_subtype_val_iff", "description": ""}, {"name": "set.image2_distrib_subset_right", "description": "The other direction does not hold because of the `u`-`u` cross terms on the RHS."}, {"name": "set.nonempty.image2", "description": ""}, {"name": "set.lt_eq_ssubset", "description": ""}, {"name": "set.diff_compl", "description": ""}, {"name": "set.preimage_image_eq", "description": ""}, {"name": "set.image2_empty_right", "description": ""}, {"name": "set_coe.forall'", "description": ""}, {"name": "set.image2_image2_right", "description": ""}, {"name": "set.nonempty_image_iff", "description": ""}, {"name": "set.inter_eq_right_iff_subset", "description": ""}, {"name": "set.preimage_id'", "description": ""}, {"name": "set.image2_nonempty_iff", "description": ""}, {"name": "set.powerset_inter", "description": ""}, {"name": "function.surjective.image_surjective", "description": ""}, {"name": "set.nonempty_of_ssubset'", "description": ""}, {"name": "set.subset_def", "description": ""}, {"name": "set.inclusion", "description": "`inclusion` is the \"identity\" function between two subsets `s` and `t`, where `s \u2286 t`"}, {"name": "set.image3_congr", "description": ""}, {"name": "set.compl_range_some", "description": ""}, {"name": "set.subset.rfl", "description": ""}, {"name": "set.union_congr_left", "description": ""}, {"name": "set.ball_insert_iff", "description": ""}, {"name": "set.compl_eq_univ_diff", "description": ""}, {"name": "set.has_union", "description": ""}, {"name": "set.image2_inter_subset_right", "description": ""}, {"name": "set.image_preimage_inter", "description": ""}, {"name": "subtype.range_coe_subtype", "description": "We make this the simp lemma instead of `range_coe`. The reason is that if we write\n for `s : set \u03b1` the function `coe : s \u2192 \u03b1`, then the inferred implicit arguments of `coe` are\n `coe \u03b1 (\u03bb x, x \u2208 s)`."}, {"name": "set.diff_subset_comm", "description": ""}, {"name": "set.union_nonempty", "description": ""}, {"name": "set.union_subset_union_left", "description": ""}, {"name": "set.inter_eq_inter_iff_right", "description": ""}, {"name": "subtype.mem", "description": "See also `subtype.prop`"}, {"name": "subtype.exists_set_subtype", "description": ""}, {"name": "set.union_eq_union_iff_left", "description": ""}, {"name": "set.subsingleton.monotone_on", "description": ""}, {"name": "set.diff_subset_iff", "description": ""}, {"name": "set.union_eq_diff_union_diff_union_inter", "description": ""}, {"name": "set.image2_subset", "description": "image2 is monotone with respect to `\u2286`."}, {"name": "set.image3_congr'", "description": "A common special case of `image3_congr`"}, {"name": "set.preimage_inter", "description": ""}, {"name": "set.diff_union_inter", "description": ""}, {"name": "set.inter_right_comm", "description": ""}, {"name": "set.insert_diff_self_of_not_mem", "description": ""}, {"name": "set.image2_subset_left", "description": ""}, {"name": "set.mem_sep", "description": ""}, {"name": "set.image2_inter_subset_left", "description": ""}, {"name": "set.range_inr_inter_range_inl", "description": ""}, {"name": "set.disjoint_left", "description": ""}, {"name": "subtype.coe_image", "description": ""}, {"name": "set.preimage_const_of_mem", "description": ""}, {"name": "set.sep_set_of", "description": ""}, {"name": "set.preimage_eq_preimage'", "description": ""}, {"name": "set.exists_subtype_range_iff", "description": ""}, {"name": "set.set_of_app_iff", "description": ""}, {"name": "set.image2_distrib_subset_left", "description": "The other direction does not hold because of the `s`-`s` cross terms on the RHS."}, {"name": "set.compl_subset_compl", "description": ""}, {"name": "set.diff_inter", "description": ""}, {"name": "set.subsingleton.induction_on", "description": ""}, {"name": "set.image_image2_antidistrib", "description": ""}, {"name": "set.inter_subset_inter", "description": ""}, {"name": "prod.range_snd", "description": ""}, {"name": "has_subset.subset.disjoint_compl_right", "description": "**Alias** of the reverse direction of `set.disjoint_compl_right_iff_subset`."}, {"name": "set.strict_anti_on_singleton", "description": ""}, {"name": "set.union_assoc", "description": ""}, {"name": "set.coe_set_of", "description": ""}, {"name": "set.subsingleton_univ", "description": ""}, {"name": "set.range_iff_surjective", "description": ""}, {"name": "set.inter_compl_nonempty_iff", "description": ""}, {"name": "set.sep_subset", "description": ""}, {"name": "set.is_compl_range_some_none", "description": ""}, {"name": "set.mem_image2", "description": ""}, {"name": "set.diff_eq_empty", "description": ""}, {"name": "set.decidable_sdiff", "description": ""}, {"name": "set.image2_assoc", "description": ""}, {"name": "set.insert_union_distrib", "description": ""}, {"name": "set.preimage_ite", "description": ""}, {"name": "set.nonempty.not_subset_empty", "description": ""}, {"name": "set.diff_diff_right", "description": ""}, {"name": "set.preimage_univ", "description": ""}, {"name": "set.has_insert.insert.nonempty", "description": ""}, {"name": "set.mem_range_of_mem_image", "description": ""}, {"name": "set.image_union", "description": ""}, {"name": "set.compl_set_of", "description": ""}, {"name": "set.image2_image_left_anticomm", "description": "Symmetric of `set.image_image2_antidistrib_left`."}, {"name": "set.has_subset.subset.is_antisymm", "description": ""}, {"name": "set.image2_comm", "description": ""}, {"name": "set.inter_distrib_right", "description": ""}, {"name": "set.union_diff_distrib", "description": ""}, {"name": "set_coe.forall", "description": ""}, {"name": "set.mem_union_left", "description": ""}, {"name": "set.powerset_empty", "description": ""}, {"name": "set.range_nonempty_iff_nonempty", "description": ""}, {"name": "set.compl_union_self", "description": ""}, {"name": "disjoint.inter_eq", "description": ""}, {"name": "set.mem_compl_iff", "description": ""}, {"name": "set.boolean_algebra", "description": ""}, {"name": "set.ssubset_singleton_iff", "description": ""}, {"name": "set.range_inl_inter_range_inr", "description": ""}, {"name": "set.eq_of_inclusion_surjective", "description": ""}, {"name": "set.image_image", "description": "A variant of `image_comp`, useful for rewriting"}, {"name": "set.range_factorization_coe", "description": ""}, {"name": "set.pair_eq_singleton", "description": ""}, {"name": "set.range_subset_iff", "description": ""}, {"name": "set.subset_union_of_subset_right", "description": ""}, {"name": "set.insert_nonempty", "description": ""}, {"name": "set.subsingleton.strict_mono_on", "description": ""}, {"name": "set.image_surjective", "description": ""}, {"name": "set.preimage_compl_eq_image_compl", "description": ""}, {"name": "set.union_left_comm", "description": ""}, {"name": "set.image2_union_left", "description": ""}, {"name": "set.image2_congr'", "description": "A common special case of `image2_congr`"}, {"name": "set.inter_def", "description": ""}, {"name": "set.range_eval", "description": ""}, {"name": "set.subset_range_iff_exists_image_eq", "description": ""}, {"name": "set.not_mem_of_mem_compl", "description": ""}, {"name": "set.image_image2_distrib_left", "description": "Symmetric of `set.image2_image_left_comm`."}, {"name": "set.right_inverse_range_splitting", "description": ""}, {"name": "set.monotone_on_singleton", "description": ""}, {"name": "set.subset.refl", "description": ""}, {"name": "set.preimage_surjective", "description": ""}, {"name": "set.image_preimage_subset", "description": ""}, {"name": "set.image_subset", "description": " Image is monotone with respect to `\u2286`. See `set.monotone_image` for the statement in\nterms of `\u2264`."}, {"name": "set.image2_right", "description": ""}, {"name": "set.mem_union", "description": ""}, {"name": "set.union_union_distrib_right", "description": ""}, {"name": "function.semiconj.set_image", "description": ""}, {"name": "set.empty_ssubset", "description": ""}, {"name": "set.image2_left", "description": ""}, {"name": "set.nonempty.some", "description": " Extract a witness from `s.nonempty`. This function might be used instead of case analysis\non the argument. Note that it makes a proof depend on the `classical.choice` axiom."}, {"name": "set.subsingleton_is_top", "description": ""}, {"name": "set.insert_eq_self", "description": ""}, {"name": "set.subsingleton_of_forall_eq", "description": ""}, {"name": "set.preimage_injective", "description": ""}, {"name": "set.range_nonempty", "description": ""}, {"name": "set.range_eq_iff", "description": ""}, {"name": "set.sep_true", "description": ""}, {"name": "set.ite_empty_right", "description": ""}, {"name": "set.image_image2_antidistrib_right", "description": "Symmetric of `set.image_image2_right_anticomm`."}, {"name": "set.decidable_set_of", "description": ""}, {"name": "set.exists_range_iff'", "description": ""}, {"name": "set.insert_idem", "description": ""}, {"name": "set.diff_subset_diff_right", "description": ""}, {"name": "set.subset_of_mem_powerset", "description": ""}, {"name": "set.range_inr_union_range_inl", "description": ""}, {"name": "set.mem_image_of_mem", "description": ""}, {"name": "set.preimage_empty", "description": ""}, {"name": "set.inter_empty", "description": ""}, {"name": "set.mem_of_mem_inter_right", "description": ""}, {"name": "set.exists_image_iff", "description": ""}, {"name": "set.nonempty.of_image2_right", "description": ""}, {"name": "set.top_eq_univ", "description": ""}, {"name": "set.has_inter", "description": ""}, {"name": "set.image2", "description": "The image of a binary function `f : \u03b1 \u2192 \u03b2 \u2192 \u03b3` as a function `set \u03b1 \u2192 set \u03b2 \u2192 set \u03b3`.\n Mathematically this should be thought of as the image of the corresponding function `\u03b1 \u00d7 \u03b2 \u2192 \u03b3`."}, {"name": "set.union_eq_left_iff_subset", "description": ""}, {"name": "set.subset.trans", "description": ""}, {"name": "set_coe_cast", "description": ""}, {"name": "set.image_image2_right_comm", "description": "Symmetric of `set.image_image2_distrib_right`."}, {"name": "set.ssubset_insert", "description": ""}, {"name": "set.inter_inter_distrib_right", "description": ""}, {"name": "set.range_eq_empty_iff", "description": ""}, {"name": "set.mem_union_eq", "description": ""}, {"name": "set.ite_same", "description": ""}, {"name": "set.surjective_onto_image", "description": ""}, {"name": "set.compl_image_set_of", "description": ""}, {"name": "set.inter_subset_ite", "description": ""}, {"name": "set.nonempty_of_nonempty_preimage", "description": ""}, {"name": "set.inter_union_diff", "description": ""}, {"name": "set.image2_image_left_comm", "description": "Symmetric of `set.image_image2_distrib_left`."}, {"name": "set.image2_subset_right", "description": ""}, {"name": "set.bex_insert_iff", "description": ""}, {"name": "set.union_eq_self_of_subset_left", "description": ""}, {"name": "set.image_factorization_eq", "description": ""}, {"name": "set.unique_empty", "description": "There is exactly one set of a type that is empty."}, {"name": "set.union_insert", "description": ""}, {"name": "set.ssubset_iff_insert", "description": ""}, {"name": "subsingleton.eq_univ_of_nonempty", "description": ""}, {"name": "set.union_subset", "description": ""}, {"name": "set.subset_inter", "description": ""}, {"name": "set.sep_inter_sep", "description": ""}, {"name": "set.nonempty_of_ssubset", "description": ""}, {"name": "set.image_image2_distrib", "description": ""}, {"name": "set.inter_comm", "description": ""}, {"name": "set.exists_eq_singleton_iff_nonempty_subsingleton", "description": ""}, {"name": "subtype.preimage_coe_nonempty", "description": ""}, {"name": "set.inter_eq_self_of_subset_right", "description": ""}, {"name": "set.range_quot_mk", "description": ""}, {"name": "set.insert_ne_self", "description": ""}, {"name": "set.insert_eq_of_mem", "description": ""}, {"name": "set.inter_eq_inter_iff_left", "description": ""}, {"name": "set.singleton_subset_iff", "description": ""}, {"name": "set.subsingleton_iff_singleton", "description": ""}, {"name": "set.nonempty_inter_iff_exists_right", "description": ""}, {"name": "set.preimage_inl_image_inr", "description": ""}, {"name": "set.range_some_inter_none", "description": ""}, {"name": "set.range_image", "description": ""}, {"name": "set.diff_univ", "description": ""}, {"name": "set.is_compl_range_inl_range_inr", "description": ""}, {"name": "set.inclusion_self", "description": ""}, {"name": "set.mem_inter_iff", "description": ""}, {"name": "set.subset.antisymm", "description": ""}, {"name": "set.inclusion_eq_id", "description": ""}, {"name": "set.empty_inter", "description": ""}, {"name": "function.injective.nonempty_apply_iff", "description": ""}, {"name": "set.compl_empty_iff", "description": ""}, {"name": "set.union_eq_union_iff_right", "description": ""}, {"name": "set.inter_assoc", "description": ""}, {"name": "set.subsingleton_coe_of_subsingleton", "description": " The `coe_sort` of a set `s` in a subsingleton type is a subsingleton.\nFor the corresponding result for `subtype`, see `subtype.subsingleton`."}, {"name": "set.image2_image_right", "description": ""}, {"name": "function.injective.exists_unique_of_mem_range", "description": ""}, {"name": "subtype.range_val_subtype", "description": ""}, {"name": "set.mem_of_mem_diff", "description": ""}, {"name": "set.union_inter_distrib_right", "description": ""}, {"name": "set.compl_range_inl", "description": ""}, {"name": "set.mem_compl_eq", "description": ""}, {"name": "set.ite_inter_self", "description": ""}, {"name": "set_coe.ext", "description": ""}, {"name": "set.subsingleton_coe", "description": " `s`, coerced to a type, is a subsingleton type if and only if `s`\nis a subsingleton set."}, {"name": "set.has_ssubset.ssubset.is_asymm", "description": ""}, {"name": "set.eq_preimage_iff_image_eq", "description": ""}, {"name": "set.preimage_singleton_eq_empty", "description": ""}, {"name": "set.image_id'", "description": "A variant of `image_id`"}, {"name": "set.union_def", "description": ""}, {"name": "set.compl_empty", "description": ""}, {"name": "set.compl_inter", "description": ""}, {"name": "set.exists_of_ssubset", "description": ""}, {"name": "set.union_eq_compl_compl_inter_compl", "description": ""}, {"name": "set.insert_image_compl_eq_range", "description": ""}, {"name": "set.empty_union", "description": ""}, {"name": "set.inclusion_comp_inclusion", "description": ""}, {"name": "set.pi_set_coe.can_lift", "description": ""}, {"name": "set.diff_diff_comm", "description": ""}, {"name": "set.coe_comp_range_factorization", "description": ""}, {"name": "subtype.preimage_coe_eq_preimage_coe_iff", "description": ""}, {"name": "set.preimage_inr_range_inl", "description": ""}, {"name": "subtype.coe_image_of_subset", "description": ""}, {"name": "set.diff_eq", "description": ""}, {"name": "set.empty_diff", "description": ""}, {"name": "set.preimage_set_of_eq", "description": ""}, {"name": "set.subset_empty_iff", "description": ""}, {"name": "set.range_diff_image", "description": ""}, {"name": "set.union_inter_distrib_left", "description": ""}, {"name": "set.mem_image3", "description": ""}, {"name": "set.eq_empty_of_subset_empty", "description": ""}, {"name": "set.nmem_set_of_eq", "description": ""}, {"name": "set.image_factorization", "description": "Restriction of `f` to `s` factors through `s.image_factorization f : s \u2192 f '' s`."}, {"name": "set.preimage_diff", "description": ""}, {"name": "set.preimage_subset_preimage_iff", "description": ""}, {"name": "set.preimage_image_preimage", "description": ""}, {"name": "set.union_subset_union", "description": ""}, {"name": "set.nonempty.some_mem", "description": ""}, {"name": "set.union_singleton", "description": ""}, {"name": "set.eq_of_not_mem_of_mem_insert", "description": ""}, {"name": "set.mem_diff_singleton", "description": ""}, {"name": "set.range_id", "description": ""}, {"name": "set.union_distrib_right", "description": ""}, {"name": "set.univ_eq_true_false", "description": ""}, {"name": "set.inter_congr_right", "description": ""}, {"name": "set.range_factorization_eq", "description": ""}, {"name": "set.le_eq_subset", "description": ""}, {"name": "set.coe_inclusion", "description": ""}, {"name": "set.insert_subset_insert_iff", "description": ""}, {"name": "set.compl_singleton_eq", "description": ""}, {"name": "set.powerset_nonempty", "description": ""}, {"name": "set.image2_empty_left", "description": ""}, {"name": "function.injective.preimage_image", "description": ""}, {"name": "set.preimage_inter_range", "description": ""}, {"name": "set.subsingleton_of_image", "description": "`s` is a subsingleton, if its image of an injective function is."}, {"name": "set.ssubset_iff_subset_ne", "description": ""}, {"name": "set.subset_preimage_univ", "description": ""}, {"name": "set.inter_union_distrib_right", "description": ""}, {"name": "set.nonempty.preimage'", "description": ""}, {"name": "set.singleton_eq_singleton_iff", "description": ""}, {"name": "set.inter_congr_left", "description": ""}, {"name": "set.has_ssubset.ssubset.is_trans", "description": ""}, {"name": "set.ite_inter_compl_self", "description": ""}, {"name": "set.has_le", "description": ""}, {"name": "set.image_comp", "description": ""}, {"name": "subtype.range_coe", "description": ""}, {"name": "set.subset.antisymm_iff", "description": ""}, {"name": "set.preimage_singleton_nonempty", "description": ""}, {"name": "set.preimage_comp", "description": ""}, {"name": "set.subsingleton", "description": "A set `s` is a `subsingleton`, if it has at most one element."}, {"name": "set.inter_preimage_subset", "description": ""}, {"name": "set.preimage_const_of_not_mem", "description": ""}, {"name": "set.not_mem_compl_iff", "description": ""}, {"name": "set.range_inl_union_range_inr", "description": ""}, {"name": "set.coe_eq_subtype", "description": ""}, {"name": "set.decidable_inter", "description": ""}, {"name": "subsingleton.set_cases", "description": ""}, {"name": "set.diff_union_self", "description": ""}, {"name": "set.image_inter_nonempty_iff", "description": ""}, {"name": "set.nonempty_coe_sort", "description": ""}, {"name": "set.sep_mem_eq", "description": ""}, {"name": "set.set_of_mem_eq", "description": ""}, {"name": "set.image_compl_subset", "description": ""}, {"name": "subtype.preimage_coe_eq_empty", "description": ""}, {"name": "set.inter_union_distrib_left", "description": ""}, {"name": "set.mem_of_mem_of_subset", "description": ""}, {"name": "set.left_inverse_range_splitting", "description": ""}, {"name": "set.preimage_range_inter", "description": ""}, {"name": "set.preimage_union", "description": ""}, {"name": "set.subsingleton_singleton", "description": ""}, {"name": "set.image.nonempty", "description": ""}, {"name": "set.eq_univ_of_forall", "description": ""}, {"name": "set.image_inter_preimage", "description": ""}, {"name": "set.inter_univ", "description": ""}, {"name": "set.inter_insert_of_not_mem", "description": ""}, {"name": "set.eq_sep_of_subset", "description": ""}, {"name": "set.mem_union.elim", "description": ""}, {"name": "set.range_quotient_mk", "description": ""}, {"name": "set.ite_diff_self", "description": ""}, {"name": "set.preimage_range", "description": ""}, {"name": "set.ite_mono", "description": ""}, {"name": "set.subset_image_diff", "description": ""}, {"name": "set.compl_univ_iff", "description": ""}, {"name": "set.inclusion_mk", "description": ""}, {"name": "set.disjoint_right", "description": ""}, {"name": "function.injective.preimage_surjective", "description": ""}, {"name": "set.subsingleton_of_univ_subsingleton", "description": ""}, {"name": "function.surjective.range_eq", "description": "**Alias** of the reverse direction of `set.range_iff_surjective`."}, {"name": "set.inf_eq_inter", "description": ""}, {"name": "set.mem_diff_singleton_empty", "description": ""}, {"name": "set.preimage_eq_preimage", "description": ""}, {"name": "set.sep_empty", "description": ""}, {"name": "set.mem_of_mem_insert_of_ne", "description": ""}, {"name": "set.image2_subset_iff", "description": ""}, {"name": "set.union_diff_cancel'", "description": ""}, {"name": "set.mem_image_iff_of_inverse", "description": ""}, {"name": "prod.range_fst", "description": ""}, {"name": "prod.has_to_tactic_format", "description": ""}, {"name": "tactic.mk_congr_arg", "description": "(mk_congr_arg h\u2081 h\u2082) is a more efficient version of (mk_app `congr_arg [h\u2081, h\u2082])"}, {"name": "tactic.unsafe_change", "description": "Change the target of the main goal.\n  The input expression must be definitionally equal to the current target.\n  The tactic does not check whether `e`\n  is definitionally equal to the current target. The error will only be detected by the kernel type checker."}, {"name": "reflected.has_to_tactic_format", "description": ""}, {"name": "tactic.clear_lst", "description": ""}, {"name": "tactic.trace", "description": ""}, {"name": "tactic.mk_const", "description": "Return `expr.const c [l_1, ..., l_n]` where l_i's are fresh universe meta-variables."}, {"name": "tactic.first", "description": "`first [t_1, ..., t_n]` applies the first tactic that doesn't fail.\n  The tactic fails if all t_i's fail."}, {"name": "tactic.mk_eq_refl", "description": "(mk_eq_refl h) is a more efficient version of (mk_app `eq.refl [h])"}, {"name": "tactic_state.has_to_string", "description": ""}, {"name": "tactic.focus1", "description": ""}, {"name": "tactic.change", "description": "Change the target of the main goal.\n  The input expression must be definitionally equal to the current target.\n  If `check` is `ff`, then the tactic does not check whether `e`\n  is definitionally equal to the current target. If it is not,\n  then the error will only be detected by the kernel type checker."}, {"name": "tactic.revertible_local_context", "description": " Get the revertible part of the local context. These are the hypotheses that\nappear after the last frozen local instance in the local context. We call them\nrevertible because `revert` can revert them, unlike those hypotheses which occur\nbefore a frozen instance."}, {"name": "tactic.capture", "description": "`capture t` acts like `t`, but succeeds with a result containing either the returned value\nor the exception.\nChanges made by `t` to the `tactic_state` are preserved in both cases.\n\nThe result can be used to inspect the error message, or passed to `unwrap` to rethrow the\nfailure later."}, {"name": "option_to_tactic_format", "description": ""}, {"name": "tactic.admit", "description": "Closes the main goal using sorry."}, {"name": "tactic.unify", "description": "Succeeds if `t` and `s` can be unified using the given transparency setting."}, {"name": "tactic.copy_attribute", "description": "`copy_attribute attr_name c_name p d_name` copy attribute `attr_name` from\n  `src` to `tgt` if it is defined for `src`; make it persistent if `p` is `tt`;\n  if `p` is `none`, the copied attribute is made persistent iff it is persistent on `src`"}, {"name": "tactic.find_same_type", "description": "`find_same_type t es` tries to find in es an expression with type definitionally equal to t"}, {"name": "tactic.mk_congr_fun", "description": "(mk_congr_fun h\u2081 h\u2082) is a more efficient version of (mk_app `congr_fun [h\u2081, h\u2082])"}, {"name": "tactic.pp", "description": ""}, {"name": "tactic.rotate", "description": "Rotate the goals to the left by `n`. That is, put the main goal to the back `n` times."}, {"name": "tactic.mk_mapp", "description": "Similar to `mk_app`, but allows to specify which arguments are explicit/implicit.\n  Example, given `(a b : nat)` then\n  ```lean\n  mk_mapp \"ite\" [some (a > b), none, none, some a, some b]\n  ```\n  returns the application\n  ```lean\n  @ite.{1} nat (a > b) (nat.decidable_gt a b) a b\n  ```"}, {"name": "tactic.open_namespaces", "description": "Return list of currently open namespaces"}, {"name": "tactic.target", "description": "Return target type of the main goal. Fail if tactic_state does not have any goal left."}, {"name": "tactic.is_trace_enabled_for", "description": ""}, {"name": "tactic.save_const_type_info", "description": ""}, {"name": "tactic.timetac", "description": ""}, {"name": "tactic.focus", "description": "`focus [t_1, ..., t_n]` applies t_i to the i-th goal. Fails if the number of\ngoals is not n. Returns the results of t_i (one per goal)."}, {"name": "option.has_to_tactic_format", "description": ""}, {"name": "tactic.find_assumption", "description": ""}, {"name": "tactic.doc_string", "description": "`doc_string env d k` returns the doc string for `d` (if available)"}, {"name": "tactic.cases", "description": "Similar to `cases_core`, but `e` doesn't need to be a hypothesis.\n   Remark, it reverts dependencies using `revert_kdeps`.\n\n   Two different transparency modes are used `md` and `dmd`.\n   The mode `md` is used with `cases_core` and `dmd` with `generalize` and `revert_kdeps`.\n\n   It returns the constructor names associated with each new goal and the newly\n   introduced hypotheses. Note that while `cases_core` may return \"new\n   hypotheses\" that are not local constants, this tactic only returns local\n   constants."}, {"name": "tactic.local_context", "description": "Return the hypothesis in the main goal. Fail if tactic_state does not have any goal left."}, {"name": "tactic.any_goals'", "description": "Apply the given tactic to any goal where it succeeds. The tactic succeeds only if\n  tac succeeds for at least one goal."}, {"name": "tactic.apply_instance", "description": "Try to solve the main goal using type class resolution."}, {"name": "tactic.whnf_target", "description": ""}, {"name": "tactic_state.get_options", "description": ""}, {"name": "tactic.get_env", "description": ""}, {"name": "tactic_state", "description": ""}, {"name": "tactic.set_basic_attribute", "description": "Set attribute `attr_name` for constant `c_name` with the given priority.\n  If the priority is none, then use default"}, {"name": "tactic.cleanup", "description": "Remark: set_goals will erase any solved goal"}, {"name": "tactic.is_prop", "description": ""}, {"name": "tactic.kdepends_on", "description": "Return tt iff `t` \"occurs\" in `e`. The occurrence checking is performed using\n   keyed matching with the given transparency setting.\n\n   We say `t` occurs in `e` by keyed matching iff there is a subterm `s`\n   s.t. `t` and `s` have the same head, and `is_def_eq t s md`\n\n   The main idea is to minimize the number of `is_def_eq` checks\n   performed."}, {"name": "tactic.seq_focus", "description": "Applies `tac1` to the main goal, then applies each of the tactics in `tacs2` to\none of the produced subgoals (like `focus'`)."}, {"name": "tactic.decl_name", "description": "Name of the declaration currently being elaborated."}, {"name": "tactic.enable_tags", "description": "Enable/disable goal tagging."}, {"name": "tactic.match_or", "description": ""}, {"name": "tactic.seq_focus'", "description": "Applies `tac1` to the main goal, then applies each of the tactics in `tacs2` to\none of the produced subgoals (like `focus`)."}, {"name": "tactic.revert_kdependencies", "description": "Revert all hypotheses that depend on `e`"}, {"name": "tactic.note", "description": "Add `h : t` to the current goal, given a proof `pr : t`"}, {"name": "tactic.is_assigned", "description": "Return true if the given meta-variable is assigned.\n   Fail if argument is not a meta-variable."}, {"name": "interactive.executor", "description": "Typeclass for custom interaction monads, which provides\n   the information required to convert an interactive-mode\n   construction to a `tactic` which can actually be executed.\n\n   Given a `[monad m]`, `execute_with` explains how to turn a `begin ... end`\n   block, or a `by ...` statement into a `tactic \u03b1` which can actually be\n   executed. The `inhabited` first argument facilitates the passing of an\n   optional configuration parameter `config`, using the syntax:\n   ```lean\n   begin [custom_monad] with config,\n       ...\n   end\n   ```"}, {"name": "interactive.executor.config_type", "description": "Typeclass for custom interaction monads, which provides\n   the information required to convert an interactive-mode\n   construction to a `tactic` which can actually be executed.\n\n   Given a `[monad m]`, `execute_with` explains how to turn a `begin ... end`\n   block, or a `by ...` statement into a `tactic \u03b1` which can actually be\n   executed. The `inhabited` first argument facilitates the passing of an\n   optional configuration parameter `config`, using the syntax:\n   ```lean\n   begin [custom_monad] with config,\n       ...\n   end\n   ```"}, {"name": "interactive.executor.inhabited", "description": "Typeclass for custom interaction monads, which provides\n   the information required to convert an interactive-mode\n   construction to a `tactic` which can actually be executed.\n\n   Given a `[monad m]`, `execute_with` explains how to turn a `begin ... end`\n   block, or a `by ...` statement into a `tactic \u03b1` which can actually be\n   executed. The `inhabited` first argument facilitates the passing of an\n   optional configuration parameter `config`, using the syntax:\n   ```lean\n   begin [custom_monad] with config,\n       ...\n   end\n   ```"}, {"name": "interactive.executor.execute_with", "description": "Typeclass for custom interaction monads, which provides\n   the information required to convert an interactive-mode\n   construction to a `tactic` which can actually be executed.\n\n   Given a `[monad m]`, `execute_with` explains how to turn a `begin ... end`\n   block, or a `by ...` statement into a `tactic \u03b1` which can actually be\n   executed. The `inhabited` first argument facilitates the passing of an\n   optional configuration parameter `config`, using the syntax:\n   ```lean\n   begin [custom_monad] with config,\n       ...\n   end\n   ```"}, {"name": "tactic.get_trace_msg_pos", "description": ""}, {"name": "tactic.save_type_info", "description": "`save_type_info e ref` save (typeof e) at position associated with ref"}, {"name": "tactic.mk_eq_mp", "description": "(mk_eq_mp h\u2081 h\u2082) is a more efficient version of (mk_app `eq.mp [h\u2081, h\u2082])"}, {"name": "tactic.match_app_of", "description": ""}, {"name": "tactic.head_zeta", "description": "(head) zeta reduction. Reduction of let bindings at the head of the expression. `let x : a := b in c` reduces to `c[x/b]`."}, {"name": "tactic_format_expr", "description": ""}, {"name": "tactic.mk_instance", "description": "Try to create an instance of the given type class."}, {"name": "tactic.intron'", "description": "`intron' n` introduces `n` hypotheses and returns the resulting local\nconstants. Fails if there are not at least `n` arguments to introduce. If you do\nnot need the return value, use `intron`."}, {"name": "tactic.result", "description": "Return the partial term/proof constructed so far. Note that the resultant expression\n  may contain variables that are not declarate in the current main goal."}, {"name": "tactic_state.env", "description": ""}, {"name": "tactic.add_inductive", "description": ""}, {"name": "tactic.mk_local'", "description": ""}, {"name": "tactic.exact", "description": "Close the current goal using `e`. Fail if the type of `e` is not definitionally equal to\n   the target type."}, {"name": "tactic.down", "description": ""}, {"name": "tactic.unwrap", "description": "`unwrap r` unwraps a result previously obtained using `capture`.\n\nIf the previous result was a success, this produces its wrapped value.\nIf the previous result was an exception, this \"rethrows\" the exception as if it came\nfrom where it originated.\n\n`do r \u2190 capture t, unwrap r` is identical to `t`, but allows for intermediate tactics to be inserted."}, {"name": "tactic.revert_all", "description": ""}, {"name": "tactic.main_goal", "description": ""}, {"name": "tactic.try_for_time", "description": "Execute `tac` for `max` milliseconds. Useful due to variance\n   in the number of heartbeats taken by various tactics."}, {"name": "tactic.assertv_core", "description": "`assertv_core H T P`, change target to (T -> target) if P has type T."}, {"name": "task.monad", "description": ""}, {"name": "tactic.whnf", "description": "Return `e` in weak head normal form with respect to the given transparency setting.\n   If `unfold_ginductive` is `tt`, then nested and/or mutually recursive inductive datatype constructors\n   and types are unfolded. Recall that nested and mutually recursive inductive datatype declarations\n   are compiled into primitive datatypes accepted by the Kernel."}, {"name": "monad_from_pure_bind", "description": ""}, {"name": "tactic.try_apply_opt_auto_param_for_apply", "description": ""}, {"name": "tactic.solve_aux", "description": "`solve_aux type tac` synthesize an element of 'type' using tactic 'tac'"}, {"name": "tactic.new_goals", "description": " How to order the new goals made from an `apply` tactic.\nSupposing we were applying `e : \u2200 (a:\u03b1) (p : P(a)), Q`\n- `non_dep_first` would produce goals `\u22a2 P(?m)`, `\u22a2 \u03b1`. It puts the P goal at the front because none of the arguments after `p` in `e` depend on `p`. It doesn't matter what the result `Q` depends on.\n- `non_dep_only` would produce goal `\u22a2 P(?m)`.\n- `all` would produce goals `\u22a2 \u03b1`, `\u22a2 P(?m)`."}, {"name": "tactic.new_goals.non_dep_first", "description": " How to order the new goals made from an `apply` tactic.\nSupposing we were applying `e : \u2200 (a:\u03b1) (p : P(a)), Q`\n- `non_dep_first` would produce goals `\u22a2 P(?m)`, `\u22a2 \u03b1`. It puts the P goal at the front because none of the arguments after `p` in `e` depend on `p`. It doesn't matter what the result `Q` depends on.\n- `non_dep_only` would produce goal `\u22a2 P(?m)`.\n- `all` would produce goals `\u22a2 \u03b1`, `\u22a2 P(?m)`."}, {"name": "tactic.new_goals.non_dep_only", "description": " How to order the new goals made from an `apply` tactic.\nSupposing we were applying `e : \u2200 (a:\u03b1) (p : P(a)), Q`\n- `non_dep_first` would produce goals `\u22a2 P(?m)`, `\u22a2 \u03b1`. It puts the P goal at the front because none of the arguments after `p` in `e` depend on `p`. It doesn't matter what the result `Q` depends on.\n- `non_dep_only` would produce goal `\u22a2 P(?m)`.\n- `all` would produce goals `\u22a2 \u03b1`, `\u22a2 P(?m)`."}, {"name": "tactic.new_goals.all", "description": " How to order the new goals made from an `apply` tactic.\nSupposing we were applying `e : \u2200 (a:\u03b1) (p : P(a)), Q`\n- `non_dep_first` would produce goals `\u22a2 P(?m)`, `\u22a2 \u03b1`. It puts the P goal at the front because none of the arguments after `p` in `e` depend on `p`. It doesn't matter what the result `Q` depends on.\n- `non_dep_only` would produce goal `\u22a2 P(?m)`.\n- `all` would produce goals `\u22a2 \u03b1`, `\u22a2 P(?m)`."}, {"name": "tactic.try_for", "description": "Execute tac for 'max' \"heartbeats\". The heartbeat is approx. the maximum number of\n   memory allocations (in thousands) performed by 'tac'. This is a deterministic way of interrupting\n   long running tactics."}, {"name": "list.any_of", "description": ""}, {"name": "tactic.match_eq", "description": ""}, {"name": "tactic.success_if_fail", "description": "`success_if_fail t` acts like `t`, but succeeds if `t` fails and fails if `t`\nsucceeds. Changes made by `t` to the `tactic_state` are preserved only if `t`\nsucceeds."}, {"name": "tactic.save_info", "description": ""}, {"name": "tactic.resolve_constant", "description": "Returns n fully qualified if it refers to a constant, or else fails."}, {"name": "tactic.subst_core", "description": "Given a local constant t, if t has type (lhs = rhs) apply substitution.\n  Otherwise, try to find a local constant that has type of the form (t = t') or (t' = t).\n  The tactic fails if the given expression is not a local constant."}, {"name": "tactic.apply_auto_param", "description": ""}, {"name": "tactic.returnopt", "description": ""}, {"name": "tactic.intros_dep", "description": "Introduces new hypotheses with forward dependencies."}, {"name": "tactic.with_ast", "description": "Run the provided tactic, associating it to the given AST node."}, {"name": "tactic.in_open_namespaces", "description": "Return tt iff 'd' is a declaration in one of the current open namespaces"}, {"name": "tactic.rename_unstable", "description": "Rename a local hypothesis. Unlike `rename` and `rename_many`, this tactic does\nnot preserve the order of hypotheses. Its implementation is simpler (and\ntherefore probably faster) than that of `rename`."}, {"name": "tactic.updateex_env", "description": ""}, {"name": "tactic.has_opt_auto_param", "description": ""}, {"name": "tactic.trace_result", "description": ""}, {"name": "tactic.kdependencies", "description": "Return all hypotheses that depends on `e`\n   The dependency test is performed using `kdepends_on` with the given transparency setting."}, {"name": "tactic.sleep", "description": "Blocks the execution of the current thread for at least `msecs` milliseconds.\n   This tactic is used mainly for debugging purposes."}, {"name": "tactic.seq'", "description": "LCF-style AND_THEN tactic. It applies tac1, and if succeed applies tac2 to each subgoal produced by tac1"}, {"name": "tactic.intro1", "description": "Like `intro` except the name is derived from the bound name in the \u03a0."}, {"name": "tactic.resume", "description": "`resume r` continues execution from a result previously obtained using `capture`.\n\nThis is like `unwrap`, but the `tactic_state` is rolled back to point of capture even upon success."}, {"name": "tactic.abstract", "description": ""}, {"name": "tactic.format_result", "description": "Display the partial term/proof constructed so far. This tactic is *not* equivalent to\n  `do { r \u2190 result, s \u2190 read, return (format_expr s r) }` because this one will format the result with respect\n  to the current goal, and trace_result will do it with respect to the initial goal."}, {"name": "tactic.whnf_no_delta", "description": ""}, {"name": "tactic.assert_core", "description": "`assert_core H T`, adds a new goal for T, and change target to `T -> target`."}, {"name": "tactic.frozen_local_instances", "description": ""}, {"name": "tactic.fail_if_success", "description": "`fail_if_success t` acts like `t`, but succeeds if `t` fails and fails if `t`\nsucceeds. Changes made by `t` to the `tactic_state` are preserved only if `t`\nsucceeds."}, {"name": "tactic.generalizes", "description": ""}, {"name": "tactic.istep", "description": ""}, {"name": "tactic.fapply", "description": "Same as `apply` but __all__ arguments that weren't inferred are added to goal list."}, {"name": "tactic.assert", "description": "`assert h t`, adds a new goal for t, and the hypothesis `h : t` in the current goal."}, {"name": "tactic.match_heq", "description": ""}, {"name": "tactic.skip", "description": "Does nothing."}, {"name": "tactic.iterate_exactly", "description": "`iterate_exactly n t` iterates `t` `n` times, returning the result of\neach iteration. If any iteration fails, the whole tactic fails."}, {"name": "interactive.executor.execute_with_explicit", "description": ""}, {"name": "tactic.by_cases", "description": "`by_cases p h` splits the main goal into two cases, assuming `h : p` in the\nfirst branch, and `h : \u00ac p` in the second branch. The expression `p` needs to\nbe a proposition.\n\nThe produced proof term is `dite p ?m_1 ?m_2`."}, {"name": "tactic.mk_app", "description": "Helper tactic for creating simple applications where some arguments are inferred using\n  type inference.\n\n  Example, given\n  ```lean\n      rel.{l_1 l_2} : Pi (\u03b1 : Type.{l_1}) (\u03b2 : \u03b1 -> Type.{l_2}), (Pi x : \u03b1, \u03b2 x) -> (Pi x : \u03b1, \u03b2 x) -> , Prop\n      nat     : Type\n      real    : Type\n      vec.{l} : Pi (\u03b1 : Type l) (n : nat), Type.{l1}\n      f g     : Pi (n : nat), vec real n\n  ```\n  then\n  ```lean\n  mk_app_core semireducible \"rel\" [f, g]\n  ```\n  returns the application\n  ```lean\n  rel.{1 2} nat (fun n : nat, vec real n) f g\n  ```\n\n  The unification constraints due to type inference are solved using the transparency `md`."}, {"name": "tactic.when_tracing", "description": "Execute tac only if option trace.n is set to true."}, {"name": "tactic.intro", "description": " Pi or elet introduction.\nGiven the tactic state `\u22a2 \u03a0 x : \u03b1, Y`, ``intro `hello`` will produce the state `hello : \u03b1 \u22a2 Y[x/hello]`.\nReturns the new local constant. Similarly for `elet` expressions.\nIf the target is not a Pi or elet it will try to put it in WHNF."}, {"name": "tactic.rename_many", "description": "Rename local hypotheses according to the given `name_map`. The `name_map`\ncontains as keys those hypotheses that should be renamed; the associated values\nare the new names.\n\nThis tactic can only rename hypotheses which occur after the last frozen local\ninstance. If you need to rename earlier hypotheses, try\n`unfreezing (rename_many ...)`.\n\nIf `strict` is true, we fail if `name_map` refers to hypotheses that do not\nappear in the local context or that appear before a frozen local instance.\nConversely, if `strict` is false, some entries of `name_map` may be silently\nignored.\n\nIf `use_unique_names` is true, the keys of `name_map` should be the unique names\nof hypotheses to be renamed. Otherwise, the keys should be display names.\n\nNote that we allow shadowing, so renamed hypotheses may have the same name\nas other hypotheses in the context. If `use_unique_names` is false and there are\nmultiple hypotheses with the same display name in the context, they are all\nrenamed."}, {"name": "tactic.decorate_ex", "description": "Decorate t's exceptions with msg."}, {"name": "tactic.try_apply_opt_auto_param", "description": ""}, {"name": "tactic.has_opt_auto_param_for_apply", "description": ""}, {"name": "tactic.mk_tagged_proof", "description": "Convenience function for creating ` for proofs."}, {"name": "tactic.transparency", "description": " A parameter representing how aggressively definitions should be unfolded when trying to decide if two terms match, unify or are definitionally equal.\nBy default, theorem declarations are never unfolded.\n- `all` will unfold everything, including macros and theorems. Except projection macros.\n- `semireducible` will unfold everything except theorems and definitions tagged as irreducible.\n- `instances` will unfold all class instance definitions and definitions tagged with reducible.\n- `reducible` will only unfold definitions tagged with the `reducible` attribute.\n- `none` will never unfold anything.\n[NOTE] You are not allowed to tag a definition with more than one of `reducible`, `irreducible`, `semireducible` attributes.\n[NOTE] there is a config flag `m_unfold_lemmas`that will make it unfold theorems."}, {"name": "tactic.transparency.all", "description": " A parameter representing how aggressively definitions should be unfolded when trying to decide if two terms match, unify or are definitionally equal.\nBy default, theorem declarations are never unfolded.\n- `all` will unfold everything, including macros and theorems. Except projection macros.\n- `semireducible` will unfold everything except theorems and definitions tagged as irreducible.\n- `instances` will unfold all class instance definitions and definitions tagged with reducible.\n- `reducible` will only unfold definitions tagged with the `reducible` attribute.\n- `none` will never unfold anything.\n[NOTE] You are not allowed to tag a definition with more than one of `reducible`, `irreducible`, `semireducible` attributes.\n[NOTE] there is a config flag `m_unfold_lemmas`that will make it unfold theorems."}, {"name": "tactic.transparency.semireducible", "description": " A parameter representing how aggressively definitions should be unfolded when trying to decide if two terms match, unify or are definitionally equal.\nBy default, theorem declarations are never unfolded.\n- `all` will unfold everything, including macros and theorems. Except projection macros.\n- `semireducible` will unfold everything except theorems and definitions tagged as irreducible.\n- `instances` will unfold all class instance definitions and definitions tagged with reducible.\n- `reducible` will only unfold definitions tagged with the `reducible` attribute.\n- `none` will never unfold anything.\n[NOTE] You are not allowed to tag a definition with more than one of `reducible`, `irreducible`, `semireducible` attributes.\n[NOTE] there is a config flag `m_unfold_lemmas`that will make it unfold theorems."}, {"name": "tactic.transparency.instances", "description": " A parameter representing how aggressively definitions should be unfolded when trying to decide if two terms match, unify or are definitionally equal.\nBy default, theorem declarations are never unfolded.\n- `all` will unfold everything, including macros and theorems. Except projection macros.\n- `semireducible` will unfold everything except theorems and definitions tagged as irreducible.\n- `instances` will unfold all class instance definitions and definitions tagged with reducible.\n- `reducible` will only unfold definitions tagged with the `reducible` attribute.\n- `none` will never unfold anything.\n[NOTE] You are not allowed to tag a definition with more than one of `reducible`, `irreducible`, `semireducible` attributes.\n[NOTE] there is a config flag `m_unfold_lemmas`that will make it unfold theorems."}, {"name": "tactic.transparency.reducible", "description": " A parameter representing how aggressively definitions should be unfolded when trying to decide if two terms match, unify or are definitionally equal.\nBy default, theorem declarations are never unfolded.\n- `all` will unfold everything, including macros and theorems. Except projection macros.\n- `semireducible` will unfold everything except theorems and definitions tagged as irreducible.\n- `instances` will unfold all class instance definitions and definitions tagged with reducible.\n- `reducible` will only unfold definitions tagged with the `reducible` attribute.\n- `none` will never unfold anything.\n[NOTE] You are not allowed to tag a definition with more than one of `reducible`, `irreducible`, `semireducible` attributes.\n[NOTE] there is a config flag `m_unfold_lemmas`that will make it unfold theorems."}, {"name": "tactic.transparency.none", "description": " A parameter representing how aggressively definitions should be unfolded when trying to decide if two terms match, unify or are definitionally equal.\nBy default, theorem declarations are never unfolded.\n- `all` will unfold everything, including macros and theorems. Except projection macros.\n- `semireducible` will unfold everything except theorems and definitions tagged as irreducible.\n- `instances` will unfold all class instance definitions and definitions tagged with reducible.\n- `reducible` will only unfold definitions tagged with the `reducible` attribute.\n- `none` will never unfold anything.\n[NOTE] You are not allowed to tag a definition with more than one of `reducible`, `irreducible`, `semireducible` attributes.\n[NOTE] there is a config flag `m_unfold_lemmas`that will make it unfold theorems."}, {"name": "tactic.set_main_tag", "description": ""}, {"name": "tactic.to_expr_strict", "description": ""}, {"name": "tactic.read", "description": "Get the tactic_state."}, {"name": "tactic.match_not", "description": ""}, {"name": "tactic.all_goals'", "description": "Apply the given tactic to all goals."}, {"name": "tactic.opt_to_tac", "description": ""}, {"name": "tactic.try_core", "description": "`try_core t` acts like `t`, but succeeds even if `t` fails. It returns the\nresult of `t` if `t` succeeded and `none` otherwise."}, {"name": "tactic.any_hyp", "description": ""}, {"name": "tactic.olean_doc_strings", "description": " Returns a list of all top-level (`/-! ... -/`) docstrings in the active module and imported ones.\nThe returned object is a list of modules, indexed by `(some filename)` for imported modules\nand `none` for the active one, where each module in the list is paired with a list\nof `(position_in_file, docstring)` pairs."}, {"name": "tactic.mk_local_pis", "description": ""}, {"name": "tactic.write", "description": "Set the tactic_state."}, {"name": "tactic.match_ne", "description": ""}, {"name": "tactic.introv", "description": ""}, {"name": "tactic.definev_core", "description": "`definev_core H T P`, change target to `let H : T := P in target` if P has type T."}, {"name": "tactic.mk_mvar", "description": "Create a fresh universe `?u`, a metavariable `?T : Type.{?u}`,\n  and return metavariable `?M : ?T`.\n  This action can be used to create a meta-variable when\n  we don't know its type at creation time"}, {"name": "tactic.eval_expr", "description": "(eval_expr \u03b1 e) evaluates 'e' IF 'e' has type '\u03b1'."}, {"name": "tactic.trace_state", "description": ""}, {"name": "tactic.intro_fresh", "description": "A variant of `intro` which makes sure that the introduced hypothesis's name is\nunique in the context. If there is no hypothesis named `n` in the context yet,\n`intro_fresh n` is the same as `intro n`. If there is already a hypothesis named\n`n`, the new hypothesis is named `n_1` (or `n_2` if `n_1` already exists, etc.).\nIf `offset` is given, the new names are `n_offset`, `n_offset+1` etc.\n\nIf `n` is `_`, `intro_fresh n` is the same as `intro1`. The `offset` is ignored\nin this case."}, {"name": "tactic.is_class", "description": "Return true if the given expression is a type class."}, {"name": "tactic.apply", "description": ""}, {"name": "tactic.get_main_tag", "description": ""}, {"name": "tactic.instantiate_mvars", "description": "instantiate assigned metavariables in the given expression"}, {"name": "tactic.try", "description": "`try t` acts like `t`, but succeeds even if `t` fails."}, {"name": "tactic.set_env_core", "description": "Changes the environment to the `new_env`.\nThe new environment does not need to be a descendant of the old one.\nUse with care."}, {"name": "tactic.intron", "description": ""}, {"name": "tactic.iterate'", "description": "`iterate' t` repeats `t` 100.000 times or until `t` fails."}, {"name": "tactic.all_goals", "description": "Apply the given tactic to all goals. Return one result per goal."}, {"name": "tactic.match_and", "description": ""}, {"name": "tactic.define_core", "description": "`define_core H T`, adds a new goal for T, and change target to  `let H : T := ?M in target` in the current goal."}, {"name": "tactic.eval_pexpr", "description": ""}, {"name": "tactic.step", "description": "Auxiliary definition used to implement begin ... end blocks"}, {"name": "expr.has_to_tactic_format", "description": ""}, {"name": "tactic.head_beta", "description": "(head) beta reduction. `(\u03bb x, B) c` reduces to `B[x/c]`."}, {"name": "tactic.unset_attribute", "description": "`unset_attribute attr_name c_name`"}, {"name": "tactic.head_eta", "description": "(head) eta reduction. `(\u03bb x, f x)` reduces to `f`."}, {"name": "tactic.is_protected_decl", "description": "check if `n` is the name of a protected declaration"}, {"name": "tactic.define", "description": "`define h t`, adds a new goal for t, and the hypothesis `h : t := ?M` in the current goal."}, {"name": "tactic.by_contradiction", "description": ""}, {"name": "tactic.get_arity", "description": "Compute the arity of the given function"}, {"name": "tactic.intros", "description": "Repeatedly apply `intro1` and return the list of new local constants in order of introduction."}, {"name": "tactic.save_info_thunk", "description": ""}, {"name": "tactic.freeze_local_instances", "description": "Freeze the current set of local instances."}, {"name": "tactic.has_attribute", "description": "`has_attribute attr_name c_name` succeeds if the declaration `decl_name`\n  has the attribute `attr_name`. The result is the priority and whether or not\n  the attribute is persistent."}, {"name": "tactic.match_iff", "description": ""}, {"name": "tactic.destruct", "description": "Similar to cases tactic, but does not revert/intro/clear hypotheses."}, {"name": "tactic_state.to_format", "description": "Format the given tactic state. If `target_lhs_only` is true and the target\n   is of the form `lhs ~ rhs`, where `~` is a simplification relation,\n   then only the `lhs` is displayed.\n\n   Remark: the parameter `target_lhs_only` is a temporary hack used to implement\n   the `conv` monad. It will be removed in the future."}, {"name": "tactic.match_refl_app", "description": ""}, {"name": "tactic.head_eta_expand", "description": "(head) eta expand the given expression. `f : \u03b1 \u2192 \u03b2` head-eta-expands to `\u03bb a, f a`. If `f` isn't a function then it just returns `f`."}, {"name": "tactic.assertv", "description": "`assertv h t v`, adds the hypothesis `h : t` in the current goal if v has type t."}, {"name": "tactic.revert_kdeps", "description": ""}, {"name": "tactic.type_check", "description": "Type check `e` with respect to the current goal.\n   Fails if `e` is not type correct."}, {"name": "tactic.andthen_seq_focus", "description": ""}, {"name": "tactic.get_pi_arity", "description": "Compute the arity of the given (Pi-)type"}, {"name": "list.for_each", "description": ""}, {"name": "tactic.focus'", "description": "`focus' [t_1, ..., t_n]` applies t_i to the i-th goal. Fails if the number of goals is not n."}, {"name": "tactic.resolve_name", "description": "Resolve a name using the current local context, environment, aliases, etc."}, {"name": "tactic.iterate", "description": "`iterate t` repeats `t` 100.000 times or until `t` fails, returning the\nresult of each iteration."}, {"name": "tactic.set_env", "description": "Changes the environment to the `new_env`. `new_env` needs to be a descendant from the current environment."}, {"name": "tactic.revert", "description": "Example: with `x : \u2115, h : P(x) \u22a2 T(x)`, `revert x` returns `2` and produces the state ` \u22a2 \u03a0 x, P(x) \u2192 T(x)`."}, {"name": "tactic.add_protected_decl", "description": "add declaration `d` as a protected declaration"}, {"name": "tactic.set_tag", "description": "Tag goal `g` with tag `t`. It does nothing if goal tagging is disabled.\n   Remark: `set_goal g []` removes the tag"}, {"name": "tactic.induction", "description": "Induction on `h` using recursor `rec`, names for the new hypotheses\n  are retrieved from `ns`. If `ns` does not have sufficient names, then use the internal binder names\n  in the recursor.\n  It returns for each new goal the name of the constructor (if `rec_name` is a builtin recursor),\n  a list of new hypotheses, and a list of substitutions for hypotheses\n  depending on `h`. The substitutions map internal names to their replacement terms. If the\n  replacement is again a hypothesis the user name stays the same. The internal names are only valid\n  in the original goal, not in the type context of the new goal.\n  Remark: if `rec_name` is not a builtin recursor, we use parameter names of `rec_name` instead of\n  constructor names.\n\n  If `rec` is none, then the type of `h` is inferred, if it is of the form `C ...`, tactic uses `C.rec`"}, {"name": "tactic.save_options", "description": ""}, {"name": "tactic.fail_if_no_goals", "description": "Fail if there are no remaining goals."}, {"name": "tactic.rename", "description": "Rename a local hypothesis. This is a special case of `rename_many`;\nsee there for caveats."}, {"name": "tactic_state.format_expr", "description": "Format expression with respect to the main goal in the tactic state.\n  If the tactic state does not contain any goals, then format expression\n  using an empty local context."}, {"name": "tactic.get_decl", "description": ""}, {"name": "tactic.any_hyp_aux", "description": ""}, {"name": "tactic.is_def_eq", "description": "Similar to `unify`, but it treats metavariables as constants."}, {"name": "tactic.mk_eq_mpr", "description": "(mk_eq_mpr h\u2081 h\u2082) is a more efficient version of (mk_app `eq.mpr [h\u2081, h\u2082])"}, {"name": "tactic.zeta", "description": "Zeta reduction. Reduction of let bindings. `let x : a := b in c` reduces to `c[x/b]`."}, {"name": "tactic.apply_cfg", "description": " Configuration options for the `apply` tactic.\n- `md` sets how aggressively definitions are unfolded.\n- `new_goals` is the strategy for ordering new goals.\n- `instances` if `tt`, then `apply` tries to synthesize unresolved `[...]` arguments using type class resolution.\n- `auto_param` if `tt`, then `apply` tries to synthesize unresolved `(h : p . tac_id)` arguments using tactic `tac_id`.\n- `opt_param` if `tt`, then `apply` tries to synthesize unresolved `(a : t := v)` arguments by setting them to `v`.\n- `unify` if `tt`, then `apply` is free to assign existing metavariables in the goal when solving unification constraints.\n   For example, in the goal `|- ?x < succ 0`, the tactic `apply succ_lt_succ` succeeds with the default configuration,\n   but `apply_with succ_lt_succ {unify := ff}` doesn't since it would require Lean to assign `?x` to `succ ?y` where\n   `?y` is a fresh metavariable."}, {"name": "tactic.apply_cfg.md", "description": " Configuration options for the `apply` tactic.\n- `md` sets how aggressively definitions are unfolded.\n- `new_goals` is the strategy for ordering new goals.\n- `instances` if `tt`, then `apply` tries to synthesize unresolved `[...]` arguments using type class resolution.\n- `auto_param` if `tt`, then `apply` tries to synthesize unresolved `(h : p . tac_id)` arguments using tactic `tac_id`.\n- `opt_param` if `tt`, then `apply` tries to synthesize unresolved `(a : t := v)` arguments by setting them to `v`.\n- `unify` if `tt`, then `apply` is free to assign existing metavariables in the goal when solving unification constraints.\n   For example, in the goal `|- ?x < succ 0`, the tactic `apply succ_lt_succ` succeeds with the default configuration,\n   but `apply_with succ_lt_succ {unify := ff}` doesn't since it would require Lean to assign `?x` to `succ ?y` where\n   `?y` is a fresh metavariable."}, {"name": "tactic.apply_cfg.approx", "description": " Configuration options for the `apply` tactic.\n- `md` sets how aggressively definitions are unfolded.\n- `new_goals` is the strategy for ordering new goals.\n- `instances` if `tt`, then `apply` tries to synthesize unresolved `[...]` arguments using type class resolution.\n- `auto_param` if `tt`, then `apply` tries to synthesize unresolved `(h : p . tac_id)` arguments using tactic `tac_id`.\n- `opt_param` if `tt`, then `apply` tries to synthesize unresolved `(a : t := v)` arguments by setting them to `v`.\n- `unify` if `tt`, then `apply` is free to assign existing metavariables in the goal when solving unification constraints.\n   For example, in the goal `|- ?x < succ 0`, the tactic `apply succ_lt_succ` succeeds with the default configuration,\n   but `apply_with succ_lt_succ {unify := ff}` doesn't since it would require Lean to assign `?x` to `succ ?y` where\n   `?y` is a fresh metavariable."}, {"name": "tactic.apply_cfg.new_goals", "description": " Configuration options for the `apply` tactic.\n- `md` sets how aggressively definitions are unfolded.\n- `new_goals` is the strategy for ordering new goals.\n- `instances` if `tt`, then `apply` tries to synthesize unresolved `[...]` arguments using type class resolution.\n- `auto_param` if `tt`, then `apply` tries to synthesize unresolved `(h : p . tac_id)` arguments using tactic `tac_id`.\n- `opt_param` if `tt`, then `apply` tries to synthesize unresolved `(a : t := v)` arguments by setting them to `v`.\n- `unify` if `tt`, then `apply` is free to assign existing metavariables in the goal when solving unification constraints.\n   For example, in the goal `|- ?x < succ 0`, the tactic `apply succ_lt_succ` succeeds with the default configuration,\n   but `apply_with succ_lt_succ {unify := ff}` doesn't since it would require Lean to assign `?x` to `succ ?y` where\n   `?y` is a fresh metavariable."}, {"name": "tactic.apply_cfg.instances", "description": " Configuration options for the `apply` tactic.\n- `md` sets how aggressively definitions are unfolded.\n- `new_goals` is the strategy for ordering new goals.\n- `instances` if `tt`, then `apply` tries to synthesize unresolved `[...]` arguments using type class resolution.\n- `auto_param` if `tt`, then `apply` tries to synthesize unresolved `(h : p . tac_id)` arguments using tactic `tac_id`.\n- `opt_param` if `tt`, then `apply` tries to synthesize unresolved `(a : t := v)` arguments by setting them to `v`.\n- `unify` if `tt`, then `apply` is free to assign existing metavariables in the goal when solving unification constraints.\n   For example, in the goal `|- ?x < succ 0`, the tactic `apply succ_lt_succ` succeeds with the default configuration,\n   but `apply_with succ_lt_succ {unify := ff}` doesn't since it would require Lean to assign `?x` to `succ ?y` where\n   `?y` is a fresh metavariable."}, {"name": "tactic.apply_cfg.auto_param", "description": " Configuration options for the `apply` tactic.\n- `md` sets how aggressively definitions are unfolded.\n- `new_goals` is the strategy for ordering new goals.\n- `instances` if `tt`, then `apply` tries to synthesize unresolved `[...]` arguments using type class resolution.\n- `auto_param` if `tt`, then `apply` tries to synthesize unresolved `(h : p . tac_id)` arguments using tactic `tac_id`.\n- `opt_param` if `tt`, then `apply` tries to synthesize unresolved `(a : t := v)` arguments by setting them to `v`.\n- `unify` if `tt`, then `apply` is free to assign existing metavariables in the goal when solving unification constraints.\n   For example, in the goal `|- ?x < succ 0`, the tactic `apply succ_lt_succ` succeeds with the default configuration,\n   but `apply_with succ_lt_succ {unify := ff}` doesn't since it would require Lean to assign `?x` to `succ ?y` where\n   `?y` is a fresh metavariable."}, {"name": "tactic.apply_cfg.opt_param", "description": " Configuration options for the `apply` tactic.\n- `md` sets how aggressively definitions are unfolded.\n- `new_goals` is the strategy for ordering new goals.\n- `instances` if `tt`, then `apply` tries to synthesize unresolved `[...]` arguments using type class resolution.\n- `auto_param` if `tt`, then `apply` tries to synthesize unresolved `(h : p . tac_id)` arguments using tactic `tac_id`.\n- `opt_param` if `tt`, then `apply` tries to synthesize unresolved `(a : t := v)` arguments by setting them to `v`.\n- `unify` if `tt`, then `apply` is free to assign existing metavariables in the goal when solving unification constraints.\n   For example, in the goal `|- ?x < succ 0`, the tactic `apply succ_lt_succ` succeeds with the default configuration,\n   but `apply_with succ_lt_succ {unify := ff}` doesn't since it would require Lean to assign `?x` to `succ ?y` where\n   `?y` is a fresh metavariable."}, {"name": "tactic.apply_cfg.unify", "description": " Configuration options for the `apply` tactic.\n- `md` sets how aggressively definitions are unfolded.\n- `new_goals` is the strategy for ordering new goals.\n- `instances` if `tt`, then `apply` tries to synthesize unresolved `[...]` arguments using type class resolution.\n- `auto_param` if `tt`, then `apply` tries to synthesize unresolved `(h : p . tac_id)` arguments using tactic `tac_id`.\n- `opt_param` if `tt`, then `apply` tries to synthesize unresolved `(a : t := v)` arguments by setting them to `v`.\n- `unify` if `tt`, then `apply` is free to assign existing metavariables in the goal when solving unification constraints.\n   For example, in the goal `|- ?x < succ 0`, the tactic `apply succ_lt_succ` succeeds with the default configuration,\n   but `apply_with succ_lt_succ {unify := ff}` doesn't since it would require Lean to assign `?x` to `succ ?y` where\n   `?y` is a fresh metavariable."}, {"name": "tactic.whnf_ginductive", "description": "Return `e` in weak head normal form with respect to the given transparency setting,\n   or `e` head is a generalized constructor or inductive datatype."}, {"name": "tactic.get_options", "description": ""}, {"name": "tactic.repeat", "description": "This tactic is applied to each goal. If the application succeeds,\n   the tactic is applied recursively to all the generated subgoals until it eventually fails.\n   The recursion stops in a subgoal when the tactic has failed to make progress.\n   The tactic `repeat` never fails."}, {"name": "tactic.mk_eq_trans", "description": "(mk_eq_trans h\u2081 h\u2082) is a more efficient version of (mk_app `eq.trans [h\u2081, h\u2082])"}, {"name": "tactic.solve1", "description": "Applies the given tactic to the main goal and fails if it is not solved."}, {"name": "tactic.iterate_at_most", "description": "`iterate_at_most n t` iterates `t` `n` times or until `t` fails, returning the\nresult of each successful iteration."}, {"name": "tactic.cases_core", "description": "Apply `cases_on` recursor, names for the new hypotheses are retrieved from `ns`.\n  `h` must be a local constant. It returns for each new goal the name of the constructor, a list of new hypotheses, and a list of\n  substitutions for hypotheses depending on `h`. The number of new goals may be smaller than the\n  number of constructors. Some goals may be discarded when the indices to not match.\n  See `induction` for information on the list of substitutions.\n\n  The `cases` tactic is implemented using this one, and it relaxes the restriction of `h`.\n\n  Note: There is one \"new hypothesis\" for every constructor argument. These are\n  usually local constants, but due to dependent pattern matching, they can also\n  be arbitrary terms."}, {"name": "tactic.get_tag", "description": "Return tag associated with `g`. Return `[]` if there is no tag."}, {"name": "tactic.ex_to_tac", "description": ""}, {"name": "tactic.rotate_left", "description": "Rotate goals to the left. That is, `rotate_left 1` takes the main goal and puts it to the back of the subgoal list."}, {"name": "tactic.andthen_seq", "description": ""}, {"name": "tactic.with_enable_tags", "description": ""}, {"name": "tactic.mk_local_def", "description": ""}, {"name": "list.has_to_tactic_format", "description": ""}, {"name": "tactic.get_assignment", "description": "Return the value assigned to the given meta-variable.\n  Fail if argument is not a meta-variable or if it is not assigned."}, {"name": "tactic.intron_base", "description": "Like `intron'` but the introduced hypotheses' names are derived from `base`,\ni.e. `base`, `base_1` etc. The new names are unique in the context. If `offset`\nis given, the new names will be `base_offset`, `base_offset+1` etc."}, {"name": "tactic.refine", "description": "The same as `exact` except you can add proof holes."}, {"name": "tactic.kabstract", "description": "Abstracts all occurrences of the term `t` in `e` using keyed matching.\n   If `unify` is `ff`, then matching is used instead of unification.\n   That is, metavariables occurring in `e` are not assigned."}, {"name": "tactic.pose", "description": "Add `h : t := pr` to the current goal"}, {"name": "tactic.funext", "description": ""}, {"name": "tactic.apply_core", "description": "Apply the expression `e` to the main goal, the unification is performed using the transparency mode in `cfg`.\n   Supposing `e : \u03a0 (a\u2081:\u03b1\u2081) ... (a\u2099:\u03b1\u2099), P(a\u2081,...,a\u2099)` and the target is `Q`, `apply` will attempt to unify `Q` with `P(?a\u2081,...?a\u2099)`.\n   All of the metavariables that are not assigned are added as new metavariables.\n   If `cfg.approx` is `tt`, then fallback to first-order unification, and approximate context during unification.\n   `cfg.new_goals` specifies which unassigned metavariables become new goals, and their order.\n   If `cfg.instances` is `tt`, then use type class resolution to instantiate unassigned meta-variables.\n   The fields `cfg.auto_param` and `cfg.opt_param` are ignored by this tactic (See `tactic.apply`).\n   It returns a list of all introduced meta variables and the parameter name associated with them, even the assigned ones."}, {"name": "interactive.executor_tactic", "description": "Default `executor` instance for `tactic`s themselves"}, {"name": "tactic.mk_congr", "description": "(mk_congr h\u2081 h\u2082) is a more efficient version of (mk_app `congr [h\u2081, h\u2082])"}, {"name": "tactic.swap", "description": "Swap first two goals, do nothing if tactic state does not have at least two goals."}, {"name": "tactic.returnex", "description": ""}, {"name": "tactic_state.set_options", "description": ""}, {"name": "tactic.mk_meta_var", "description": ""}, {"name": "tactic.rexact", "description": ""}, {"name": "tactic.unfreeze_local_instances", "description": "Avoid this function!  Use `unfreezingI`/`resetI`/etc. instead!\n\nUnfreezes the current set of local instances.\nAfter this tactic, the instance cache is disabled."}, {"name": "tactic.up", "description": ""}, {"name": "tactic.mk_fresh_name", "description": "Make a name that is guaranteed to be unique. Eg `_fresh.1001.4667`. These will be different for each run of the tactic."}, {"name": "tactic.new_aux_decl_name", "description": ""}, {"name": "tactic.add_decl", "description": "Add the given declaration to the environment"}, {"name": "tactic.iterate_at_most'", "description": "`iterate_at_most' n t` repeats `t` `n` times or until `t` fails."}, {"name": "tactic.add_meta_definition", "description": ""}, {"name": "tactic.assumption", "description": ""}, {"name": "tactic.is_proof", "description": ""}, {"name": "tactic.infer_type", "description": "Infer the type of the given expression.\n  Remark: transparency does not affect type inference"}, {"name": "tactic.add_doc_string", "description": "Set the docstring for the given declaration."}, {"name": "tactic.eapplyc", "description": ""}, {"name": "tactic.replace_target", "description": ""}, {"name": "tactic.run_simple", "description": ""}, {"name": "tactic.trace_call_stack", "description": ""}, {"name": "tactic.intro_core", "description": ""}, {"name": "tactic.mk_num_meta_univs", "description": "Create a list of universe meta-variables of the given size."}, {"name": "tactic.try_lst", "description": ""}, {"name": "tactic.clear", "description": "Clear the given local constant. The tactic fails if the given expression is not a local constant."}, {"name": "tactic.get_local", "description": "Get the `local_const` expr for the given `name`."}, {"name": "tactic.set_goals", "description": "Replace the current list of goals with the given one. Each expr in the list should be a metavariable. Any assigned metavariables will be ignored."}, {"name": "tactic.alternative", "description": ""}, {"name": "tactic.seq", "description": "LCF-style AND_THEN tactic. It applies `tac1` to the main goal, then applies\n`tac2` to each goal produced by `tac1`."}, {"name": "tactic.definev", "description": "`definev h t v`, adds the hypothesis (h : t := v) in the current goal if v has type t."}, {"name": "has_to_tactic_format", "description": ""}, {"name": "has_to_tactic_format.to_tactic_format", "description": ""}, {"name": "tactic.is_prop_decl", "description": "Return true iff n is the name of declaration that is a proposition."}, {"name": "tactic.add_defn_equations", "description": "`add_defn_equations` adds a definition specified by a list of equations.\n\n The arguments:\n   * `lp`: list of universe parameters\n   * `params`: list of parameters (binders before the colon);\n   * `fn`: a local constant giving the name and type of the declaration\n     (with `params` in the local context);\n   * `eqns`: a list of equations, each of which is a list of patterns\n     (constructors applied to new local constants) and the branch\n     expression;\n   * `is_meta`: is the definition meta?\n\n\n `add_defn_equations` can be used as:\n\n     do my_add \u2190 mk_local_def `my_add `(\u2115 \u2192 \u2115),\n         a \u2190 mk_local_def `a \u2115,\n         b \u2190 mk_local_def `b \u2115,\n         add_defn_equations [a] my_add\n             [ ([``(nat.zero)], a),\n               ([``(nat.succ %%b)], my_add b) ])\n             ff -- non-meta\n\n to create the following definition:\n\n     def my_add (a : \u2115) : \u2115 \u2192 \u2115\n     | nat.zero := a\n     | (nat.succ b) := my_add b"}, {"name": "tactic.applyc", "description": "Apply the constant `c`"}, {"name": "tactic.triv", "description": ""}, {"name": "tactic.revert_lst", "description": " `revert_lst : list expr \u2192 tactic nat` is the reverse of `intron`. It takes a local constant `c` and puts it back as bound by a `pi` or `elet` of the main target.\nIf there are other local constants that depend on `c`, these are also reverted. Because of this, the `nat` that is returned is the actual number of reverted local constants.\nExample: with `x : \u2115, h : P(x) \u22a2 T(x)`, `revert_lst [x]` returns `2` and produces the state ` \u22a2 \u03a0 x, P(x) \u2192 T(x)`."}, {"name": "tactic.get_univ_assignment", "description": "Return the value assigned to the given universe meta-variable.\n  Fail if argument is not an universe meta-variable or if it is not assigned."}, {"name": "tactic.tag", "description": "A `tag` is a list of `names`. These are attached to goals to help tactics track them."}, {"name": "tactic.funext_lst", "description": ""}, {"name": "has_to_format_to_has_to_tactic_format", "description": ""}, {"name": "tactic.funext_core", "description": ""}, {"name": "tactic.intron_with", "description": "`intron_with i ns base offset` introduces `i` hypotheses using the names from\n`ns`. If `ns` contains less than `i` names, the remaining hypotheses' names are\nderived from `base` and `offset` (as with `intron_base`). If `base` is `_`, the\nnames are derived from the \u03a0 binder names.\n\nReturns the introduced local constants and the remaining names from `ns` (if\n`ns` contains more than `i` names)."}, {"name": "tactic.rotate_right", "description": " Rotate the goals to the right by `n`. That is, take the goal at the back and push it to the front `n` times.\n[NOTE] We have to provide the instance argument `[has_mod nat]` because\n   mod for nat was not defined yet"}, {"name": "tactic.replace_hyp", "description": "\"Replace\" hypothesis `h : type` with `h : new_type` where `eq_pr` is a proof\nthat (type = new_type). The tactic actually creates a new hypothesis\nwith the same user facing name, and (tries to) clear `h`.\nThe `clear` step fails if `h` has forward dependencies. In this case, the old `h`\nwill remain in the local context. The tactic returns the new hypothesis."}, {"name": "tactic.set_options", "description": ""}, {"name": "order_laws_tac", "description": "Try to prove with `iff.refl`."}, {"name": "tactic.induction'", "description": ""}, {"name": "tactic.any_goals", "description": "Apply `tac` to any goal where it succeeds. The tactic succeeds if `tac`\nsucceeds for at least one goal. The returned list contains the result of `tac`\nfor each goal: `some a` if tac succeeded, or `none` if it did not."}, {"name": "tactic.intro_lst_fresh", "description": "A variant of `intro_lst` which makes sure that the introduced hypotheses' names\nare unique in the context. See `intro_fresh`."}, {"name": "tactic.solve", "description": "`solve [t_1, ... t_n]` applies the first tactic that solves the main goal."}, {"name": "tactic.subst", "description": ""}, {"name": "interactive.executor.execute_explicit", "description": ""}, {"name": "tactic.mk_eq_symm", "description": "(mk_eq_symm h) is a more efficient version of (mk_app `eq.symm [h])"}, {"name": "tactic.get_unused_name", "description": "Get a fresh name that is guaranteed to not be in use in the local context.\n   If `n` is provided and `n` is not in use, then `n` is returned.\n   Otherwise a number `i` is appended to give `\"n_i\"`."}, {"name": "tactic.get_goals", "description": "Gets a list of metavariables, one for each goal."}, {"name": "tactic.iterate_exactly'", "description": "`iterate_exactly' n t` executes `t` `n` times. If any iteration fails, the whole\ntactic fails."}, {"name": "tactic.to_expr", "description": "Elaborate the given quoted expression with respect to the current main goal.\n   Note that this means that any implicit arguments for the given `pexpr` will be applied with fresh metavariables.\n   If `allow_mvars` is tt, then metavariables are tolerated and become new goals if `subgoals` is tt."}, {"name": "tactic.failed", "description": "Cause the tactic to fail with no error message."}, {"name": "tactic.intro_lst", "description": "Same as `intros`, except with the given names for the new hypotheses. Use the name ```_``` to instead use the binder's name."}, {"name": "tactic.done", "description": "Fail if there are unsolved goals."}, {"name": "tactic.num_goals", "description": "Return the number of goals that need to be solved"}, {"name": "tactic", "description": "`tactic` is the monad for building tactics.\n   You use this to:\n   - View and modify the local goals and hypotheses in the prover's state.\n   - Invoke type checking and elaboration of terms.\n   - View and modify the environment.\n   - Build new tactics out of existing ones such as `simp` and `rewrite`."}, {"name": "tactic.apply_opt_param", "description": ""}, {"name": "tactic.add_aux_decl", "description": "Create an auxiliary definition with name `c` where `type` and `value` may contain local constants and\nmeta-variables. This function collects all dependencies (universe parameters, universe metavariables,\nlocal constants (aka hypotheses) and metavariables).\nIt updates the environment in the tactic_state, and returns an expression of the form\n\n          (c.{l_1 ... l_n} a_1 ... a_m)\n\nwhere l_i's and a_j's are the collected dependencies."}, {"name": "tactic_state.has_to_format", "description": ""}, {"name": "tactic.mk_sorry", "description": "Makes a sorry macro with a meta-variable as its type."}, {"name": "tactic.get_local_type", "description": ""}, {"name": "tactic_result", "description": ""}, {"name": "tactic.tags_enabled", "description": "Return tt iff goal tagging is enabled."}, {"name": "tactic.module_doc_strings", "description": " Returns a list of docstrings in the active module. An entry in the list can be either:\n- a top-level (`/-! ... -/`) docstring, represented as `(none, docstring)`\n- a declaration-specific (`/-- ... -/`) docstring, represented as `(some decl_name, docstring)`"}, {"name": "tactic.eapply", "description": "Same as `apply` but only goals that don't depend on other goals are added to goal list."}, {"name": "tactic.mk_meta_univ", "description": ""}, {"name": "tactic.fail", "description": ""}, {"name": "tactic.generalize", "description": "Generalizes the target with respect to `e`."}, {"name": "with_one.coe_mul_hom_apply", "description": ""}, {"name": "with_zero.add_monoid", "description": ""}, {"name": "with_one.coe_mul", "description": ""}, {"name": "with_zero.has_coe_t", "description": ""}, {"name": "with_one.has_inv", "description": ""}, {"name": "with_one", "description": "Add an extra element `1` to a type"}, {"name": "with_one.has_coe_t", "description": ""}, {"name": "with_zero.coe_pow", "description": ""}, {"name": "with_zero.rec_zero_coe", "description": "Recursor for `with_zero` using the preferred forms `0` and `\u2191a`."}, {"name": "with_zero.nat.has_pow", "description": ""}, {"name": "with_one.rec_one_coe", "description": "Recursor for `with_one` using the preferred forms `1` and `\u2191a`."}, {"name": "mul_equiv.with_one_congr_refl", "description": ""}, {"name": "with_one.has_involutive_inv", "description": ""}, {"name": "with_zero.add_zero_class", "description": ""}, {"name": "with_zero.mul_zero", "description": ""}, {"name": "with_one.one_ne_coe", "description": ""}, {"name": "with_one.monoid", "description": ""}, {"name": "with_one.ne_one_iff_exists", "description": ""}, {"name": "with_zero.has_add", "description": ""}, {"name": "with_zero.unzero_coe", "description": ""}, {"name": "with_zero.coe_add", "description": ""}, {"name": "with_zero.lift_coe", "description": ""}, {"name": "with_zero.mul_zero_class", "description": ""}, {"name": "with_zero.map_id", "description": ""}, {"name": "with_zero.can_lift", "description": ""}, {"name": "with_zero.lift_unique", "description": ""}, {"name": "with_zero.lift", "description": "Lift an add_semigroup homomorphism `f` to a bundled add_monoid homorphism."}, {"name": "with_one.map_coe", "description": ""}, {"name": "with_zero.zero_mul", "description": ""}, {"name": "with_zero.map_comp", "description": ""}, {"name": "with_zero.unzero", "description": "Deconstruct a `x : with_zero \u03b1` to the underlying value in `\u03b1`, given a proof that `x \u2260 0`."}, {"name": "with_zero.group_with_zero", "description": "if `G` is a group then `with_zero G` is a group with zero."}, {"name": "with_one.with_zero.has_repr", "description": ""}, {"name": "with_one.cases_on", "description": ""}, {"name": "with_one.unone_coe", "description": ""}, {"name": "mul_equiv.with_one_congr_apply", "description": ""}, {"name": "with_zero.int.has_pow", "description": ""}, {"name": "with_zero.coe_ne_zero", "description": ""}, {"name": "with_zero", "description": "Add an extra element `0` to a type"}, {"name": "with_one.coe_ne_one", "description": ""}, {"name": "with_zero.units_with_zero_equiv", "description": "Any group is isomorphic to the units of itself adjoined with `0`."}, {"name": "with_zero.map_coe", "description": ""}, {"name": "with_zero.div_inv_monoid", "description": ""}, {"name": "with_zero.division_monoid", "description": ""}, {"name": "with_zero.has_neg", "description": ""}, {"name": "with_one.nontrivial", "description": ""}, {"name": "with_one.has_one", "description": ""}, {"name": "mul_equiv.with_one_congr_symm", "description": ""}, {"name": "with_one.has_mul", "description": ""}, {"name": "with_one.coe_inj", "description": ""}, {"name": "with_one.mul_one_class", "description": ""}, {"name": "with_zero.zero_ne_coe", "description": ""}, {"name": "with_zero.coe_div", "description": ""}, {"name": "with_one.map", "description": "Given a multiplicative map from `\u03b1 \u2192 \u03b2` returns a monoid homomorphism\n from `with_one \u03b1` to `with_one \u03b2`"}, {"name": "with_zero.mul_zero_one_class", "description": ""}, {"name": "with_zero.has_involutive_inv", "description": ""}, {"name": "with_zero.monad", "description": ""}, {"name": "with_zero.comm_semigroup", "description": ""}, {"name": "with_one.map_map", "description": ""}, {"name": "with_zero.has_involutive_neg", "description": ""}, {"name": "add_equiv.with_zero_congr_apply", "description": ""}, {"name": "with_one.lift_unique", "description": ""}, {"name": "with_one.lift_coe", "description": ""}, {"name": "with_zero.has_inv", "description": "Given an inverse operation on `\u03b1` there is an inverse operation\n on `with_zero \u03b1` sending `0` to `0`"}, {"name": "with_zero.ne_zero_iff_exists", "description": ""}, {"name": "mul_equiv.with_one_congr_trans", "description": ""}, {"name": "with_zero.comm_group_with_zero", "description": ""}, {"name": "with_zero.inv_one", "description": ""}, {"name": "with_zero.semiring", "description": ""}, {"name": "with_zero.lift_zero", "description": ""}, {"name": "with_one.lift_one", "description": ""}, {"name": "with_zero.map_map", "description": ""}, {"name": "with_zero.division_comm_monoid", "description": ""}, {"name": "with_one.map_comp", "description": ""}, {"name": "with_zero.cases_on", "description": ""}, {"name": "with_one.inhabited", "description": ""}, {"name": "with_one.can_lift", "description": ""}, {"name": "with_zero.semigroup_with_zero", "description": ""}, {"name": "with_one.coe_inv", "description": ""}, {"name": "with_zero.inv_zero", "description": ""}, {"name": "with_one.some_eq_coe", "description": ""}, {"name": "with_zero.coe_zpow", "description": ""}, {"name": "with_zero.coe_mul", "description": ""}, {"name": "with_zero.add_comm_monoid", "description": ""}, {"name": "with_one.unone", "description": "Deconstruct a `x : with_one \u03b1` to the underlying value in `\u03b1`, given a proof that `x \u2260 1`."}, {"name": "with_zero.coe_add_hom", "description": "`coe` as a bundled morphism"}, {"name": "with_zero.coe_add_hom_apply", "description": ""}, {"name": "with_zero.nontrivial", "description": ""}, {"name": "with_zero.some_eq_coe", "description": ""}, {"name": "with_one.lift", "description": "Lift a semigroup homomorphism `f` to a bundled monoid homorphism."}, {"name": "with_zero.coe_inv", "description": ""}, {"name": "with_zero.coe_inj", "description": ""}, {"name": "with_one.monad", "description": ""}, {"name": "with_zero.coe_unzero", "description": ""}, {"name": "add_equiv.with_zero_congr", "description": "A version of `equiv.option_congr` for `with_zero`."}, {"name": "with_zero.has_one", "description": ""}, {"name": "with_one.comm_monoid", "description": ""}, {"name": "with_zero.map", "description": "Given an additive map from `\u03b1 \u2192 \u03b2` returns an add_monoid homomorphism\n  from `with_zero \u03b1` to `with_zero \u03b2`"}, {"name": "with_zero.coe_one", "description": ""}, {"name": "with_zero.comm_monoid_with_zero", "description": ""}, {"name": "with_one.has_repr", "description": ""}, {"name": "mul_equiv.with_one_congr", "description": "A version of `equiv.option_congr` for `with_one`."}, {"name": "with_zero.has_repr", "description": ""}, {"name": "with_zero.add_monoid_with_one", "description": ""}, {"name": "with_zero.no_zero_divisors", "description": ""}, {"name": "with_one.map_id", "description": ""}, {"name": "with_zero.inhabited", "description": ""}, {"name": "with_zero.monoid_with_zero", "description": ""}, {"name": "with_zero.coe_neg", "description": ""}, {"name": "with_one.coe_mul_hom", "description": "`coe` as a bundled morphism"}, {"name": "with_zero.has_div", "description": ""}, {"name": "with_zero.has_zero", "description": ""}, {"name": "with_one.coe_unone", "description": ""}, {"name": "tsub_self_add", "description": ""}, {"name": "tsub_zero", "description": ""}, {"name": "add_le_cancellable.tsub_eq_of_eq_add", "description": ""}, {"name": "add_le_cancellable.add_tsub_cancel_right", "description": ""}, {"name": "add_tsub_add_eq_tsub_right", "description": ""}, {"name": "add_le_cancellable.eq_tsub_iff_add_eq_of_le", "description": ""}, {"name": "add_le_cancellable.tsub_lt_iff_left", "description": ""}, {"name": "with_top.sub", "description": "If `\u03b1` has subtraction and `0`, we can extend the subtraction to `with_top \u03b1`."}, {"name": "lt_tsub_comm", "description": ""}, {"name": "add_le_cancellable.lt_tsub_iff_left_of_le", "description": ""}, {"name": "add_le_cancellable.tsub_eq_iff_eq_add_of_le", "description": ""}, {"name": "tsub_le_tsub_iff_right", "description": ""}, {"name": "add_le_of_le_tsub_right_of_le", "description": ""}, {"name": "tsub_lt_iff_right", "description": ""}, {"name": "le_mul_tsub", "description": ""}, {"name": "tsub_tsub_tsub_cancel_right", "description": ""}, {"name": "le_add_tsub'", "description": ""}, {"name": "add_tsub_le_left", "description": "See `add_tsub_cancel_left` for the equality if `contravariant_class \u03b1 \u03b1 (+) (\u2264)`."}, {"name": "tsub_le_tsub_left", "description": ""}, {"name": "tsub_lt_of_lt", "description": ""}, {"name": "tsub_right_inj", "description": ""}, {"name": "add_tsub_cancel_left", "description": ""}, {"name": "tsub_lt_iff_tsub_lt", "description": ""}, {"name": "add_le_cancellable.tsub_tsub_cancel_of_le", "description": ""}, {"name": "add_le_cancellable.tsub_lt_tsub_iff_left_of_le", "description": "See `lt_tsub_iff_left_of_le_of_le` for a weaker statement in a partial order."}, {"name": "add_le_cancellable.tsub_add_eq_add_tsub", "description": ""}, {"name": "with_top.has_sub", "description": ""}, {"name": "lt_tsub_iff_right_of_le", "description": "See `lt_tsub_iff_right` for a stronger statement in a linear order."}, {"name": "lt_add_of_tsub_lt_left", "description": ""}, {"name": "add_hom.le_map_tsub", "description": ""}, {"name": "add_le_cancellable.lt_tsub_of_add_lt_right", "description": ""}, {"name": "tsub_eq_iff_eq_add_of_le", "description": ""}, {"name": "le_tsub_of_add_le_left", "description": ""}, {"name": "eq_tsub_of_add_eq", "description": ""}, {"name": "tsub_lt_tsub_iff_right", "description": "This lemma also holds for `ennreal`, but we need a different proof for that."}, {"name": "lt_of_tsub_lt_tsub_left", "description": "See `lt_of_tsub_lt_tsub_left_of_le` for a weaker statement in a partial order."}, {"name": "tsub_add_tsub_comm", "description": ""}, {"name": "tsub_tsub_cancel_of_le", "description": "See `tsub_tsub_le` for an inequality."}, {"name": "tsub_le_self", "description": ""}, {"name": "eq_tsub_iff_add_eq_of_le", "description": ""}, {"name": "tsub_eq_of_eq_add_rev", "description": ""}, {"name": "add_le_add_add_tsub", "description": ""}, {"name": "lt_tsub_of_add_lt_right", "description": ""}, {"name": "add_tsub_add_le_tsub_right", "description": "See `add_tsub_add_eq_tsub_right` for the equality."}, {"name": "lt_add_of_tsub_lt_right", "description": ""}, {"name": "tsub_add_min", "description": ""}, {"name": "add_le_cancellable.tsub_lt_iff_right", "description": ""}, {"name": "tsub_eq_of_eq_add", "description": ""}, {"name": "add_tsub_cancel_iff_le", "description": ""}, {"name": "add_tsub_add_eq_tsub_left", "description": ""}, {"name": "tsub_le_iff_tsub_le", "description": ""}, {"name": "add_le_cancellable.le_tsub_iff_left", "description": ""}, {"name": "lt_tsub_of_add_lt_left", "description": " This lemma (and some of its corollaries) also holds for `ennreal`, but this proof doesn't work\nfor it. Maybe we should add this lemma as field to `has_ordered_sub`?"}, {"name": "le_tsub_mul", "description": ""}, {"name": "add_le_cancellable.tsub_lt_self_iff", "description": ""}, {"name": "add_le_cancellable.tsub_tsub_assoc", "description": ""}, {"name": "tsub_tsub_tsub_le_tsub", "description": ""}, {"name": "tsub_eq_zero_iff_le", "description": ""}, {"name": "tsub_tsub_le", "description": "See `tsub_tsub_cancel_of_le` for the equality."}, {"name": "tsub_add_eq_max", "description": ""}, {"name": "add_le_cancellable.tsub_add_tsub_comm", "description": ""}, {"name": "tsub_le_iff_right", "description": ""}, {"name": "tsub_add_eq_add_tsub", "description": ""}, {"name": "add_le_cancellable.eq_tsub_of_add_eq", "description": ""}, {"name": "add_tsub_add_le_tsub_add_tsub", "description": "See `tsub_add_tsub_comm` for the equality."}, {"name": "add_le_cancellable.tsub_lt_tsub_iff_right", "description": ""}, {"name": "tsub_tsub_assoc", "description": ""}, {"name": "lt_tsub_iff_left", "description": "See `lt_tsub_iff_left_of_le` for a weaker statement in a partial order."}, {"name": "add_tsub_cancel_of_le", "description": ""}, {"name": "le_tsub_add", "description": ""}, {"name": "has_ordered_sub", "description": " `has_ordered_sub \u03b1` means that `\u03b1` has a subtraction characterized by `a - b \u2264 c \u2194 a \u2264 c + b`.\nIn other words, `a - b` is the least `c` such that `a \u2264 b + c`.\n\nThis is satisfied both by the subtraction in additive ordered groups and by truncated subtraction\nin canonically ordered monoids on many specific types."}, {"name": "has_ordered_sub.tsub_le_iff_right", "description": " `has_ordered_sub \u03b1` means that `\u03b1` has a subtraction characterized by `a - b \u2264 c \u2194 a \u2264 c + b`.\nIn other words, `a - b` is the least `c` such that `a \u2264 b + c`.\n\nThis is satisfied both by the subtraction in additive ordered groups and by truncated subtraction\nin canonically ordered monoids on many specific types."}, {"name": "add_le_cancellable.le_tsub_iff_right", "description": ""}, {"name": "tsub_pos_of_lt", "description": ""}, {"name": "tsub_add_tsub_cancel", "description": ""}, {"name": "add_le_cancellable.le_tsub_of_add_le_right", "description": ""}, {"name": "tsub_add_eq_tsub_tsub_swap", "description": ""}, {"name": "add_tsub_assoc_of_le", "description": "See `add_tsub_le_assoc` for an inequality."}, {"name": "lt_of_tsub_lt_tsub_right", "description": "See `lt_of_tsub_lt_tsub_right_of_le` for a weaker statement in a partial order."}, {"name": "zero_tsub", "description": ""}, {"name": "add_tsub_le_tsub_add", "description": "See `tsub_add_eq_add_tsub` for the equality."}, {"name": "add_tsub_tsub_cancel", "description": ""}, {"name": "tsub_lt_self_iff", "description": ""}, {"name": "tsub_le_tsub_iff_left", "description": ""}, {"name": "tsub_inj_right", "description": ""}, {"name": "tsub_add_cancel_of_le", "description": ""}, {"name": "add_le_cancellable.lt_of_tsub_lt_tsub_left_of_le", "description": ""}, {"name": "tsub_nonpos_of_le", "description": "**Alias** of the reverse direction of `tsub_nonpos`."}, {"name": "add_monoid_hom.le_map_tsub", "description": ""}, {"name": "tsub_le_tsub_add_tsub", "description": ""}, {"name": "add_le_cancellable.lt_add_of_tsub_lt_left", "description": ""}, {"name": "tsub_left_inj", "description": ""}, {"name": "add_le_cancellable.le_tsub_of_add_le_left", "description": ""}, {"name": "le_tsub_add_add", "description": ""}, {"name": "tsub_le_iff_left", "description": ""}, {"name": "add_le_cancellable.le_add_tsub_swap", "description": ""}, {"name": "le_tsub_of_add_le_right", "description": ""}, {"name": "tsub_eq_tsub_min", "description": ""}, {"name": "add_le_of_le_tsub_left_of_le", "description": ""}, {"name": "add_le_cancellable.lt_tsub_iff_left", "description": ""}, {"name": "le_tsub_iff_right", "description": ""}, {"name": "tsub_pos_iff_not_le", "description": ""}, {"name": "tsub_eq_zero_of_le", "description": "**Alias** of the reverse direction of `tsub_eq_zero_iff_le`."}, {"name": "lt_of_tsub_lt_tsub_left_of_le", "description": "See `lt_of_tsub_lt_tsub_left` for a stronger statement in a linear order."}, {"name": "add_le_cancellable.tsub_right_inj", "description": ""}, {"name": "tsub_add_cancel_iff_le", "description": ""}, {"name": "add_le_cancellable.le_tsub_iff_le_tsub", "description": ""}, {"name": "add_tsub_le_right", "description": "See `add_tsub_cancel_right` for the equality if `contravariant_class \u03b1 \u03b1 (+) (\u2264)`."}, {"name": "le_tsub_iff_left", "description": ""}, {"name": "tsub_lt_tsub_iff_left_of_le", "description": "See `lt_tsub_iff_left_of_le_of_le` for a weaker statement in a partial order."}, {"name": "add_le_cancellable.add_tsub_tsub_cancel", "description": ""}, {"name": "tsub_nonpos", "description": ""}, {"name": "with_top.coe_sub", "description": ""}, {"name": "add_le_cancellable.lt_tsub_of_add_lt_left", "description": ""}, {"name": "tsub_right_comm", "description": ""}, {"name": "add_tsub_cancel_right", "description": ""}, {"name": "add_tsub_le_assoc", "description": "See `add_tsub_assoc_of_le` for the equality."}, {"name": "tsub_lt_iff_left", "description": ""}, {"name": "tsub_le_tsub", "description": ""}, {"name": "tsub_add_eq_tsub_tsub", "description": ""}, {"name": "tsub_tsub", "description": ""}, {"name": "add_le_cancellable.tsub_lt_iff_tsub_lt", "description": ""}, {"name": "add_le_cancellable.tsub_eq_of_eq_add_rev", "description": ""}, {"name": "tsub_le_tsub_right", "description": ""}, {"name": "tsub_lt_self", "description": ""}, {"name": "tsub_self", "description": ""}, {"name": "with_top.has_ordered_sub", "description": ""}, {"name": "order_iso.map_tsub", "description": " An order isomorphism between types with ordered subtraction preserves subtraction provided that\nit preserves addition."}, {"name": "tsub_lt_tsub_iff_left_of_le_of_le", "description": "See `tsub_lt_tsub_iff_left_of_le` for a stronger statement in a linear order."}, {"name": "with_top.sub_top", "description": ""}, {"name": "tsub_min", "description": ""}, {"name": "add_tsub_add_le_tsub_left", "description": "See `add_tsub_add_eq_tsub_left` for the equality."}, {"name": "add_le_cancellable.tsub_le_tsub_iff_left", "description": ""}, {"name": "le_add_tsub", "description": ""}, {"name": "le_tsub_iff_le_tsub", "description": ""}, {"name": "add_le_cancellable.tsub_inj_right", "description": ""}, {"name": "tsub_tsub_le_tsub_add", "description": ""}, {"name": "add_le_cancellable.le_add_tsub", "description": ""}, {"name": "add_le_cancellable.add_tsub_assoc_of_le", "description": ""}, {"name": "add_le_cancellable.lt_tsub_iff_right", "description": ""}, {"name": "add_le_cancellable.tsub_lt_tsub_right_of_le", "description": ""}, {"name": "add_le_cancellable.tsub_lt_self", "description": ""}, {"name": "add_le_cancellable.tsub_lt_tsub_iff_left_of_le_of_le", "description": ""}, {"name": "add_le_cancellable.add_tsub_cancel_left", "description": ""}, {"name": "with_top.top_sub_coe", "description": ""}, {"name": "lt_tsub_iff_right", "description": "See `lt_tsub_iff_right_of_le` for a weaker statement in a partial order."}, {"name": "tsub_lt_tsub_right_of_le", "description": ""}, {"name": "le_add_tsub_swap", "description": ""}, {"name": "lt_of_tsub_lt_tsub_right_of_le", "description": "See `lt_of_tsub_lt_tsub_right` for a stronger statement in a linear order."}, {"name": "add_le_cancellable.lt_add_of_tsub_lt_right", "description": ""}, {"name": "add_le_cancellable.lt_tsub_iff_right_of_le", "description": ""}, {"name": "add_tsub_eq_max", "description": ""}, {"name": "lt_tsub_iff_left_of_le", "description": "See `lt_tsub_iff_left` for a stronger statement in a linear order."}, {"name": "tsub_pos_iff_lt", "description": ""}, {"name": "tsub_inj_left", "description": ""}, {"name": "tactic.by_proof_irrel", "description": " Attempts to prove the goal by proof irrelevance, but avoids unifying universe metavariables\nto do so."}, {"name": "tactic.congr'", "description": "Same as the `congr` tactic, but takes an optional argument which gives\nthe depth of recursive applications.\n* This is useful when `congr` is too aggressive in breaking down the goal.\n* For example, given `\u22a2 f (g (x + y)) = f (g (y + x))`, `congr'` produces the goals `\u22a2 x = y`\n  and `\u22a2 y = x`, while `congr' 2` produces the intended `\u22a2 x + y = y + x`.\n* If, at any point, a subgoal matches a hypothesis then the subgoal will be closed."}, {"name": "tactic.interactive.convert", "description": "The `exact e` and `refine e` tactics require a term `e` whose type is\ndefinitionally equal to the goal. `convert e` is similar to `refine e`,\nbut the type of `e` is not required to exactly match the\ngoal. Instead, new goals are created for differences between the type\nof `e` and the goal. For example, in the proof state\n\n```lean\nn : \u2115,\ne : prime (2 * n + 1)\n\u22a2 prime (n + n + 1)\n```\n\nthe tactic `convert e` will change the goal to\n\n```lean\n\u22a2 n + n = 2 * n\n```\n\nIn this example, the new goal can be solved using `ring`.\n\nThe `convert` tactic applies congruence lemmas eagerly before reducing,\ntherefore it can fail in cases where `exact` succeeds:\n```lean\ndef p (n : \u2115) := true\nexample (h : p 0) : p 1 := by exact h -- succeeds\nexample (h : p 0) : p 1 := by convert h -- fails, with leftover goal `1 = 0`\n```\n\nIf `x y : t`, and an instance `subsingleton t` is in scope, then any goals of the form\n`x = y` are solved automatically.\n\nThe syntax `convert \u2190 e` will reverse the direction of the new goals\n(producing `\u22a2 2 * n = n + n` in this example).\n\nInternally, `convert e` works by creating a new goal asserting that\nthe goal equals the type of `e`, then simplifying it using\n`congr'`. The syntax `convert e using n` can be used to control the\ndepth of matching (like `congr' n`). In the example, `convert e using\n1` would produce a new goal `\u22a2 n + n + 1 = 2 * n + 1`."}, {"name": "tactic.interactive.rcongr", "description": "Repeatedly and apply `congr'` and `ext`, using the given patterns as arguments for `ext`.\n\nThere are two ways this tactic stops:\n* `congr'` fails (makes no progress), after having already applied `ext`.\n* `congr'` canceled out the last usage of `ext`. In this case, the state is reverted to before\n  the `congr'` was applied.\n\nFor example, when the goal is\n```lean\n\u22a2 (\u03bb x, f x + 3) '' s = (\u03bb x, g x + 3) '' s\n```\nthen `rcongr x` produces the goal\n```lean\nx : \u03b1 \u22a2 f x = g x\n```\nThis gives the same result as `congr', ext x, congr'`.\n\nIn contrast, `congr'` would produce\n```lean\n\u22a2 (\u03bb x, f x + 3) = (\u03bb x, g x + 3)\n```\nand `congr' with x` (or `congr', ext x`) would produce\n```lean\nx : \u03b1 \u22a2 f x + 3 = g x + 3\n```"}, {"name": "tactic.convert_to_core", "description": "The main function in `convert_to`. Changes the goal to `r` and a proof obligation that the goal\n is equal to `r`."}, {"name": "tactic_doc.tactic.congr'", "description": "Same as the `congr` tactic, but takes an optional argument which gives\nthe depth of recursive applications.\n* This is useful when `congr` is too aggressive in breaking down the goal.\n* For example, given `\u22a2 f (g (x + y)) = f (g (y + x))`, `congr'` produces the goals `\u22a2 x = y`\n  and `\u22a2 y = x`, while `congr' 2` produces the intended `\u22a2 x + y = y + x`.\n* If, at any point, a subgoal matches a hypothesis then the subgoal will be closed.\n* You can use `congr' with p (: n)?` to call `ext p (: n)?` to all subgoals generated by `congr'`.\n  For example, if the goal is `\u22a2 f '' s = g '' s` then `congr' with x` generates the goal\n  `x : \u03b1 \u22a2 f x = g x`."}, {"name": "tactic.congr_core'", "description": "The main part of the body for the loop in `congr'`. This will try to replace a goal `f x = f y`\nwith `x = y`. Also has support for `==` and `\u2194`."}, {"name": "tactic.interactive.convert_to", "description": "`convert_to g using n` attempts to change the current goal to `g`, but unlike `change`,\nit will generate equality proof obligations using `congr' n` to resolve discrepancies.\n`convert_to g` defaults to using `congr' 1`.\n\n`convert_to` is similar to `convert`, but `convert_to` takes a type (the desired subgoal) while\n`convert` takes a proof term.\nThat is, `convert_to g using n` is equivalent to `convert (_ : g) using n`."}, {"name": "tactic.interactive.congr'", "description": "Same as the `congr` tactic, but takes an optional argument which gives\nthe depth of recursive applications.\n* This is useful when `congr` is too aggressive in breaking down the goal.\n* For example, given `\u22a2 f (g (x + y)) = f (g (y + x))`, `congr'` produces the goals `\u22a2 x = y`\n  and `\u22a2 y = x`, while `congr' 2` produces the intended `\u22a2 x + y = y + x`.\n* If, at any point, a subgoal matches a hypothesis then the subgoal will be closed.\n* You can use `congr' with p (: n)?` to call `ext p (: n)?` to all subgoals generated by `congr'`.\n  For example, if the goal is `\u22a2 f '' s = g '' s` then `congr' with x` generates the goal\n  `x : \u03b1 \u22a2 f x = g x`."}, {"name": "tactic.interactive.ac_change", "description": "`ac_change g using n` is `convert_to g using n` followed by `ac_refl`. It is useful for\nrearranging/reassociating e.g. sums:\n```lean\nexample (a b c d e f g N : \u2115) : (a + b) + (c + d) + (e + f) + g \u2264 N :=\nbegin\n  ac_change a + d + e + f + c + g + b \u2264 _,\n-- \u22a2 a + d + e + f + c + g + b \u2264 N\nend\n```"}, {"name": "tactic_doc.tactic.convert_to", "description": "`convert_to g using n` attempts to change the current goal to `g`, but unlike `change`,\nit will generate equality proof obligations using `congr' n` to resolve discrepancies.\n`convert_to g` defaults to using `congr' 1`.\n\n`convert_to` is similar to `convert`, but `convert_to` takes a type (the desired subgoal) while\n`convert` takes a proof term.\nThat is, `convert_to g using n` is equivalent to `convert (_ : g) using n`."}, {"name": "tactic_doc.tactic.convert", "description": "The `exact e` and `refine e` tactics require a term `e` whose type is\ndefinitionally equal to the goal. `convert e` is similar to `refine e`,\nbut the type of `e` is not required to exactly match the\ngoal. Instead, new goals are created for differences between the type\nof `e` and the goal. For example, in the proof state\n\n```lean\nn : \u2115,\ne : prime (2 * n + 1)\n\u22a2 prime (n + n + 1)\n```\n\nthe tactic `convert e` will change the goal to\n\n```lean\n\u22a2 n + n = 2 * n\n```\n\nIn this example, the new goal can be solved using `ring`.\n\nThe `convert` tactic applies congruence lemmas eagerly before reducing,\ntherefore it can fail in cases where `exact` succeeds:\n```lean\ndef p (n : \u2115) := true\nexample (h : p 0) : p 1 := by exact h -- succeeds\nexample (h : p 0) : p 1 := by convert h -- fails, with leftover goal `1 = 0`\n```\n\nIf `x y : t`, and an instance `subsingleton t` is in scope, then any goals of the form\n`x = y` are solved automatically.\n\nThe syntax `convert \u2190 e` will reverse the direction of the new goals\n(producing `\u22a2 2 * n = n + n` in this example).\n\nInternally, `convert e` works by creating a new goal asserting that\nthe goal equals the type of `e`, then simplifying it using\n`congr'`. The syntax `convert e using n` can be used to control the\ndepth of matching (like `congr' n`). In the example, `convert e using\n1` would produce a new goal `\u22a2 n + n + 1 = 2 * n + 1`."}, {"name": "tactic.apply_iff_congr_core", "description": "Apply the constant `iff_of_eq` to the goal."}, {"name": "tactic.rcases.process_constructors", "description": " Takes a list of constructor names, and an (alternation) list of patterns, and matches each\npattern against its constructor. It returns the list of names that will be passed to `cases`,\nand the list of `(constructor name, patterns)` for each constructor, where `patterns` is the\n(conjunctive) list of patterns to apply to each constructor argument."}, {"name": "tactic.rintro_hint", "description": "* `rintro?` is like `rintro ...`, except it generates `...` by introducing and matching on\neverything it can, and it outputs an `rintro` invocation that should have the same effect.\n* `rintro? : n` can be used to control the depth of case splits (especially important for\nrecursive types like `nat`, which can be cased as many times as you like)."}, {"name": "tactic.rcases_patt.tuple\u2081_core", "description": " This function is used for producing rcases patterns based on a case tree. Suppose that we have\na list of patterns `ps` that will match correctly against the branches of the case tree for one\nconstructor. This function will merge tuples at the end of the list, so that `[a, b, \u27e8c, d\u27e9]`\nbecomes `\u27e8a, b, c, d\u27e9` instead of `\u27e8a, b, \u27e8c, d\u27e9\u27e9`.\n\nWe must be careful to turn `[a, \u27e8\u27e9]` into `\u27e8a, \u27e8\u27e9\u27e9` instead of `\u27e8a\u27e9` (which will not perform the\nnested match)."}, {"name": "tactic.rcases_hint.process_constructors", "description": "* `rcases_hint_core depth e` does the same as `rcases p e`, except the pattern `p` is an output\n  instead of an input, controlled only by the case depth argument `depth`. We use `cases` to depth\n  `depth` and then reconstruct an `rcases` pattern `p` that would, if passed to `rcases`, perform\n  the same thing as the case tree we just constructed (or at least, the nearest expressible\n  approximation to this.)\n* `rcases_hint.process_constructors depth cs l` takes a list of constructor names `cs` and a\n  matching list `l` of elements `(g, c', hs, _)` where  `c'` is a constructor name (used for\n  alignment with `cs`), `g` is the subgoal, and `hs` is the list of local hypotheses created by\n  `cases` in that subgoal. It matches on all of them, and then produces a `\u03a3\u03a0`-list of `rcases`\n  patterns describing the result, and the list of generated subgoals.\n* `rcases_hint.continue depth es` does the same as `rcases.continue (ps.zip es)`, except the\n  patterns `ps` are an output instead of an input, created by matching on everything to depth\n  `depth` and recording the successful cases. It returns `ps`, and the list of generated subgoals."}, {"name": "tactic.rcases.process_constructor", "description": " Takes the number of fields of a single constructor and patterns to match its fields against\n(not necessarily the same number). The returned lists each contain one element per field of the\nconstructor. The `name` is the name which will be used in the top-level `cases` tactic, and the\n`rcases_patt` is the pattern which the field will be matched against by subsequent `cases`\ntactics."}, {"name": "tactic.rcases_patt_parse_hi", "description": " `rcases_patt_parse_hi` will parse a high precedence `rcases` pattern, `patt_hi`.\nThis means only tuples and identifiers are allowed; alternations and type ascriptions\nrequire `(...)` instead, which switches to `patt`.\n```lean\npatt_hi ::= id | \"rfl\" | \"_\" | \"\u27e8\" (patt \",\")* patt \"\u27e9\" | \"(\" patt \")\"\n```"}, {"name": "tactic.rcases_args", "description": " The arguments to `rcases`, which in fact dispatch to several other tactics.\n* `rcases? expr (: n)?` or `rcases? \u27e8expr, ...\u27e9 (: n)?` calls `rcases_hint`\n* `rcases? \u27e8expr, ...\u27e9 (: n)?` calls `rcases_hint_many`\n* `rcases (h :)? expr (with patt)?` calls `rcases`\n* `rcases \u27e8expr, ...\u27e9 (with patt)?` calls `rcases_many`"}, {"name": "tactic.rcases_args.hint", "description": " The arguments to `rcases`, which in fact dispatch to several other tactics.\n* `rcases? expr (: n)?` or `rcases? \u27e8expr, ...\u27e9 (: n)?` calls `rcases_hint`\n* `rcases? \u27e8expr, ...\u27e9 (: n)?` calls `rcases_hint_many`\n* `rcases (h :)? expr (with patt)?` calls `rcases`\n* `rcases \u27e8expr, ...\u27e9 (with patt)?` calls `rcases_many`"}, {"name": "tactic.rcases_args.rcases", "description": " The arguments to `rcases`, which in fact dispatch to several other tactics.\n* `rcases? expr (: n)?` or `rcases? \u27e8expr, ...\u27e9 (: n)?` calls `rcases_hint`\n* `rcases? \u27e8expr, ...\u27e9 (: n)?` calls `rcases_hint_many`\n* `rcases (h :)? expr (with patt)?` calls `rcases`\n* `rcases \u27e8expr, ...\u27e9 (with patt)?` calls `rcases_many`"}, {"name": "tactic.rcases_args.rcases_many", "description": " The arguments to `rcases`, which in fact dispatch to several other tactics.\n* `rcases? expr (: n)?` or `rcases? \u27e8expr, ...\u27e9 (: n)?` calls `rcases_hint`\n* `rcases? \u27e8expr, ...\u27e9 (: n)?` calls `rcases_hint_many`\n* `rcases (h :)? expr (with patt)?` calls `rcases`\n* `rcases \u27e8expr, ...\u27e9 (with patt)?` calls `rcases_many`"}, {"name": "tactic.rcases_hint", "description": "* `rcases? e` is like `rcases e with ...`, except it generates `...` by matching on everything it\ncan, and it outputs an `rcases` invocation that should have the same effect.\n* `rcases? e : n` can be used to control the depth of case splits (especially important for\nrecursive types like `nat`, which can be cased as many times as you like)."}, {"name": "tactic.rintro_patt_parse_low", "description": "`rintro_patt_parse_low` parses `rintro_patt_low`, which is the same as `rintro_patt_parse tt` but\nit does not permit an unparenthesized alternation list, it must have the form `p1 p2 p3 (: ty)?`.\n```lean\nrintro_patt_low ::= rintro_patt_hi* (\":\" expr)?\n```"}, {"name": "tactic_doc.tactic.obtain", "description": "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain \u27e8patt\u27e9 : type,\n{ ... }\n```\nis equivalent to\n```lean\nhave h : type,\n{ ... },\nrcases h with \u27e8patt\u27e9\n```\n\nThe syntax `obtain \u27e8patt\u27e9 : type := proof` is also supported.\n\nIf `\u27e8patt\u27e9` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required."}, {"name": "tactic.rcases_patt.format", "description": " Formats an `rcases` pattern. If the `bracket` argument is true, then it will be\nprinted at high precedence, i.e. it will have parentheses around it if it is not already a tuple\nor atomic name."}, {"name": "tactic.interactive.rcases", "description": "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a \u2227 b \u2227 c \u2228 d` or\n`h2 : \u2203 x y, trans_rel R x y`. Usual usage might be `rcases h1 with \u27e8ha, hb, hc\u27e9 | hd` or\n`rcases h2 with \u27e8x, y, _ | \u27e8z, hxz, hzy\u27e9\u27e9` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `\u27e8p1, p2, p3\u27e9`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a \u2227 b \u2227 c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* An alteration pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a \u2228 b \u2228 c`.\n\nA pattern like `\u27e8a, b, c\u27e9 | \u27e8d, e\u27e9` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `\u27e8\u27e8a\u27e9, b | c\u27e9 | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `\u27e8a, b, c\u27e9` for splitting on\n`\u2203 x, \u2203 y, p x`, then it will be treated as `\u27e8a, \u27e8b, c\u27e9\u27e9`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n\n`rcases? e` will perform case splits on `e` in the same way as `rcases e`,\nbut rather than accepting a pattern, it does a maximal cases and prints the\npattern that would produce this case splitting. The default maximum depth is 5,\nbut this can be modified with `rcases? e : n`."}, {"name": "tactic.uncleared_goal", "description": "A metavariable representing a subgoal, together with a list of local constants to clear."}, {"name": "tactic.rcases_patt.merge", "description": " Merge two `rcases` patterns. This is used to underapproximate a case tree by an `rcases`\npattern. The two patterns come from cases in two branches, that due to the syntax of `rcases`\npatterns are forced to overlap. The rule here is that we take only the case splits that are in\ncommon between both branches. For example if one branch does `\u27e8a, b\u27e9` and the other does `c`,\nthen we return `c` because we don't know that a case on `c` would be safe to do."}, {"name": "tactic.rcases_patt.name", "description": "Get the name from a pattern, if provided"}, {"name": "tactic.rcases_patt", "description": "An `rcases` pattern can be one of the following, in a nested combination:\n\n* A name like `foo`\n* The special keyword `rfl` (for pattern matching on equality using `subst`)\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* A type ascription like `pat : ty` (parentheses are optional)\n* A tuple constructor like `\u27e8p1, p2, p3\u27e9`\n* An alternation / variant pattern `p1 | p2 | p3`\n\nParentheses can be used for grouping; alternation is higher precedence than type ascription, so\n`p1 | p2 | p3 : ty` means `(p1 | p2 | p3) : ty`.\n\nN-ary alternations are treated as a group, so `p1 | p2 | p3` is not the same as `p1 | (p2 | p3)`,\nand similarly for tuples. However, note that an n-ary alternation or tuple can match an n-ary\nconjunction or disjunction, because if the number of patterns exceeds the number of constructors in\nthe type being destructed, the extra patterns will match on the last element, meaning that\n`p1 | p2 | p3` will act like `p1 | (p2 | p3)` when matching `a1 \u2228 a2 \u2228 a3`. If matching against a\ntype with 3 constructors,  `p1 | (p2 | p3)` will act like `p1 | (p2 | p3) | _` instead."}, {"name": "tactic.rcases_patt.one", "description": "An `rcases` pattern can be one of the following, in a nested combination:\n\n* A name like `foo`\n* The special keyword `rfl` (for pattern matching on equality using `subst`)\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* A type ascription like `pat : ty` (parentheses are optional)\n* A tuple constructor like `\u27e8p1, p2, p3\u27e9`\n* An alternation / variant pattern `p1 | p2 | p3`\n\nParentheses can be used for grouping; alternation is higher precedence than type ascription, so\n`p1 | p2 | p3 : ty` means `(p1 | p2 | p3) : ty`.\n\nN-ary alternations are treated as a group, so `p1 | p2 | p3` is not the same as `p1 | (p2 | p3)`,\nand similarly for tuples. However, note that an n-ary alternation or tuple can match an n-ary\nconjunction or disjunction, because if the number of patterns exceeds the number of constructors in\nthe type being destructed, the extra patterns will match on the last element, meaning that\n`p1 | p2 | p3` will act like `p1 | (p2 | p3)` when matching `a1 \u2228 a2 \u2228 a3`. If matching against a\ntype with 3 constructors,  `p1 | (p2 | p3)` will act like `p1 | (p2 | p3) | _` instead."}, {"name": "tactic.rcases_patt.clear", "description": "An `rcases` pattern can be one of the following, in a nested combination:\n\n* A name like `foo`\n* The special keyword `rfl` (for pattern matching on equality using `subst`)\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* A type ascription like `pat : ty` (parentheses are optional)\n* A tuple constructor like `\u27e8p1, p2, p3\u27e9`\n* An alternation / variant pattern `p1 | p2 | p3`\n\nParentheses can be used for grouping; alternation is higher precedence than type ascription, so\n`p1 | p2 | p3 : ty` means `(p1 | p2 | p3) : ty`.\n\nN-ary alternations are treated as a group, so `p1 | p2 | p3` is not the same as `p1 | (p2 | p3)`,\nand similarly for tuples. However, note that an n-ary alternation or tuple can match an n-ary\nconjunction or disjunction, because if the number of patterns exceeds the number of constructors in\nthe type being destructed, the extra patterns will match on the last element, meaning that\n`p1 | p2 | p3` will act like `p1 | (p2 | p3)` when matching `a1 \u2228 a2 \u2228 a3`. If matching against a\ntype with 3 constructors,  `p1 | (p2 | p3)` will act like `p1 | (p2 | p3) | _` instead."}, {"name": "tactic.rcases_patt.typed", "description": "An `rcases` pattern can be one of the following, in a nested combination:\n\n* A name like `foo`\n* The special keyword `rfl` (for pattern matching on equality using `subst`)\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* A type ascription like `pat : ty` (parentheses are optional)\n* A tuple constructor like `\u27e8p1, p2, p3\u27e9`\n* An alternation / variant pattern `p1 | p2 | p3`\n\nParentheses can be used for grouping; alternation is higher precedence than type ascription, so\n`p1 | p2 | p3 : ty` means `(p1 | p2 | p3) : ty`.\n\nN-ary alternations are treated as a group, so `p1 | p2 | p3` is not the same as `p1 | (p2 | p3)`,\nand similarly for tuples. However, note that an n-ary alternation or tuple can match an n-ary\nconjunction or disjunction, because if the number of patterns exceeds the number of constructors in\nthe type being destructed, the extra patterns will match on the last element, meaning that\n`p1 | p2 | p3` will act like `p1 | (p2 | p3)` when matching `a1 \u2228 a2 \u2228 a3`. If matching against a\ntype with 3 constructors,  `p1 | (p2 | p3)` will act like `p1 | (p2 | p3) | _` instead."}, {"name": "tactic.rcases_patt.tuple", "description": "An `rcases` pattern can be one of the following, in a nested combination:\n\n* A name like `foo`\n* The special keyword `rfl` (for pattern matching on equality using `subst`)\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* A type ascription like `pat : ty` (parentheses are optional)\n* A tuple constructor like `\u27e8p1, p2, p3\u27e9`\n* An alternation / variant pattern `p1 | p2 | p3`\n\nParentheses can be used for grouping; alternation is higher precedence than type ascription, so\n`p1 | p2 | p3 : ty` means `(p1 | p2 | p3) : ty`.\n\nN-ary alternations are treated as a group, so `p1 | p2 | p3` is not the same as `p1 | (p2 | p3)`,\nand similarly for tuples. However, note that an n-ary alternation or tuple can match an n-ary\nconjunction or disjunction, because if the number of patterns exceeds the number of constructors in\nthe type being destructed, the extra patterns will match on the last element, meaning that\n`p1 | p2 | p3` will act like `p1 | (p2 | p3)` when matching `a1 \u2228 a2 \u2228 a3`. If matching against a\ntype with 3 constructors,  `p1 | (p2 | p3)` will act like `p1 | (p2 | p3) | _` instead."}, {"name": "tactic.rcases_patt.alts", "description": "An `rcases` pattern can be one of the following, in a nested combination:\n\n* A name like `foo`\n* The special keyword `rfl` (for pattern matching on equality using `subst`)\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* A type ascription like `pat : ty` (parentheses are optional)\n* A tuple constructor like `\u27e8p1, p2, p3\u27e9`\n* An alternation / variant pattern `p1 | p2 | p3`\n\nParentheses can be used for grouping; alternation is higher precedence than type ascription, so\n`p1 | p2 | p3 : ty` means `(p1 | p2 | p3) : ty`.\n\nN-ary alternations are treated as a group, so `p1 | p2 | p3` is not the same as `p1 | (p2 | p3)`,\nand similarly for tuples. However, note that an n-ary alternation or tuple can match an n-ary\nconjunction or disjunction, because if the number of patterns exceeds the number of constructors in\nthe type being destructed, the extra patterns will match on the last element, meaning that\n`p1 | p2 | p3` will act like `p1 | (p2 | p3)` when matching `a1 \u2228 a2 \u2228 a3`. If matching against a\ntype with 3 constructors,  `p1 | (p2 | p3)` will act like `p1 | (p2 | p3) | _` instead."}, {"name": "tactic.rcases_patt.tuple\u2081", "description": " This function is used for producing rcases patterns based on a case tree. This is like\n`tuple\u2081_core` but it produces a pattern instead of a tuple pattern list, converting `[n]` to `n`\ninstead of `\u27e8n\u27e9` and `[]` to `_`, and otherwise just converting `[a, b, c]` to `\u27e8a, b, c\u27e9`."}, {"name": "tactic.rintro_parse", "description": "Syntax for a `rintro` pattern: `('?' (: n)?) | rintro_patt`."}, {"name": "tactic.rcases_patt.alts'", "description": " Convert a list of patterns to an alternation pattern, but mapping `[p]` to `p` instead of\na unary alternation `|p`."}, {"name": "tactic.rintro", "description": " `rintro pat\u2081 pat\u2082 ... pat\u2099` introduces `n` arguments, then pattern matches on the `pat\u1d62` using\nthe same syntax as `rcases`."}, {"name": "tactic.rcases_patt_parse_list_rest", "description": "* `rcases_patt_parse_hi` will parse a high precedence `rcases` pattern, `patt_hi`.\n  This means only tuples and identifiers are allowed; alternations and type ascriptions\n  require `(...)` instead, which switches to `patt`.\n* `rcases_patt_parse` will parse a low precedence `rcases` pattern, `patt`. This consists of a\n  `patt_med` (which deals with alternations), optionally followed by a `: ty` type ascription. The\n  expression `ty` is at `texpr` precedence because it can appear at the end of a tactic, for\n  example in `rcases e with x : ty <|> skip`.\n* `rcases_patt_parse_list` will parse an alternation list, `patt_med`, one or more `patt`\n  patterns separated by `|`. It does not parse a `:` at the end, so that `a | b : ty` parses as\n  `(a | b) : ty` where `a | b` is the `patt_med` part.\n* `rcases_patt_parse_list_rest a` parses an alternation list after the initial pattern, `| b | c`.\n\n```lean\npatt ::= patt_med (\":\" expr)?\npatt_med ::= (patt_hi \"|\")* patt_hi\npatt_hi ::= id | \"rfl\" | \"_\" | \"\u27e8\" (patt \",\")* patt \"\u27e9\" | \"(\" patt \")\"\n```"}, {"name": "tactic.interactive.obtain_parse", "description": " Parses `patt? (: expr)? (:= expr)?`, the arguments for `obtain`.\n (This is almost the same as `rcases_patt_parse`,\nbut it allows the pattern part to be empty.)"}, {"name": "tactic.interactive.rintros", "description": "Alias for `rintro`."}, {"name": "tactic.rcases_hint_core", "description": "* `rcases_hint_core depth e` does the same as `rcases p e`, except the pattern `p` is an output\n  instead of an input, controlled only by the case depth argument `depth`. We use `cases` to depth\n  `depth` and then reconstruct an `rcases` pattern `p` that would, if passed to `rcases`, perform\n  the same thing as the case tree we just constructed (or at least, the nearest expressible\n  approximation to this.)\n* `rcases_hint.process_constructors depth cs l` takes a list of constructor names `cs` and a\n  matching list `l` of elements `(g, c', hs, _)` where  `c'` is a constructor name (used for\n  alignment with `cs`), `g` is the subgoal, and `hs` is the list of local hypotheses created by\n  `cases` in that subgoal. It matches on all of them, and then produces a `\u03a3\u03a0`-list of `rcases`\n  patterns describing the result, and the list of generated subgoals.\n* `rcases_hint.continue depth es` does the same as `rcases.continue (ps.zip es)`, except the\n  patterns `ps` are an output instead of an input, created by matching on everything to depth\n  `depth` and recording the successful cases. It returns `ps`, and the list of generated subgoals."}, {"name": "tactic.rcases_patt_parse_list'", "description": "* `rcases_patt_parse_hi` will parse a high precedence `rcases` pattern, `patt_hi`.\n  This means only tuples and identifiers are allowed; alternations and type ascriptions\n  require `(...)` instead, which switches to `patt`.\n* `rcases_patt_parse` will parse a low precedence `rcases` pattern, `patt`. This consists of a\n  `patt_med` (which deals with alternations), optionally followed by a `: ty` type ascription. The\n  expression `ty` is at `texpr` precedence because it can appear at the end of a tactic, for\n  example in `rcases e with x : ty <|> skip`.\n* `rcases_patt_parse_list` will parse an alternation list, `patt_med`, one or more `patt`\n  patterns separated by `|`. It does not parse a `:` at the end, so that `a | b : ty` parses as\n  `(a | b) : ty` where `a | b` is the `patt_med` part.\n* `rcases_patt_parse_list_rest a` parses an alternation list after the initial pattern, `| b | c`.\n\n```lean\npatt ::= patt_med (\":\" expr)?\npatt_med ::= (patt_hi \"|\")* patt_hi\npatt_hi ::= id | \"rfl\" | \"_\" | \"\u27e8\" (patt \",\")* patt \"\u27e9\" | \"(\" patt \")\"\n```"}, {"name": "tactic.rcases_parse_depth", "description": "Parse the optional depth argument `(: n)?` of `rcases?` and `rintro?`, with default depth 5."}, {"name": "tactic.rcases_patt_parse'", "description": "* `rcases_patt_parse_hi` will parse a high precedence `rcases` pattern, `patt_hi`.\n  This means only tuples and identifiers are allowed; alternations and type ascriptions\n  require `(...)` instead, which switches to `patt`.\n* `rcases_patt_parse` will parse a low precedence `rcases` pattern, `patt`. This consists of a\n  `patt_med` (which deals with alternations), optionally followed by a `: ty` type ascription. The\n  expression `ty` is at `texpr` precedence because it can appear at the end of a tactic, for\n  example in `rcases e with x : ty <|> skip`.\n* `rcases_patt_parse_list` will parse an alternation list, `patt_med`, one or more `patt`\n  patterns separated by `|`. It does not parse a `:` at the end, so that `a | b : ty` parses as\n  `(a | b) : ty` where `a | b` is the `patt_med` part.\n* `rcases_patt_parse_list_rest a` parses an alternation list after the initial pattern, `| b | c`.\n\n```lean\npatt ::= patt_med (\":\" expr)?\npatt_med ::= (patt_hi \"|\")* patt_hi\npatt_hi ::= id | \"rfl\" | \"_\" | \"\u27e8\" (patt \",\")* patt \"\u27e9\" | \"(\" patt \")\"\n```"}, {"name": "tactic.rcases_parse", "description": " Syntax for a `rcases` pattern:\n* `rcases? expr (: n)?`\n* `rcases (h :)? expr (with patt_list (: expr)?)?`."}, {"name": "tactic.rcases_patt.tuple'", "description": "Convert a list of patterns to a tuple pattern, but mapping `[p]` to `p` instead of `\u27e8p\u27e9`."}, {"name": "tactic.merge_list", "description": " Like `zip_with`, but if the lists don't match in length, the excess elements will be put at the\nend of the result."}, {"name": "tactic.rcases_patt.alts\u2081_core", "description": " This function is used for producing rcases patterns based on a case tree. Here we are given\nthe list of patterns to apply to each argument of each constructor after the main case, and must\nproduce a list of alternatives with the same effect. This function calls `tuple\u2081` to make the\nindividual alternatives, and handles merging `[a, b, c | d]` to `a | b | c | d` instead of\n`a | b | (c | d)`."}, {"name": "tactic.rcases_hint.continue", "description": "* `rcases_hint_core depth e` does the same as `rcases p e`, except the pattern `p` is an output\n  instead of an input, controlled only by the case depth argument `depth`. We use `cases` to depth\n  `depth` and then reconstruct an `rcases` pattern `p` that would, if passed to `rcases`, perform\n  the same thing as the case tree we just constructed (or at least, the nearest expressible\n  approximation to this.)\n* `rcases_hint.process_constructors depth cs l` takes a list of constructor names `cs` and a\n  matching list `l` of elements `(g, c', hs, _)` where  `c'` is a constructor name (used for\n  alignment with `cs`), `g` is the subgoal, and `hs` is the list of local hypotheses created by\n  `cases` in that subgoal. It matches on all of them, and then produces a `\u03a3\u03a0`-list of `rcases`\n  patterns describing the result, and the list of generated subgoals.\n* `rcases_hint.continue depth es` does the same as `rcases.continue (ps.zip es)`, except the\n  patterns `ps` are an output instead of an input, created by matching on everything to depth\n  `depth` and recording the successful cases. It returns `ps`, and the list of generated subgoals."}, {"name": "tactic.rcases_many", "description": " `rcases_many es pats` performs case distinction on the `es` using `pat` to\nname the arising new variables and assumptions.\nSee the module comment for the syntax of `pat`."}, {"name": "tactic.interactive.obtain", "description": "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain \u27e8patt\u27e9 : type,\n{ ... }\n```\nis equivalent to\n```lean\nhave h : type,\n{ ... },\nrcases h with \u27e8patt\u27e9\n```\n\nThe syntax `obtain \u27e8patt\u27e9 : type := proof` is also supported.\n\nIf `\u27e8patt\u27e9` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required."}, {"name": "tactic.rcases_patt_parse", "description": " `rcases_patt_parse` will parse a low precedence `rcases` pattern, `patt`. This consists of a\n`patt_med` (which deals with alternations), optionally followed by a `: ty` type ascription. The\nexpression `ty` is at `texpr` precedence because it can appear at the end of a tactic, for\nexample in `rcases e with x : ty <|> skip`.\n```lean\npatt ::= patt_med (\":\" expr)?\n```"}, {"name": "tactic.rcases_patt.inhabited", "description": ""}, {"name": "tactic.rcases_patt.as_alts", "description": " Interpret an rcases pattern as an alternation, where non-alternations are treated as one\nalternative."}, {"name": "tactic.clear_goals", "description": " Given a list of `uncleared_goal`s, each of which is a goal metavariable and\na list of variables to clear, actually perform the clear and set the goals with the result."}, {"name": "tactic.rcases_patt.alts\u2081", "description": " This function is used for producing rcases patterns based on a case tree. This is like\n`alts\u2081_core`, but it produces a cases pattern directly instead of a list of alternatives. We\nspecially translate the empty alternation to `\u27e8\u27e9`, and translate `|(a | b)` to `\u27e8a | b\u27e9` (because we\ndon't have any syntax for unary alternation). Otherwise we can use the regular merging of\nalternations at the last argument so that `a | b | (c | d)` becomes `a | b | c | d`."}, {"name": "tactic.interactive.rintro", "description": "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | \u27e8b, c\u27e9) \u27e8d, e\u27e9`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n\n`rintro?` will introduce and case split on variables in the same way as\n`rintro`, but will also print the `rintro` invocation that would have the same\nresult. Like `rcases?`, `rintro? : n` allows for modifying the\ndepth of splitting; the default is 5.\n\n`rintros` is an alias for `rintro`."}, {"name": "tactic.rcases.continue", "description": "* `rcases_core p e` will match a pattern `p` against a local hypothesis `e`.\n  It returns the list of subgoals that were produced.\n* `rcases.continue pes` will match a (conjunctive) list of `(p, e)` pairs which refer to\n  patterns and local hypotheses to match against, and applies all of them. Note that this can\n  involve matching later arguments multiple times given earlier arguments, for example\n  `\u27e8a | b, \u27e8c, d\u27e9\u27e9` performs the `\u27e8c, d\u27e9` match twice, once on the `a` branch and once on `b`."}, {"name": "tactic.rcases", "description": " `rcases h e pat` performs case distinction on `e` using `pat` to\nname the arising new variables and assumptions. If `h` is `some` name,\na new assumption `h : e = pat` will relate the expression `e` with the\ncurrent pattern. See the module comment for the syntax of `pat`."}, {"name": "tactic.rcases_patt_parse_hi'", "description": "* `rcases_patt_parse_hi` will parse a high precedence `rcases` pattern, `patt_hi`.\n  This means only tuples and identifiers are allowed; alternations and type ascriptions\n  require `(...)` instead, which switches to `patt`.\n* `rcases_patt_parse` will parse a low precedence `rcases` pattern, `patt`. This consists of a\n  `patt_med` (which deals with alternations), optionally followed by a `: ty` type ascription. The\n  expression `ty` is at `texpr` precedence because it can appear at the end of a tactic, for\n  example in `rcases e with x : ty <|> skip`.\n* `rcases_patt_parse_list` will parse an alternation list, `patt_med`, one or more `patt`\n  patterns separated by `|`. It does not parse a `:` at the end, so that `a | b : ty` parses as\n  `(a | b) : ty` where `a | b` is the `patt_med` part.\n* `rcases_patt_parse_list_rest a` parses an alternation list after the initial pattern, `| b | c`.\n\n```lean\npatt ::= patt_med (\":\" expr)?\npatt_med ::= (patt_hi \"|\")* patt_hi\npatt_hi ::= id | \"rfl\" | \"_\" | \"\u27e8\" (patt \",\")* patt \"\u27e9\" | \"(\" patt \")\"\n```"}, {"name": "tactic.rcases_hint_many", "description": "* `rcases? \u27e8e1, e2, e3\u27e9` is like `rcases \u27e8e1, e2, e3\u27e9 with ...`, except it\n  generates `...` by matching on everything it can, and it outputs an `rcases`\n  invocation that should have the same effect.\n* `rcases? \u27e8e1, e2, e3\u27e9 : n` can be used to control the depth of case splits\n  (especially important for recursive types like `nat`, which can be cased as many\n  times as you like)."}, {"name": "tactic.rintro_patt_parse", "description": "`rintro_patt_parse` will parse a low precedence `rcases` pattern, `rintro_patt` below.\nThis consists of either a sequence of patterns `p1 p2 p3` or an alternation list `p1 | p2 | p3`\ntreated as a single pattern, optionally followed by a `: ty` type ascription, which applies to\nevery pattern in the list.\n```lean\nrintro_patt ::= (rintro_patt_hi+ | patt_med) (\":\" expr)?\n```"}, {"name": "tactic.list_Sigma", "description": "A list, with a disjunctive meaning (like a list of inductive constructors, or subgoals)"}, {"name": "tactic.rcases_patt.as_tuple", "description": " Interpret an rcases pattern as a tuple, where `p` becomes `\u27e8p\u27e9`\nif `p` is not already a tuple."}, {"name": "tactic.rintro_patt_parse'", "description": "`rintro_patt_parse_hi` and `rintro_patt_parse` are like `rcases_patt_parse`, but is used for\nparsing top level `rintro` patterns, which allow sequences like `(x y : t)` in addition to simple\n`rcases` patterns.\n\n* `rintro_patt_parse_hi` will parse a high precedence `rcases` pattern, `rintro_patt_hi` below.\n  This means only tuples and identifiers are allowed; alternations and type ascriptions\n  require `(...)` instead, which switches to `patt`.\n* `rintro_patt_parse` will parse a low precedence `rcases` pattern, `rintro_patt` below.\n  This consists of either a sequence of patterns `p1 p2 p3` or an alternation list `p1 | p2 | p3`\n  treated as a single pattern, optionally followed by a `: ty` type ascription, which applies to\n  every pattern in the list.\n* `rintro_patt_parse_low` parses `rintro_patt_low`, which is the same as `rintro_patt_parse tt` but\n  it does not permit an unparenthesized alternation list, it must have the form `p1 p2 p3 (: ty)?`.\n\n```lean\nrintro_patt ::= (rintro_patt_hi+ | patt_med) (\":\" expr)?\nrintro_patt_low ::= rintro_patt_hi* (\":\" expr)?\nrintro_patt_hi ::= patt_hi | \"(\" rintro_patt \")\"\n```"}, {"name": "tactic.rintro_patt_parse_hi'", "description": "`rintro_patt_parse_hi` and `rintro_patt_parse` are like `rcases_patt_parse`, but is used for\nparsing top level `rintro` patterns, which allow sequences like `(x y : t)` in addition to simple\n`rcases` patterns.\n\n* `rintro_patt_parse_hi` will parse a high precedence `rcases` pattern, `rintro_patt_hi` below.\n  This means only tuples and identifiers are allowed; alternations and type ascriptions\n  require `(...)` instead, which switches to `patt`.\n* `rintro_patt_parse` will parse a low precedence `rcases` pattern, `rintro_patt` below.\n  This consists of either a sequence of patterns `p1 p2 p3` or an alternation list `p1 | p2 | p3`\n  treated as a single pattern, optionally followed by a `: ty` type ascription, which applies to\n  every pattern in the list.\n* `rintro_patt_parse_low` parses `rintro_patt_low`, which is the same as `rintro_patt_parse tt` but\n  it does not permit an unparenthesized alternation list, it must have the form `p1 p2 p3 (: ty)?`.\n\n```lean\nrintro_patt ::= (rintro_patt_hi+ | patt_med) (\":\" expr)?\nrintro_patt_low ::= rintro_patt_hi* (\":\" expr)?\nrintro_patt_hi ::= patt_hi | \"(\" rintro_patt \")\"\n```"}, {"name": "tactic_doc.tactic.rintro", "description": "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | \u27e8b, c\u27e9) \u27e8d, e\u27e9`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n\n`rintro?` will introduce and case split on variables in the same way as\n`rintro`, but will also print the `rintro` invocation that would have the same\nresult. Like `rcases?`, `rintro? : n` allows for modifying the\ndepth of splitting; the default is 5.\n\n`rintros` is an alias for `rintro`."}, {"name": "tactic.rcases_core", "description": "* `rcases_core p e` will match a pattern `p` against a local hypothesis `e`.\n  It returns the list of subgoals that were produced.\n* `rcases.continue pes` will match a (conjunctive) list of `(p, e)` pairs which refer to\n  patterns and local hypotheses to match against, and applies all of them. Note that this can\n  involve matching later arguments multiple times given earlier arguments, for example\n  `\u27e8a | b, \u27e8c, d\u27e9\u27e9` performs the `\u27e8c, d\u27e9` match twice, once on the `a` branch and once on `b`."}, {"name": "tactic.list_Pi", "description": "A list, with a conjunctive meaning (like a list of constructor arguments, or hypotheses)"}, {"name": "tactic.rcases_patt.has_to_tactic_format", "description": ""}, {"name": "tactic.rcases_args.has_reflect", "description": ""}, {"name": "tactic.rcases_patt_parse_list", "description": " `rcases_patt_parse_list` will parse an alternation list, `patt_med`, one or more `patt`\npatterns separated by `|`. It does not parse a `:` at the end, so that `a | b : ty` parses as\n`(a | b) : ty` where `a | b` is the `patt_med` part.\n```lean\npatt_med ::= (patt_hi \"|\")* patt_hi\n```"}, {"name": "tactic_doc.tactic.rcases", "description": "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a \u2227 b \u2227 c \u2228 d` or\n`h2 : \u2203 x y, trans_rel R x y`. Usual usage might be `rcases h1 with \u27e8ha, hb, hc\u27e9 | hd` or\n`rcases h2 with \u27e8x, y, _ | \u27e8z, hxz, hzy\u27e9\u27e9` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `\u27e8p1, p2, p3\u27e9`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a \u2227 b \u2227 c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* An alteration pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a \u2228 b \u2228 c`.\n\nA pattern like `\u27e8a, b, c\u27e9 | \u27e8d, e\u27e9` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `\u27e8\u27e8a\u27e9, b | c\u27e9 | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `\u27e8a, b, c\u27e9` for splitting on\n`\u2203 x, \u2203 y, p x`, then it will be treated as `\u27e8a, \u27e8b, c\u27e9\u27e9`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n\n`rcases? e` will perform case splits on `e` in the same way as `rcases e`,\nbut rather than accepting a pattern, it does a maximal cases and prints the\npattern that would produce this case splitting. The default maximum depth is 5,\nbut this can be modified with `rcases? e : n`."}, {"name": "tactic.rintro_patt_parse_hi", "description": "`rintro_patt_parse_hi` will parse a high precedence `rcases` pattern, `rintro_patt_hi` below.\nThis means only tuples and identifiers are allowed; alternations and type ascriptions\nrequire `(...)` instead, which switches to `patt`.\n```lean\nrintro_patt_hi ::= patt_hi | \"(\" rintro_patt \")\"\n```"}, {"name": "tactic.rcases_patt.has_reflect", "description": ""}, {"name": "has_ssubset.ssubset.trans_subset", "description": "**Alias** of `ssubset_of_ssubset_of_subset`."}, {"name": "is_order_connected_of_is_strict_total_order'", "description": ""}, {"name": "ne_of_ssuperset", "description": ""}, {"name": "well_founded_lt_dual_iff", "description": ""}, {"name": "ge.is_total_preorder", "description": ""}, {"name": "gt.is_asymm", "description": ""}, {"name": "antisymm_iff", "description": ""}, {"name": "set.unbounded", "description": "An unbounded or cofinal set."}, {"name": "order_dual.well_founded_lt", "description": ""}, {"name": "ge.is_total", "description": ""}, {"name": "is_well_order.linear_order", "description": "Construct a decidable linear order from a well-founded linear order."}, {"name": "well_founded_lt", "description": "A class for a well founded relation `<`."}, {"name": "subset_iff_ssubset_or_eq", "description": ""}, {"name": "has_ssubset.ssubset.false", "description": "**Alias** of `ssubset_irrfl`."}, {"name": "eq_empty_relation", "description": ""}, {"name": "not_rel_of_subsingleton", "description": ""}, {"name": "has_lt.lt.is_antisymm", "description": ""}, {"name": "ssubset_of_subset_of_ne", "description": ""}, {"name": "ge.is_antisymm", "description": ""}, {"name": "is_well_founded.is_irrefl", "description": ""}, {"name": "right_iff_left_not_left", "description": ""}, {"name": "is_strict_total_order'.swap", "description": ""}, {"name": "is_strict_total_order'", "description": " This is basically the same as `is_strict_total_order`, but that definition has a redundant\nassumption `is_incomp_trans \u03b1 lt`."}, {"name": "is_strict_total_order'.to_is_trichotomous", "description": " This is basically the same as `is_strict_total_order`, but that definition has a redundant\nassumption `is_incomp_trans \u03b1 lt`."}, {"name": "is_strict_total_order'.to_is_strict_order", "description": " This is basically the same as `is_strict_total_order`, but that definition has a redundant\nassumption `is_incomp_trans \u03b1 lt`."}, {"name": "subset_of_eq", "description": ""}, {"name": "gt.is_trans", "description": ""}, {"name": "is_well_order.is_asymm", "description": ""}, {"name": "has_le.le.is_trans", "description": ""}, {"name": "order_dual.well_founded_gt", "description": ""}, {"name": "ge.is_trans", "description": ""}, {"name": "antisymm_of'", "description": " A version of `antisymm'` with `r` explicit.\n\nThis lemma matches the lemmas from lean core in `init.algebra.classes`, but is missing there."}, {"name": "is_well_order.is_trichotomous", "description": ""}, {"name": "ne.ssubset_of_subset", "description": "**Alias** of `ssubset_of_ne_of_subset`."}, {"name": "measure.is_well_founded", "description": ""}, {"name": "ge.is_partial_order", "description": ""}, {"name": "is_asymm.is_antisymm", "description": ""}, {"name": "has_subset.subset.antisymm", "description": "**Alias** of `subset_antisymm`."}, {"name": "ge.is_trichotomous", "description": ""}, {"name": "has_ssubset.ssubset.not_subset", "description": "**Alias** of `not_subset_of_ssubset`."}, {"name": "gt.is_well_order", "description": ""}, {"name": "is_total.swap", "description": ""}, {"name": "is_linear_order.swap", "description": ""}, {"name": "well_founded_gt_dual_iff", "description": ""}, {"name": "is_total.is_trichotomous", "description": ""}, {"name": "ssubset_irrfl", "description": ""}, {"name": "ssubset_iff_subset_not_subset", "description": ""}, {"name": "well_founded_gt.fix_eq", "description": "The value from `well_founded_gt.fix` is built from the successive ones as specified."}, {"name": "order_dual.is_total_le", "description": ""}, {"name": "ge.is_linear_order", "description": ""}, {"name": "has_subset.subset.not_ssubset", "description": "**Alias** of `not_ssubset_of_subset`."}, {"name": "has_le.le.is_refl", "description": ""}, {"name": "transitive_gt", "description": ""}, {"name": "has_ssubset.ssubset.subset", "description": "**Alias** of `subset_of_ssubset`."}, {"name": "is_total_preorder.swap", "description": ""}, {"name": "has_lt.lt.is_strict_order", "description": ""}, {"name": "well_founded_gt", "description": "A class for a well founded relation `>`."}, {"name": "set.bounded", "description": "A bounded or final set. Not to be confused with `metric.bounded`."}, {"name": "prod.is_refl_preimage_fst", "description": ""}, {"name": "ssubset_of_subset_of_ssubset", "description": ""}, {"name": "has_le.le.is_partial_order", "description": ""}, {"name": "nat.well_founded_lt", "description": ""}, {"name": "is_refl.swap", "description": ""}, {"name": "empty_relation.is_irrefl", "description": ""}, {"name": "has_ssubset.ssubset.asymm", "description": "**Alias** of `ssubset_asymm`."}, {"name": "ssubset_of_subset_not_subset", "description": ""}, {"name": "is_well_order.is_irrefl", "description": ""}, {"name": "empty_relation_apply", "description": ""}, {"name": "has_subset.subset.ssubset_of_ne", "description": "**Alias** of `ssubset_of_subset_of_ne`."}, {"name": "subset_antisymm", "description": ""}, {"name": "ne_of_not_subset", "description": ""}, {"name": "eq.subset'", "description": "**Alias** of `subset_of_eq`."}, {"name": "has_ssubset.ssubset.ne'", "description": "**Alias** of `ne_of_ssuperset`."}, {"name": "is_asymm.is_irrefl", "description": ""}, {"name": "has_subset.subset.trans_ssubset", "description": "**Alias** of `ssubset_of_subset_of_ssubset`."}, {"name": "subset_rfl", "description": ""}, {"name": "ssubset_or_eq_of_subset", "description": ""}, {"name": "well_founded_lt.induction", "description": "Inducts on a well-founded `<` relation."}, {"name": "gt.is_antisymm", "description": ""}, {"name": "has_ssubset.ssubset.trans", "description": "**Alias** of `ssubset_trans`."}, {"name": "ne_of_ssubset", "description": ""}, {"name": "transitive_le", "description": ""}, {"name": "has_lt.lt.is_strict_weak_order", "description": ""}, {"name": "well_founded_lt.to_has_well_founded", "description": "Derive a `has_well_founded` instance from a `well_founded_lt` instance."}, {"name": "well_founded_lt.fix_eq", "description": "The value from `well_founded_lt.fix` is built from the previous ones as specified."}, {"name": "prod.is_trans_preimage_snd", "description": ""}, {"name": "is_nonstrict_strict_order.to_is_irrefl", "description": ""}, {"name": "extensional_of_trichotomous_of_irrefl", "description": "In a trichotomous irreflexive order, every element is determined by the set of predecessors."}, {"name": "not_subset_of_ssubset", "description": ""}, {"name": "is_nonstrict_strict_order", "description": " An unbundled relation class stating that `r` is the nonstrict relation corresponding to the\nstrict relation `s`. Compare `preorder.lt_iff_le_not_le`. This is mostly meant to provide dot\nnotation on `(\u2286)` and `(\u2282)`."}, {"name": "is_nonstrict_strict_order.right_iff_left_not_left", "description": " An unbundled relation class stating that `r` is the nonstrict relation corresponding to the\nstrict relation `s`. Compare `preorder.lt_iff_le_not_le`. This is mostly meant to provide dot\nnotation on `(\u2286)` and `(\u2282)`."}, {"name": "prod.lex.is_well_order", "description": ""}, {"name": "ge.is_preorder", "description": ""}, {"name": "prod.is_refl_preimage_snd", "description": ""}, {"name": "ne_of_irrefl", "description": ""}, {"name": "eq_or_ssubset_of_subset", "description": ""}, {"name": "linear_order.is_total_preorder", "description": ""}, {"name": "is_well_order.to_has_well_founded", "description": "Derive a `has_well_founded` instance from a `is_well_order` instance."}, {"name": "has_subset.subset.ssubset_of_not_subset", "description": "**Alias** of `ssubset_of_subset_not_subset`."}, {"name": "well_founded_gt.fix", "description": " Creates data, given a way to generate a value from all that compare as greater. See also\n`well_founded_gt.fix_eq`."}, {"name": "has_lt.lt.is_nonstrict_strict_order", "description": ""}, {"name": "has_lt.lt.is_asymm", "description": ""}, {"name": "has_well_founded.is_well_founded", "description": ""}, {"name": "comm_of", "description": " A version of `comm` with `r` explicit.\n\nThis lemma matches the lemmas from lean core in `init.algebra.classes`, but is missing there."}, {"name": "is_well_founded.is_asymm", "description": ""}, {"name": "is_preorder.swap", "description": ""}, {"name": "has_lt.lt.is_trans", "description": ""}, {"name": "well_founded_lt.fix", "description": " Creates data, given a way to generate a value from all that compare as lesser. See also\n`well_founded_lt.fix_eq`."}, {"name": "has_le.le.is_linear_order", "description": ""}, {"name": "has_lt.lt.is_strict_total_order'", "description": ""}, {"name": "is_antisymm.swap", "description": ""}, {"name": "nat.lt.is_well_order", "description": ""}, {"name": "rel_of_subsingleton", "description": ""}, {"name": "superset_antisymm_iff", "description": ""}, {"name": "ne_of_irrefl'", "description": ""}, {"name": "gt.is_trichotomous", "description": ""}, {"name": "is_strict_weak_order_of_is_order_connected", "description": ""}, {"name": "is_order_connected", "description": "A connected order is one satisfying the condition `a < c \u2192 a < b \u2228 b < c`.\n This is recognizable as an intuitionistic substitute for `a \u2264 b \u2228 b \u2264 a` on\n the constructive reals, and is also known as negative transitivity,\n since the contrapositive asserts transitivity of the relation `\u00ac a < b`."}, {"name": "is_order_connected.conn", "description": "A connected order is one satisfying the condition `a < c \u2192 a < b \u2228 b < c`.\n This is recognizable as an intuitionistic substitute for `a \u2264 b \u2228 b \u2264 a` on\n the constructive reals, and is also known as negative transitivity,\n since the contrapositive asserts transitivity of the relation `\u00ac a < b`."}, {"name": "well_founded_lt.apply", "description": "All values are accessible under the well-founded `<`."}, {"name": "is_strict_order.swap", "description": ""}, {"name": "antisymm_of", "description": " A version of `antisymm` with `r` explicit.\n\nThis lemma matches the lemmas from lean core in `init.algebra.classes`, but is missing there."}, {"name": "is_well_founded_iff", "description": ""}, {"name": "ssubset_irrefl", "description": ""}, {"name": "is_asymm.swap", "description": ""}, {"name": "has_lt.lt.is_incomp_trans", "description": ""}, {"name": "is_well_founded.induction", "description": "Induction on a well-founded relation."}, {"name": "has_le.le.is_total", "description": ""}, {"name": "is_order_connected.neg_trans", "description": ""}, {"name": "is_well_order.is_strict_total_order", "description": ""}, {"name": "set.unbounded_of_is_empty", "description": ""}, {"name": "prod.is_trans_preimage_fst", "description": ""}, {"name": "superset_of_eq", "description": ""}, {"name": "set.not_bounded_iff", "description": ""}, {"name": "has_le.le.is_antisymm", "description": ""}, {"name": "empty_relation.is_well_order", "description": ""}, {"name": "comm", "description": ""}, {"name": "ssubset_of_ssubset_of_subset", "description": ""}, {"name": "is_partial_order.swap", "description": ""}, {"name": "subset_antisymm_iff", "description": ""}, {"name": "antisymm'", "description": ""}, {"name": "has_le.le.is_trichotomous", "description": ""}, {"name": "is_well_order.is_trans", "description": ""}, {"name": "eq.superset", "description": "**Alias** of `superset_of_eq`."}, {"name": "gt.is_strict_order", "description": ""}, {"name": "has_subset.subset.eq_or_ssubset", "description": "**Alias** of `eq_or_ssubset_of_subset`."}, {"name": "ne_of_not_superset", "description": ""}, {"name": "subrelation.is_well_founded", "description": ""}, {"name": "is_well_order", "description": "A well order is a well-founded linear order."}, {"name": "is_well_order.to_is_strict_total_order'", "description": "A well order is a well-founded linear order."}, {"name": "is_well_order.wf", "description": "A well order is a well-founded linear order."}, {"name": "well_founded.asymmetric", "description": ""}, {"name": "ssubset_of_ne_of_subset", "description": ""}, {"name": "subset_refl", "description": ""}, {"name": "has_lt.lt.is_well_order", "description": ""}, {"name": "has_lt.lt.is_irrefl", "description": ""}, {"name": "is_strict_total_order_of_is_strict_total_order'", "description": ""}, {"name": "transitive_lt", "description": ""}, {"name": "is_well_founded.to_has_well_founded", "description": "Derive a `has_well_founded` instance from an `is_well_founded` instance."}, {"name": "has_subset.subset.ssubset_or_eq", "description": "**Alias** of `ssubset_or_eq_of_subset`."}, {"name": "is_trichotomous.swap", "description": ""}, {"name": "is_total.to_is_refl", "description": ""}, {"name": "trans_trichotomous_left", "description": ""}, {"name": "subset_of_ssubset", "description": ""}, {"name": "gt.is_irrefl", "description": ""}, {"name": "has_lt.lt.is_order_connected", "description": ""}, {"name": "ssubset_iff_subset_ne", "description": ""}, {"name": "not_ssubset_of_subset", "description": ""}, {"name": "prod.lex.is_well_founded", "description": ""}, {"name": "transitive_of_trans", "description": ""}, {"name": "has_le.le.is_preorder", "description": ""}, {"name": "well_founded_gt.to_has_well_founded", "description": "Derive a `has_well_founded` instance from a `well_founded_gt` instance."}, {"name": "has_ssubset.ssubset.ne", "description": "**Alias** of `ne_of_ssubset`."}, {"name": "has_subset.subset.trans", "description": "**Alias** of `subset_trans`."}, {"name": "is_empty.is_well_order", "description": ""}, {"name": "ssubset_asymm", "description": ""}, {"name": "has_lt.lt.is_trichotomous", "description": ""}, {"name": "subset_trans", "description": ""}, {"name": "ssubset_trans", "description": ""}, {"name": "superset_antisymm", "description": ""}, {"name": "is_well_founded", "description": "A well-founded relation. Not to be confused with `is_well_order`."}, {"name": "is_well_founded.wf", "description": "A well-founded relation. Not to be confused with `is_well_order`."}, {"name": "inv_image.is_well_founded", "description": ""}, {"name": "is_trans.swap", "description": ""}, {"name": "has_lt.lt.is_strict_total_order", "description": ""}, {"name": "subsingleton.is_well_order", "description": ""}, {"name": "is_well_founded.fix_eq", "description": "The value from `is_well_founded.fix` is built from the previous ones as specified."}, {"name": "is_irrefl.swap", "description": ""}, {"name": "transitive_ge", "description": ""}, {"name": "ge.is_refl", "description": ""}, {"name": "has_subset.subset.antisymm'", "description": "**Alias** of `superset_antisymm`."}, {"name": "of_eq", "description": ""}, {"name": "set.not_unbounded_iff", "description": ""}, {"name": "linear_order_of_STO'", "description": " Construct a linear order from an `is_strict_total_order'` relation.\n\nSee note [reducible non-instances]."}, {"name": "partial_order_of_SO", "description": " Construct a partial order from a `is_strict_order` relation.\n\nSee note [reducible non-instances]."}, {"name": "trans_trichotomous_right", "description": ""}, {"name": "is_well_founded.apply", "description": "All values are accessible under the well-founded relation."}, {"name": "is_well_founded.fix", "description": " Creates data, given a way to generate a value from all that compare as less under a well-founded\nrelation. See also `is_well_founded.fix_eq`."}, {"name": "right_iff_left_not_left_of", "description": "A version of `right_iff_left_not_left` with explicit `r` and `s`."}, {"name": "well_founded_gt.apply", "description": "All values are accessible under the well-founded `>`."}, {"name": "well_founded_gt.induction", "description": "Inducts on a well-founded `>` relation."}, {"name": "list.decidable_bex", "description": ""}, {"name": "list.decidable_ball", "description": ""}, {"name": "list.alternative", "description": ""}, {"name": "list.bin_tree_to_list", "description": ""}, {"name": "list.monad", "description": ""}, {"name": "list.is_lawful_monad", "description": ""}, {"name": "nat.one_div_pos_of_nat", "description": ""}, {"name": "nat.one_div_lt_one_div", "description": ""}, {"name": "nat.inv_pos_of_nat", "description": ""}, {"name": "nat.one_div_le_one_div", "description": ""}, {"name": "nat.cast_div", "description": ""}, {"name": "nat.cast_div_le", "description": "Natural division is always less than division in the field."}, {"name": "int.lt_of_le_sub_one", "description": ""}, {"name": "int.add_one_le_of_lt", "description": ""}, {"name": "int.decidable_lt", "description": ""}, {"name": "int.lt_neg_add_of_add_lt", "description": ""}, {"name": "int.neg_le_sub_left_of_le_add", "description": ""}, {"name": "int.lt_of_add_one_le", "description": ""}, {"name": "int.sub_neg_of_lt", "description": ""}, {"name": "int.sub_lt_sub_of_lt_of_le", "description": ""}, {"name": "int.lt_add_of_sub_left_lt", "description": ""}, {"name": "int.lt_of_sub_pos", "description": ""}, {"name": "int.le.dest", "description": ""}, {"name": "int.le_neg_of_le_neg", "description": ""}, {"name": "int.lt_of_add_lt_add_right", "description": ""}, {"name": "int.le_of_add_le_add_right", "description": ""}, {"name": "int.sub_right_le_of_le_add", "description": ""}, {"name": "int.mul_le_mul_of_nonneg_right", "description": ""}, {"name": "int.eq_of_sub_eq_zero", "description": ""}, {"name": "int.lt_of_neg_lt_neg", "description": ""}, {"name": "int.neg_add_lt_right_of_lt_add", "description": ""}, {"name": "int.lt.intro", "description": ""}, {"name": "int.le_of_lt_add_one", "description": ""}, {"name": "int.nonneg_or_nonneg_neg", "description": ""}, {"name": "int.neg_mul_eq_neg_mul", "description": ""}, {"name": "int.has_lt", "description": ""}, {"name": "int.sub_lt_self", "description": ""}, {"name": "int.eq_of_mul_eq_mul_left", "description": ""}, {"name": "int.le_of_coe_nat_le_coe_nat", "description": ""}, {"name": "int.neg_lt_sub_left_of_lt_add", "description": ""}, {"name": "int.sub_left_le_of_le_add", "description": ""}, {"name": "int.neg_mul_eq_neg_mul_symm", "description": ""}, {"name": "int.le_add_of_neg_le_sub_right", "description": ""}, {"name": "int.le.dest_sub", "description": ""}, {"name": "int.lt_add_of_neg_add_lt", "description": ""}, {"name": "int.le_of_sub_nonpos", "description": ""}, {"name": "int.nonneg_of_neg_nonpos", "description": ""}, {"name": "int.lt_add_of_pos_right", "description": ""}, {"name": "int.sub_self", "description": ""}, {"name": "int.eq_zero_or_eq_zero_of_mul_eq_zero", "description": ""}, {"name": "int.sub_one_lt_of_le", "description": ""}, {"name": "int.mul_lt_mul", "description": ""}, {"name": "int.coe_nat_le_coe_nat_iff", "description": ""}, {"name": "int.lt.elim", "description": ""}, {"name": "int.mul_pos_of_neg_of_neg", "description": ""}, {"name": "int.le_add_of_neg_add_le", "description": ""}, {"name": "int.add_lt_add_right", "description": ""}, {"name": "int.add_lt_add", "description": ""}, {"name": "int.mul_self_le_mul_self", "description": ""}, {"name": "int.lt_add_of_neg_add_lt_left", "description": ""}, {"name": "int.add_le_add_right", "description": ""}, {"name": "int.add_pos", "description": ""}, {"name": "int.le_of_neg_le_neg", "description": ""}, {"name": "int.nonneg", "description": ""}, {"name": "int.lt_succ", "description": ""}, {"name": "int.decidable_nonneg", "description": ""}, {"name": "int.add_neg_of_nonpos_of_neg", "description": ""}, {"name": "int.mul_self_lt_mul_self", "description": ""}, {"name": "int.lt_add_of_pos_left", "description": ""}, {"name": "int.lt_add_succ", "description": ""}, {"name": "int.neg_lt_neg", "description": ""}, {"name": "int.le_add_of_neg_add_le_right", "description": ""}, {"name": "int.neg_lt_of_neg_lt", "description": ""}, {"name": "int.lt_sub_left_of_add_lt", "description": ""}, {"name": "int.lt_of_add_lt_add_left", "description": ""}, {"name": "int.sign_eq_neg_one_iff_neg", "description": ""}, {"name": "int.sub_lt_sub_left", "description": ""}, {"name": "int.sub_le_sub", "description": ""}, {"name": "int.add_le_add_three", "description": ""}, {"name": "int.lt_of_coe_nat_lt_coe_nat", "description": ""}, {"name": "int.mul_nonpos_of_nonpos_of_nonneg", "description": ""}, {"name": "int.neg_of_neg_pos", "description": ""}, {"name": "int.of_nat_nat_abs_of_nonpos", "description": ""}, {"name": "int.mul_lt_mul_of_pos_right", "description": ""}, {"name": "int.coe_nat_lt_coe_nat_iff", "description": ""}, {"name": "int.mul_neg_of_neg_of_pos", "description": ""}, {"name": "int.add_le_add", "description": ""}, {"name": "int.of_nat_nonneg", "description": ""}, {"name": "int.sub_lt_sub_of_le_of_lt", "description": ""}, {"name": "int.sub_mul", "description": ""}, {"name": "int.mul_lt_mul'", "description": ""}, {"name": "int.mul_sub", "description": ""}, {"name": "int.mul_le_mul_of_nonneg_left", "description": ""}, {"name": "int.nonneg.elim", "description": ""}, {"name": "int.lt_irrefl", "description": ""}, {"name": "int.add_lt_add_left", "description": ""}, {"name": "int.lt_add_of_le_of_pos", "description": ""}, {"name": "int.lt_neg_of_lt_neg", "description": ""}, {"name": "int.le_antisymm", "description": ""}, {"name": "int.neg_lt_sub_right_of_lt_add", "description": ""}, {"name": "int.eq_one_of_mul_eq_self_left", "description": ""}, {"name": "int.sign_eq_one_iff_pos", "description": ""}, {"name": "int.mul_le_mul_of_nonpos_right", "description": ""}, {"name": "int.add_lt_of_lt_neg_add", "description": ""}, {"name": "int.add_le_of_le_sub_right", "description": ""}, {"name": "int.lt_iff_le_and_ne", "description": ""}, {"name": "int.zero_lt_one", "description": ""}, {"name": "int.sub_le_sub_right", "description": ""}, {"name": "int.has_le", "description": ""}, {"name": "int.lt_add_of_neg_lt_sub_left", "description": ""}, {"name": "int.le.intro", "description": ""}, {"name": "int.neg_le_sub_right_of_le_add", "description": ""}, {"name": "int.le_sub_one_of_lt", "description": ""}, {"name": "int.sub_le_of_sub_le", "description": ""}, {"name": "int.le_trans", "description": ""}, {"name": "int.eq_neg_of_eq_neg", "description": ""}, {"name": "int.add_lt_add_of_lt_of_le", "description": ""}, {"name": "int.eq_neg_succ_of_lt_zero", "description": ""}, {"name": "int.ne_of_lt", "description": ""}, {"name": "int.sub_nonpos_of_le", "description": ""}, {"name": "int.sub_eq_zero_iff_eq", "description": ""}, {"name": "int.add_nonneg", "description": ""}, {"name": "int.le_add_of_sub_left_le", "description": ""}, {"name": "int.lt_of_sub_neg", "description": ""}, {"name": "int.neg_eq_of_add_eq_zero", "description": ""}, {"name": "int.neg_add_cancel_left", "description": ""}, {"name": "int.neg_pos_of_neg", "description": ""}, {"name": "int.neg_mul_eq_mul_neg", "description": ""}, {"name": "int.sub_add_cancel", "description": ""}, {"name": "int.mul_pos", "description": ""}, {"name": "int.eq_succ_of_zero_lt", "description": ""}, {"name": "int.add_neg_cancel_left", "description": ""}, {"name": "int.mul_le_mul", "description": ""}, {"name": "int.nonpos_of_neg_nonneg", "description": ""}, {"name": "int.coe_nat_lt_coe_nat_of_lt", "description": ""}, {"name": "int.sub_right_lt_of_lt_add", "description": ""}, {"name": "int.sub_nonneg_of_le", "description": ""}, {"name": "int.eq_coe_of_zero_le", "description": ""}, {"name": "int.add_le_add_left", "description": ""}, {"name": "int.sub_pos_of_lt", "description": ""}, {"name": "int.le_add_of_neg_le_sub_left", "description": ""}, {"name": "int.neg_mul_comm", "description": ""}, {"name": "int.le_add_of_neg_add_le_left", "description": ""}, {"name": "int.add_le_of_le_neg_add", "description": ""}, {"name": "int.eq_nat_abs_of_zero_le", "description": ""}, {"name": "int.add_nonpos", "description": ""}, {"name": "int.sub_lt_sub_right", "description": ""}, {"name": "int.mul_lt_mul_of_neg_right", "description": ""}, {"name": "int.mul_lt_mul_of_neg_left", "description": ""}, {"name": "int.lt_iff_le_not_le", "description": ""}, {"name": "int.add_lt_add_of_le_of_lt", "description": ""}, {"name": "int.coe_nat_le_coe_nat_of_le", "description": ""}, {"name": "int.sign_eq_zero_iff_zero", "description": ""}, {"name": "int.neg_neg_of_pos", "description": ""}, {"name": "int.mul_nonneg_of_nonpos_of_nonpos", "description": ""}, {"name": "int.le_total", "description": ""}, {"name": "int.add_neg", "description": ""}, {"name": "int.pos_of_sign_eq_one", "description": ""}, {"name": "int.lt_add_of_sub_right_lt", "description": ""}, {"name": "int.neg_le_of_neg_le", "description": ""}, {"name": "int.neg_succ_lt_zero", "description": ""}, {"name": "int.sub_lt_of_sub_lt", "description": ""}, {"name": "int.neg_of_sign_eq_neg_one", "description": ""}, {"name": "int.add_sub_assoc", "description": ""}, {"name": "int.le_of_add_le_add_left", "description": ""}, {"name": "int.le_refl", "description": ""}, {"name": "int.neg_nonneg_of_nonpos", "description": ""}, {"name": "int.add_pos_of_pos_of_nonneg", "description": ""}, {"name": "int.le_add_of_sub_right_le", "description": ""}, {"name": "int.exists_eq_neg_of_nat", "description": ""}, {"name": "int.lt_sub_right_of_add_lt", "description": ""}, {"name": "int.neg_add_cancel_right", "description": ""}, {"name": "int.add_le_of_le_sub_left", "description": ""}, {"name": "int.nat_abs_of_nonneg", "description": ""}, {"name": "int.mul_nonneg", "description": ""}, {"name": "int.eq_of_mul_eq_mul_right", "description": ""}, {"name": "int.le.elim", "description": ""}, {"name": "int.linear_order", "description": ""}, {"name": "int.sign_of_succ", "description": ""}, {"name": "int.mul_neg_of_pos_of_neg", "description": ""}, {"name": "int.neg_add_lt_left_of_lt_add", "description": ""}, {"name": "int.eq_one_of_mul_eq_self_right", "description": ""}, {"name": "int.add_pos_of_nonneg_of_pos", "description": ""}, {"name": "int.add_sub_cancel", "description": ""}, {"name": "int.lt_add_one_of_le", "description": ""}, {"name": "int.le_sub_right_of_add_le", "description": ""}, {"name": "int.le.intro_sub", "description": ""}, {"name": "int.sign_eq_neg_one_of_neg", "description": ""}, {"name": "int.le_of_sub_nonneg", "description": ""}, {"name": "int.add_lt_of_lt_sub_left", "description": ""}, {"name": "int.eq_zero_of_sign_eq_zero", "description": ""}, {"name": "int.lt.dest", "description": ""}, {"name": "int.neg_add_le_right_of_le_add", "description": ""}, {"name": "int.le_sub_left_of_add_le", "description": ""}, {"name": "int.sub_eq_zero_of_eq", "description": ""}, {"name": "int.coe_succ_pos", "description": ""}, {"name": "int.sub_le_sub_left", "description": ""}, {"name": "int.le_add_of_nonneg_right", "description": ""}, {"name": "int.sign_eq_one_of_pos", "description": ""}, {"name": "int.neg_mul_neg", "description": ""}, {"name": "int.lt_add_of_neg_lt_sub_right", "description": ""}, {"name": "int.lt_iff_add_one_le", "description": ""}, {"name": "int.add_lt_of_lt_sub_right", "description": ""}, {"name": "int.neg_add_lt_of_lt_add", "description": ""}, {"name": "int.neg_nonpos_of_nonneg", "description": ""}, {"name": "int.neg_le_neg", "description": ""}, {"name": "int.sub_le_self", "description": ""}, {"name": "int.le_of_sub_one_lt", "description": ""}, {"name": "int.le_nat_abs", "description": ""}, {"name": "int.le_of_lt", "description": ""}, {"name": "int.mul_nonpos_of_nonneg_of_nonpos", "description": ""}, {"name": "int.add_neg_cancel_right", "description": ""}, {"name": "int.le_neg_add_of_add_le", "description": ""}, {"name": "int.le", "description": ""}, {"name": "int.le_add_of_nonneg_left", "description": ""}, {"name": "int.sub_lt_sub", "description": ""}, {"name": "int.neg_add_le_left_of_le_add", "description": ""}, {"name": "int.lt", "description": ""}, {"name": "int.neg_add_le_of_le_add", "description": ""}, {"name": "int.pos_of_neg_neg", "description": ""}, {"name": "int.add_neg_of_neg_of_nonpos", "description": ""}, {"name": "int.lt_add_of_neg_add_lt_right", "description": ""}, {"name": "int.coe_zero_le", "description": ""}, {"name": "int.mul_lt_mul_of_pos_left", "description": ""}, {"name": "int.decidable_le", "description": ""}, {"name": "int.mul_neg_eq_neg_mul_symm", "description": ""}, {"name": "int.sub_left_lt_of_lt_add", "description": ""}, {"name": "set.inter_Union\u2082", "description": ""}, {"name": "set.sigma.univ", "description": ""}, {"name": "set.subset_sInter", "description": ""}, {"name": "set.sInter_eq_compl_sUnion_compl", "description": ""}, {"name": "set.sInter_insert", "description": ""}, {"name": "set.Union_Union_eq_left", "description": ""}, {"name": "set.antitone_set_of", "description": ""}, {"name": "set.bInter_insert", "description": ""}, {"name": "set.Union_Inter_subset", "description": "An equality version of this lemma is `Union_Inter_of_monotone` in `data.set.finite`."}, {"name": "set.bInter_image", "description": ""}, {"name": "set.pi_diff_pi_subset", "description": ""}, {"name": "set.bij_on_Inter", "description": ""}, {"name": "set.preimage_kern_image", "description": ""}, {"name": "set.disjoint_of_subset_right", "description": ""}, {"name": "set.bUnion_singleton", "description": ""}, {"name": "set.monotone_image", "description": "`set.image` is monotone. See `set.image_image` for the statement in terms of `\u2286`."}, {"name": "set.set_of_exists", "description": ""}, {"name": "set.subset_Inter_iff", "description": ""}, {"name": "set.antitone_bforall", "description": "Quantifying over a set is antitone in the set"}, {"name": "set.Union_mono'", "description": ""}, {"name": "set.not_disjoint_iff", "description": ""}, {"name": "set.monotone_set_of", "description": ""}, {"name": "set.maps_to_Union_Union", "description": ""}, {"name": "set.sInter_diff_singleton_univ", "description": ""}, {"name": "set.Inter_union_of_antitone", "description": ""}, {"name": "set.bInter_univ", "description": ""}, {"name": "set.sUnion_diff_singleton_empty", "description": ""}, {"name": "set.not_mem_of_not_mem_sUnion", "description": ""}, {"name": "set.disjoint_preimage_iff", "description": ""}, {"name": "set.univ_subtype", "description": ""}, {"name": "set.mem_Inter\u2082", "description": ""}, {"name": "set.Inter_congr", "description": ""}, {"name": "set.Inter_set_of", "description": ""}, {"name": "set.mem_Inter\u2082_of_mem", "description": ""}, {"name": "set.bInter_eq_Inter", "description": ""}, {"name": "set.nonempty.of_sUnion", "description": ""}, {"name": "set.subset_Inter\u2082", "description": ""}, {"name": "set.Union\u2082_congr", "description": ""}, {"name": "set.mem_sInter", "description": ""}, {"name": "set.bUnion_of_singleton", "description": ""}, {"name": "set.Inter\u2082_eq_empty_iff", "description": ""}, {"name": "set.diff_Union", "description": ""}, {"name": "set.Union_inter_subset", "description": ""}, {"name": "set.disjoint_iff", "description": ""}, {"name": "set.maps_to_Inter", "description": ""}, {"name": "set.Union_empty", "description": ""}, {"name": "set.disjoint_Union\u2082_right", "description": ""}, {"name": "set.maps_to_Union\u2082", "description": ""}, {"name": "set.Union_prod_of_monotone", "description": ""}, {"name": "set.image2_Inter\u2082_subset_left", "description": ""}, {"name": "set.disjoint_singleton_right", "description": ""}, {"name": "set.subset_diff", "description": ""}, {"name": "set.mem_Union", "description": ""}, {"name": "set.disjoint_of_subset", "description": ""}, {"name": "set.Union_eq_dif", "description": ""}, {"name": "set.maps_to_Inter\u2082_Inter\u2082", "description": ""}, {"name": "set.Inter_coe_set", "description": ""}, {"name": "set.has_Sup", "description": ""}, {"name": "set.Union\u2082_comm", "description": ""}, {"name": "sup_closed_of_linear_order", "description": ""}, {"name": "set.Inter_subset", "description": ""}, {"name": "set.Union_dite", "description": ""}, {"name": "disjoint.subset_right_of_subset_union", "description": ""}, {"name": "set.union_Union_nat_succ", "description": ""}, {"name": "set.sInter_singleton", "description": ""}, {"name": "Sup_sUnion", "description": ""}, {"name": "set.bInter_pair", "description": ""}, {"name": "antitone.Inter_nat_add", "description": ""}, {"name": "set.compl_sInter", "description": ""}, {"name": "set.bUnion_eq_Union", "description": ""}, {"name": "set.Inter_Inter_eq_or_left", "description": ""}, {"name": "set.disjoint_Union_left", "description": ""}, {"name": "set.sUnion_mono", "description": ""}, {"name": "set.Inter_eq_if", "description": ""}, {"name": "set.inter_eq_Inter", "description": ""}, {"name": "set.Union_comm", "description": ""}, {"name": "sup_closed", "description": "A set `s` is sup-closed if for all `x\u2081, x\u2082 \u2208 s`, `x\u2081 \u2294 x\u2082 \u2208 s`."}, {"name": "set.disjoint_diff", "description": ""}, {"name": "set.subset_Inter\u2082_iff", "description": ""}, {"name": "set.Union_ge_eq_Union_nat_add", "description": ""}, {"name": "set.bInter_singleton", "description": ""}, {"name": "set.union_distrib_Inter_left", "description": ""}, {"name": "set.Inter_or", "description": ""}, {"name": "set.bUnion_self", "description": ""}, {"name": "set.Union_subset", "description": ""}, {"name": "set.seq_subset", "description": ""}, {"name": "set.Inter_inter", "description": ""}, {"name": "set.sUnion", "description": "Union of a set of sets."}, {"name": "set.disjoint_image_image", "description": ""}, {"name": "set.nonempty_bUnion", "description": ""}, {"name": "set.image_Inter_subset", "description": ""}, {"name": "set.bUnion_image", "description": ""}, {"name": "set.set_of_forall", "description": ""}, {"name": "set.image_projection_prod", "description": ""}, {"name": "antitone.inter", "description": ""}, {"name": "set.Union_image_right", "description": ""}, {"name": "set.empty_disjoint", "description": ""}, {"name": "set.disjoint_Union\u2082_left", "description": ""}, {"name": "set.disjoint_empty", "description": ""}, {"name": "set.bUnion_and'", "description": ""}, {"name": "sup_closed.inter", "description": ""}, {"name": "set.bInter_subset_of_mem", "description": "A specialization of `Inter\u2082_subset`."}, {"name": "set.nonempty.not_disjoint", "description": "**Alias** of the reverse direction of `set.not_disjoint_iff_nonempty_inter`."}, {"name": "set.maps_to_sInter", "description": ""}, {"name": "antitone.union", "description": ""}, {"name": "set.bUnion_union", "description": ""}, {"name": "set.Union_range_eq_Union", "description": ""}, {"name": "set.sUnion_empty", "description": ""}, {"name": "set.seq_seq", "description": ""}, {"name": "set.Inter_congr_of_surjective", "description": ""}, {"name": "disjoint.of_preimage", "description": ""}, {"name": "function.surjective.Union_comp", "description": ""}, {"name": "set.image_eq_Union", "description": ""}, {"name": "set.pi_def", "description": ""}, {"name": "set.Union_Union_eq_or_left", "description": ""}, {"name": "set.compl_Inter", "description": ""}, {"name": "set.disjoint_or_nonempty_inter", "description": ""}, {"name": "monotone_on.inter", "description": ""}, {"name": "set.Inter\u2082_comm", "description": ""}, {"name": "disjoint.subset_left_of_subset_union", "description": ""}, {"name": "set.sUnion_eq_bUnion", "description": ""}, {"name": "set.sUnion_eq_Union", "description": ""}, {"name": "sup_closed_singleton", "description": ""}, {"name": "set.Union_mono", "description": ""}, {"name": "set.bUnion_subset_bUnion_left", "description": ""}, {"name": "set.range_sigma_eq_Union_range", "description": ""}, {"name": "set.preimage_sInter", "description": ""}, {"name": "set.union_eq_Union", "description": ""}, {"name": "set.Union_and", "description": ""}, {"name": "set.sInter_eq_empty_iff", "description": ""}, {"name": "set.prod_eq_seq", "description": ""}, {"name": "set.nonempty_sInter", "description": ""}, {"name": "set.Inter_subset_Inter\u2082", "description": ""}, {"name": "set.kern_image", "description": "`kern_image f s` is the set of `y` such that `f \u207b\u00b9 y \u2286 s`."}, {"name": "set.Union_false", "description": ""}, {"name": "set.sUnion_subset_sUnion", "description": ""}, {"name": "set.bUnion_univ", "description": ""}, {"name": "set.bij_on_Union_of_directed", "description": ""}, {"name": "set.Union_eq_univ_iff", "description": ""}, {"name": "set.maps_to_Union\u2082_Union\u2082", "description": ""}, {"name": "set.disjoint_sUnion_left", "description": ""}, {"name": "set.sUnion_prod_const", "description": ""}, {"name": "set.surj_on_Union\u2082_Union\u2082", "description": ""}, {"name": "set.union_Inter\u2082", "description": ""}, {"name": "set.univ_pi_eq_Inter", "description": ""}, {"name": "set.Union_congr_of_surjective", "description": ""}, {"name": "set.Ici_supr", "description": ""}, {"name": "set.bInter_union", "description": ""}, {"name": "function.surjective.Inter_comp", "description": ""}, {"name": "set.prod_sUnion", "description": ""}, {"name": "set.disjoint_union_left", "description": ""}, {"name": "set.Union_subset_iff", "description": ""}, {"name": "set.preimage_eq_empty", "description": ""}, {"name": "set.surj_on_Union", "description": ""}, {"name": "set.sUnion_eq_empty", "description": ""}, {"name": "set.Inter_false", "description": ""}, {"name": "set.Inter_congr_Prop", "description": ""}, {"name": "disjoint.of_image", "description": ""}, {"name": "set.nonempty_sUnion", "description": ""}, {"name": "set.Union\u2082_inter", "description": ""}, {"name": "set.Union_eq_compl_Inter_compl", "description": ""}, {"name": "set.Union_image_left", "description": ""}, {"name": "set.image2_Inter_subset_left", "description": ""}, {"name": "set.Inter_eq_univ", "description": ""}, {"name": "set.disjoint_union_right", "description": ""}, {"name": "set.disjoint_image_of_injective", "description": ""}, {"name": "set.Union_congr", "description": ""}, {"name": "set.Union_of_singleton", "description": ""}, {"name": "set.Inter\u2082_mono'", "description": ""}, {"name": "set.sInter_union_sInter", "description": ""}, {"name": "set.Union_Union_eq_right", "description": ""}, {"name": "set.sUnion_image", "description": ""}, {"name": "set.nonempty_of_union_eq_top_of_nonempty", "description": ""}, {"name": "set.Inter\u2082_union", "description": ""}, {"name": "set.mem_Union\u2082_of_mem", "description": ""}, {"name": "set.Inter_and", "description": ""}, {"name": "set.Union_eq_empty", "description": ""}, {"name": "set.preimage_Inter\u2082", "description": ""}, {"name": "set.Union_option", "description": ""}, {"name": "set.inter_Union", "description": ""}, {"name": "set.bij_on_Union", "description": ""}, {"name": "set.Inter", "description": "Indexed intersection of a family of sets"}, {"name": "set.monotone_preimage", "description": ""}, {"name": "set.Iic_Inf", "description": ""}, {"name": "set.sInter_Union", "description": ""}, {"name": "set.image2_Union\u2082_left", "description": ""}, {"name": "set.Union_Inter_ge_nat_add", "description": ""}, {"name": "disjoint.union_right", "description": ""}, {"name": "antitone_on.union", "description": ""}, {"name": "set.inj_on.image_inter", "description": ""}, {"name": "set.surj_on_sUnion", "description": ""}, {"name": "set.Union_eq_sigma_of_disjoint", "description": "Equivalence between a disjoint union and a dependent sum."}, {"name": "set.subset_sUnion_of_mem", "description": ""}, {"name": "set.exists_set_mem_of_union_eq_top", "description": ""}, {"name": "set.sUnion_subset", "description": ""}, {"name": "set.compl_sUnion", "description": ""}, {"name": "set.preimage_eq_empty_iff", "description": ""}, {"name": "set.univ_disjoint", "description": ""}, {"name": "set.image2_eq_seq", "description": ""}, {"name": "set.Union_range_eq_sUnion", "description": ""}, {"name": "set.inj_on.image_Inter_eq", "description": ""}, {"name": "set.inter_bInter", "description": ""}, {"name": "set.preimage_Inter", "description": ""}, {"name": "set.Union_union", "description": ""}, {"name": "set.compl_Union", "description": ""}, {"name": "set.Inter_univ", "description": ""}, {"name": "set.bUnion_insert", "description": ""}, {"name": "set.Union\u2082_mono", "description": ""}, {"name": "set.Union_eq_if", "description": ""}, {"name": "set.Union_nonempty_self", "description": ""}, {"name": "set.infi_eq_Inter", "description": ""}, {"name": "set.inter_empty_of_inter_sUnion_empty", "description": ""}, {"name": "set.mem_sUnion", "description": ""}, {"name": "set.Union_const", "description": ""}, {"name": "set.nonempty_Inter\u2082", "description": ""}, {"name": "set.sInter_empty", "description": ""}, {"name": "set.bUnion_Union", "description": ""}, {"name": "set.image_Union", "description": ""}, {"name": "set.subset_sUnion_of_subset", "description": ""}, {"name": "set.Inter_subtype", "description": ""}, {"name": "set.image2_Union\u2082_right", "description": ""}, {"name": "set.preimage_Union\u2082", "description": ""}, {"name": "set.Infi_eq_dif", "description": ""}, {"name": "set.seq_mono", "description": ""}, {"name": "set.image2_Union_right", "description": ""}, {"name": "infi_Union", "description": ""}, {"name": "set.Union_inter_of_antitone", "description": ""}, {"name": "set.Union\u2082_subset", "description": ""}, {"name": "set.Union_prod", "description": ""}, {"name": "disjoint.inter_left", "description": ""}, {"name": "set.Inter_dite", "description": ""}, {"name": "set.sigma_to_Union", "description": " If `t` is an indexed family of sets, then there is a natural map from `\u03a3 i, t i` to `\u22c3 i, t i`\nsending `\u27e8i, x\u27e9` to `x`."}, {"name": "set.surj_on_Inter_Inter", "description": ""}, {"name": "set.bInter_inter", "description": ""}, {"name": "set.preimage_sUnion", "description": ""}, {"name": "set.seq_def", "description": ""}, {"name": "set.bUnion_mono", "description": ""}, {"name": "set.Union_singleton_eq_range", "description": ""}, {"name": "set.sUnion_Union", "description": ""}, {"name": "set.Inter_union", "description": ""}, {"name": "set.Union_image_preimage_sigma_mk_eq_self", "description": ""}, {"name": "set.inter_Inter", "description": ""}, {"name": "set.Union_eq_range_sigma", "description": ""}, {"name": "set.disjoint_Union_right", "description": ""}, {"name": "set.nonempty.of_sUnion_eq_univ", "description": ""}, {"name": "set.sUnion_subset_iff", "description": ""}, {"name": "set.Sup_eq_sUnion", "description": ""}, {"name": "set.Union\u2082_eq_univ_iff", "description": ""}, {"name": "set.Inter\u2082_mono", "description": ""}, {"name": "set.sInter", "description": "Intersection of a set of sets."}, {"name": "set.maps_to_Union", "description": ""}, {"name": "set.Union_prod_const", "description": ""}, {"name": "set.sInter_subset_sInter", "description": ""}, {"name": "set.image_Union\u2082", "description": ""}, {"name": "set.Union_subset_Union_const", "description": ""}, {"name": "set.mem_Inter", "description": ""}, {"name": "set.seq", "description": " Given a set `s` of functions `\u03b1 \u2192 \u03b2` and `t : set \u03b1`, `seq s t` is the union of `f '' t` over\nall `f \u2208 s`."}, {"name": "set.bInter_mono", "description": ""}, {"name": "set.prod_eq_bUnion_left", "description": ""}, {"name": "set.bij_on_Inter_of_directed", "description": ""}, {"name": "set.surj_on_Inter", "description": ""}, {"name": "set.Inter_mono", "description": ""}, {"name": "set.sigma_to_Union_surjective", "description": ""}, {"name": "set.Union_univ_pi", "description": ""}, {"name": "disjoint.inter_right'", "description": ""}, {"name": "set.Union_true", "description": ""}, {"name": "disjoint.ne_of_mem", "description": ""}, {"name": "set.Union_Union_eq'", "description": ""}, {"name": "set.Inter_Inter_eq_right", "description": ""}, {"name": "set.Ici_Sup", "description": ""}, {"name": "set.sUnion_union", "description": ""}, {"name": "set.mem_bUnion", "description": "A specialization of `mem_Union\u2082`."}, {"name": "set.bInter_and", "description": ""}, {"name": "set.sUnion_pair", "description": ""}, {"name": "set.not_disjoint_iff_nonempty_inter", "description": ""}, {"name": "set.Union_union_distrib", "description": ""}, {"name": "set.prod_image_seq_comm", "description": ""}, {"name": "set.Iic_infi\u2082", "description": ""}, {"name": "set.Union\u2082_prod_const", "description": ""}, {"name": "set.Union\u2082_subset_Union", "description": ""}, {"name": "monotone.Union_nat_add", "description": ""}, {"name": "set.nonempty_Union", "description": ""}, {"name": "set.prod_Union\u2082", "description": ""}, {"name": "set.prod_eq_bUnion_right", "description": ""}, {"name": "set.Union\u2082_mono'", "description": ""}, {"name": "set.mem_bInter", "description": "A specialization of `mem_Inter\u2082`."}, {"name": "set.Union_subtype", "description": ""}, {"name": "set.Inter_exists", "description": ""}, {"name": "set.sInter_eq_univ", "description": ""}, {"name": "set.maps_to_Inter\u2082", "description": ""}, {"name": "set.sUnion_insert", "description": ""}, {"name": "set.sInter_pair", "description": ""}, {"name": "set.Iic_infi", "description": ""}, {"name": "set.compl_Union\u2082", "description": ""}, {"name": "set.image2_Inter_subset_right", "description": ""}, {"name": "set.mem_sUnion_of_mem", "description": ""}, {"name": "set.bUnion_preimage_singleton", "description": ""}, {"name": "set.supr_eq_Union", "description": ""}, {"name": "set.Union_eq_range_psigma", "description": ""}, {"name": "supr_Union", "description": ""}, {"name": "set.bUnion_range_preimage_singleton", "description": ""}, {"name": "set.Inter_Inter_eq'", "description": ""}, {"name": "set.seq_singleton", "description": ""}, {"name": "set.sInter_union", "description": ""}, {"name": "set.nonempty_Inter", "description": ""}, {"name": "set.Ici_supr\u2082", "description": ""}, {"name": "set.surj_on_Union\u2082", "description": ""}, {"name": "set.bUnion_empty", "description": ""}, {"name": "set.inter_Inter_nat_succ", "description": ""}, {"name": "set.subset_sInter_iff", "description": ""}, {"name": "set.disjoint_iff_forall_ne", "description": ""}, {"name": "set.Union_nonempty_index", "description": ""}, {"name": "set.mem_seq_iff", "description": ""}, {"name": "set.Inter_union_of_monotone", "description": ""}, {"name": "set.image_preimage", "description": ""}, {"name": "set.directed_on_Union", "description": ""}, {"name": "set.Inf_eq_sInter", "description": ""}, {"name": "set.bUnion_range", "description": ""}, {"name": "set.Union_exists", "description": ""}, {"name": "set.inj_on_Union_of_directed", "description": ""}, {"name": "set.subset_Union\u2082", "description": ""}, {"name": "set.Inter_Inter_eq_left", "description": ""}, {"name": "set.union_Inter", "description": ""}, {"name": "set.Union_congr_Prop", "description": ""}, {"name": "set.disjoint_image_iff", "description": ""}, {"name": "set.subset_Union_of_subset", "description": " This rather trivial consequence of `subset_Union`is convenient with `apply`, and has `i`\nexplicit for this purpose."}, {"name": "set.disjoint_sUnion_right", "description": ""}, {"name": "set.sigma_to_Union_injective", "description": ""}, {"name": "set.Union", "description": "Indexed union of a family of sets"}, {"name": "disjoint.preimage", "description": ""}, {"name": "set.Inter_eq_compl_Union_compl", "description": ""}, {"name": "set.Inter_ite", "description": ""}, {"name": "monotone.union", "description": ""}, {"name": "set.sInter_eq_bInter", "description": ""}, {"name": "set.image_seq", "description": ""}, {"name": "set.mem_Inter_of_mem", "description": ""}, {"name": "set.image2_eq_Union", "description": "The `set.image2` version of `set.image_eq_Union`"}, {"name": "set.disjoint_singleton_left", "description": ""}, {"name": "set.maps_to_Inter_Inter", "description": ""}, {"name": "set.preimage_Union", "description": ""}, {"name": "set.union_Union", "description": ""}, {"name": "set.Union\u2082_subset_iff", "description": ""}, {"name": "set.bInter_empty", "description": ""}, {"name": "set.Inter_comm", "description": ""}, {"name": "set.subset_bUnion_of_mem", "description": "A specialization of `subset_Union\u2082`."}, {"name": "disjoint.inter_left'", "description": ""}, {"name": "set.Inter_subset_of_subset", "description": " This rather trivial consequence of `Inter_subset`is convenient with `apply`, and has `i`\nexplicit for this purpose."}, {"name": "set.range_eq_Union", "description": ""}, {"name": "set.Inter_const", "description": ""}, {"name": "set.Union_or", "description": ""}, {"name": "set.Union_of_singleton_coe", "description": ""}, {"name": "monotone_on.union", "description": ""}, {"name": "set.subset_Union", "description": ""}, {"name": "monotone.inter", "description": ""}, {"name": "set.bUnion_diff_bUnion_subset", "description": ""}, {"name": "set.union_distrib_Inter_right", "description": ""}, {"name": "set.disjoint_of_subset_left", "description": ""}, {"name": "disjoint.union_left", "description": ""}, {"name": "set.Inter\u2082_subset", "description": ""}, {"name": "set.diff_Inter", "description": ""}, {"name": "disjoint.inter_right", "description": ""}, {"name": "set.bInter_subset_bInter_left", "description": ""}, {"name": "set.disjoint_univ", "description": ""}, {"name": "set.image2_Union_left", "description": ""}, {"name": "set.sigma_to_Union_bijective", "description": ""}, {"name": "set.Union_diff", "description": ""}, {"name": "set.complete_boolean_algebra", "description": ""}, {"name": "set.mem_Union_of_mem", "description": ""}, {"name": "set.union_distrib_Inter\u2082_right", "description": ""}, {"name": "set.union_distrib_Inter\u2082_left", "description": ""}, {"name": "set.disjoint_iff_inter_eq_empty", "description": ""}, {"name": "set.bUnion_and", "description": ""}, {"name": "Inf_sUnion", "description": ""}, {"name": "set.Union_inter_of_monotone", "description": ""}, {"name": "set.order_top", "description": ""}, {"name": "set.surj_on_Union_Union", "description": ""}, {"name": "set.sUnion_eq_compl_sInter_compl", "description": ""}, {"name": "sup_closed_of_totally_ordered", "description": ""}, {"name": "set.has_Inf", "description": ""}, {"name": "set.bInter_Union", "description": ""}, {"name": "set.Union_ite", "description": ""}, {"name": "set.Inter_eq_empty_iff", "description": ""}, {"name": "set.Inter_true", "description": ""}, {"name": "set.bInter_and'", "description": ""}, {"name": "set.sUnion_singleton", "description": ""}, {"name": "set.sInter_image", "description": ""}, {"name": "set.Inter_ge_eq_Inter_nat_add", "description": ""}, {"name": "set.sUnion_inter_sUnion", "description": ""}, {"name": "set.compl_Inter\u2082", "description": ""}, {"name": "set.image_Inter\u2082_subset", "description": ""}, {"name": "set.Union_coe_set", "description": ""}, {"name": "set.Inter_inter_distrib", "description": ""}, {"name": "set.Union_set_of", "description": ""}, {"name": "set.Union_inter", "description": ""}, {"name": "set.bInter_range", "description": ""}, {"name": "set.prod_Union", "description": ""}, {"name": "set.sUnion_range", "description": ""}, {"name": "set.sInter_subset_of_mem", "description": ""}, {"name": "set.bUnion_pair", "description": ""}, {"name": "set.Inter_mono'", "description": ""}, {"name": "set.Inter_option", "description": ""}, {"name": "set.singleton_seq", "description": ""}, {"name": "set.sInter_eq_Inter", "description": ""}, {"name": "set.image_sInter_subset", "description": ""}, {"name": "disjoint.image", "description": ""}, {"name": "set.inj_on.image_bInter_eq", "description": ""}, {"name": "set.sUnion_eq_univ_iff", "description": ""}, {"name": "set.Inter\u2082_congr", "description": ""}, {"name": "set.disjoint_singleton", "description": ""}, {"name": "antitone_on.inter", "description": ""}, {"name": "set.subset_Inter", "description": ""}, {"name": "set.image2_Inter\u2082_subset_right", "description": ""}, {"name": "set.maps_to_sUnion", "description": ""}, {"name": "set.mem_Union\u2082", "description": ""}, {"name": "set.sInter_range", "description": ""}, {"name": "ne_zero_of_map", "description": ""}, {"name": "mul_hom.has_one", "description": "`1` is the multiplicative homomorphism sending all elements to `1`."}, {"name": "monoid_hom.one_comp", "description": ""}, {"name": "monoid_hom.has_coe_to_fun", "description": ""}, {"name": "monoid_hom.comp", "description": "Composition of monoid morphisms as a monoid morphism."}, {"name": "one_hom", "description": " `one_hom M N` is the type of functions `M \u2192 N` that preserve one.\n\nWhen possible, instead of parametrizing results over `(f : one_hom M N)`,\nyou should parametrize over `(F : Type*) [one_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to also extend `one_hom_class`."}, {"name": "one_hom.to_fun", "description": " `one_hom M N` is the type of functions `M \u2192 N` that preserve one.\n\nWhen possible, instead of parametrizing results over `(f : one_hom M N)`,\nyou should parametrize over `(F : Type*) [one_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to also extend `one_hom_class`."}, {"name": "one_hom.map_one'", "description": " `one_hom M N` is the type of functions `M \u2192 N` that preserve one.\n\nWhen possible, instead of parametrizing results over `(f : one_hom M N)`,\nyou should parametrize over `(F : Type*) [one_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to also extend `one_hom_class`."}, {"name": "zero_hom.congr_fun", "description": "Deprecated: use `fun_like.congr_fun` instead."}, {"name": "monoid_with_zero_hom.congr_fun", "description": "Deprecated: use `fun_like.congr_fun` instead."}, {"name": "map_add", "description": ""}, {"name": "monoid_hom.cancel_left", "description": ""}, {"name": "one_hom.cancel_left", "description": ""}, {"name": "add_hom.add_hom_class", "description": ""}, {"name": "monoid_with_zero_hom.congr_arg", "description": "Deprecated: use `fun_like.congr_arg` instead."}, {"name": "mul_hom.id_comp", "description": ""}, {"name": "mul_hom.mul_apply", "description": ""}, {"name": "zero_hom.comp_id", "description": ""}, {"name": "zero_hom.coe_inj", "description": "Deprecated: use `fun_like.coe_injective` instead."}, {"name": "monoid_with_zero_hom.id_comp", "description": ""}, {"name": "add_monoid_hom.has_neg", "description": " If `f` is an additive monoid homomorphism to an additive commutative group, then `-f` is the\nhomomorphism sending `x` to `-(f x)`."}, {"name": "monoid_with_zero_hom.inhabited", "description": ""}, {"name": "mul_hom_class.to_fun_like", "description": ""}, {"name": "monoid_with_zero_hom.comp_assoc", "description": ""}, {"name": "monoid_hom.coe_eq_to_mul_hom", "description": ""}, {"name": "add_hom_class", "description": " `add_hom_class F M N` states that `F` is a type of addition-preserving homomorphisms.\nYou should declare an instance of this typeclass when you extend `add_hom`."}, {"name": "add_hom_class.coe", "description": " `add_hom_class F M N` states that `F` is a type of addition-preserving homomorphisms.\nYou should declare an instance of this typeclass when you extend `add_hom`."}, {"name": "add_hom_class.coe_injective'", "description": " `add_hom_class F M N` states that `F` is a type of addition-preserving homomorphisms.\nYou should declare an instance of this typeclass when you extend `add_hom`."}, {"name": "add_hom_class.map_add", "description": " `add_hom_class F M N` states that `F` is a type of addition-preserving homomorphisms.\nYou should declare an instance of this typeclass when you extend `add_hom`."}, {"name": "monoid_hom.congr_arg", "description": "Deprecated: use `fun_like.congr_arg` instead."}, {"name": "monoid_with_zero_hom.map_one", "description": ""}, {"name": "zero_hom.id_comp", "description": ""}, {"name": "add_monoid_hom.map_zsmul", "description": "Additive group homomorphisms preserve integer scaling."}, {"name": "monoid_hom.comp_id", "description": ""}, {"name": "add_hom.add_comp", "description": ""}, {"name": "map_zsmul", "description": "Additive group homomorphisms preserve integer scaling."}, {"name": "mul_hom.cancel_left", "description": ""}, {"name": "monoid_hom", "description": " `M \u2192* N` is the type of functions `M \u2192 N` that preserve the `monoid` structure.\n`monoid_hom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M \u2192+ N)`,\nyou should parametrize over `(F : Type*) [monoid_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `monoid_hom_class`."}, {"name": "monoid_hom.to_fun", "description": " `M \u2192* N` is the type of functions `M \u2192 N` that preserve the `monoid` structure.\n`monoid_hom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M \u2192+ N)`,\nyou should parametrize over `(F : Type*) [monoid_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `monoid_hom_class`."}, {"name": "monoid_hom.map_one'", "description": " `M \u2192* N` is the type of functions `M \u2192 N` that preserve the `monoid` structure.\n`monoid_hom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M \u2192+ N)`,\nyou should parametrize over `(F : Type*) [monoid_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `monoid_hom_class`."}, {"name": "monoid_hom.map_mul'", "description": " `M \u2192* N` is the type of functions `M \u2192 N` that preserve the `monoid` structure.\n`monoid_hom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M \u2192+ N)`,\nyou should parametrize over `(F : Type*) [monoid_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `monoid_hom_class`."}, {"name": "add_monoid_hom.zero_apply", "description": ""}, {"name": "zero_hom.copy", "description": "Copy of a `zero_hom` with a new `to_fun` equal to the old one. Useful to fix\ndefinitional equalities."}, {"name": "monoid_hom.map_pow", "description": ""}, {"name": "monoid_with_zero_hom.comp_id", "description": ""}, {"name": "add_monoid_hom.has_coe_to_fun", "description": ""}, {"name": "monoid_with_zero_hom_class", "description": " `monoid_with_zero_hom_class F M N` states that `F` is a type of\n`monoid_with_zero`-preserving homomorphisms.\n\nYou should also extend this typeclass when you extend `monoid_with_zero_hom`."}, {"name": "monoid_with_zero_hom_class.coe", "description": " `monoid_with_zero_hom_class F M N` states that `F` is a type of\n`monoid_with_zero`-preserving homomorphisms.\n\nYou should also extend this typeclass when you extend `monoid_with_zero_hom`."}, {"name": "monoid_with_zero_hom_class.coe_injective'", "description": " `monoid_with_zero_hom_class F M N` states that `F` is a type of\n`monoid_with_zero`-preserving homomorphisms.\n\nYou should also extend this typeclass when you extend `monoid_with_zero_hom`."}, {"name": "monoid_with_zero_hom_class.map_mul", "description": " `monoid_with_zero_hom_class F M N` states that `F` is a type of\n`monoid_with_zero`-preserving homomorphisms.\n\nYou should also extend this typeclass when you extend `monoid_with_zero_hom`."}, {"name": "monoid_with_zero_hom_class.map_one", "description": " `monoid_with_zero_hom_class F M N` states that `F` is a type of\n`monoid_with_zero`-preserving homomorphisms.\n\nYou should also extend this typeclass when you extend `monoid_with_zero_hom`."}, {"name": "monoid_with_zero_hom_class.map_zero", "description": " `monoid_with_zero_hom_class F M N` states that `F` is a type of\n`monoid_with_zero`-preserving homomorphisms.\n\nYou should also extend this typeclass when you extend `monoid_with_zero_hom`."}, {"name": "add_monoid_hom_class", "description": " `add_monoid_hom_class F M N` states that `F` is a type of `add_zero_class`-preserving\nhomomorphisms.\n\nYou should also extend this typeclass when you extend `add_monoid_hom`."}, {"name": "add_monoid_hom_class.coe", "description": " `add_monoid_hom_class F M N` states that `F` is a type of `add_zero_class`-preserving\nhomomorphisms.\n\nYou should also extend this typeclass when you extend `add_monoid_hom`."}, {"name": "add_monoid_hom_class.coe_injective'", "description": " `add_monoid_hom_class F M N` states that `F` is a type of `add_zero_class`-preserving\nhomomorphisms.\n\nYou should also extend this typeclass when you extend `add_monoid_hom`."}, {"name": "add_monoid_hom_class.map_add", "description": " `add_monoid_hom_class F M N` states that `F` is a type of `add_zero_class`-preserving\nhomomorphisms.\n\nYou should also extend this typeclass when you extend `add_monoid_hom`."}, {"name": "add_monoid_hom_class.map_zero", "description": " `add_monoid_hom_class F M N` states that `F` is a type of `add_zero_class`-preserving\nhomomorphisms.\n\nYou should also extend this typeclass when you extend `add_monoid_hom`."}, {"name": "monoid_with_zero_hom.cancel_right", "description": ""}, {"name": "monoid.End.monoid_hom_class", "description": ""}, {"name": "zero_hom", "description": " `zero_hom M N` is the type of functions `M \u2192 N` that preserve zero.\n\nWhen possible, instead of parametrizing results over `(f : zero_hom M N)`,\nyou should parametrize over `(F : Type*) [zero_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to also extend `zero_hom_class`."}, {"name": "zero_hom.to_fun", "description": " `zero_hom M N` is the type of functions `M \u2192 N` that preserve zero.\n\nWhen possible, instead of parametrizing results over `(f : zero_hom M N)`,\nyou should parametrize over `(F : Type*) [zero_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to also extend `zero_hom_class`."}, {"name": "zero_hom.map_zero'", "description": " `zero_hom M N` is the type of functions `M \u2192 N` that preserve zero.\n\nWhen possible, instead of parametrizing results over `(f : zero_hom M N)`,\nyou should parametrize over `(F : Type*) [zero_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to also extend `zero_hom_class`."}, {"name": "map_pow", "description": ""}, {"name": "injective_iff_map_eq_zero'", "description": "A homomorphism from an additive group to an additive monoid is injective iff its\nkernel is trivial, stated as an iff on the triviality of the kernel. For the implication, see\n`injective_iff_map_eq_zero`."}, {"name": "monoid_hom.of_map_div", "description": "Define a morphism of additive groups given a map which respects ratios."}, {"name": "add_monoid_hom.eq_on_neg", "description": "If two homomorphism from an additive group to an additive monoid are equal at `x`,\nthen they are equal at `-x`."}, {"name": "add_monoid_hom.to_zero_hom_injective", "description": ""}, {"name": "add_monoid_hom.coe_inj", "description": "Deprecated: use `fun_like.coe_injective` instead."}, {"name": "neg_add_monoid_hom", "description": "Negation on a commutative additive group, considered as an additive monoid\nhomomorphism."}, {"name": "zero_hom.mk_coe", "description": ""}, {"name": "one_hom.has_one", "description": "`1` is the homomorphism sending all elements to `1`."}, {"name": "add_monoid_hom.has_coe_t", "description": ""}, {"name": "mul_hom.map_mul", "description": ""}, {"name": "mul_hom.coe_mk", "description": ""}, {"name": "one_hom.map_one", "description": ""}, {"name": "add_hom.has_add", "description": " Given two additive morphisms `f`, `g` to an additive commutative semigroup, `f + g` is the\nadditive morphism sending `x` to `f x + g x`."}, {"name": "zero_hom.ext", "description": ""}, {"name": "add_monoid_hom.comp_neg", "description": ""}, {"name": "one_hom.inhabited", "description": ""}, {"name": "add_monoid_hom.mk_coe", "description": ""}, {"name": "monoid_with_zero_hom.mk_coe", "description": ""}, {"name": "add_monoid_hom.inhabited", "description": ""}, {"name": "monoid_with_zero_hom.has_mul", "description": " Given two monoid with zero morphisms `f`, `g` to a commutative monoid, `f * g` is the monoid\nwith zero morphism sending `x` to `f x * g x`."}, {"name": "add_monoid_hom.zero_comp", "description": ""}, {"name": "monoid_hom.ext", "description": ""}, {"name": "one_hom.mk_coe", "description": ""}, {"name": "mul_hom.congr_arg", "description": "Deprecated: use `fun_like.congr_arg` instead."}, {"name": "one_hom.one_comp", "description": ""}, {"name": "monoid_with_zero_hom.cancel_left", "description": ""}, {"name": "mul_hom.ext", "description": ""}, {"name": "monoid_hom.to_mul_hom_injective", "description": ""}, {"name": "monoid_hom.map_div", "description": "Group homomorphisms preserve division."}, {"name": "add_monoid_hom.cancel_right", "description": ""}, {"name": "one_hom.comp_assoc", "description": "Composition of monoid homomorphisms is associative."}, {"name": "add_monoid_hom.add_monoid_hom_class", "description": ""}, {"name": "monoid_hom.mk'_apply", "description": ""}, {"name": "monoid_hom.has_coe_t", "description": ""}, {"name": "monoid_hom_class", "description": " `monoid_hom_class F M N` states that `F` is a type of `monoid`-preserving homomorphisms.\nYou should also extend this typeclass when you extend `monoid_hom`."}, {"name": "monoid_hom_class.coe", "description": " `monoid_hom_class F M N` states that `F` is a type of `monoid`-preserving homomorphisms.\nYou should also extend this typeclass when you extend `monoid_hom`."}, {"name": "monoid_hom_class.coe_injective'", "description": " `monoid_hom_class F M N` states that `F` is a type of `monoid`-preserving homomorphisms.\nYou should also extend this typeclass when you extend `monoid_hom`."}, {"name": "monoid_hom_class.map_mul", "description": " `monoid_hom_class F M N` states that `F` is a type of `monoid`-preserving homomorphisms.\nYou should also extend this typeclass when you extend `monoid_hom`."}, {"name": "monoid_hom_class.map_one", "description": " `monoid_hom_class F M N` states that `F` is a type of `monoid`-preserving homomorphisms.\nYou should also extend this typeclass when you extend `monoid_hom`."}, {"name": "zero_hom.comp", "description": "Composition of `zero_hom`s as a `zero_hom`."}, {"name": "monoid_with_zero_hom.comp_apply", "description": ""}, {"name": "add_monoid.coe_one", "description": ""}, {"name": "zero_hom.zero_comp", "description": ""}, {"name": "map_mul_inv", "description": "Group homomorphisms preserve division."}, {"name": "monoid_hom.ext_iff", "description": "Deprecated: use `fun_like.ext_iff` instead."}, {"name": "add_hom.ext", "description": ""}, {"name": "add_monoid_hom.to_add_hom", "description": ""}, {"name": "monoid_hom.coe_of_map_mul_inv", "description": ""}, {"name": "monoid_hom.has_one", "description": "`1` is the monoid homomorphism sending all elements to `1`."}, {"name": "add_monoid_hom.neg_comp", "description": ""}, {"name": "add_hom.map_add", "description": ""}, {"name": "zero_hom.has_coe_to_fun", "description": ""}, {"name": "monoid_hom.id_apply", "description": ""}, {"name": "zero_hom.map_zero", "description": ""}, {"name": "add_monoid_hom.to_add_hom_injective", "description": ""}, {"name": "add_monoid_hom.has_coe_to_zero_hom", "description": ""}, {"name": "monoid_with_zero_hom.to_zero_hom", "description": ""}, {"name": "injective_iff_map_eq_one'", "description": " A homomorphism from a group to a monoid is injective iff its kernel is trivial,\nstated as an iff on the triviality of the kernel.\nFor the implication, see `injective_iff_map_eq_one`."}, {"name": "mul_hom.comp_mul", "description": ""}, {"name": "monoid_hom.map_mul", "description": "If `f` is a monoid homomorphism then `f (a * b) = f a * f b`."}, {"name": "monoid_with_zero_hom.map_mul", "description": ""}, {"name": "monoid_hom.coe_inj", "description": "Deprecated: use `fun_like.coe_injective` instead."}, {"name": "map_zpow'", "description": ""}, {"name": "monoid_with_zero_hom.has_coe_to_zero_hom", "description": ""}, {"name": "add_monoid_hom.coe_comp", "description": ""}, {"name": "add_monoid_hom", "description": " `M \u2192+ N` is the type of functions `M \u2192 N` that preserve the `add_zero_class` structure.\n\n`add_monoid_hom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M \u2192+ N)`,\nyou should parametrize over `(F : Type*) [add_monoid_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `add_monoid_hom_class`."}, {"name": "add_monoid_hom.to_fun", "description": " `M \u2192+ N` is the type of functions `M \u2192 N` that preserve the `add_zero_class` structure.\n\n`add_monoid_hom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M \u2192+ N)`,\nyou should parametrize over `(F : Type*) [add_monoid_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `add_monoid_hom_class`."}, {"name": "add_monoid_hom.map_zero'", "description": " `M \u2192+ N` is the type of functions `M \u2192 N` that preserve the `add_zero_class` structure.\n\n`add_monoid_hom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M \u2192+ N)`,\nyou should parametrize over `(F : Type*) [add_monoid_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `add_monoid_hom_class`."}, {"name": "add_monoid_hom.map_add'", "description": " `M \u2192+ N` is the type of functions `M \u2192 N` that preserve the `add_zero_class` structure.\n\n`add_monoid_hom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M \u2192+ N)`,\nyou should parametrize over `(F : Type*) [add_monoid_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `add_monoid_hom_class`."}, {"name": "add_monoid_hom.map_add", "description": "If `f` is an additive monoid homomorphism then `f (a + b) = f a + f b`."}, {"name": "mul_hom.has_coe_t", "description": ""}, {"name": "monoid_hom_class.to_one_hom_class", "description": ""}, {"name": "add_monoid_hom.of_map_sub", "description": "Define a morphism of additive groups given a map which respects difference."}, {"name": "add_hom", "description": " `add_hom M N` is the type of functions `M \u2192 N` that preserve addition.\n\nWhen possible, instead of parametrizing results over `(f : add_hom M N)`,\nyou should parametrize over `(F : Type*) [add_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `add_hom_class`."}, {"name": "add_hom.to_fun", "description": " `add_hom M N` is the type of functions `M \u2192 N` that preserve addition.\n\nWhen possible, instead of parametrizing results over `(f : add_hom M N)`,\nyou should parametrize over `(F : Type*) [add_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `add_hom_class`."}, {"name": "add_hom.map_add'", "description": " `add_hom M N` is the type of functions `M \u2192 N` that preserve addition.\n\nWhen possible, instead of parametrizing results over `(f : add_hom M N)`,\nyou should parametrize over `(F : Type*) [add_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `add_hom_class`."}, {"name": "add_monoid_hom_class.to_add_hom_class", "description": ""}, {"name": "add_commute.map", "description": ""}, {"name": "add_monoid_hom.id_comp", "description": ""}, {"name": "monoid.End.monoid", "description": ""}, {"name": "mul_hom.comp", "description": "Composition of `mul_hom`s as a `mul_hom`."}, {"name": "zero_hom.ext_iff", "description": "Deprecated: use `fun_like.ext_iff` instead."}, {"name": "zero_hom_class.to_fun_like", "description": ""}, {"name": "add_hom.ext_iff", "description": ""}, {"name": "monoid_with_zero_hom.monoid_with_zero_hom_class", "description": ""}, {"name": "add_monoid_hom.coe_mk", "description": ""}, {"name": "monoid_with_zero_hom.coe_mk", "description": ""}, {"name": "add_monoid_hom.to_zero_hom", "description": ""}, {"name": "monoid_hom.comp_inv", "description": ""}, {"name": "monoid_hom.coe_of_map_div", "description": ""}, {"name": "add_semiconj_by.map", "description": ""}, {"name": "monoid_with_zero_hom.to_fun_eq_coe", "description": ""}, {"name": "map_inv", "description": "Group homomorphisms preserve inverse."}, {"name": "zero_hom.id", "description": "The identity map from an type with zero to itself."}, {"name": "add_monoid_hom.sub_apply", "description": ""}, {"name": "map_mul_eq_one", "description": ""}, {"name": "monoid_hom.mk_coe", "description": ""}, {"name": "add_hom.comp_id", "description": ""}, {"name": "monoid_hom_class.to_mul_hom_class", "description": ""}, {"name": "add_monoid_hom.comp_add", "description": ""}, {"name": "monoid_hom.map_exists_right_inv", "description": " Given a monoid homomorphism `f : M \u2192* N` and an element `x : M`, if `x` has a right inverse,\nthen `f x` has a right inverse too. For elements invertible on both sides see `is_unit.map`."}, {"name": "one_hom.congr_arg", "description": "Deprecated: use `fun_like.congr_arg` instead."}, {"name": "mul_hom.has_coe_to_fun", "description": ""}, {"name": "add_monoid_hom.to_add_hom_coe", "description": ""}, {"name": "mul_hom", "description": " `M \u2192\u2099* N` is the type of functions `M \u2192 N` that preserve multiplication. The `\u2099` in the notation\nstands for \"non-unital\" because it is intended to match the notation for `non_unital_alg_hom` and\n`non_unital_ring_hom`, so a `mul_hom` is a non-unital monoid hom.\n\nWhen possible, instead of parametrizing results over `(f : M \u2192\u2099* N)`,\nyou should parametrize over `(F : Type*) [mul_hom_class F M N] (f : F)`.\nWhen you extend this structure, make sure to extend `mul_hom_class`."}, {"name": "mul_hom.to_fun", "description": " `M \u2192\u2099* N` is the type of functions `M \u2192 N` that preserve multiplication. The `\u2099` in the notation\nstands for \"non-unital\" because it is intended to match the notation for `non_unital_alg_hom` and\n`non_unital_ring_hom`, so a `mul_hom` is a non-unital monoid hom.\n\nWhen possible, instead of parametrizing results over `(f : M \u2192\u2099* N)`,\nyou should parametrize over `(F : Type*) [mul_hom_class F M N] (f : F)`.\nWhen you extend this structure, make sure to extend `mul_hom_class`."}, {"name": "mul_hom.map_mul'", "description": " `M \u2192\u2099* N` is the type of functions `M \u2192 N` that preserve multiplication. The `\u2099` in the notation\nstands for \"non-unital\" because it is intended to match the notation for `non_unital_alg_hom` and\n`non_unital_ring_hom`, so a `mul_hom` is a non-unital monoid hom.\n\nWhen possible, instead of parametrizing results over `(f : M \u2192\u2099* N)`,\nyou should parametrize over `(F : Type*) [mul_hom_class F M N] (f : F)`.\nWhen you extend this structure, make sure to extend `mul_hom_class`."}, {"name": "monoid_hom.cancel_right", "description": ""}, {"name": "monoid_hom.div_apply", "description": ""}, {"name": "monoid_with_zero_hom.coe_comp", "description": ""}, {"name": "monoid.coe_one", "description": ""}, {"name": "inv_monoid_hom", "description": "Inversion on a commutative group, considered as a monoid homomorphism."}, {"name": "zero_hom.inhabited", "description": ""}, {"name": "zero_hom.coe_comp", "description": ""}, {"name": "add_monoid.End.add_monoid_hom_class", "description": ""}, {"name": "map_add_neg", "description": "Additive group homomorphisms preserve subtraction."}, {"name": "monoid_hom.eq_on_inv", "description": "If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x\u207b\u00b9`."}, {"name": "add_hom.comp_assoc", "description": ""}, {"name": "one_hom.comp", "description": "Composition of `one_hom`s as a `one_hom`."}, {"name": "map_zpow", "description": "Group homomorphisms preserve integer power."}, {"name": "one_hom.coe_comp", "description": ""}, {"name": "add_hom.has_coe_t", "description": ""}, {"name": "monoid_with_zero_hom_class.to_monoid_hom_class", "description": ""}, {"name": "mul_hom.id_apply", "description": ""}, {"name": "one_hom.ext", "description": ""}, {"name": "add_monoid_hom.to_fun_eq_coe", "description": ""}, {"name": "injective_iff_map_eq_one", "description": " A homomorphism from a group to a monoid is injective iff its kernel is trivial.\nFor the iff statement on the triviality of the kernel, see `injective_iff_map_eq_one'`."}, {"name": "mul_hom_class", "description": " `mul_hom_class F M N` states that `F` is a type of multiplication-preserving homomorphisms.\n\nYou should declare an instance of this typeclass when you extend `mul_hom`."}, {"name": "mul_hom_class.coe", "description": " `mul_hom_class F M N` states that `F` is a type of multiplication-preserving homomorphisms.\n\nYou should declare an instance of this typeclass when you extend `mul_hom`."}, {"name": "mul_hom_class.coe_injective'", "description": " `mul_hom_class F M N` states that `F` is a type of multiplication-preserving homomorphisms.\n\nYou should declare an instance of this typeclass when you extend `mul_hom`."}, {"name": "mul_hom_class.map_mul", "description": " `mul_hom_class F M N` states that `F` is a type of multiplication-preserving homomorphisms.\n\nYou should declare an instance of this typeclass when you extend `mul_hom`."}, {"name": "add_monoid_hom.comp_assoc", "description": ""}, {"name": "add_monoid.End.monoid", "description": ""}, {"name": "monoid_hom.map_zpow", "description": "Group homomorphisms preserve integer power."}, {"name": "add_hom.has_zero", "description": "`0` is the additive homomorphism sending all elements to `0`."}, {"name": "monoid_hom.inv_apply", "description": ""}, {"name": "add_monoid_hom.map_neg", "description": "Additive group homomorphisms preserve negation."}, {"name": "monoid_with_zero_hom", "description": " `M \u2192*\u2080 N` is the type of functions `M \u2192 N` that preserve\nthe `monoid_with_zero` structure.\n\n`monoid_with_zero_hom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M \u2192*\u2080 N)`,\nyou should parametrize over `(F : Type*) [monoid_with_zero_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `monoid_with_zero_hom_class`."}, {"name": "monoid_with_zero_hom.to_fun", "description": " `M \u2192*\u2080 N` is the type of functions `M \u2192 N` that preserve\nthe `monoid_with_zero` structure.\n\n`monoid_with_zero_hom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M \u2192*\u2080 N)`,\nyou should parametrize over `(F : Type*) [monoid_with_zero_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `monoid_with_zero_hom_class`."}, {"name": "monoid_with_zero_hom.map_zero'", "description": " `M \u2192*\u2080 N` is the type of functions `M \u2192 N` that preserve\nthe `monoid_with_zero` structure.\n\n`monoid_with_zero_hom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M \u2192*\u2080 N)`,\nyou should parametrize over `(F : Type*) [monoid_with_zero_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `monoid_with_zero_hom_class`."}, {"name": "monoid_with_zero_hom.map_one'", "description": " `M \u2192*\u2080 N` is the type of functions `M \u2192 N` that preserve\nthe `monoid_with_zero` structure.\n\n`monoid_with_zero_hom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M \u2192*\u2080 N)`,\nyou should parametrize over `(F : Type*) [monoid_with_zero_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `monoid_with_zero_hom_class`."}, {"name": "monoid_with_zero_hom.map_mul'", "description": " `M \u2192*\u2080 N` is the type of functions `M \u2192 N` that preserve\nthe `monoid_with_zero` structure.\n\n`monoid_with_zero_hom` is also used for group homomorphisms.\n\nWhen possible, instead of parametrizing results over `(f : M \u2192*\u2080 N)`,\nyou should parametrize over `(F : Type*) [monoid_with_zero_hom_class F M N] (f : F)`.\n\nWhen you extend this structure, make sure to extend `monoid_with_zero_hom_class`."}, {"name": "mul_hom.id", "description": "The identity map from a type with multiplication to itself."}, {"name": "mul_hom.congr_fun", "description": "Deprecated: use `fun_like.congr_fun` instead."}, {"name": "monoid_hom.has_mul", "description": " Given two monoid morphisms `f`, `g` to a commutative monoid, `f * g` is the monoid morphism\nsending `x` to `f x * g x`."}, {"name": "map_zsmul.aux", "description": ""}, {"name": "add_hom.coe_inj", "description": "Deprecated: use `fun_like.coe_injective` instead."}, {"name": "add_monoid_hom.neg_apply", "description": ""}, {"name": "one_hom.comp_id", "description": ""}, {"name": "mul_hom.coe_inj", "description": "Deprecated: use `fun_like.coe_injective` instead."}, {"name": "monoid_hom.one_apply", "description": ""}, {"name": "add_monoid_hom.of_map_add_neg", "description": "Makes an additive group homomorphism from a proof that the map preserves\nthe operation `\u03bb a b, a + -b`. See also `add_monoid_hom.of_map_sub` for a version using\n`\u03bb a b, a - b`."}, {"name": "one_hom.coe_mk", "description": ""}, {"name": "semiconj_by.map", "description": ""}, {"name": "injective_iff_map_eq_zero", "description": "A homomorphism from an additive group to an additive monoid is injective iff\nits kernel is trivial. For the iff statement on the triviality of the kernel,\nsee `injective_iff_map_eq_zero'`."}, {"name": "map_div", "description": "Group homomorphisms preserve division."}, {"name": "add_monoid_hom.map_sub", "description": "Additive group homomorphisms preserve subtraction."}, {"name": "add_hom.cancel_right", "description": ""}, {"name": "monoid_hom.of_map_mul_inv", "description": " Makes a group homomorphism from a proof that the map preserves right division `\u03bb x y, x * y\u207b\u00b9`.\nSee also `monoid_hom.of_map_div` for a version using `\u03bb x y, x / y`."}, {"name": "add_monoid.End.inhabited", "description": ""}, {"name": "monoid_with_zero_hom.to_zero_hom_injective", "description": ""}, {"name": "add_hom.mk_coe", "description": ""}, {"name": "map_one", "description": ""}, {"name": "add_hom.copy", "description": "Copy of an `add_hom` with a new `to_fun` equal to the old one. Useful to fix\ndefinitional equalities."}, {"name": "mul_hom.comp_id", "description": ""}, {"name": "add_monoid.End", "description": "The monoid of endomorphisms."}, {"name": "monoid_hom.comp_assoc", "description": ""}, {"name": "add_monoid_hom.map_exists_right_neg", "description": "Given an add_monoid homomorphism `f : M \u2192+ N` and an element `x : M`, if `x` has\na right inverse, then `f x` has a right inverse too."}, {"name": "add_hom.congr_fun", "description": "Deprecated: use `fun_like.congr_fun` instead."}, {"name": "one_hom.comp_one", "description": ""}, {"name": "add_monoid_hom.ext", "description": ""}, {"name": "one_hom.comp_apply", "description": ""}, {"name": "add_monoid_hom.congr_arg", "description": "Deprecated: use `fun_like.congr_arg` instead."}, {"name": "mul_hom.mul_comp", "description": ""}, {"name": "one_hom.ext_iff", "description": "Deprecated: use `fun_like.ext_iff` instead."}, {"name": "monoid_with_zero_hom.coe_inj", "description": "Deprecated: use `fun_like.coe_injective` instead."}, {"name": "monoid_with_zero_hom.copy", "description": " Copy of a `monoid_hom` with a new `to_fun` equal to the old one. Useful to fix\ndefinitional equalities."}, {"name": "zero_hom.cancel_right", "description": ""}, {"name": "monoid_hom.to_fun_eq_coe", "description": ""}, {"name": "add_monoid_hom.comp_id", "description": ""}, {"name": "monoid_with_zero_hom.ext", "description": ""}, {"name": "add_monoid_hom.add_apply", "description": ""}, {"name": "one_hom.has_coe_to_fun", "description": ""}, {"name": "monoid_hom.id", "description": "The identity map from a monoid to itself."}, {"name": "add_monoid_hom.coe_eq_to_add_hom", "description": ""}, {"name": "add_monoid_hom.map_add_neg", "description": "Additive group homomorphisms preserve subtraction."}, {"name": "monoid_with_zero_hom.to_monoid_hom_injective", "description": ""}, {"name": "monoid_with_zero_hom.id", "description": "The identity map from a monoid_with_zero to itself."}, {"name": "add_monoid_hom.coe_of_map_sub", "description": ""}, {"name": "mul_hom.has_mul", "description": " Given two mul morphisms `f`, `g` to a commutative semigroup, `f * g` is the mul morphism\nsending `x` to `f x * g x`."}, {"name": "monoid_hom.inhabited", "description": ""}, {"name": "monoid_with_zero_hom.coe_eq_to_zero_hom", "description": ""}, {"name": "add_monoid_hom.map_zsmul'", "description": ""}, {"name": "add_hom.comp_add", "description": ""}, {"name": "map_add_eq_zero", "description": ""}, {"name": "zero_hom.comp_apply", "description": ""}, {"name": "zero_hom.has_coe_t", "description": ""}, {"name": "mul_hom.comp_assoc", "description": ""}, {"name": "add_monoid_hom.add_comp", "description": ""}, {"name": "ne_one_of_map", "description": ""}, {"name": "one_hom.coe_inj", "description": "Deprecated: use `fun_like.coe_injective` instead."}, {"name": "add_monoid_hom.ext_iff", "description": ""}, {"name": "add_monoid_hom.coe_of_map_add_neg", "description": ""}, {"name": "zero_hom.cancel_left", "description": ""}, {"name": "monoid_with_zero_hom.coe_eq_to_monoid_hom", "description": ""}, {"name": "mul_hom.ext_iff", "description": "Deprecated: use `fun_like.ext_iff` instead."}, {"name": "monoid_hom.map_mul_inv", "description": "Group homomorphisms preserve division."}, {"name": "zero_hom.congr_arg", "description": "Deprecated: use `fun_like.congr_arg` instead."}, {"name": "add_hom.id_apply", "description": ""}, {"name": "add_monoid_hom.map_exists_left_neg", "description": "Given an add_monoid homomorphism `f : M \u2192+ N` and an element `x : M`, if `x` has\na left inverse, then `f x` has a left inverse too. For elements invertible on both sides see\n`is_add_unit.map`."}, {"name": "add_monoid_hom.mk'", "description": "Makes an additive group homomorphism from a proof that the map preserves addition."}, {"name": "monoid_hom.to_mul_hom_coe", "description": ""}, {"name": "add_hom.id_comp", "description": ""}, {"name": "add_monoid_hom.to_zero_hom_coe", "description": ""}, {"name": "map_div'", "description": ""}, {"name": "monoid_hom.congr_fun", "description": "Deprecated: use `fun_like.congr_fun` instead."}, {"name": "map_nsmul", "description": ""}, {"name": "monoid_hom.comp_apply", "description": ""}, {"name": "add_monoid_hom.copy", "description": "Copy of an `add_monoid_hom` with a new `to_fun` equal to the old one. Useful to fix\ndefinitional equalities."}, {"name": "add_monoid_hom.coe_eq_to_zero_hom", "description": ""}, {"name": "monoid_with_zero_hom.comp", "description": "Composition of `monoid_with_zero_hom`s as a `monoid_with_zero_hom`."}, {"name": "monoid_hom.copy", "description": " Copy of a `monoid_hom` with a new `to_fun` equal to the old one. Useful to fix\ndefinitional equalities."}, {"name": "add_monoid_hom.mk'_apply", "description": ""}, {"name": "zero_hom.to_fun_eq_coe", "description": ""}, {"name": "map_ne_zero_iff", "description": ""}, {"name": "add_hom.comp_apply", "description": ""}, {"name": "one_hom.to_fun_eq_coe", "description": ""}, {"name": "add_hom.cancel_left", "description": ""}, {"name": "monoid_hom.coe_eq_to_one_hom", "description": ""}, {"name": "one_hom.one_hom_class", "description": ""}, {"name": "mul_hom.mul_hom_class", "description": ""}, {"name": "monoid_hom.to_one_hom", "description": ""}, {"name": "mul_hom.mk_coe", "description": ""}, {"name": "one_hom_class", "description": " `one_hom_class F M N` states that `F` is a type of one-preserving homomorphisms.\nYou should extend this typeclass when you extend `one_hom`."}, {"name": "one_hom_class.coe", "description": " `one_hom_class F M N` states that `F` is a type of one-preserving homomorphisms.\nYou should extend this typeclass when you extend `one_hom`."}, {"name": "one_hom_class.coe_injective'", "description": " `one_hom_class F M N` states that `F` is a type of one-preserving homomorphisms.\nYou should extend this typeclass when you extend `one_hom`."}, {"name": "one_hom_class.map_one", "description": " `one_hom_class F M N` states that `F` is a type of one-preserving homomorphisms.\nYou should extend this typeclass when you extend `one_hom`."}, {"name": "one_hom.id_apply", "description": ""}, {"name": "one_hom.cancel_right", "description": ""}, {"name": "monoid_hom.to_one_hom_coe", "description": ""}, {"name": "monoid_hom.has_coe_to_one_hom", "description": ""}, {"name": "mul_hom.coe_comp", "description": ""}, {"name": "map_mul", "description": ""}, {"name": "map_sub'", "description": ""}, {"name": "monoid_with_zero_hom.has_coe_to_fun", "description": ""}, {"name": "add_hom.has_coe_to_fun", "description": ""}, {"name": "zero_hom.has_zero", "description": "`0` is the homomorphism sending all elements to `0`."}, {"name": "add_monoid_hom.has_sub", "description": " If `f` and `g` are monoid homomorphisms to an additive commutative group, then `f - g`\nis the homomorphism sending `x` to `(f x) - (g x)`."}, {"name": "monoid_with_zero_hom.has_coe_t", "description": ""}, {"name": "monoid_hom.map_inv", "description": "Group homomorphisms preserve inverse."}, {"name": "monoid_hom.coe_mk", "description": ""}, {"name": "zero_hom.coe_mk", "description": ""}, {"name": "zero_hom.comp_assoc", "description": ""}, {"name": "monoid_hom.coe_comp", "description": ""}, {"name": "monoid_with_zero_hom.id_apply", "description": ""}, {"name": "zero_hom_class", "description": " `zero_hom_class F M N` states that `F` is a type of zero-preserving homomorphisms.\n\nYou should extend this typeclass when you extend `zero_hom`."}, {"name": "zero_hom_class.coe", "description": " `zero_hom_class F M N` states that `F` is a type of zero-preserving homomorphisms.\n\nYou should extend this typeclass when you extend `zero_hom`."}, {"name": "zero_hom_class.coe_injective'", "description": " `zero_hom_class F M N` states that `F` is a type of zero-preserving homomorphisms.\n\nYou should extend this typeclass when you extend `zero_hom`."}, {"name": "zero_hom_class.map_zero", "description": " `zero_hom_class F M N` states that `F` is a type of zero-preserving homomorphisms.\n\nYou should extend this typeclass when you extend `zero_hom`."}, {"name": "monoid_hom.comp_mul", "description": ""}, {"name": "one_hom.id_comp", "description": ""}, {"name": "add_monoid_hom.id_apply", "description": ""}, {"name": "one_hom.congr_fun", "description": "Deprecated: use `fun_like.congr_fun` instead."}, {"name": "add_hom.coe_mk", "description": ""}, {"name": "monoid_hom.map_exists_left_inv", "description": " Given a monoid homomorphism `f : M \u2192* N` and an element `x : M`, if `x` has a left inverse,\nthen `f x` has a left inverse too. For elements invertible on both sides see `is_unit.map`."}, {"name": "map_neg", "description": "Additive group homomorphisms preserve negation."}, {"name": "monoid_hom.id_comp", "description": ""}, {"name": "monoid_with_zero_hom.to_monoid_hom", "description": ""}, {"name": "map_eq_one_iff", "description": ""}, {"name": "map_eq_zero_iff", "description": ""}, {"name": "add_monoid_hom.comp_apply", "description": ""}, {"name": "add_monoid_hom.id", "description": "The identity map from an additive monoid to itself."}, {"name": "monoid_hom.mk'", "description": "Makes a group homomorphism from a proof that the map preserves multiplication."}, {"name": "add_hom.inhabited", "description": ""}, {"name": "add_monoid_hom.has_add", "description": " Given two additive monoid morphisms `f`, `g` to an additive commutative monoid, `f + g` is the\nadditive monoid morphism sending `x` to `f x + g x`."}, {"name": "monoid_hom.to_mul_hom", "description": ""}, {"name": "one_hom.one_apply", "description": ""}, {"name": "monoid_hom.has_div", "description": " If `f` and `g` are monoid homomorphisms to a commutative group, then `f / g` is the homomorphism\nsending `x` to `(f x) / (g x)`."}, {"name": "add_monoid_hom.comp", "description": "Composition of additive monoid morphisms as an additive monoid morphism."}, {"name": "mul_hom.cancel_right", "description": ""}, {"name": "monoid_hom.comp_one", "description": ""}, {"name": "monoid_hom.to_one_hom_injective", "description": ""}, {"name": "add_monoid_hom.comp_zero", "description": ""}, {"name": "inv_monoid_hom_apply", "description": ""}, {"name": "monoid.End", "description": "The monoid of endomorphisms."}, {"name": "add_monoid_hom.map_zero", "description": "If `f` is an additive monoid homomorphism then `f 0 = 0`."}, {"name": "one_hom.id", "description": "The identity map from a type with 1 to itself."}, {"name": "monoid_hom.inv_comp", "description": ""}, {"name": "add_monoid.coe_mul", "description": ""}, {"name": "add_hom.to_fun_eq_coe", "description": ""}, {"name": "mul_hom.comp_apply", "description": ""}, {"name": "mul_hom.copy", "description": " Copy of a `mul_hom` with a new `to_fun` equal to the old one. Useful to fix definitional\nequalities."}, {"name": "zero_hom.zero_apply", "description": ""}, {"name": "monoid_hom.mul_comp", "description": ""}, {"name": "add_hom.id", "description": "The identity map from an type with addition to itself."}, {"name": "map_zero", "description": ""}, {"name": "add_monoid_hom.has_coe_to_add_hom", "description": ""}, {"name": "add_hom.congr_arg", "description": "Deprecated: use `fun_like.congr_arg` instead."}, {"name": "monoid_hom.has_inv", "description": " If `f` is a monoid homomorphism to a commutative group, then `f\u207b\u00b9` is the homomorphism sending\n`x` to `(f x)\u207b\u00b9`."}, {"name": "add_hom.comp", "description": "Composition of `add_hom`s as a `add_hom`."}, {"name": "one_hom_class.to_fun_like", "description": ""}, {"name": "map_ne_one_iff", "description": ""}, {"name": "one_hom.has_coe_t", "description": ""}, {"name": "zero_hom.zero_hom_class", "description": ""}, {"name": "map_sub", "description": "Additive group homomorphisms preserve subtraction."}, {"name": "map_nsmul.aux", "description": ""}, {"name": "coe_inv_monoid_hom", "description": ""}, {"name": "one_hom.copy", "description": " Copy of a `one_hom` with a new `to_fun` equal to the old one. Useful to fix definitional\nequalities."}, {"name": "monoid_hom.monoid_hom_class", "description": ""}, {"name": "monoid_hom.mul_apply", "description": ""}, {"name": "mul_hom.to_fun_eq_coe", "description": ""}, {"name": "add_monoid_hom.has_zero", "description": "`0` is the additive monoid homomorphism sending all elements to `0`."}, {"name": "commute.map", "description": ""}, {"name": "add_monoid_hom_class.to_zero_hom_class", "description": ""}, {"name": "add_hom_class.to_fun_like", "description": ""}, {"name": "monoid_with_zero_hom.has_coe_to_monoid_hom", "description": ""}, {"name": "add_monoid_hom.map_nsmul", "description": ""}, {"name": "monoid_with_zero_hom.ext_iff", "description": "Deprecated: use `fun_like.ext_iff` instead."}, {"name": "monoid_with_zero_hom.map_zero", "description": ""}, {"name": "add_hom.coe_comp", "description": ""}, {"name": "monoid.End.inhabited", "description": ""}, {"name": "add_hom.add_apply", "description": ""}, {"name": "monoid_with_zero_hom.to_zero_hom_coe", "description": ""}, {"name": "mul_hom.inhabited", "description": ""}, {"name": "map_zsmul'", "description": ""}, {"name": "add_monoid_hom.cancel_left", "description": ""}, {"name": "zero_hom.comp_zero", "description": ""}, {"name": "monoid_hom.map_one", "description": "If `f` is a monoid homomorphism then `f 1 = 1`."}, {"name": "add_monoid_hom.congr_fun", "description": "Deprecated: use `fun_like.congr_fun` instead."}, {"name": "zero_hom.id_apply", "description": ""}, {"name": "monoid_with_zero_hom.to_monoid_hom_coe", "description": ""}, {"name": "monoid.coe_mul", "description": ""}, {"name": "monoid_with_zero_hom_class.to_zero_hom_class", "description": ""}, {"name": "monoid_hom.map_zpow'", "description": ""}, {"name": "monoid_hom.has_coe_to_mul_hom", "description": ""}, {"name": "multiset.fold_eq_foldr", "description": ""}, {"name": "multiset.fold_eq_foldl", "description": ""}, {"name": "multiset.fold_cons'_left", "description": ""}, {"name": "multiset.fold", "description": "`fold op b s` folds a commutative associative operation `op` over\n the multiset `s`."}, {"name": "multiset.fold_cons_right", "description": ""}, {"name": "multiset.fold_distrib", "description": ""}, {"name": "multiset.fold_cons'_right", "description": ""}, {"name": "multiset.fold_dedup_idem", "description": ""}, {"name": "multiset.fold_cons_left", "description": ""}, {"name": "multiset.fold_add", "description": ""}, {"name": "multiset.fold_singleton", "description": ""}, {"name": "multiset.max_le_of_forall_le", "description": ""}, {"name": "multiset.fold_union_inter", "description": ""}, {"name": "multiset.coe_fold_r", "description": ""}, {"name": "multiset.coe_fold_l", "description": ""}, {"name": "multiset.fold_hom", "description": ""}, {"name": "multiset.le_smul_dedup", "description": ""}, {"name": "multiset.fold_zero", "description": ""}, {"name": "multiset.max_nat_le_of_forall_le", "description": ""}, {"name": "multiset.card_eq_zero", "description": ""}, {"name": "multiset.ext", "description": ""}, {"name": "multiset.card_eq_countp_add_countp", "description": ""}, {"name": "multiset.le_count_iff_repeat_le", "description": ""}, {"name": "multiset.of_mem_filter", "description": ""}, {"name": "multiset.map_subset_map", "description": ""}, {"name": "multiset.mem_add", "description": ""}, {"name": "multiset.filter_zero", "description": ""}, {"name": "multiset.add_eq_union_iff_disjoint", "description": ""}, {"name": "multiset.strong_induction_on", "description": " A strong induction principle for multisets:\nIf you construct a value for a particular multiset given values for all strictly smaller multisets,\nyou can construct a value for any multiset."}, {"name": "multiset.zero_ne_cons", "description": ""}, {"name": "multiset.mem_union", "description": ""}, {"name": "multiset.foldr", "description": "`foldr f H b s` is the lift of the list operation `foldr f b l`,\n which folds `f` over the multiset. It is well defined when `f` is left-commutative,\n that is, `f a\u2081 (f a\u2082 b) = f a\u2082 (f a\u2081 b)`."}, {"name": "multiset", "description": "`multiset \u03b1` is the quotient of `list \u03b1` by list permutation. The result\n is a type of finite sets with duplicates allowed."}, {"name": "multiset.disjoint_right", "description": ""}, {"name": "multiset.rel_add_right", "description": ""}, {"name": "multiset.filter_singleton", "description": ""}, {"name": "multiset.subsingleton_equiv", "description": "The equivalence between lists and multisets of a subsingleton type."}, {"name": "multiset.exists_mem_of_ne_zero", "description": ""}, {"name": "multiset.foldr_zero", "description": ""}, {"name": "multiset.filter_map", "description": "`filter_map f s` is a combination filter/map operation on `s`.\n The function `f : \u03b1 \u2192 option \u03b2` is applied to each element of `s`;\n if `f a` is `some b` then `b` is added to the result, otherwise\n `a` is removed from the resulting multiset."}, {"name": "multiset.inter_le_right", "description": ""}, {"name": "multiset.card_erase_eq_ite", "description": ""}, {"name": "multiset.union_comm", "description": ""}, {"name": "multiset.card_mono", "description": ""}, {"name": "multiset.count_cons_of_ne", "description": ""}, {"name": "multiset.strong_downward_induction_eq", "description": ""}, {"name": "multiset.countp", "description": "`countp p s` counts the number of elements of `s` (with multiplicity) that\n satisfy `p`."}, {"name": "multiset.card_zero", "description": ""}, {"name": "multiset.sub_add_inter", "description": ""}, {"name": "multiset.inter_eq_zero_iff_disjoint", "description": ""}, {"name": "multiset.attach_map_val", "description": ""}, {"name": "multiset.coe_foldl", "description": ""}, {"name": "multiset.insert_eq_cons", "description": ""}, {"name": "multiset.le_iff_count", "description": ""}, {"name": "multiset.foldr_induction", "description": ""}, {"name": "multiset.repeat_le_coe", "description": ""}, {"name": "multiset.card_eq_two", "description": ""}, {"name": "multiset.ext'", "description": ""}, {"name": "multiset.mem_cons", "description": ""}, {"name": "multiset.count_inter", "description": ""}, {"name": "multiset.disjoint_union_right", "description": ""}, {"name": "multiset.card_lt_of_lt", "description": ""}, {"name": "multiset.can_lift", "description": " If each element of `s : multiset \u03b1` can be lifted to `\u03b2`, then `s` can be lifted to\n`multiset \u03b2`."}, {"name": "multiset.map_erase", "description": ""}, {"name": "multiset.eq_repeat_of_mem", "description": ""}, {"name": "multiset.disjoint_cons_right", "description": ""}, {"name": "multiset.choose_x", "description": " Given a proof `hp` that there exists a unique `a \u2208 l` such that `p a`, `choose_x p l hp` returns\nthat `a` together with proofs of `a \u2208 l` and `p a`."}, {"name": "multiset.repeat_left_injective", "description": ""}, {"name": "multiset.filter_map_filter", "description": ""}, {"name": "multiset.pairwise_coe_iff_pairwise", "description": ""}, {"name": "multiset.coe_map", "description": ""}, {"name": "multiset.filter_eq", "description": ""}, {"name": "multiset.coe_pmap", "description": ""}, {"name": "multiset.mem_inter", "description": ""}, {"name": "multiset.filter_map_eq_map", "description": ""}, {"name": "multiset.rel.trans", "description": ""}, {"name": "multiset.erase_le_erase", "description": ""}, {"name": "multiset.sizeof_lt_sizeof_of_mem", "description": ""}, {"name": "multiset.rel_cons_left", "description": ""}, {"name": "multiset.distrib_lattice", "description": ""}, {"name": "multiset.map_cons", "description": ""}, {"name": "multiset.le_union_right", "description": ""}, {"name": "multiset.map_injective", "description": ""}, {"name": "multiset.add_inter_distrib", "description": ""}, {"name": "multiset.not_mem_mono", "description": ""}, {"name": "multiset.disjoint_of_subset_right", "description": ""}, {"name": "multiset.mem_to_list", "description": ""}, {"name": "multiset.bot_eq_zero", "description": "This is a `rfl` and `simp` version of `bot_eq_zero`."}, {"name": "multiset.cons_coe", "description": ""}, {"name": "multiset.singleton_disjoint", "description": ""}, {"name": "multiset.countp_pos_of_mem", "description": ""}, {"name": "multiset.coe_add", "description": ""}, {"name": "multiset.disjoint.symm", "description": ""}, {"name": "multiset.erase_add_right_pos", "description": ""}, {"name": "multiset.foldr_cons", "description": ""}, {"name": "multiset.mem_map_of_mem", "description": ""}, {"name": "multiset.card_singleton", "description": ""}, {"name": "multiset.coe_erase", "description": ""}, {"name": "multiset.mem_filter_of_mem", "description": ""}, {"name": "multiset.count_repeat_self", "description": ""}, {"name": "multiset.induction_on'", "description": ""}, {"name": "multiset.attach_cons", "description": ""}, {"name": "multiset.map_filter_map", "description": ""}, {"name": "multiset.map_comp_cons", "description": ""}, {"name": "multiset.repeat_left_inj", "description": ""}, {"name": "multiset.repeat_subset_singleton", "description": ""}, {"name": "multiset.card_map", "description": ""}, {"name": "multiset.subset.refl", "description": ""}, {"name": "multiset.count_singleton", "description": ""}, {"name": "multiset.add", "description": "The sum of two multisets is the lift of the list append operation.\n This adds the multiplicities of each element,\n i.e. `count a (s + t) = count a s + count a t`."}, {"name": "multiset.add_singleton_eq_iff", "description": ""}, {"name": "multiset.monotone_filter_right", "description": ""}, {"name": "multiset.disjoint_cons_left", "description": ""}, {"name": "multiset.card_pos", "description": ""}, {"name": "multiset.rel_iff", "description": ""}, {"name": "multiset.inter_zero", "description": ""}, {"name": "multiset.exists_mem_of_rel_of_mem", "description": ""}, {"name": "multiset.coe_map_add_monoid_hom", "description": ""}, {"name": "multiset.le_union_left", "description": ""}, {"name": "multiset.singleton_le", "description": ""}, {"name": "multiset.sub_zero", "description": "This is a special case of `tsub_zero`, which should be used instead of this.\n This is needed to prove `has_ordered_sub (multiset \u03b1)`."}, {"name": "multiset.map_singleton", "description": ""}, {"name": "multiset.erase_add_left_neg", "description": ""}, {"name": "multiset.quot_mk_to_coe'", "description": ""}, {"name": "multiset.map_filter", "description": ""}, {"name": "multiset.eq_repeat", "description": ""}, {"name": "multiset.attach_zero", "description": ""}, {"name": "multiset.rel_zero_left", "description": ""}, {"name": "multiset.countp_zero", "description": ""}, {"name": "multiset.countp_map", "description": ""}, {"name": "multiset.union_def", "description": ""}, {"name": "multiset.rel_eq", "description": ""}, {"name": "multiset.nsmul_singleton", "description": ""}, {"name": "multiset.order_bot", "description": ""}, {"name": "multiset.card", "description": "The cardinality of a multiset is the sum of the multiplicities\n of all its elements, or simply the length of the underlying list."}, {"name": "multiset.countp_eq_card", "description": ""}, {"name": "multiset.countp_add_monoid_hom", "description": " `countp p`, the number of elements of a multiset satisfying `p`, promoted to an\n`add_monoid_hom`."}, {"name": "multiset.le_cons_erase", "description": ""}, {"name": "multiset.count_add", "description": ""}, {"name": "multiset.induction_on_multiset_quot", "description": ""}, {"name": "multiset.union_le_union_right", "description": ""}, {"name": "multiset.mem_of_subset", "description": ""}, {"name": "multiset.case_strong_induction_on", "description": ""}, {"name": "multiset.filter_add", "description": ""}, {"name": "multiset.disjoint_union_left", "description": ""}, {"name": "multiset.eq_of_le_of_card_le", "description": ""}, {"name": "multiset.rel.mono", "description": ""}, {"name": "multiset.monotone_filter_left", "description": ""}, {"name": "multiset.card_nsmul", "description": ""}, {"name": "multiset.erase_cons_head", "description": ""}, {"name": "multiset.count_cons_self", "description": ""}, {"name": "multiset.cons_erase", "description": ""}, {"name": "multiset.sup_eq_union", "description": ""}, {"name": "multiset.foldr_add", "description": ""}, {"name": "multiset.pmap_eq_map", "description": ""}, {"name": "multiset.count_le_card", "description": ""}, {"name": "multiset.repeat_succ", "description": ""}, {"name": "multiset.le_cons_of_not_mem", "description": ""}, {"name": "multiset.countp_sub", "description": ""}, {"name": "multiset.inter_comm", "description": ""}, {"name": "multiset.rel.countp_eq", "description": ""}, {"name": "multiset.zero", "description": "`0 : multiset \u03b1` is the empty set"}, {"name": "multiset.union_le_add", "description": ""}, {"name": "multiset.countp_eq_zero", "description": ""}, {"name": "multiset.mem_filter_map", "description": ""}, {"name": "multiset.decidable_exists_multiset", "description": " If `p` is a decidable predicate,\nso is the existence of an element in a multiset satisfying `p`."}, {"name": "multiset.rel_cons_right", "description": ""}, {"name": "multiset.card_erase_lt_of_mem", "description": ""}, {"name": "multiset.is_lawful_singleton", "description": ""}, {"name": "multiset.map_id", "description": ""}, {"name": "multiset.cons_ne_zero", "description": ""}, {"name": "multiset.subset", "description": "`s \u2286 t` is the lift of the list subset relation. It means that any\n element with nonzero multiplicity in `s` has nonzero multiplicity in `t`,\n but it does not imply that the multiplicity of `a` in `s` is less or equal than in `t`;\n see `s \u2264 t` for this relation."}, {"name": "multiset.mem_cons_of_mem", "description": ""}, {"name": "multiset.filter_sub", "description": ""}, {"name": "multiset.union_add_inter", "description": ""}, {"name": "multiset.coe_eq_zero", "description": ""}, {"name": "multiset.countp_filter", "description": ""}, {"name": "multiset.decidable_dforall_multiset", "description": ""}, {"name": "multiset.foldr_induction'", "description": ""}, {"name": "multiset.coe_reverse", "description": ""}, {"name": "multiset.mem_attach", "description": ""}, {"name": "multiset.filter", "description": "`filter p s` returns the elements in `s` (with the same multiplicities)\n which satisfy `p`, and removes the rest."}, {"name": "multiset.rel_flip_eq", "description": ""}, {"name": "multiset.le_filter", "description": ""}, {"name": "multiset.rel_repeat_right", "description": ""}, {"name": "multiset.has_subset", "description": ""}, {"name": "multiset.disjoint_of_le_left", "description": ""}, {"name": "multiset.disjoint_add_right", "description": ""}, {"name": "multiset.decidable_mem", "description": ""}, {"name": "multiset.disjoint_map_map", "description": ""}, {"name": "multiset.map_hcongr", "description": ""}, {"name": "multiset.repeat_one", "description": ""}, {"name": "multiset.lt_cons_self", "description": ""}, {"name": "multiset.pmap_eq_map_attach", "description": ""}, {"name": "multiset.filter_map_filter_map", "description": ""}, {"name": "multiset.zero_le", "description": ""}, {"name": "multiset.map_add_monoid_hom", "description": "`multiset.map` as an `add_monoid_hom`."}, {"name": "multiset.filter_subset", "description": ""}, {"name": "multiset.mem_erase_of_ne", "description": ""}, {"name": "multiset.filter_eq_nil", "description": ""}, {"name": "multiset.has_union", "description": ""}, {"name": "multiset.pmap", "description": "Lift of the list `pmap` operation. Map a partial function `f` over a multiset\n `s` whose elements are all in the domain of `f`."}, {"name": "multiset.union_add_distrib", "description": ""}, {"name": "multiset.to_list", "description": "Produces a list of the elements in the multiset using choice."}, {"name": "multiset.card_sub", "description": ""}, {"name": "multiset.cons_subset", "description": ""}, {"name": "multiset.map_eq_cons", "description": ""}, {"name": "multiset.quot_mk_to_coe", "description": ""}, {"name": "multiset.sub_inter", "description": ""}, {"name": "multiset.filter_map_map", "description": ""}, {"name": "multiset.map_id'", "description": ""}, {"name": "multiset.filter_cons", "description": ""}, {"name": "multiset.has_sub", "description": ""}, {"name": "multiset.cons_subset_cons", "description": ""}, {"name": "multiset.strong_downward_induction_on", "description": "Analogue of `strong_downward_induction` with order of arguments swapped."}, {"name": "multiset.subset_cons", "description": ""}, {"name": "multiset.singleton_eq_cons", "description": ""}, {"name": "multiset.count_repeat", "description": ""}, {"name": "multiset.inter_le_left", "description": ""}, {"name": "multiset.filter_filter", "description": ""}, {"name": "multiset.cons_swap", "description": ""}, {"name": "multiset.has_inter", "description": ""}, {"name": "multiset.rel_map", "description": ""}, {"name": "multiset.induction", "description": ""}, {"name": "multiset.disjoint_singleton", "description": ""}, {"name": "multiset.repeat_injective", "description": ""}, {"name": "multiset.has_mem", "description": ""}, {"name": "multiset.induction_on", "description": ""}, {"name": "multiset.forall_mem_map_iff", "description": ""}, {"name": "multiset.le_inter_iff", "description": ""}, {"name": "multiset.countp_false", "description": ""}, {"name": "multiset.map_embedding_apply", "description": ""}, {"name": "multiset.pmap_cons", "description": ""}, {"name": "multiset.coe_le", "description": ""}, {"name": "multiset.filter_le_filter", "description": ""}, {"name": "multiset.has_decidable_eq", "description": ""}, {"name": "multiset.rel_eq_refl", "description": ""}, {"name": "multiset.coe_inter", "description": ""}, {"name": "multiset.card_pair", "description": ""}, {"name": "multiset.map_eq_singleton", "description": ""}, {"name": "multiset.filter_add_not", "description": ""}, {"name": "multiset.map_const", "description": ""}, {"name": "multiset.map_filter_map_of_inv", "description": ""}, {"name": "multiset.filter_map_le_filter_map", "description": ""}, {"name": "multiset.card_repeat", "description": ""}, {"name": "multiset.coe_nil_eq_zero", "description": ""}, {"name": "multiset.foldl_induction'", "description": ""}, {"name": "multiset.eq_repeat'", "description": ""}, {"name": "multiset.has_insert", "description": ""}, {"name": "multiset.card_attach", "description": ""}, {"name": "multiset.map_eq_map", "description": ""}, {"name": "multiset.sub_eq_fold_erase", "description": ""}, {"name": "multiset.map_count_true_eq_filter_card", "description": "Mapping a multiset through a predicate and counting the `true`s yields the cardinality of the set\nfiltered by the predicate. Note that this uses the notion of a multiset of `Prop`s - due to the\ndecidability requirements of `count`, the decidability instance on the LHS is different from the\nRHS. In particular, the decidability instance on the left leaks `classical.dec_eq`.\nSee [here](https://github.com/leanprover-community/mathlib/pull/11306#discussion_r782286812)\nfor more discussion."}, {"name": "multiset.pmap_congr", "description": ""}, {"name": "multiset.union_le", "description": ""}, {"name": "multiset.erase", "description": "`erase s a` is the multiset that subtracts 1 from the\n multiplicity of `a`."}, {"name": "multiset.cons_inj_left", "description": ""}, {"name": "multiset.singleton_ne_zero", "description": ""}, {"name": "multiset.has_zero", "description": ""}, {"name": "multiset.rel.add", "description": ""}, {"name": "multiset.count", "description": "`count a s` is the multiplicity of `a` in `s`."}, {"name": "multiset.mem_nsmul", "description": ""}, {"name": "multiset.has_coe", "description": ""}, {"name": "multiset.disjoint_of_le_right", "description": ""}, {"name": "multiset.card_eq_three", "description": ""}, {"name": "multiset.erase_cons_tail", "description": ""}, {"name": "multiset.map_union", "description": ""}, {"name": "multiset.has_ordered_sub", "description": ""}, {"name": "multiset.disjoint_of_subset_left", "description": ""}, {"name": "multiset.mem_coe", "description": ""}, {"name": "multiset.mem_cons_self", "description": ""}, {"name": "multiset.eq_zero_of_forall_not_mem", "description": ""}, {"name": "multiset.filter_inter", "description": ""}, {"name": "multiset.filter_le", "description": ""}, {"name": "multiset.zero_inter", "description": ""}, {"name": "multiset.sub_cons", "description": ""}, {"name": "multiset.mem_repeat", "description": ""}, {"name": "multiset.repeat_inf", "description": ""}, {"name": "multiset.map", "description": "`map f s` is the lift of the list `map` operation. The multiplicity\n of `b` in `map f s` is the number of `a \u2208 s` (counting multiplicity)\n such that `f a = b`."}, {"name": "multiset.erase_zero", "description": ""}, {"name": "multiset.card_le_of_le", "description": ""}, {"name": "multiset.repeat", "description": "`repeat a n` is the multiset containing only `a` with multiplicity `n`."}, {"name": "multiset.subset.trans", "description": ""}, {"name": "multiset.disjoint_add_left", "description": ""}, {"name": "multiset.count_erase_self", "description": ""}, {"name": "multiset.pair_comm", "description": ""}, {"name": "multiset.count_singleton_self", "description": ""}, {"name": "multiset.forall_mem_cons", "description": ""}, {"name": "multiset.disjoint", "description": "`disjoint s t` means that `s` and `t` have no elements in common."}, {"name": "multiset.card_erase_le", "description": ""}, {"name": "multiset.count_map_eq_count", "description": " `multiset.map f` preserves `count` if `f` is injective on the set of elements contained in\nthe multiset"}, {"name": "multiset.map_congr", "description": ""}, {"name": "multiset.rec_on_0", "description": ""}, {"name": "multiset.nsmul_repeat", "description": ""}, {"name": "multiset.countp_nsmul", "description": ""}, {"name": "multiset.rel_map_left", "description": ""}, {"name": "multiset.countp_cons_of_neg", "description": ""}, {"name": "multiset.attach", "description": "\"Attach\" a proof that `a \u2208 s` to each element `a` in `s` to produce\n a multiset on `{x // x \u2208 s}`."}, {"name": "multiset.map_map", "description": ""}, {"name": "multiset.coe_sub", "description": ""}, {"name": "multiset.strong_downward_induction", "description": " Suppose that, given that `p t` can be defined on all supersets of `s` of cardinality less than\n`n`, one knows how to define `p s`. Then one can inductively define `p s` for all multisets `s` of\ncardinality less than `n`, starting from multisets of card `n` and iterating. This\ncan be used either to define data, or to prove properties."}, {"name": "multiset.sub", "description": "`s - t` is the multiset such that `count a (s - t) = count a s - count a t` for all `a`\n (note that it is truncated subtraction, so it is `0` if `count a t \u2265 count a s`)."}, {"name": "multiset.foldr_swap", "description": ""}, {"name": "multiset.le_inter", "description": ""}, {"name": "multiset.card_erase_of_mem", "description": ""}, {"name": "multiset.card_eq_one", "description": ""}, {"name": "multiset.nsmul_cons", "description": ""}, {"name": "multiset.le.subset", "description": "**Alias** of `multiset.subset_of_le`."}, {"name": "multiset.card_eq_card_of_rel", "description": ""}, {"name": "multiset.coe_foldr", "description": ""}, {"name": "multiset.filter_eq'", "description": ""}, {"name": "multiset.erase_add_right_neg", "description": ""}, {"name": "multiset.mem_of_mem_nsmul", "description": ""}, {"name": "multiset.le_add_right", "description": ""}, {"name": "multiset.card_erase_add_one", "description": ""}, {"name": "multiset.cons_eq_cons", "description": ""}, {"name": "multiset.mem_pmap", "description": ""}, {"name": "multiset.union_le_iff", "description": ""}, {"name": "multiset.lt_iff_cons_le", "description": ""}, {"name": "multiset.singleton_add", "description": ""}, {"name": "multiset.filter_map_zero", "description": ""}, {"name": "multiset.filter_map_some", "description": ""}, {"name": "multiset.count_eq_card_filter_eq", "description": ""}, {"name": "multiset.ordered_cancel_add_comm_monoid", "description": ""}, {"name": "multiset.cons_union_distrib", "description": ""}, {"name": "multiset.to_list_zero", "description": ""}, {"name": "multiset.count_map_eq_count'", "description": "`multiset.map f` preserves `count` if `f` is injective"}, {"name": "multiset.choose_spec", "description": ""}, {"name": "multiset.countp_eq_countp_filter_add", "description": ""}, {"name": "multiset.count_le_of_le", "description": ""}, {"name": "multiset.lattice", "description": ""}, {"name": "multiset.erase_singleton", "description": ""}, {"name": "multiset.coe_subsingleton_equiv", "description": ""}, {"name": "multiset.count_eq_zero", "description": ""}, {"name": "multiset.empty_or_exists_mem", "description": ""}, {"name": "multiset.countp_congr", "description": ""}, {"name": "multiset.filter_map_cons_none", "description": ""}, {"name": "multiset.coe_disjoint", "description": ""}, {"name": "multiset.erase_lt", "description": ""}, {"name": "multiset.has_singleton", "description": ""}, {"name": "multiset.le_cons_self", "description": ""}, {"name": "multiset.countp_pos", "description": ""}, {"name": "multiset.count_pos", "description": ""}, {"name": "multiset.count_filter_of_pos", "description": ""}, {"name": "multiset.mem_singleton_self", "description": ""}, {"name": "multiset.rec_on_cons", "description": ""}, {"name": "multiset.count_union", "description": ""}, {"name": "multiset.foldl", "description": "`foldl f H b s` is the lift of the list operation `foldl f b l`,\n which folds `f` over the multiset. It is well defined when `f` is right-commutative,\n that is, `f (f b a\u2081) a\u2082 = f (f b a\u2082) a\u2081`."}, {"name": "multiset.add_cons", "description": ""}, {"name": "multiset.erase_subset", "description": ""}, {"name": "multiset.disjoint_comm", "description": ""}, {"name": "multiset.foldl_swap", "description": ""}, {"name": "multiset.card_pmap", "description": ""}, {"name": "multiset.pairwise_nil", "description": ""}, {"name": "multiset.filter_nsmul", "description": ""}, {"name": "multiset.singleton_coe", "description": ""}, {"name": "multiset.eq_of_mem_map_const", "description": ""}, {"name": "multiset.foldl_zero", "description": ""}, {"name": "multiset.rel_refl_of_refl_on", "description": ""}, {"name": "multiset.count_filter", "description": ""}, {"name": "multiset.coe_eq_coe", "description": ""}, {"name": "multiset.well_founded_lt", "description": "Another way of expressing `strong_induction_on`: the `(<)` relation is well-founded."}, {"name": "multiset.map_mono", "description": ""}, {"name": "multiset.map_embedding", "description": " Associate to an embedding `f` from `\u03b1` to `\u03b2` the order embedding that maps a multiset to its\nimage under `f`."}, {"name": "multiset.eq_zero_iff_forall_not_mem", "description": ""}, {"name": "multiset.count_le_count_cons", "description": ""}, {"name": "multiset.cons_add", "description": ""}, {"name": "multiset.choose_mem", "description": ""}, {"name": "multiset.count_nsmul", "description": ""}, {"name": "multiset.map_pmap", "description": ""}, {"name": "multiset.le_zero", "description": ""}, {"name": "multiset.map_eq_zero", "description": ""}, {"name": "multiset.eq_union_left", "description": ""}, {"name": "multiset.rel_add_left", "description": ""}, {"name": "multiset.singleton_inj", "description": ""}, {"name": "multiset.cons_inter_of_pos", "description": ""}, {"name": "multiset.rel_flip", "description": ""}, {"name": "multiset.mem_map", "description": ""}, {"name": "multiset.subset_zero", "description": ""}, {"name": "multiset.decidable_forall_multiset", "description": " If `p` is a decidable predicate,\nso is the predicate that all elements of a multiset satisfy `p`."}, {"name": "multiset.has_ssubset", "description": ""}, {"name": "multiset.eq_zero_of_subset_zero", "description": ""}, {"name": "multiset.zero_subset", "description": ""}, {"name": "multiset.inter", "description": "`s \u2229 t` is the lattice meet operation with respect to the\n multiset `\u2264`. The multiplicity of `a` in `s \u2229 t` is the minimum\n of the multiplicities in `s` and `t`."}, {"name": "multiset.canonically_ordered_add_monoid", "description": ""}, {"name": "multiset.not_mem_zero", "description": ""}, {"name": "multiset.mem", "description": "`a \u2208 s` means that `a` has nonzero multiplicity in `s`."}, {"name": "multiset.coe_attach", "description": ""}, {"name": "multiset.disjoint_left", "description": ""}, {"name": "multiset.count_erase_of_ne", "description": ""}, {"name": "multiset.one_le_count_iff_mem", "description": ""}, {"name": "multiset.choose", "description": " Given a proof `hp` that there exists a unique `a \u2208 l` such that `p a`, `choose p l hp` returns\nthat `a`."}, {"name": "multiset.union", "description": "`s \u222a t` is the lattice join operation with respect to the\n multiset `\u2264`. The multiplicity of `a` in `s \u222a t` is the maximum\n of the multiplicities in `s` and `t`."}, {"name": "multiset.inter_add_distrib", "description": ""}, {"name": "multiset.coe_count_add_monoid_hom", "description": ""}, {"name": "multiset.repeat_inter", "description": ""}, {"name": "multiset.countp_add", "description": ""}, {"name": "multiset.ssubset_cons", "description": ""}, {"name": "multiset.foldl_cons", "description": ""}, {"name": "multiset.subset_of_le", "description": ""}, {"name": "multiset.disjoint_iff_ne", "description": ""}, {"name": "multiset.strong_induction_eq", "description": ""}, {"name": "multiset.pairwise", "description": " `pairwise r m` states that there exists a list of the elements s.t. `r` holds pairwise on this\nlist."}, {"name": "multiset.coe_to_list", "description": ""}, {"name": "multiset.foldl_induction", "description": ""}, {"name": "multiset.count_sub", "description": ""}, {"name": "multiset.repeat_zero", "description": ""}, {"name": "multiset.erase_of_not_mem", "description": ""}, {"name": "multiset.map_add", "description": ""}, {"name": "multiset.add_union_distrib", "description": ""}, {"name": "multiset.eq_union_right", "description": ""}, {"name": "multiset.partial_order", "description": ""}, {"name": "multiset.filter_eq_self", "description": ""}, {"name": "multiset.card_pos_iff_exists_mem", "description": ""}, {"name": "multiset.rel_map_right", "description": ""}, {"name": "multiset.le", "description": "`s \u2264 t` means that `s` is a sublist of `t` (up to permutation).\n Equivalently, `s \u2264 t` means that `count a s \u2264 count a t` for all `a`."}, {"name": "multiset.countp_le_of_le", "description": ""}, {"name": "multiset.rec_on", "description": "Companion to `multiset.rec` with more convenient argument order."}, {"name": "multiset.has_add", "description": ""}, {"name": "multiset.exists_multiset_eq_map_quot_mk", "description": ""}, {"name": "multiset.filter_cons_of_neg", "description": ""}, {"name": "multiset.count_zero", "description": ""}, {"name": "multiset.inf_eq_inter", "description": ""}, {"name": "multiset.map_mk_eq_map_mk_of_rel", "description": ""}, {"name": "multiset.countp_le_card", "description": ""}, {"name": "multiset.count_eq_card", "description": ""}, {"name": "multiset.map_zero", "description": ""}, {"name": "multiset.rec", "description": " Dependent recursor on multisets.\nTODO: should be @[recursor 6], but then the definition of `multiset.pi` fails with a stack\noverflow in `whnf`."}, {"name": "multiset.erase_le", "description": ""}, {"name": "multiset.filter_filter_map", "description": ""}, {"name": "multiset.mem_singleton", "description": ""}, {"name": "multiset.map_surjective_of_surjective", "description": ""}, {"name": "multiset.countp_true", "description": ""}, {"name": "multiset.filter_cons_of_pos", "description": ""}, {"name": "multiset.has_emptyc", "description": ""}, {"name": "multiset.cons_le_cons", "description": ""}, {"name": "multiset.sizeof", "description": "defines a size for a multiset by referring to the size of the underlying list"}, {"name": "multiset.coe_foldr_swap", "description": ""}, {"name": "multiset.quot_mk_to_coe''", "description": ""}, {"name": "multiset.has_le.le.contravariant_class", "description": ""}, {"name": "multiset.foldr_singleton", "description": ""}, {"name": "multiset.card_cons", "description": ""}, {"name": "multiset.eq_of_mem_repeat", "description": ""}, {"name": "multiset.coe_card", "description": ""}, {"name": "multiset.coe_filter", "description": ""}, {"name": "multiset.map_lt_map", "description": ""}, {"name": "multiset.pairwise_coe_iff", "description": ""}, {"name": "multiset.coe_filter_map", "description": ""}, {"name": "multiset.rel_of_forall", "description": ""}, {"name": "multiset.has_sizeof", "description": ""}, {"name": "multiset.filter_congr", "description": ""}, {"name": "multiset.choose_property", "description": ""}, {"name": "multiset.mem_map_of_injective", "description": ""}, {"name": "multiset.cons_inj_right", "description": ""}, {"name": "multiset.le_iff_exists_add", "description": ""}, {"name": "multiset.card_add", "description": ""}, {"name": "multiset.filter_map_eq_filter", "description": ""}, {"name": "multiset.rel", "description": " `rel r s t` -- lift the relation `r` between two elements to a relation between `s` and `t`,\ns.t. there is a one-to-one mapping betweem elements in `s` and `t` following `r`."}, {"name": "multiset.rel.zero", "description": " `rel r s t` -- lift the relation `r` between two elements to a relation between `s` and `t`,\ns.t. there is a one-to-one mapping betweem elements in `s` and `t` following `r`."}, {"name": "multiset.rel.cons", "description": " `rel r s t` -- lift the relation `r` between two elements to a relation between `s` and `t`,\ns.t. there is a one-to-one mapping betweem elements in `s` and `t` following `r`."}, {"name": "multiset.foldl_add", "description": ""}, {"name": "multiset.erase_add_left_pos", "description": ""}, {"name": "multiset.mem_of_le", "description": ""}, {"name": "multiset.coe_countp_add_monoid_hom", "description": ""}, {"name": "multiset.mem_filter", "description": ""}, {"name": "multiset.coe_countp", "description": ""}, {"name": "multiset.count_add_monoid_hom", "description": "`count a`, the multiplicity of `a` in a multiset, promoted to an `add_monoid_hom`."}, {"name": "multiset.le_add_left", "description": ""}, {"name": "multiset.count_ne_zero", "description": ""}, {"name": "multiset.erase_comm", "description": ""}, {"name": "multiset.inter_repeat", "description": ""}, {"name": "multiset.le_induction_on", "description": ""}, {"name": "multiset.decidable_dexists_multiset", "description": ""}, {"name": "multiset.filter_add_filter", "description": ""}, {"name": "multiset.count_eq_zero_of_not_mem", "description": ""}, {"name": "multiset.filter_union", "description": ""}, {"name": "multiset.map_le_map_iff", "description": ""}, {"name": "multiset.count_filter_of_neg", "description": ""}, {"name": "multiset.sub_le_iff_le_add", "description": "This is a special case of `tsub_le_iff_right`, which should be used instead of this.\n This is needed to prove `has_ordered_sub (multiset \u03b1)`."}, {"name": "multiset.cons_inter_distrib", "description": ""}, {"name": "multiset.pmap_zero", "description": ""}, {"name": "multiset.count_map", "description": ""}, {"name": "multiset.union_le_union_left", "description": ""}, {"name": "multiset.filter_map_cons_some", "description": ""}, {"name": "multiset.countp_eq_card_filter", "description": ""}, {"name": "multiset.count_cons", "description": ""}, {"name": "multiset.empty_eq_zero", "description": ""}, {"name": "multiset.zero_disjoint", "description": ""}, {"name": "multiset.cons", "description": "`cons a s` is the multiset which contains `s` plus one more\n instance of `a`."}, {"name": "multiset.map_repeat", "description": ""}, {"name": "multiset.subset_iff", "description": ""}, {"name": "multiset.map_strict_mono", "description": ""}, {"name": "multiset.cons_inter_of_neg", "description": ""}, {"name": "multiset.inhabited_multiset", "description": ""}, {"name": "multiset.erase_le_iff_le_cons", "description": ""}, {"name": "multiset.rel_zero_right", "description": ""}, {"name": "multiset.mem_of_mem_erase", "description": ""}, {"name": "multiset.coe_count", "description": ""}, {"name": "multiset.countp_cons_of_pos", "description": ""}, {"name": "multiset.map_nsmul", "description": ""}, {"name": "multiset.has_le.le.covariant_class", "description": ""}, {"name": "multiset.map_le_map", "description": ""}, {"name": "multiset.strong_downward_induction_on_eq", "description": ""}, {"name": "multiset.coe_subset", "description": ""}, {"name": "multiset.decidable_eq_pi_multiset", "description": "decidable equality for functions whose domain is bounded by multisets"}, {"name": "multiset.mem_of_mem_filter", "description": ""}, {"name": "multiset.rel_repeat_left", "description": ""}, {"name": "multiset.cons_le_cons_iff", "description": ""}, {"name": "multiset.exists_cons_of_mem", "description": ""}, {"name": "multiset.countp_cons", "description": ""}, {"name": "list.sublist_iff_exists_order_embedding_nth_eq", "description": "A `l : list \u03b1` is `sublist l l'` for `l' : list \u03b1` iff\nthere is `f`, an order-preserving embedding of `\u2115` into `\u2115` such that\nany element of `l` found at index `ix` can be found at index `f ix` in `l'`."}, {"name": "list.nodup.nth_le_equiv_apply_coe", "description": ""}, {"name": "list.sorted.nth_le_mono", "description": ""}, {"name": "list.sublist_of_order_embedding_nth_eq", "description": "If there is `f`, an order-preserving embedding of `\u2115` into `\u2115` such that\nany element of `l` found at index `ix` can be found at index `f ix` in `l'`,\nthen `sublist l l'`."}, {"name": "list.sorted.nth_le_iso", "description": " If `l` is a list sorted w.r.t. `(<)`, then `list.nth_le` defines an order isomorphism between\n`fin (length l)` and the set of elements of `l`."}, {"name": "list.sorted.nth_le_strict_mono", "description": ""}, {"name": "list.nodup.nth_le_equiv_of_forall_mem_list_symm_apply_coe", "description": ""}, {"name": "list.nodup.nth_le_bijection_of_forall_mem_list_coe", "description": ""}, {"name": "list.nodup.nth_le_equiv_of_forall_mem_list_apply", "description": ""}, {"name": "list.sorted.coe_nth_le_iso_symm_apply", "description": ""}, {"name": "list.nodup.nth_le_equiv_of_forall_mem_list", "description": " If `l` lists all the elements of `\u03b1` without duplicates, then `list.nth_le` defines\nan equivalence between `fin l.length` and `\u03b1`.\n\nSee `list.nodup.nth_le_bijection_of_forall_mem_list` for a version without\ndecidable equality."}, {"name": "list.nodup.nth_le_equiv", "description": " If `l` has no duplicates, then `list.nth_le` defines an equivalence between `fin (length l)` and\nthe set of elements of `l`."}, {"name": "list.sublist_iff_exists_fin_order_embedding_nth_le_eq", "description": "A `l : list \u03b1` is `sublist l l'` for `l' : list \u03b1` iff\nthere is `f`, an order-preserving embedding of `fin l.length` into `fin l'.length` such that\nany element of `l` found at index `ix` can be found at index `f ix` in `l'`."}, {"name": "list.nodup.nth_le_equiv_symm_apply_coe", "description": ""}, {"name": "list.nodup.nth_le_bijection_of_forall_mem_list", "description": " If `l` lists all the elements of `\u03b1` without duplicates, then `list.nth_le` defines\na bijection `fin l.length \u2192 \u03b1`.  See `list.nodup.nth_le_equiv_of_forall_mem_list`\nfor a version giving an equivalence when there is decidable equality."}, {"name": "list.sorted.coe_nth_le_iso_apply", "description": ""}, {"name": "list.duplicate_iff_exists_distinct_nth_le", "description": "An element `x : \u03b1` of `l : list \u03b1` is a duplicate iff it can be found\nat two distinct indices `n m : \u2115` inside the list `l`."}, {"name": "tactic.unfreezing_hyp", "description": "Unfreeze local instances while executing `tac`,\nif the passed expression is amongst the frozen instances."}, {"name": "tactic.interactive.letI", "description": " Used to add typeclasses to the context so that they can\nbe used in typeclass inference. The syntax is the same as `let`."}, {"name": "tactic.interactive.casesI", "description": "Like `cases`, but can also be used with instance arguments."}, {"name": "tactic.interactive.unfreezingI", "description": "`unfreezingI { tac }` executes tac while temporarily unfreezing the instance cache."}, {"name": "tactic.interactive.exactI", "description": " Like `exact`, but uses all variables in the context\nfor typeclass inference."}, {"name": "tactic.interactive.haveI", "description": " Used to add typeclasses to the context so that they can\nbe used in typeclass inference. The syntax is the same as `have`."}, {"name": "tactic.unfreezing", "description": "Unfreeze the local instances while executing `tac` on the main goal."}, {"name": "tactic.interactive.resetI", "description": " Reset the instance cache. This allows any new instances\nadded to the context to be used in typeclass inference."}, {"name": "tactic.interactive.substI", "description": "Like `subst`, but can also substitute in instance arguments."}, {"name": "tactic.reset_instance_cache", "description": "Reset the instance cache for the main goal."}, {"name": "tactic.interactive.revertI", "description": "Like `revert`, but can also revert instance arguments."}, {"name": "tactic.interactive.introI", "description": " Like `intro`, but uses the introduced variable\nin typeclass inference."}, {"name": "tactic.interactive.introsI", "description": " Like `intros`, but uses the introduced variable(s)\nin typeclass inference."}, {"name": "false_of_a_eq_not_a", "description": ""}, {"name": "ne_of_eq_of_ne", "description": ""}, {"name": "not_imp_eq_of_eq_false_right", "description": ""}, {"name": "and_eq_of_eq_true_left", "description": ""}, {"name": "and_eq_of_eq_true_right", "description": ""}, {"name": "imp_eq_of_eq_false_right", "description": ""}, {"name": "imp_eq_of_eq_false_left", "description": ""}, {"name": "eq_true_of_and_eq_true_right", "description": ""}, {"name": "eq_true_of_not_eq_false", "description": ""}, {"name": "iff_eq_true_of_eq", "description": ""}, {"name": "imp_eq_true_of_eq", "description": ""}, {"name": "and_eq_of_eq_false_right", "description": ""}, {"name": "eq_false_of_or_eq_false_right", "description": ""}, {"name": "ne_of_ne_of_eq", "description": ""}, {"name": "not_eq_of_eq_false", "description": ""}, {"name": "or_eq_of_eq_true_right", "description": ""}, {"name": "eq_false_of_not_eq_true", "description": ""}, {"name": "imp_eq_of_eq_true_left", "description": ""}, {"name": "and_eq_of_eq_false_left", "description": ""}, {"name": "or_eq_of_eq_false_left", "description": ""}, {"name": "eq_true_of_and_eq_true_left", "description": ""}, {"name": "or_eq_of_eq_false_right", "description": ""}, {"name": "and_eq_of_eq", "description": ""}, {"name": "or_eq_of_eq", "description": ""}, {"name": "if_eq_of_eq_false", "description": ""}, {"name": "iff_eq_of_eq_true_left", "description": ""}, {"name": "iff_eq_of_eq_true_right", "description": ""}, {"name": "imp_eq_of_eq_true_right", "description": ""}, {"name": "if_eq_of_eq", "description": ""}, {"name": "eq_false_of_or_eq_false_left", "description": ""}, {"name": "if_eq_of_eq_true", "description": ""}, {"name": "not_eq_of_eq_true", "description": ""}, {"name": "or_eq_of_eq_true_left", "description": ""}, {"name": "tactic.refl_conv", "description": "Reflexivity conversion: given `e` returns `(e, \u22a2 e = e)`"}, {"name": "tactic.eval_expr'", "description": " `eval_expr' \u03b1 e` attempts to evaluate the expression `e` in the type `\u03b1`.\nThis is a variant of `eval_expr` in core. Due to unexplained behavior in the VM, in rare\nsituations the latter will fail but the former will succeed."}, {"name": "tactic.replace_at", "description": "Given a tactic `tac` that takes an expression\nand returns a new expression and a proof of equality,\nuse that tactic to change the type of the hypotheses listed in `hs`,\nas well as the goal if `tgt = tt`.\n\nReturns `tt` if any types were successfully changed."}, {"name": "format.comma_separated", "description": "Format a list as a comma separated list, without any brackets."}, {"name": "tactic.strip_prefix", "description": "Strips unnecessary prefixes from a name, e.g. if a namespace is open."}, {"name": "tactic.instance_cache.get", "description": " If `n` is the name of a type class with one parameter, `get c n` tries to find an instance of\n`n c.\u03b1` by checking the cache `c`. If there is no entry in the cache, it tries to find the instance\nvia type class resolution, and updates the cache."}, {"name": "tactic.apply_iff", "description": "Attempts to apply `e`, and if that fails, if `e` is an `iff`,\ntry applying both directions separately."}, {"name": "tactic.get_expl_arity", "description": "Compute the arity of explicit arguments of `fn`'s type."}, {"name": "lean.parser.get_variables", "description": " `get_variables` returns a list of existing variable names, along with their types and binder\ninfo."}, {"name": "tactic.succeeds_or_fails_with_msg", "description": "This tactic succeeds if `t` succeeds or fails with message `msg` such that `p msg` is `tt`."}, {"name": "expr.mk_exists_lst", "description": " Generates an expression of the form `\u2203(args), inner`. `args` is assumed to be a list of local\nconstants. When possible, `p \u2227 q` is used instead of `\u2203(_ : p), q`."}, {"name": "lean.parser.get_included_variables", "description": " `get_included_variables` returns those variables `v` returned by `get_variables` which have been\n\"included\" by an `include v` statement and are not (yet) `omit`ed."}, {"name": "tactic.subst'", "description": "If the expression `h` is a local variable with type `x = t` or `t = x`, where `x` is a local\nconstant, `tactic.subst' h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.\nIf `h` is another local variable, then we find a local constant with type `h = t` or `t = h` and\nsubstitute `t` for `h`.\n\nThis is like `tactic.subst`, but fails with a nicer error message if the substituted variable is a\nlocal definition. It is trickier to fix this in core, since `tactic.is_local_def` is in mathlib."}, {"name": "tactic.tactic_statement", "description": "Construct a `Try this: refine ...` or `Try this: exact ...` string which would construct `g`."}, {"name": "tactic_doc.hole_command.instance_stub", "description": "Hole command used to fill in a structure's field when specifying an instance.\n\nIn the following:\n\n```lean\ninstance : monad id :=\n{! !}\n```\n\ninvoking the hole command \"Instance Stub\" (\"Generate a skeleton for the structure under\nconstruction.\") produces:\n\n```lean\ninstance : monad id :=\n{ map := _,\n  map_const := _,\n  pure := _,\n  seq := _,\n  seq_left := _,\n  seq_right := _,\n  bind := _ }\n```"}, {"name": "tactic.mk_comp", "description": " `mk_comp v e` checks whether `e` is a sequence of nested applications `f (g (h v))`, and if so,\nreturns the expression `f \u2218 g \u2218 h`."}, {"name": "tactic_doc.command.run_parser", "description": " `run_parser p` is like `run_cmd` but for the parser monad. It executes parser `p` at the\ntop level, giving access to operations like `emit_code_here`."}, {"name": "tactic.mk_psigma", "description": " `mk_psigma [x,y,z]`, with `[x,y,z]` list of local constants of types `x : tx`,\n`y : ty x` and `z : tz x y`, creates an expression of sigma type:\n`\u27e8x,y,z\u27e9 : \u03a3' (x : tx) (y : ty x), tz x y`."}, {"name": "tactic.instance_cache.append_typeclasses", "description": " If `e` is a `pi` expression that binds an instance-implicit variable of type `n`,\n`append_typeclasses e c l` searches `c` for an instance `p` of type `n` and returns `p :: l`."}, {"name": "tactic.mk_iff_mp_app", "description": " Auxiliary function for `iff_mp` and `iff_mpr`. Takes a name, which should be either `` `iff.mp``\nor `` `iff.mpr``. If the passed expression is an iterated function type eventually producing an\n`iff`, returns an expression with the `iff` converted to either the forwards or backwards\nimplication, as requested."}, {"name": "interaction_monad.run_with_state", "description": "`run_with_state state tac` applies `tac` to the given state `state` and returns the result,\nsubsequently restoring the original state.\nIf `tac` fails, then `run_with_state` does too."}, {"name": "tactic.mk_higher_order_type", "description": "From a lemma of the shape `\u2200 x, f (g x) = h x`\nderive an auxiliary lemma of the form `f \u2218 g = h`\nfor reasoning about higher-order functions."}, {"name": "tactic.get_unused_decl_name", "description": " Return a name which doesn't already exist in the environment. If `nm` doesn't exist, it\nreturns that, otherwise it tries `nm_2`, `nm_3`, ..."}, {"name": "tactic.apply_list_expr", "description": "`apply_list l`, for `l : list (tactic expr)`,\ntries to apply the lemmas generated by the tactics in `l` on the first goal, and\nfail if none succeeds."}, {"name": "tactic.is_in_mathlib", "description": " Checks whether a declaration with the given name is declared in mathlib.\nIf you want to run this tactic many times, you should use `environment.is_prefix_of_file` instead,\nsince it is expensive to execute `get_mathlib_dir` many times."}, {"name": "tactic.mk_simp_attribute_cmd", "description": "The command `mk_simp_attribute simp_name \"description\"` creates a simp set with name `simp_name`.\nLemmas tagged with `@[simp_name]` will be included when `simp with simp_name` is called.\n`mk_simp_attribute simp_name none` will use a default description.\n\nAppending the command with `with attr1 attr2 ...` will include all declarations tagged with\n`attr1`, `attr2`, ... in the new simp set.\n\nThis command is preferred to using ``run_cmd mk_simp_attr `simp_name`` since it adds a doc string\nto the attribute that is defined. If you need to create a simp set in a file where this command is\nnot available, you should use\n```lean\nrun_cmd mk_simp_attr `simp_name\nrun_cmd add_doc_string `simp_attr.simp_name \"Description of the simp set here\"\n```"}, {"name": "lean.parser.repeat_at_least", "description": "A version of `lean.parser.many` that requires at least `n` items"}, {"name": "format.join'", "description": " `join' [a,b,c]` produces the format object `abc`.\nIt differs from `format.join` by using `format.nil` instead of `\"\"` for the empty list."}, {"name": "tactic.replace", "description": " `replace h p` elaborates the pexpr `p`, clears the existing hypothesis named `h` from the local\ncontext, and adds a new hypothesis named `h`. The type of this hypothesis is the type of `p`.\nFails if there is nothing named `h` in the local context."}, {"name": "lean.parser.emit_command_here", "description": " `emit_command_here str` behaves as if the string `str` were placed as a user command at the\ncurrent line."}, {"name": "tactic.symmetry_hyp", "description": "`symmetry_hyp h` applies `symmetry` on hypothesis `h`."}, {"name": "tactic.elim_gen_sum", "description": " `elim_gen_sum n e` applies cases on `e` `n` times. `e` is assumed to be a local constant whose\ntype is a (nested) sum `\u2295`. Returns the list of local constants representing the components of `e`."}, {"name": "tactic.repeat1", "description": " Repeat a tactic at least once, calling it recursively on all subgoals,\nuntil it fails. This tactic fails if the first invocation fails."}, {"name": "tactic.pis", "description": " `pis loc_consts f` is used to create a pi expression whose body is `f`.\n`loc_consts` should be a list of local constants. The function will abstract these local\nconstants from `f` and bind them with pi binders.\n\nFor example, if `a, b` are local constants with types `Ta, Tb`,\n``pis [a, b] `(f a b)`` will return the expression\n`\u03a0 (a : Ta) (b : Tb), f a b`."}, {"name": "tactic.mk_iff", "description": "Given two expressions `e\u2080` and `e\u2081`, return the expression `` `(%%e\u2080 \u2194 %%e\u2081)``."}, {"name": "tactic.iterate_range", "description": " `iterate_range m n t`: Repeat the given tactic at least `m` times and\nat most `n` times or until `t` fails. Fails if `t` does not run at least `m` times."}, {"name": "tactic.get_app_fn_args_whnf", "description": "For `e = f x\u2081 ... x\u2099`, `get_app_fn_args_whnf e` returns `(f, [x\u2081, ..., x\u2099])`. `e`\nis normalised as necessary; for example:\n\n```lean\nget_app_fn_args_whnf `(let f := g x in f y) = (`(g), [`(x), `(y)])\n```\n\nThe returned expression is in whnf, but the arguments are generally not."}, {"name": "tactic.independent_goal", "description": "Succeeds only if the current goal is \"independent\", in the sense\nthat no other goals depend on it, even through shared meta-variables."}, {"name": "list.to_line_wrap_format", "description": "format a `list` by separating elements with `soft_break` instead of `line`"}, {"name": "tactic.or_refl_conv", "description": " Turns a conversion tactic into one that always succeeds, where failure is interpreted as a\nproof by reflexivity."}, {"name": "tactic_doc.hole_command.Equations Stub", "description": "Invoking hole command \"Equations Stub\" (\"Generate a list of equations for a recursive definition\")\nin the following:\n\n```lean\nmeta def foo : {! expr \u2192 tactic unit !} -- `:=` is omitted\n```\n\nproduces:\n\n```lean\nmeta def foo : expr \u2192 tactic unit\n| (expr.var a) := _\n| (expr.sort a) := _\n| (expr.const a a_1) := _\n| (expr.mvar a a_1 a_2) := _\n| (expr.local_const a a_1 a_2 a_3) := _\n| (expr.app a a_1) := _\n| (expr.lam a a_1 a_2 a_3) := _\n| (expr.pi a a_1 a_2 a_3) := _\n| (expr.elet a a_1 a_2 a_3) := _\n| (expr.macro a a_1) := _\n```\n\nA similar result can be obtained by invoking \"Equations Stub\" on the following:\n\n```lean\nmeta def foo : expr \u2192 tactic unit := -- do not forget to write `:=`!!\n{! !}\n```\n\n```lean\nmeta def foo : expr \u2192 tactic unit := -- don't forget to erase `:=`!!\n| (expr.var a) := _\n| (expr.sort a) := _\n| (expr.const a a_1) := _\n| (expr.mvar a a_1 a_2) := _\n| (expr.local_const a a_1 a_2 a_3) := _\n| (expr.app a a_1) := _\n| (expr.lam a a_1 a_2 a_3) := _\n| (expr.pi a a_1 a_2 a_3) := _\n| (expr.elet a a_1 a_2 a_3) := _\n| (expr.macro a a_1) := _\n```"}, {"name": "tactic.instance_cache.mk_app", "description": "Creates the application `n c.\u03b1 p l`, where `p` is a type class instance found in the cache `c`."}, {"name": "tactic.terminal_goal", "description": "Succeeds only if the current goal is \"terminal\",\nin the sense that no other goals depend on it\n(except possibly through shared metavariables; see `independent_goal`)."}, {"name": "tactic.mk_user_fresh_name", "description": " `mk_fresh_name` returns identifiers starting with underscores,\nwhich are not legal when emitted by tactic programs. `mk_user_fresh_name`\nturns the useful source of random names provided by `mk_fresh_name` into\nnames which are usable by tactic programs.\n\nThe returned name has four components which are all strings."}, {"name": "tactic.trace_macro", "description": "The combination of `pformat` and `trace`."}, {"name": "tactic.mk_mvar_list", "description": "Create a list of `n` fresh metavariables."}, {"name": "tactic.goal_of_mvar", "description": " `goal_of_mvar g`, with `g` a meta variable, creates a\n`packaged_goal` corresponding to `g` interpretted as a proof goal"}, {"name": "tactic_doc.command.mk_simp_attribute", "description": "The command `mk_simp_attribute simp_name \"description\"` creates a simp set with name `simp_name`.\nLemmas tagged with `@[simp_name]` will be included when `simp with simp_name` is called.\n`mk_simp_attribute simp_name none` will use a default description.\n\nAppending the command with `with attr1 attr2 ...` will include all declarations tagged with\n`attr1`, `attr2`, ... in the new simp set.\n\nThis command is preferred to using ``run_cmd mk_simp_attr `simp_name`` since it adds a doc string\nto the attribute that is defined. If you need to create a simp set in a file where this command is\nnot available, you should use\n```lean\nrun_cmd mk_simp_attr `simp_name\nrun_cmd add_doc_string `simp_attr.simp_name \"Description of the simp set here\"\n```"}, {"name": "tactic.clear_value", "description": " `clear_value [e\u2080, e\u2081, e\u2082, ...]` clears the body of the local definitions `e\u2080`, `e\u2081`, `e\u2082`, ...\nchanging them into regular hypotheses. A hypothesis `e : \u03b1 := t` is changed to `e : \u03b1`. The order of\nlocals `e\u2080`, `e\u2081`, `e\u2082` does not matter as a permutation will be chosen so as to preserve type\ncorrectness. This tactic is called `clearbody` in Coq."}, {"name": "tactic.extract_def", "description": " Given `elab_def`, a tactic to solve the current goal,\n`extract_def n trusted elab_def` will create an auxiliary definition named `n` and use it\nto close the goal. If `trusted` is false, it will be a meta definition."}, {"name": "tactic.is_local_def", "description": " `is_local_def e` succeeds when `e` is a local definition (a local constant of the form\n`e : \u03b1 := t`) and otherwise fails."}, {"name": "expr.mfoldl", "description": " `mfoldl f a e` folds the monadic function `f` over the subterms of the expression `e`,\nwith initial value `a`."}, {"name": "tactic.try_all_sorted", "description": "Try all the tactics in a list, each time starting at the original `tactic_state`,\nreturning the list of successful results sorted by\nthe value produced by a subsequent execution of the `sort_by` tactic,\nand reverting to the original `tactic_state`."}, {"name": "tactic.tactic.has_to_tactic_format", "description": ""}, {"name": "tactic.trace_if_enabled", "description": "``trace_if_enabled `n msg`` traces the message `msg`\nonly if tracing is enabled for the name `n`.\n\nCreate new names registered for tracing with `declare_trace n`.\nThen use `set_option trace.n true/false` to enable or disable tracing for `n`."}, {"name": "tactic.get_decls_from", "description": " `get_decls_from` returns a dictionary mapping names to their\ncorresponding declarations.  Covers all declarations the files listed\nin `fs`, with the current file listed as `none`.\n\nThe path of the file names is expected to be relative to\nthe root of the project (i.e. the location of `leanpkg.toml` when it\nis present); e.g. `\"src/tactic/core.lean\"`\n\nPossible issue: `get_decls_from` uses `get_cwd`, the current working\ndirectory, which may not always point at the root of the project.\nIt would work better if it searched for the root directory or,\nbetter yet, if Lean exposed its path information."}, {"name": "tactic_doc.command.import_private", "description": " `import_private foo from bar` finds a private declaration `foo` in the same file as `bar`\nand creates a local notation to refer to it.\n\n`import_private foo` looks for `foo` in all imported files.\n\nWhen possible, make `foo` non-private rather than using this feature."}, {"name": "tactic.local_proof", "description": " A variation on `assert` where a (possibly incomplete)\nproof of the assertion is provided as a parameter.\n\n``(h,gs) \u2190 local_proof `h p tac`` creates a local `h : p` and\nuse `tac` to (partially) construct a proof for it. `gs` is the\nlist of remaining goals in the proof of `h`.\n\nThe benefits over assert are:\n- unlike with ``h \u2190 assert `h p, tac`` , `h` cannot be used by `tac`;\n- when `tac` does not complete the proof of `h`, returning the list\n  of goals allows one to write a tactic using `h` and with the confidence\n  that a proof will not boil over to goals left over from the proof of `h`,\n  unlike what would be the case when using `tactic.swap`."}, {"name": "tactic_doc.hole_command.List Constructors", "description": "This command lists the constructors that can be used to satisfy the expected type.\n\nInvoking \"List Constructors\" (\"Show the list of constructors of the expected type\")\nin the following hole:\n\n```lean\ndef foo : \u2124 \u2295 \u2115 :=\n{! !}\n```\n\nproduces:\n\n```lean\ndef foo : \u2124 \u2295 \u2115 :=\n{! sum.inl, sum.inr !}\n```\n\nand will display:\n\n```lean\nsum.inl : \u2124 \u2192 \u2124 \u2295 \u2115\n\nsum.inr : \u2115 \u2192 \u2124 \u2295 \u2115\n```"}, {"name": "expr.traverse", "description": "`traverse f e` applies the monadic function `f` to the direct descendants of `e`."}, {"name": "tactic.interactive.under_binders", "description": "Run a tactic \"under binders\", by running `intros` before, and `revert` afterwards."}, {"name": "tactic.propositional_goal", "description": "Succeeds only if the current goal is a proposition."}, {"name": "tactic.get_proof_state", "description": " `get_proof_state` lists the user visible goal for each goal\nof the current state and for each goal, abstracts all of the\nmeta variables of the other gaols.\n\nThis produces a list of goals in the form of `\u2115 \u00d7 expr` where\nthe `expr` encodes the following proof state:\n\n```lean\n2 goals\nl\u2081 : t\u2081,\nl\u2082 : t\u2082,\nl\u2083 : t\u2083\n\u22a2 tgt\u2081\n\n\u22a2 tgt\u2082\n```\n\nas\n\n```lean\n[ (3, \u2200 (mv : tgt\u2081) (mv : tgt\u2082) (l\u2081 : t\u2081) (l\u2082 : t\u2082) (l\u2083 : t\u2083), tgt\u2081),\n  (0, \u2200 (mv : tgt\u2081) (mv : tgt\u2082), tgt\u2082) ]\n```\n\nwith 2 goals, the first 2 bound variables encode the meta variable\nof all the goals, the next 3 (in the first goal) and 0 (in the second goal)\nare the local constants.\n\nThis representation allows us to compare goals and proof states while\nignoring information like the unique name of local constants and\nthe equality or difference of meta variables that encode the same goal."}, {"name": "tactic.get_goal", "description": "Returns the only goal, or fails if there isn't just one goal."}, {"name": "lean.parser.run_parser_cmd", "description": " `run_parser p` is like `run_cmd` but for the parser monad. It executes parser `p` at the\ntop level, giving access to operations like `emit_code_here`."}, {"name": "tactic.interactive.injections_and_clear", "description": " Calls `injection` on each hypothesis, and then, for each hypothesis on which `injection`\nsucceeds, clears the old hypothesis."}, {"name": "tactic.change_core", "description": " `change_core e none` is equivalent to `change e`. It tries to change the goal to `e` and fails\nif this is not a definitional equality.\n\n`change_core e (some h)` assumes `h` is a local constant, and tries to change the type of `h` to `e`\nby reverting `h`, changing the goal, and reintroducing hypotheses."}, {"name": "tactic.instance_stub", "description": "Hole command used to fill in a structure's field when specifying an instance.\n\nIn the following:\n\n```lean\ninstance : monad id :=\n{! !}\n```\n\ninvoking the hole command \"Instance Stub\" (\"Generate a skeleton for the structure under\nconstruction.\") produces:\n\n```lean\ninstance : monad id :=\n{ map := _,\n  map_const := _,\n  pure := _,\n  seq := _,\n  seq_left := _,\n  seq_right := _,\n  bind := _ }\n```"}, {"name": "tactic_doc.tactic.injections_and_clear", "description": " Calls `injection` on each hypothesis, and then, for each hypothesis on which `injection`\nsucceeds, clears the old hypothesis."}, {"name": "expr.of_list", "description": "Convert a list of expressions to an expression denoting the list of those expressions."}, {"name": "tactic.apply_assumption", "description": "Try to apply a hypothesis from the local context to the goal."}, {"name": "tactic.iff_mp_core", "description": " `iff_mp_core e ty` assumes that `ty` is the type of `e`.\nIf `ty` has the shape `\u03a0 ..., A \u2194 B`, returns an expression whose type is `\u03a0 ..., A \u2192 B`."}, {"name": "tactic.instance_cache", "description": "Caches unary type classes on a type `\u03b1 : Type.{univ}`."}, {"name": "tactic.instance_cache.\u03b1", "description": "Caches unary type classes on a type `\u03b1 : Type.{univ}`."}, {"name": "tactic.instance_cache.univ", "description": "Caches unary type classes on a type `\u03b1 : Type.{univ}`."}, {"name": "tactic.instance_cache.inst", "description": "Caches unary type classes on a type `\u03b1 : Type.{univ}`."}, {"name": "tactic.apply_under_n_pis", "description": "Assumes `pi_expr` is of the form `\u03a0 x1 ... xn xn+1..., _`.\nCreates a pexpr of the form `\u03a0 x1 ... xn, func (arg x1 ... xn)`.\nAll arguments (implicit and explicit) to `arg` should be supplied."}, {"name": "tactic.get_packaged_goal", "description": "create a `packaged_goal` corresponding to the current goal"}, {"name": "tactic.change_with_at", "description": "`change_with_at olde newe hyp` replaces occurences of `olde` with `newe` at hypothesis `hyp`,\nassuming `olde` and `newe` are defeq when elaborated."}, {"name": "tactic.clear_aux_decl", "description": "`clear_aux_decl` clears all expressions from the local context that represent aux decls."}, {"name": "tactic.has_attribute'", "description": " `has_attribute' attr_name decl_name` checks\nwhether `decl_name` exists and has attribute `attr_name`."}, {"name": "tactic.classical", "description": " Makes the declaration `classical.prop_decidable` available to type class inference.\nThis asserts that all propositions are decidable, but does not have computational content.\n\nThe `aggressive` argument controls whether the instance is added globally, where it has low\npriority, or in the local context, where it has very high priority."}, {"name": "tactic.dependent_pose_core", "description": " `dependent_pose_core l`: introduce dependent hypotheses, where the proofs depend on the values\nof the previous local constants. `l` is a list of local constants and their values."}, {"name": "name.contains_sorry_aux", "description": "`pre.contains_sorry_aux nm` checks whether `sorry` occurs in the value of the declaration `nm`\nor (recusively) in any declarations occurring in the value of `nm` with namespace `pre`.\nAuxiliary function for `name.contains_sorry`."}, {"name": "tactic.add_local_consts_as_local_hyps", "description": "`add_local_consts_as_local_hyps vars` add the given list `vars` of `expr.local_const`s to the\n   tactic state. This is harder than it sounds, since the list of local constants which we have\n   been passed can have dependencies between their types.\n\n   For example, suppose we have two local constants `n : \u2115` and `h : n = 3`. Then we cannot blindly\n   add `h` as a local hypothesis, since we need the `n` to which it refers to be the `n` created as\n   a new local hypothesis, not the old local constant `n` with the same name. Of course, these\n   dependencies can be nested arbitrarily deep.\n\n   If the list of passed local constants have types which depend on one another (which can only\n   happen by hand-crafting the `expr`s manually), this function will loop forever."}, {"name": "tactic.set_attribute", "description": "A tactic to set either a basic attribute or a user attribute.\n If the user attribute has a parameter, the default value will be used.\n This tactic raises an error if there is no `inhabited` instance for the parameter type."}, {"name": "tactic.successes", "description": "`successes` invokes each tactic in turn, returning the list of successful results."}, {"name": "tactic.instance_cache.of_nat", "description": "`c.of_nat n` creates the `c.\u03b1`-valued numeral expression corresponding to `n`."}, {"name": "tactic.packaged_goal", "description": " Representation of a proof goal that lends itself to comparison. The\nfollowing goal:\n\n```lean\nl\u2080 : T,\nl\u2081 : T\n\u22a2 \u2200 v : T, foo\n```\n\nis represented as\n\n```lean\n(2, \u2200 l\u2080 l\u2081 v : T, foo)\n```\n\nThe number 2 indicates that first the two bound variables of the\n`\u2200` are actually local constant. Comparing two such goals with `=`\nrather than `=\u2090` or `is_def_eq` tells us that proof script should\nnot see the difference between the two."}, {"name": "tactic.trace_error", "description": " `trace_error msg t` executes the tactic `t`. If `t` fails, traces `msg` and the failure message\nof `t`."}, {"name": "tactic.mk_patterns", "description": "Used to format return strings for the hole commands `match_stub` and `eqn_stub`."}, {"name": "lean.parser.sep_by_trailing", "description": " A version of `lean.parser.sep_by` that allows trailing delimiters, but requires at least one\nitem. Like `lean.parser.sep_by`, as a result of the `lean.parser` monad not being pure, this is only\nwell-behaved if `p` and `s` are backtrackable; which in practice means they must not consume the\ninput when they do not have a match."}, {"name": "tactic.local_defs", "description": " Returns the local definitions from the context. A local definition is a\nlocal constant of the form `e : \u03b1 := t`. The local definitions are returned in\nthe order in which they appear in the context."}, {"name": "tactic.goal.inhabited", "description": ""}, {"name": "tactic.apply_at_aux", "description": " `apply_at_aux e et [] h ht` (with `et` the type of `e` and `ht` the type of `h`)\nfinds a list of expressions `vs` and returns `(e.mk_args (vs ++ [h]), vs)`."}, {"name": "tactic.pformat.mk", "description": "`mk` lifts `fmt : format` to the tactic monad (`pformat`)."}, {"name": "tactic.case_bash", "description": " Calls `cases` on every local hypothesis, succeeding if\nit succeeds on at least one hypothesis."}, {"name": "tactic.elim_gen_prod", "description": " `elim_gen_prod n e _ ns` with `e` an expression of type `psigma _`, applies `cases` on `e` `n`\ntimes and uses `ns` to name the resulting variables. Returns a triple: list of new variables,\nremaining term and unused variable names."}, {"name": "tactic.update_type", "description": "Update the type of a local constant or metavariable. For local constants and\nmetavariables obtained via, for example, `tactic.get_local`, the type stored in\nthe expression is not necessarily the same as the type returned by `infer_type`.\nThis tactic, given a local constant or metavariable, updates the stored type to\nmatch the output of `infer_type`. If the input is not a local constant or\nmetavariable, `update_type` does nothing."}, {"name": "tactic.add_theorem_by", "description": " `add_theorem_by n ls type tac` uses `tac` to synthesize a term with type `type`, and adds this\nto the environment as a theorem with name `n` and universe parameters `ls`."}, {"name": "tactic.subobject_names", "description": " When `struct_n` is the name of a structure type,\n`subobject_names struct_n` returns two lists of names `(instances, fields)`.\nThe names in `instances` are the projections from `struct_n` to the structures that it extends\n(assuming it was defined with `old_structure_cmd false`).\nThe names in `fields` are the standard fields of `struct_n`."}, {"name": "tactic.get_unused_decl_name_aux", "description": "If `{nm}_{n}` doesn't exist in the environment, returns that, otherwise tries `{nm}_{n+1}`"}, {"name": "name.contains_sorry", "description": "`nm.contains_sorry` checks whether `sorry` occurs in the value of the declaration `nm` or\n in any declarations `nm._proof_i` (or to be more precise: any declaration in namespace `nm`).\n See also `expr.contains_sorry`."}, {"name": "tactic.mk_theorem", "description": " `mk_theorem n ls t e` creates a theorem declaration with name `n`, universe parameters named\n`ls`, type `t`, and body `e`."}, {"name": "tactic.eqn_stub", "description": "Invoking hole command \"Equations Stub\" (\"Generate a list of equations for a recursive definition\")\nin the following:\n\n```lean\nmeta def foo : {! expr \u2192 tactic unit !} -- `:=` is omitted\n```\n\nproduces:\n\n```lean\nmeta def foo : expr \u2192 tactic unit\n| (expr.var a) := _\n| (expr.sort a) := _\n| (expr.const a a_1) := _\n| (expr.mvar a a_1 a_2) := _\n| (expr.local_const a a_1 a_2 a_3) := _\n| (expr.app a a_1) := _\n| (expr.lam a a_1 a_2 a_3) := _\n| (expr.pi a a_1 a_2 a_3) := _\n| (expr.elet a a_1 a_2 a_3) := _\n| (expr.macro a a_1) := _\n```\n\nA similar result can be obtained by invoking \"Equations Stub\" on the following:\n\n```lean\nmeta def foo : expr \u2192 tactic unit := -- do not forget to write `:=`!!\n{! !}\n```\n\n```lean\nmeta def foo : expr \u2192 tactic unit := -- don't forget to erase `:=`!!\n| (expr.var a) := _\n| (expr.sort a) := _\n| (expr.const a a_1) := _\n| (expr.mvar a a_1 a_2) := _\n| (expr.local_const a a_1 a_2 a_3) := _\n| (expr.app a a_1) := _\n| (expr.lam a a_1 a_2 a_3) := _\n| (expr.pi a a_1 a_2 a_3) := _\n| (expr.elet a a_1 a_2 a_3) := _\n| (expr.macro a a_1) := _\n```"}, {"name": "tactic.mk_conditional_instance", "description": "Finds an instance of an implication `cond \u2192 tgt`.\nReturns a pair of a local constant `e` of type `cond`, and an instance of `tgt` that can mention\n`e`. The local constant `e` is added as an hypothesis to the tactic state, but should not be used,\nsince it has been \"proven\" by a metavariable."}, {"name": "tactic.lock_tactic_state", "description": " This makes sure that the execution of the tactic does not change the tactic state.\nThis can be helpful while using rewrite, apply, or expr munging.\nRemember to instantiate your metavariables before you're done!"}, {"name": "tactic.var_names", "description": "`var_names e` returns a list of the unique names of the initial pi bindings in `e`."}, {"name": "tactic.decl_mk_const", "description": "Returns a pair `(e, t)`, where `e \u2190 mk_const d.to_name`, and `t = d.type`\nbut with universe params updated to match the fresh universe metavariables in `e`.\n\nThis should have the same effect as just\n```lean\ndo e \u2190 mk_const d.to_name,\n   t \u2190 infer_type e,\n   return (e, t)\n```\nbut is hopefully faster."}, {"name": "tactic_doc.tactic.fsplit", "description": "Just like `split`, `fsplit` applies the constructor when the type of the target is\nan inductive data type with one constructor.\nHowever it does not reorder goals or invoke `auto_param` tactics."}, {"name": "tactic.get_app_args_whnf", "description": "`get_app_args_whnf e md unfold_ginductive` is like `expr.get_app_args e` but `e`\nis normalised as necessary (with transparency `md`). `unfold_ginductive`\ncontrols whether constructors of generalised inductive types are unfolded. The\nreturned expressions are not necessarily in whnf."}, {"name": "tactic.retrieve'", "description": "Runs a tactic for a result, reverting the state after completion or error."}, {"name": "tactic.iterate1", "description": " Apply a tactic as many times as possible, collecting the results in a list.\nFail if the tactic does not succeed at least once."}, {"name": "tactic.retrieve_or_report_error", "description": "Applies tactic `t`. If it succeeds, revert the state, and return the value. If it fails,\n returns the error message."}, {"name": "tactic.apply_under_pis", "description": "Assumes `pi_expr` is of the form `\u03a0 x1 ... xn, _`.\nCreates a pexpr of the form `\u03a0 x1 ... xn, func (arg x1 ... xn)`.\nAll arguments (implicit and explicit) to `arg` should be supplied."}, {"name": "tactic.higher_order_attr", "description": " A user attribute that applies to lemmas of the shape `\u2200 x, f (g x) = h x`.\nIt derives an auxiliary lemma of the form `f \u2218 g = h` for reasoning about higher-order functions."}, {"name": "tactic.list_constructors_hole", "description": "This command lists the constructors that can be used to satisfy the expected type.\n\nInvoking \"List Constructors\" (\"Show the list of constructors of the expected type\")\nin the following hole:\n\n```lean\ndef foo : \u2124 \u2295 \u2115 :=\n{! !}\n```\n\nproduces:\n\n```lean\ndef foo : \u2124 \u2295 \u2115 :=\n{! sum.inl, sum.inr !}\n```\n\nand will display:\n\n```lean\nsum.inl : \u2124 \u2192 \u2124 \u2295 \u2115\n\nsum.inr : \u2115 \u2192 \u2124 \u2295 \u2115\n```"}, {"name": "tactic.get_user_attribute_name", "description": "Given a user attribute name `attr_name`, `get_user_attribute_name attr_name` returns\nthe name of the declaration that defines this attribute.\nFails if there is no user attribute with this name.\nExample: ``get_user_attribute_name `norm_cast`` returns `` `norm_cast.norm_cast_attr``"}, {"name": "tactic.mk_local", "description": " `mk_local n` creates a dummy local variable with name `n`.\nThe type of this local constant is a constant with name `n`, so it is very unlikely to be\na meaningful expression."}, {"name": "tactic.name_to_tactic", "description": "Runs a tactic by name.\nIf it is a `tactic string`, return whatever string it returns.\nIf it is a `tactic unit`, return the name.\n(This is mostly used in invoking \"self-reporting tactics\", e.g. by `tidy` and `hint`.)"}, {"name": "tactic.local_def_value", "description": "`local_def_value e` returns the value of the expression `e`, assuming that `e` has been defined\n locally using a `let` expression. Otherwise it fails."}, {"name": "lean.parser.emit_code_here", "description": " `emit_code_here str` behaves as if the string `str` were placed at the current location in\nsource code."}, {"name": "tactic.use", "description": " Similar to `existsi`, `use l` will use entries in `l` to instantiate existential obligations\nat the beginning of a target. Unlike `existsi`, the pexprs in `l` are elaborated with respect to\nthe expected type.\n\n```lean\nexample : \u2203 x : \u2124, x = x :=\nby tactic.use ``(42)\n```\n\nSee the doc string for `tactic.interactive.use` for more information."}, {"name": "tactic.sorry_if_contains_sorry", "description": "`sorry_if_contains_sorry` will solve any goal already containing `sorry` in its type with `sorry`,\nand fail otherwise."}, {"name": "format.soft_break", "description": " `soft_break` is similar to `line`. Whereas in `group (x ++ line ++ y ++ line ++ z)`\nthe result either fits on one line or in three, `x ++ soft_break ++ y ++ soft_break ++ z`\neach line break is decided independently"}, {"name": "expr.of_int", "description": " Given an expr `\u03b1` representing a type with numeral structure,\n`of_int \u03b1 n` creates the `\u03b1`-valued numeral expression corresponding to `n`.\nThe output is either a numeral or the negation of a numeral."}, {"name": "tactic.pformat", "description": "A type alias for `tactic format`, standing for \"pretty print format\"."}, {"name": "tactic.context_upto_hyp_has_local_def", "description": "`context_upto_hyp_has_local_def h` is true iff any of the hypotheses in the\ncontext up to and including `h` is a local definition."}, {"name": "tactic.find_local", "description": "`find_local t` returns a local constant with type t, or fails if none exists."}, {"name": "tactic.is_instance", "description": "Checks whether the name is an instance."}, {"name": "tactic.interactive_attr", "description": "Copies a definition into the `tactic.interactive` namespace to make it usable\nin proof scripts. It allows one to write\n\n```lean\n@[interactive]\nmeta def my_tactic := ...\n```\n\ninstead of\n\n```lean\nmeta def my_tactic := ...\n\nrun_cmd add_interactive [``my_tactic]\n```"}, {"name": "tactic.intron_no_renames", "description": "`intron_no_renames n` calls `intro` `n` times, using the pretty-printing name\nprovided by the binder to name the new local constant.\nUnlike `intron`, it does not rename introduced constants if the names shadow existing constants."}, {"name": "tactic.apply_any", "description": "`apply_any lemmas` tries to apply one of the list `lemmas` to the current goal.\n\n`apply_any lemmas opt` allows control over how lemmas are applied.\n`opt` has fields:\n* `use_symmetry`: if no lemma applies, call `symmetry` and try again. (Defaults to `tt`.)\n* `use_exfalso`: if no lemma applies, call `exfalso` and try again. (Defaults to `tt`.)\n* `apply`: use a tactic other than `tactic.apply` (e.g. `tactic.fapply` or `tactic.eapply`).\n\n`apply_any lemmas tac` calls the tactic `tac` after a successful application.\nDefaults to `skip`. This is used, for example, by `solve_by_elim` to arrange\nrecursive invocations of `apply_any`."}, {"name": "tactic.pformat_macro", "description": " See `format!` in `init/meta/interactive_base.lean`.\n\nThe main differences are that `pp` is called instead of `to_fmt` and that we can use\narguments of type `tactic \u03b1` in the quotations.\n\nNow, consider the following:\n```lean\ne \u2190 to_expr ``(3 + 7),\ntrace format!\"{e}\"  -- outputs `has_add.add.{0} nat nat.has_add\n                    -- (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)) ...`\ntrace pformat!\"{e}\" -- outputs `3 + 7`\n```\n\nThe difference is significant. And now, the following is expressible:\n\n```lean\ne \u2190 to_expr ``(3 + 7),\ntrace pformat!\"{e} : {infer_type e}\" -- outputs `3 + 7 : \u2115`\n```\n\nSee also: `trace!` and `fail!`"}, {"name": "tactic.trace_state_if_enabled", "description": "``trace_state_if_enabled `n msg`` prints the tactic state,\npreceded by the optional string `msg`,\nonly if tracing is enabled for the name `n`."}, {"name": "tactic.iterate_at_most_on_subgoals", "description": " `iterate_at_most_on_subgoals n t`: repeat the tactic `t` at most `n` times on the first\ngoal and on all subgoals thus produced, or until it fails. Fails iff `t` fails on\ncurrent goal."}, {"name": "tactic.no_mvars_in_target", "description": "Fail if the target contains a metavariable."}, {"name": "tactic.iff_mpr", "description": " Given an expression whose type is (a possibly iterated function producing) an `iff`,\ncreate the expression which is the reverse implication."}, {"name": "tactic.retrieve", "description": "Runs a tactic for a result, reverting the state after completion."}, {"name": "tactic.get_app_fn_whnf", "description": "`get_app_fn_whnf e md unfold_ginductive` is like `expr.get_app_fn e` but `e` is\nnormalised as necessary (with transparency `md`). `unfold_ginductive` controls\nwhether constructors of generalised inductive types are unfolded. The returned\nexpression is in whnf."}, {"name": "tactic.iff_mpr_core", "description": " `iff_mpr_core e ty` assumes that `ty` is the type of `e`.\nIf `ty` has the shape `\u03a0 ..., A \u2194 B`, returns an expression whose type is `\u03a0 ..., B \u2192 A`."}, {"name": "tactic.proof_state.inhabited", "description": ""}, {"name": "tactic.instantiate_mvars_in_goals", "description": "Instantiates metavariables in all goals."}, {"name": "tactic.fsplit", "description": "Just like `split`, `fsplit` applies the constructor when the type of the target is\nan inductive data type with one constructor.\nHowever it does not reorder goals or invoke `auto_param` tactics."}, {"name": "tactic.get_proof_state_after", "description": "Run `tac` in a disposable proof state and return the state.\nSee `proof_state`, `goal` and `get_proof_state`."}, {"name": "tactic.get_univ_level", "description": "`get_univ_level t` returns the universe level of a type `t`"}, {"name": "tactic.transparency.decidable_eq", "description": ""}, {"name": "tactic.subsingleton_goal", "description": "Succeeds only if we can construct an instance showing the\n current goal is a subsingleton type."}, {"name": "pos.has_lt", "description": ""}, {"name": "tactic.lambdas", "description": " `lambdas loc_consts f` is used to create a lambda expression whose body is `f`.\n`loc_consts` should be a list of local constants. The function will abstract these local\nconstants from `f` and bind them with lambda binders.\n\nFor example, if `a, b` are local constants with types `Ta, Tb`,\n``lambdas [a, b] `(f a b)`` will return the expression\n`\u03bb (a : Ta) (b : Tb), f a b`."}, {"name": "tactic.list_binary_operands", "description": "  Given an expression `f` (likely a binary operation) and a further expression `x`, calling\n`list_binary_operands f x` breaks `x` apart into successions of applications of `f` until this can\nno longer be done and returns a list of the leaves of the process.\n\nThis matches `f` up to semireducible unification. In particular, it will match applications of the\nsame polymorphic function with different type-class arguments.\n\nE.g., if `i1` and `i2` are both instances of `has_add T` and\n`e := has_add.add T i1 x (has_add.add T i2 y z)`, then ``list_binary_operands `((+) : T \u2192 T \u2192 T) e``\nreturns `[x, y, z]`.\n\nFor example:\n```lean\n#eval list_binary_operands `(@has_add.add \u2115 _) `(3 + (4 * 5 + 6) + 7 / 3) >>= tactic.trace\n-- [3, 4 * 5, 6, 7 / 3]\n#eval list_binary_operands `(@list.append \u2115) `([1, 2] ++ [3, 4] ++ (1 :: [])) >>= tactic.trace\n-- [[1, 2], [3, 4], [1]]\n```"}, {"name": "tactic_doc.attribute.interactive", "description": "Copies a definition into the `tactic.interactive` namespace to make it usable\nin proof scripts. It allows one to write\n\n```lean\n@[interactive]\nmeta def my_tactic := ...\n```\n\ninstead of\n\n```lean\nmeta def my_tactic := ...\n\nrun_cmd add_interactive [``my_tactic]\n```"}, {"name": "tactic.simp_bottom_up'", "description": " A variant of `simplify_bottom_up`. Given a tactic `post` for rewriting subexpressions,\n`simp_bottom_up post e` tries to rewrite `e` starting at the leaf nodes. Returns the resulting\nexpression and a proof of equality."}, {"name": "tactic.match_stub", "description": "Hole command used to generate a `match` expression.\n\nIn the following:\n\n```lean\nmeta def foo (e : expr) : tactic unit :=\n{! e !}\n```\n\ninvoking hole command \"Match Stub\" (\"Generate a list of equations for a `match` expression\")\nproduces:\n\n```lean\nmeta def foo (e : expr) : tactic unit :=\nmatch e with\n| (expr.var a) := _\n| (expr.sort a) := _\n| (expr.const a a_1) := _\n| (expr.mvar a a_1 a_2) := _\n| (expr.local_const a a_1 a_2 a_3) := _\n| (expr.app a a_1) := _\n| (expr.lam a a_1 a_2 a_3) := _\n| (expr.pi a a_1 a_2 a_3) := _\n| (expr.elet a a_1 a_2 a_3) := _\n| (expr.macro a a_1) := _\nend\n```"}, {"name": "tactic.resolve_attribute_expr_list", "description": "Given the name of a user attribute, produces a list of `tactic expr`s, each of which is the\napplication of `i_to_expr_for_apply` to a declaration with that attribute."}, {"name": "tactic.with_local_goals'", "description": "like `with_local_goals` but discards the resulting goals"}, {"name": "tactic.on_exception", "description": "`on_exception handler tac` runs `tac` first, and then runs `handler` only if `tac` failed."}, {"name": "tactic.iterate_at_most_on_all_goals", "description": " `iterate_at_most_on_all_goals n t`: repeat the given tactic at most `n` times on all goals,\nor until it fails. Always succeeds."}, {"name": "is_lawful_applicative.map_comp_pure", "description": ""}, {"name": "tactic.get_project_dir", "description": "A hackish way to get the `src` directory of any project.\n Requires as argument any declaration name `n` in that project, and `k`, the number of characters\n in the path of the file where `n` is declared not part of the `src` directory.\n Example: For `mathlib_dir_locator` this is the length of `tactic/project_dir.lean`, so `23`.\n Note: does not work in the file where `n` is declared."}, {"name": "tactic.instantiate_mvars_in_target", "description": "Instantiates metavariables that appear in the current goal."}, {"name": "tactic.apply_rules", "description": "`apply_rules args attrs n`: apply the lists of rules `args` (given as pexprs) and `attrs` (given\nas names of attributes) and `the tactic assumption` on the first goal and the resulting subgoals,\niteratively, at most `n` times.\n\nUnlike `solve_by_elim`, `apply_rules` does not do any backtracking, and just greedily applies\na lemma from the list until it can't."}, {"name": "tactic_doc.command.setup_tactic_parser", "description": " `setup_tactic_parser` is a user command that opens the namespaces used in writing\ninteractive tactics, and declares the local postfix notation `?` for `optional` and `*` for `many`.\nIt does *not* use the `namespace` command, so it will typically be used after\n`namespace tactic.interactive`."}, {"name": "tactic.trans_conv", "description": " Transitivity conversion: given two conversions (which take an\nexpression `e` and returns `(e', \u22a2 e = e')`), produces another\nconversion that combines them with transitivity, treating failures\nas reflexivity conversions."}, {"name": "tactic.iff_mp", "description": " Given an expression whose type is (a possibly iterated function producing) an `iff`,\ncreate the expression which is the forward implication."}, {"name": "expr.kreplace", "description": " `kreplace e old new` replaces all occurrences of the expression `old` in `e`\nwith `new`. The occurrences of `old` in `e` are determined using keyed matching\nwith transparency `md`; see `kabstract` for details. If `unify` is true,\nwe may assign metavariables in `e` as we match subterms of `e` against `old`."}, {"name": "tactic.get_pexpr_arg_arity_with_tgt", "description": "If `func` is a `pexpr` representing a function that takes an argument `a`,\n`get_pexpr_arg_arity_with_tgt func tgt` returns the arity of `a`.\nWhen `tgt` is a `pi` expr, `func` is elaborated in a context\nwith the domain of `tgt`.\n\nExamples:\n* ```get_pexpr_arg_arity ``(ring) `(true)``` returns 0, since `ring` takes one non-function\n  argument.\n* ```get_pexpr_arg_arity_with_tgt ``(monad) `(true)``` returns 1, since `monad` takes one argument\n  of type `\u03b1 \u2192 \u03b1`.\n* ```get_pexpr_arg_arity_with_tgt ``(module R) `(\u03a0 (R : Type), comm_ring R \u2192 true)``` returns 0"}, {"name": "tactic.generalize'", "description": " `generalize' e n` generalizes the target with respect to `e`. It creates a new local constant\nwith name `n` of the same type as `e` and replaces all occurrences of `e` by `n`.\n\n`generalize'` is similar to `generalize` but also succeeds when `e` does not occur in the\ngoal, in which case it just calls `assert`.\nIn contrast to `generalize` it already introduces the generalized variable."}, {"name": "tactic.mk_protected", "description": "Protect the declaration `n`"}, {"name": "tactic.get_app_fn_const_whnf", "description": "`get_app_fn_const_whnf e md unfold_ginductive` expects that `e = C x\u2081 ... x\u2099`,\nwhere `C` is a constant, after normalisation with transparency `md`. If so, the\nname of `C` is returned. Otherwise the tactic fails. `unfold_ginductive`\ncontrols whether constructors of generalised inductive types are unfolded."}, {"name": "tactic.setup_tactic_parser_cmd", "description": " `setup_tactic_parser` is a user command that opens the namespaces used in writing\ninteractive tactics, and declares the local postfix notation `?` for `optional` and `*` for `many`.\nIt does *not* use the `namespace` command, so it will typically be used after\n`namespace tactic.interactive`."}, {"name": "tactic.pformat.has_to_tactic_format", "description": ""}, {"name": "tactic.get_mathlib_dir", "description": "A hackish way to get the `src` directory of mathlib."}, {"name": "tactic.apply_any_opt", "description": "Configuration options for `apply_any`:\n* `use_symmetry`: if `apply_any` fails to apply any lemma, call `symmetry` and try again.\n* `use_exfalso`: if `apply_any` fails to apply any lemma, call `exfalso` and try again.\n* `apply`: specify an alternative to `tactic.apply`; usually `apply := tactic.eapply`."}, {"name": "tactic.apply_any_opt.to_apply_cfg", "description": "Configuration options for `apply_any`:\n* `use_symmetry`: if `apply_any` fails to apply any lemma, call `symmetry` and try again.\n* `use_exfalso`: if `apply_any` fails to apply any lemma, call `exfalso` and try again.\n* `apply`: specify an alternative to `tactic.apply`; usually `apply := tactic.eapply`."}, {"name": "tactic.apply_any_opt.use_symmetry", "description": "Configuration options for `apply_any`:\n* `use_symmetry`: if `apply_any` fails to apply any lemma, call `symmetry` and try again.\n* `use_exfalso`: if `apply_any` fails to apply any lemma, call `exfalso` and try again.\n* `apply`: specify an alternative to `tactic.apply`; usually `apply := tactic.eapply`."}, {"name": "tactic.apply_any_opt.use_exfalso", "description": "Configuration options for `apply_any`:\n* `use_symmetry`: if `apply_any` fails to apply any lemma, call `symmetry` and try again.\n* `use_exfalso`: if `apply_any` fails to apply any lemma, call `exfalso` and try again.\n* `apply`: specify an alternative to `tactic.apply`; usually `apply := tactic.eapply`."}, {"name": "tactic.replace_univ_metas_with_univ_params", "description": "Replace every universe metavariable in an expression with a universe parameter.\n\n(This is useful when making new declarations.)"}, {"name": "tactic.apply_any_thunk", "description": "This is a version of `apply_any` that takes a list of `tactic expr`s instead of `expr`s,\nand evaluates these as thunks before trying to apply them.\n\nWe need to do this to avoid metavariables getting stuck during subsequent rounds of `apply`."}, {"name": "tactic.local_decls", "description": " `local_decls` returns a dictionary mapping names to their corresponding declarations.\nCovers all declarations from the current file."}, {"name": "tactic_doc.attribute.higher_order", "description": " A user attribute that applies to lemmas of the shape `\u2200 x, f (g x) = h x`.\nIt derives an auxiliary lemma of the form `f \u2218 g = h` for reasoning about higher-order functions."}, {"name": "lean.parser.synthesize_tactic_state_with_variables_as_hyps", "description": " From the `lean.parser` monad, synthesize a `tactic_state` which includes all of the local\nvariables referenced in `es : list pexpr`, and those variables which have been `include`ed in the\nlocal context---precisely those variables which would be ambiently accessible if we were in a\ntactic-mode block where the goals had types `es.mmap to_expr`, for example.\n\nReturns a new `ts : tactic_state` with these local variables added, and\n`mappings : list (expr \u00d7 expr)`, for which pairs `(var, hyp)` correspond to an existing variable\n`var` and the local hypothesis `hyp` which was added to the tactic state `ts` as a result."}, {"name": "tactic.instance_cache.of_int", "description": " `c.of_int n` creates the `c.\u03b1`-valued numeral expression corresponding to `n`.\nThe output is either a numeral or the negation of a numeral."}, {"name": "format.intercalate", "description": " `intercalate x [a, b, c]` produces the format object `a.x.b.x.c`,\nwhere `.` represents `format.join`."}, {"name": "tactic.pformat.has_append", "description": ""}, {"name": "tactic.interactive.fsplit", "description": "Just like `split`, `fsplit` applies the constructor when the type of the target is\nan inductive data type with one constructor.\nHowever it does not reorder goals or invoke `auto_param` tactics."}, {"name": "tactic.injections_and_clear", "description": " Calls `injection` on each hypothesis, and then, for each hypothesis on which `injection`\nsucceeds, clears the old hypothesis."}, {"name": "tactic.context_has_local_def", "description": "`context_has_local_def` is true iff there is at least one local definition in\nthe context."}, {"name": "tactic.to_pfmt", "description": "an alias for `pp`."}, {"name": "tactic.under_binders", "description": "Run a tactic \"under binders\", by running `intros` before, and `revert` afterwards."}, {"name": "tactic_doc.hole_command.Match Stub", "description": "Hole command used to generate a `match` expression.\n\nIn the following:\n\n```lean\nmeta def foo (e : expr) : tactic unit :=\n{! e !}\n```\n\ninvoking hole command \"Match Stub\" (\"Generate a list of equations for a `match` expression\")\nproduces:\n\n```lean\nmeta def foo (e : expr) : tactic unit :=\nmatch e with\n| (expr.var a) := _\n| (expr.sort a) := _\n| (expr.const a a_1) := _\n| (expr.mvar a a_1 a_2) := _\n| (expr.local_const a a_1 a_2 a_3) := _\n| (expr.app a a_1) := _\n| (expr.lam a a_1 a_2 a_3) := _\n| (expr.pi a a_1 a_2 a_3) := _\n| (expr.elet a a_1 a_2 a_3) := _\n| (expr.macro a a_1) := _\nend\n```"}, {"name": "tactic.find_private_decl", "description": " `find_private_decl n none` finds a private declaration named `n` in any of the imported files.\n\n`find_private_decl n (some m)` finds a private declaration named `n` in the same file where a\ndeclaration named `m` can be found."}, {"name": "tactic.try_all", "description": "Try all the tactics in a list, each time starting at the original `tactic_state`,\nreturning the list of successful results,\nand reverting to the original `tactic_state`."}, {"name": "interaction_monad.set_state", "description": "`set_state` sets the underlying state inside an interaction monad, from within that monad."}, {"name": "list.find_defeq", "description": "`find_defeq red m e` looks for a key in `m` that is defeq to `e` (up to transparency `red`),\nand returns the value associated with this key if it exists.\nOtherwise, it fails."}, {"name": "tactic.resolve_name'", "description": " Like `resolve_name` except when the list of goals is\nempty. In that situation `resolve_name` fails whereas\n`resolve_name'` simply proceeds on a dummy goal"}, {"name": "interaction_monad.get_state", "description": "`get_state` returns the underlying state inside an interaction monad, from within that monad."}, {"name": "tactic.with_local_goals", "description": " `with_local_goals gs tac` runs `tac` on the goals `gs` and then restores the\ninitial goals and returns the goals `tac` ended on."}, {"name": "tactic.intros1", "description": " Introduces one or more variables and returns the new local constants.\nFails if `intro` cannot be applied."}, {"name": "tactic.revert_after", "description": "`revert_after e` reverts all local constants after local constant `e`."}, {"name": "tactic.exact_dec_trivial", "description": "Attempts to close the goal with `dec_trivial`."}, {"name": "tactic.decorate_error", "description": "`decorate_error add_msg tac` prepends `add_msg` to an exception produced by `tac`"}, {"name": "tactic.mk_instance_cache", "description": "Creates an `instance_cache` for the type `\u03b1`."}, {"name": "tactic.try_or_report_error", "description": "Applies tactic `t`. If it succeeds, return the value. If it fails, returns the error message."}, {"name": "tactic.clear_aux_decl_aux", "description": " `clear_aux_decl_aux l` clears all expressions in `l` that represent aux decls from the\nlocal context."}, {"name": "tactic.get_classes", "description": "Return a list of all type classes which can be instantiated\nfor the given expression."}, {"name": "tactic.import_private_cmd", "description": " `import_private foo from bar` finds a private declaration `foo` in the same file as `bar`\nand creates a local notation to refer to it.\n\n`import_private foo` looks for `foo` in all imported files.\n\nWhen possible, make `foo` non-private rather than using this feature."}, {"name": "tactic.expanded_field_list", "description": " `expanded_field_list struct_n` produces a list of the names of the fields of the structure\nnamed `struct_n`. These are returned as pairs of names `(prefix, name)`, where the full name\nof the projection is `prefix.name`.\n\n`struct_n` cannot be a synonym for a `structure`, it must be itself a `structure`"}, {"name": "tactic.metavariables", "description": " Returns a list of all metavariables in the current partial proof. This can differ from\nthe list of goals, since the goals can be manually edited."}, {"name": "tactic.success_if_fail_with_msg", "description": "This combinator is for testing purposes. It succeeds if `t` fails with message `msg`,\nand fails otherwise."}, {"name": "tactic.triv'", "description": " `triv'` tries to close the first goal with the proof `trivial : true`. Unlike `triv`,\nit only unfolds reducible definitions, so it sometimes fails faster."}, {"name": "tactic.finally", "description": " `finally tac finalizer` runs `tac` first, then runs `finalizer` even if\n`tac` fails. `finally tac finalizer` fails if either `tac` or `finalizer` fails."}, {"name": "expr.of_nat", "description": " Given an expr `\u03b1` representing a type with numeral structure,\n`of_nat \u03b1 n` creates the `\u03b1`-valued numeral expression corresponding to `n`."}, {"name": "tactic.fail_macro", "description": "The combination of `pformat` and `fail`."}, {"name": "tactic.partition_local_deps", "description": " `partition_local_deps vs`, with `vs` a list of local constants,\nreorders `vs` in the order they appear in the local context together\nwith the variables that follow them. If local context is `[a,b,c,d,e,f]`,\nand that we call `partition_local_deps [d,b]`, we get `[[d,e,f], [b,c]]`.\nThe head of each list is one of the variables given as a parameter."}, {"name": "lean.parser.emit_code_here_aux", "description": "Inner recursion for `emit_code_here`."}, {"name": "tactic.proof_state", "description": " proof state made of multiple `goal` meant for comparing\nthe result of running different tactics"}, {"name": "tactic.transparency.has_reflect", "description": ""}, {"name": "tactic.apply_at", "description": "`apply_at e h` applies implication `e` on hypothesis `h` and replaces `h` with the result."}, {"name": "lean.parser.get_current_namespace", "description": " `get_current_namespace` returns the current namespace (it could be `name.anonymous`).\n\nThis function deserves a C++ implementation in core lean, and will fail if it is not called from\nthe body of a command (i.e. anywhere else that the `lean.parser` monad can be invoked)."}, {"name": "tactic.revert_target_deps", "description": "`revert_target_deps` reverts all local constants on which the target depends (recursively).\n Returns the number of local constants that have been reverted."}, {"name": "tactic.note_anon", "description": "`note_anon t v`, given a proof `v : t`,\nadds `h : t` to the current context, where the name `h` is fresh.\n\n`note_anon none v` will infer the type `t` from `v`."}, {"name": "tactic.get_expl_pi_arity", "description": "Compute the arity of explicit arguments of `type`."}, {"name": "tactic.is_simp_lemma", "description": "Checks whether the name is a simp lemma"}, {"name": "vector.nth_update_nth_eq_if", "description": ""}, {"name": "vector.flip.is_lawful_traversable", "description": ""}, {"name": "vector.sum_update_nth'", "description": ""}, {"name": "vector.mk_to_list", "description": ""}, {"name": "vector.nth_map", "description": ""}, {"name": "vector.to_array", "description": "Cast a vector to an array."}, {"name": "vector.comp_traverse", "description": ""}, {"name": "vector.remove_nth_val", "description": ""}, {"name": "vector.ext", "description": "Two `v w : vector \u03b1 n` are equal iff they are equal at every single index."}, {"name": "vector.reflect", "description": ""}, {"name": "vector.insert_nth", "description": " `v.insert_nth a i` inserts `a` into the vector `v` at position `i`\n(and shifting later components to the right)."}, {"name": "vector.head'_to_list", "description": ""}, {"name": "vector.nth_eq_nth_le", "description": ""}, {"name": "vector.length_coe", "description": ""}, {"name": "vector.nth_update_nth_same", "description": ""}, {"name": "vector.scanl_nil", "description": "Providing an empty vector to `scanl` gives the starting value `b : \u03b2`."}, {"name": "vector.head_map", "description": ""}, {"name": "vector.zero_subsingleton", "description": "The empty `vector` is a `subsingleton`."}, {"name": "vector.to_list_update_nth", "description": ""}, {"name": "vector.tail_map", "description": ""}, {"name": "vector.induction_on\u2082", "description": "Define `C v w` by induction on a pair of vectors `v : vector \u03b1 n` and `w : vector \u03b2 n`."}, {"name": "vector.nth_tail_succ", "description": ""}, {"name": "vector.cons_val", "description": ""}, {"name": "vector.to_list_of_fn", "description": ""}, {"name": "vector.insert_nth_val", "description": ""}, {"name": "vector.prod_update_nth", "description": ""}, {"name": "vector.nodup_iff_nth_inj", "description": ""}, {"name": "vector.cons_tail", "description": ""}, {"name": "vector.tail_of_fn", "description": ""}, {"name": "vector.to_list_scanl", "description": "The `to_list` of a `vector` after a `scanl` is the `list.scanl`\nof the `to_list` of the original `vector`."}, {"name": "vector.scanl_val", "description": "The underlying `list` of a `vector` after a `scanl` is the `list.scanl`\nof the underlying `list` of the original `vector`."}, {"name": "vector.ne_cons_iff", "description": ""}, {"name": "vector.induction_on\u2083", "description": " Define `C u v w` by induction on a triplet of vectors\n`u : vector \u03b1 n`, `v : vector \u03b2 n`, and `w : vector \u03b3 b`."}, {"name": "vector.scanl_singleton", "description": "The recursive step of `scanl` splits a vector made up of a single element\n`x ::\u1d65 nil : vector \u03b1 1` into a `vector` of the provided starting value `b : \u03b2`\nand the mapped `f b x : \u03b2` as the last value."}, {"name": "vector.last", "description": "The last element of a `vector`, given that the vector is at least one element."}, {"name": "vector.reverse_reverse", "description": ""}, {"name": "vector.insert_nth_comm", "description": ""}, {"name": "vector.m_of_fn_pure", "description": ""}, {"name": "vector.cons_head", "description": ""}, {"name": "vector.naturality", "description": ""}, {"name": "vector.to_list_reverse", "description": " The `list` of a vector after a `reverse`, retrieved by `to_list` is equal\nto the `list.reverse` after retrieving a vector's `to_list`."}, {"name": "vector.remove_nth_insert_nth", "description": ""}, {"name": "vector.tail_val", "description": ""}, {"name": "vector.m_of_fn", "description": " Monadic analog of `vector.of_fn`.\nGiven a monadic function on `fin n`, return a `vector \u03b1 n` inside the monad."}, {"name": "vector.nth_cons_succ", "description": ""}, {"name": "vector.to_list_singleton", "description": " The list that makes up a `vector` made up of a single element,\nretrieved via `to_list`, is equal to the list of that single element."}, {"name": "vector.sum_update_nth", "description": ""}, {"name": "vector.of_fn_nth", "description": ""}, {"name": "vector.remove_nth_insert_nth'", "description": ""}, {"name": "vector.to_list_map", "description": ""}, {"name": "vector.scanl_cons", "description": "The recursive step of `scanl` splits a vector `x ::\u1d65 v : vector \u03b1 (n + 1)`\ninto the provided starting value `b : \u03b2` and the recursed `scanl`\n`f b x : \u03b2` as the starting value.\n\nThis lemma is the `cons` version of `scanl_nth`."}, {"name": "vector.eq_cons_iff", "description": ""}, {"name": "vector.id_traverse", "description": ""}, {"name": "vector.nth_update_nth_of_ne", "description": ""}, {"name": "vector.nth_of_fn", "description": ""}, {"name": "vector.to_list_injective", "description": ""}, {"name": "vector.nth_cons_zero", "description": ""}, {"name": "vector.update_nth", "description": "`update_nth v n a` replaces the `n`th element of `v` with `a`"}, {"name": "vector.prod_update_nth'", "description": ""}, {"name": "vector.scanl", "description": "Construct a `vector \u03b2 (n + 1)` from a `vector \u03b1 n` by scanning `f : \u03b2 \u2192 \u03b1 \u2192 \u03b2`\nfrom the \"left\", that is, from 0 to `fin.last n`, using `b : \u03b2` as the starting value."}, {"name": "vector.mmap_cons", "description": ""}, {"name": "vector.nth_zero", "description": ""}, {"name": "vector.inhabited", "description": ""}, {"name": "vector.traverse", "description": "Apply an applicative function to each component of a vector."}, {"name": "vector.head_of_fn", "description": ""}, {"name": "vector.nth_repeat", "description": ""}, {"name": "vector.last_def", "description": "The last element of a `vector`, given that the vector is at least one element."}, {"name": "equiv.vector_equiv_fin", "description": "The natural equivalence between length-`n` vectors and functions from `fin n`."}, {"name": "vector.mmap", "description": " Apply a monadic function to each component of a vector,\nreturning a vector inside the monad."}, {"name": "vector.nth_cons_nil", "description": " Accessing the `nth` element of a vector made up\nof one element `x : \u03b1` is `x` itself."}, {"name": "vector.flip.traversable", "description": ""}, {"name": "vector.scanl_nth", "description": "For an index `i : fin n`, the `nth` element of `scanl` of a\nvector `v : vector \u03b1 n` at `i.succ`, is equal to the application\nfunction `f : \u03b2 \u2192 \u03b1 \u2192 \u03b2` of the `i.cast_succ` element of\n`scanl f b v` and `nth v i`.\n\nThis lemma is the `nth` version of `scanl_cons`."}, {"name": "vector.singleton_tail", "description": "The `tail` of a vector made up of one element is `nil`."}, {"name": "vector.reverse_nth_zero", "description": "The `last` element of a vector is the `head` of the `reverse` vector."}, {"name": "vector.reverse", "description": "Reverse a vector."}, {"name": "vector.tail_nil", "description": "The `tail` of a `nil` vector is `nil`."}, {"name": "vector.mmap_nil", "description": ""}, {"name": "vector.traverse_def", "description": ""}, {"name": "vector.nth_tail", "description": ""}, {"name": "vector.map_id", "description": "Mapping under `id` does not change a vector."}, {"name": "vector.traverse_eq_map_id", "description": ""}, {"name": "vector.induction_on", "description": " Define `C v` by induction on `v : vector \u03b1 n`.\n\nThis function has two arguments: `h_nil` handles the base case on `C nil`,\nand `h_cons` defines the inductive step using `\u2200 x : \u03b1, C w \u2192 C (x ::\u1d65 w)`.\n\nThis can be used as `induction v using vector.induction_on`."}, {"name": "vector.exists_eq_cons", "description": ""}, {"name": "vector.scanl_head", "description": "The first element of `scanl` of a vector `v : vector \u03b1 n`,\nretrieved via `head`, is the starting value `b : \u03b2`."}, {"name": "has_lt.lt.of_dual", "description": "**Alias** of the reverse direction of `order_dual.of_dual_lt_of_dual`."}, {"name": "lex", "description": "A type synonym to equip a type with its lexicographic order."}, {"name": "order_dual.of_dual_to_dual", "description": ""}, {"name": "order_dual.of_dual", "description": "`of_dual` is the identity function from the `order_dual` of a linear order."}, {"name": "order_dual.exists", "description": ""}, {"name": "of_lex_inj", "description": ""}, {"name": "has_le.le.of_dual", "description": "**Alias** of the reverse direction of `order_dual.of_dual_le_of_dual`."}, {"name": "order_dual.nontrivial", "description": ""}, {"name": "order_dual.of_dual_inj", "description": ""}, {"name": "order_dual.to_dual", "description": "`to_dual` is the identity function to the `order_dual` of a linear order."}, {"name": "order_dual.to_dual_le", "description": ""}, {"name": "order_dual.forall", "description": ""}, {"name": "order_dual.to_dual_le_to_dual", "description": ""}, {"name": "to_lex_symm_eq", "description": ""}, {"name": "to_lex", "description": "`to_lex` is the identity function to the `lex` of a type."}, {"name": "to_lex_of_lex", "description": ""}, {"name": "order_dual.le_to_dual", "description": ""}, {"name": "to_lex_inj", "description": ""}, {"name": "order_dual.to_dual_inj", "description": ""}, {"name": "order_dual.of_dual_lt_of_dual", "description": ""}, {"name": "of_lex_to_lex", "description": ""}, {"name": "order_dual.lt_to_dual", "description": ""}, {"name": "of_lex", "description": "`of_lex` is the identity function from the `lex` of a type."}, {"name": "order_dual.to_dual_lt", "description": ""}, {"name": "lex.rec", "description": "A recursor for `lex`. Use as `induction x using lex.rec`."}, {"name": "order_dual.rec", "description": "Recursor for `\u03b1\u1d52\u1d48`."}, {"name": "has_le.le.dual", "description": "**Alias** of the reverse direction of `order_dual.to_dual_le_to_dual`."}, {"name": "order_dual.to_dual_of_dual", "description": ""}, {"name": "order_dual.to_dual_lt_to_dual", "description": ""}, {"name": "order_dual.to_dual_symm_eq", "description": ""}, {"name": "order_dual.of_dual_symm_eq", "description": ""}, {"name": "order_dual.of_dual_le_of_dual", "description": ""}, {"name": "has_lt.lt.dual", "description": "**Alias** of the reverse direction of `order_dual.to_dual_lt_to_dual`."}, {"name": "of_lex_symm_eq", "description": ""}, {"name": "function.right_id", "description": ""}, {"name": "function.uncurry_curry", "description": ""}, {"name": "function.comp.assoc", "description": ""}, {"name": "function.left_inverse.injective", "description": ""}, {"name": "function.has_left_inverse.injective", "description": ""}, {"name": "function.surjective", "description": " A function `f : \u03b1 \u2192 \u03b2` is called surjective if every `b : \u03b2` is equal to `f a`\nfor some `a : \u03b1`."}, {"name": "function.on_fun", "description": " Given functions `f : \u03b2 \u2192 \u03b2 \u2192 \u03c6` and `g : \u03b1 \u2192 \u03b2`, produce a function `\u03b1 \u2192 \u03b1 \u2192 \u03c6` that evaluates\n`g` on each argument, then applies `f` to the results. Can be used, e.g., to transfer a relation\nfrom `\u03b2` to `\u03b1`."}, {"name": "function.right_inverse.surjective", "description": ""}, {"name": "function.bijective", "description": "A function is called bijective if it is both injective and surjective."}, {"name": "function.injective", "description": "A function `f : \u03b1 \u2192 \u03b2` is called injective if `f x = f y` implies `x = y`."}, {"name": "function.has_right_inverse", "description": "`has_right_inverse f` means that `f` has an unspecified right inverse."}, {"name": "function.curry_uncurry", "description": ""}, {"name": "function.combine", "description": ""}, {"name": "function.comp", "description": "Composition of functions: `(f \u2218 g) x = f (g x)`."}, {"name": "function.dcomp", "description": " Composition of dependent functions: `(f \u2218' g) x = f (g x)`, where type of `g x` depends on `x`\nand type of `f (g x)` depends on `x` and `g x`."}, {"name": "function.surjective.comp", "description": ""}, {"name": "function.comp_right", "description": ""}, {"name": "function.comp_app", "description": ""}, {"name": "function.comp.right_id", "description": ""}, {"name": "function.left_inverse_of_surjective_of_right_inverse", "description": ""}, {"name": "function.comp_left", "description": ""}, {"name": "function.injective.comp", "description": ""}, {"name": "function.has_right_inverse.surjective", "description": ""}, {"name": "function.uncurry", "description": "Interpret a function with two arguments as a function on `\u03b1 \u00d7 \u03b2`"}, {"name": "function.surjective_id", "description": ""}, {"name": "function.comp_const_right", "description": ""}, {"name": "function.swap", "description": ""}, {"name": "function.comp.left_id", "description": ""}, {"name": "function.right_inverse", "description": "`right_inverse g f` means that g is a right inverse to f. That is, `f \u2218 g = id`."}, {"name": "function.const", "description": "Constant `\u03bb _, a`."}, {"name": "function.bijective_id", "description": ""}, {"name": "function.app", "description": ""}, {"name": "function.injective_id", "description": ""}, {"name": "function.right_inverse.id", "description": ""}, {"name": "function.curry", "description": "Interpret a function on `\u03b1 \u00d7 \u03b2` as a function with two arguments."}, {"name": "function.right_inverse_of_injective_of_left_inverse", "description": ""}, {"name": "function.left_id", "description": ""}, {"name": "function.bijective.comp", "description": ""}, {"name": "function.left_inverse", "description": "`left_inverse g f` means that g is a left inverse to f. That is, `g \u2218 f = id`."}, {"name": "function.left_inverse.id", "description": ""}, {"name": "function.has_left_inverse", "description": "`has_left_inverse f` means that `f` has an unspecified left inverse."}, {"name": "tactic.tautology", "description": ""}, {"name": "tactic.symm_eq", "description": "Given hypotheses `a` and `b`, build a proof that `a` is equivalent to `b`,\napplying congruence and recursing into arguments if `a` and `b`\nare applications of function symbols."}, {"name": "tactic.root", "description": "Retrieve the root of the hypothesis `e` from the proof forest.\nIf `e` has not been internalized, add it to the proof forest."}, {"name": "tactic_doc.tactic.tautology", "description": "This tactic (with shorthand `tauto`) breaks down assumptions of the form\n`_ \u2227 _`, `_ \u2228 _`, `_ \u2194 _` and `\u2203 _, _`\nand splits a goal of the form `_ \u2227 _`, `_ \u2194 _` or `\u2203 _, _` until it can be discharged\nusing `reflexivity` or `solve_by_elim`. This is a finishing tactic: it\neither closes the goal or raises an error.\n\nThe variants `tautology!` and `tauto!` use the law of excluded middle.\n\nFor instance, one can write:\n```lean\nexample (p q r : Prop) [decidable p] [decidable r] : p \u2228 (q \u2227 r) \u2194 (p \u2228 q) \u2227 (r \u2228 p \u2228 r) := by tauto\n```\nand the decidability assumptions can be dropped if `tauto!` is used\ninstead of `tauto`.\n\n`tauto {closer := tac}` will use `tac` on any subgoals created by `tauto`\nthat it is unable to solve before failing."}, {"name": "tactic.assumption_symm", "description": ""}, {"name": "tactic.tauto_state", "description": ""}, {"name": "tactic.contradiction_with", "description": ""}, {"name": "tactic.add_symm_proof", "description": "If there exists a symmetry lemma that can be applied to the hypothesis `e`,\nstore it."}, {"name": "tactic.tauto_cfg", "description": "Configuration options for `tauto`.\nIf `classical` is `tt`, runs `classical` before the rest of `tauto`.\n`closer` is run on any remaining subgoals left by `tauto_core; basic_tauto_tacs`."}, {"name": "tactic.tauto_cfg.classical", "description": "Configuration options for `tauto`.\nIf `classical` is `tt`, runs `classical` before the rest of `tauto`.\n`closer` is run on any remaining subgoals left by `tauto_core; basic_tauto_tacs`."}, {"name": "tactic.tauto_cfg.closer", "description": "Configuration options for `tauto`.\nIf `classical` is `tt`, runs `classical` before the rest of `tauto`.\n`closer` is run on any remaining subgoals left by `tauto_core; basic_tauto_tacs`."}, {"name": "tactic.distrib_not", "description": "find all assumptions of the shape `\u00ac (p \u2227 q)` or `\u00ac (p \u2228 q)` and\nreplace them using de Morgan's law."}, {"name": "tactic.add_edge", "description": ""}, {"name": "tactic.interactive.tauto", "description": "`tauto` breaks down assumptions of the form `_ \u2227 _`, `_ \u2228 _`, `_ \u2194 _` and `\u2203 _, _`\nand splits a goal of the form `_ \u2227 _`, `_ \u2194 _` or `\u2203 _, _` until it can be discharged\nusing `reflexivity` or `solve_by_elim`.\nThis is a finishing tactic: it either closes the goal or raises an error.\nThe variant `tauto!` uses the law of excluded middle.\n\n`tauto {closer := tac}` will use `tac` on any subgoals created by `tauto`\nthat it is unable to solve before failing."}, {"name": "tactic.assumption_with", "description": ""}, {"name": "tactic.modify_ref", "description": ""}, {"name": "tactic.interactive.tautology", "description": "`tautology` breaks down assumptions of the form `_ \u2227 _`, `_ \u2228 _`, `_ \u2194 _` and `\u2203 _, _`\nand splits a goal of the form `_ \u2227 _`, `_ \u2194 _` or `\u2203 _, _` until it can be discharged\nusing `reflexivity` or `solve_by_elim`.\nThis is a finishing tactic: it either closes the goal or raises an error.\nThe variant `tautology!` uses the law of excluded middle.\n\n`tautology {closer := tac}` will use `tac` on any subgoals created by `tautology`\nthat it is unable to solve before failing."}, {"name": "tactic.contradiction_symm", "description": ""}, {"name": "tactic.find_eq_type", "description": ""}, {"name": "tactic.add_refl", "description": ""}, {"name": "classical.inhabited_of_nonempty'", "description": "Using `classical.choice`, lifts a (`Prop`-valued) `nonempty` instance to a (`Type`-valued)\n `inhabited` instance. `classical.inhabited_of_nonempty` already exists, in\n `core/init/classical.lean`, but the assumption is not a type class argument,\n which makes it unsuitable for some applications."}, {"name": "classical.arbitrary", "description": "Using `classical.choice`, extracts a term from a `nonempty` type."}, {"name": "nonempty_sum", "description": ""}, {"name": "nonempty_sigma", "description": ""}, {"name": "nonempty_empty", "description": ""}, {"name": "nonempty_ulift", "description": ""}, {"name": "nonempty.map2", "description": ""}, {"name": "nonempty.map", "description": "Given `f : \u03b1 \u2192 \u03b2`, if `\u03b1` is nonempty then `\u03b2` is also nonempty.\n `nonempty` cannot be a `functor`, because `functor` is restricted to `Type`."}, {"name": "nonempty_psigma", "description": ""}, {"name": "prod.nonempty", "description": ""}, {"name": "nonempty.elim_to_inhabited", "description": ""}, {"name": "function.surjective.nonempty", "description": ""}, {"name": "nonempty_Prop", "description": ""}, {"name": "pi.nonempty", "description": ""}, {"name": "has_zero.nonempty", "description": ""}, {"name": "nonempty_subtype", "description": ""}, {"name": "nonempty.some", "description": "Using `classical.choice`, extracts a term from a `nonempty` type."}, {"name": "subsingleton_of_not_nonempty", "description": ""}, {"name": "classical.nonempty_pi", "description": ""}, {"name": "nonempty.congr", "description": ""}, {"name": "nonempty_plift", "description": ""}, {"name": "exists_true_iff_nonempty", "description": ""}, {"name": "has_one.nonempty", "description": ""}, {"name": "nonempty.exists", "description": ""}, {"name": "nonempty_psum", "description": ""}, {"name": "not_nonempty_iff_imp_false", "description": ""}, {"name": "nonempty_prod", "description": ""}, {"name": "nonempty_pprod", "description": ""}, {"name": "nonempty.forall", "description": ""}, {"name": "tactic.itauto.and_kind.has_reflect", "description": ""}, {"name": "tactic.itauto.has_lt.lt.decidable_rel", "description": ""}, {"name": "tactic.itauto.proof.to_format", "description": "Debugging printer for proof objects."}, {"name": "tactic.itauto.and_kind.cmp", "description": "A comparator for `and_kind`. (There should really be a derive handler for this.)"}, {"name": "tactic.itauto.and_kind.sides", "description": "Given the contents of an `and` variant, return the two conjuncts."}, {"name": "tactic.itauto.prop.and", "description": "Constructor for `p \u2227 q`."}, {"name": "tactic.itauto.context.has_to_format", "description": ""}, {"name": "tactic_doc.tactic.itauto", "description": " A decision procedure for intuitionistic propositional logic. Unlike `finish` and `tauto!` this\ntactic never uses the law of excluded middle (without the `!` option), and the proof search is\ntailored for this use case. (`itauto!` will work as a classical SAT solver, but the algorithm is\nnot very good in this situation.)\n\n```lean\nexample (p : Prop) : \u00ac (p \u2194 \u00ac p) := by itauto\n```\n\n`itauto [a, b]` will additionally attempt case analysis on `a` and `b` assuming that it can derive\n`decidable a` and `decidable b`. `itauto *` will case on all decidable propositions that it can\nfind among the atomic propositions, and `itauto! *` will case on all propositional atoms.\n*Warning:* This can blow up the proof search, so it should be used sparingly."}, {"name": "tactic.itauto.prop.decidable_eq", "description": ""}, {"name": "tactic.itauto", "description": " A decision procedure for intuitionistic propositional logic.\n\n* `use_dec` will add `a \u2228 \u00ac a` to the context for every decidable atomic proposition `a`.\n* `use_classical` will allow `a \u2228 \u00ac a` to be added even if the proposition is not decidable,\n  using classical logic.\n* `extra_dec` will add `a \u2228 \u00ac a` to the context for specified (not necessarily atomic)\n  propositions `a`."}, {"name": "tactic.itauto.is_ok", "description": "Convert a value-with-success to an optional value."}, {"name": "tactic.itauto.search", "description": " The search phase, which deals with the level 3 rules, which are rules that are not validity\npreserving and so require proof search. One obvious one is the or-introduction rule: we prove\n`A \u2228 B` by proving `A` or `B`, and we might have to try one and backtrack.\n\nThere are two rules dealing with implication in this category: `p, p \u2192 C \u22a2 B` where `p` is an\natom (which is safe if we can find it but often requires the right search to expose the `p`\nassumption), and `(A\u2081 \u2192 A\u2082) \u2192 C \u22a2 B`. We decompose the double implication into two subgoals: one to\nprove `A\u2081 \u2192 A\u2082`, which can be written `A\u2082 \u2192 C, A\u2081 \u22a2 A\u2082` (where we used `A\u2081` to simplify\n`(A\u2081 \u2192 A\u2082) \u2192 C`), and one to use the consequent, `C \u22a2 B`. The search here is that there are\npotentially many implications to split like this, and we have to try all of them if we want to be\ncomplete."}, {"name": "tactic.itauto.when_ok", "description": "Skip the continuation and return a failed proof if the boolean is false."}, {"name": "tactic.itauto.reify", "description": " Reify an `expr` into a `prop`, allocating anything non-propositional as an atom in the\n`atoms` list."}, {"name": "tactic.itauto.proof.has_to_format", "description": ""}, {"name": "tactic.itauto.reify_atom", "description": " Reifies an atomic or otherwise unrecognized proposition. If it is defeq to a proposition we\nhave already allocated, we reuse it, otherwise we name it with a new index."}, {"name": "tactic.itauto.context", "description": "The context during proof search is a map from propositions to proof values."}, {"name": "tactic.itauto.prop", "description": "A reified inductive type for propositional logic."}, {"name": "tactic.itauto.prop.var", "description": "A reified inductive type for propositional logic."}, {"name": "tactic.itauto.prop.true", "description": "A reified inductive type for propositional logic."}, {"name": "tactic.itauto.prop.false", "description": "A reified inductive type for propositional logic."}, {"name": "tactic.itauto.prop.and'", "description": "A reified inductive type for propositional logic."}, {"name": "tactic.itauto.prop.or", "description": "A reified inductive type for propositional logic."}, {"name": "tactic.itauto.prop.imp", "description": "A reified inductive type for propositional logic."}, {"name": "tactic.itauto.proof.exfalso", "description": "A variant on `proof.exfalso'` that performs opportunistic simplification."}, {"name": "tactic.itauto.prop.eq", "description": "Constructor for `p = q`."}, {"name": "tactic.itauto.map_proof", "description": "Map a function over the proof (regardless of whether the proof is successful or not)."}, {"name": "tactic.itauto.proof.has_reflect", "description": ""}, {"name": "tactic.itauto.context.with_add", "description": " Add `A` to the context `\u0393` with proof `p`. This version of `context.add` takes a continuation\nand a target proposition `B`, so that in the case that `\u22a5` is found we can skip the continuation\nand just prove `B` outright."}, {"name": "tactic.itauto.prop.inhabited", "description": ""}, {"name": "tactic.itauto.proof.or_elim", "description": "A variant on `proof.or_elim` that performs opportunistic simplification."}, {"name": "tactic.itauto.prop.has_lt", "description": ""}, {"name": "tactic.itauto.context.add", "description": " Insert a proposition and its proof into the context, as in `have : A := p`. This will eagerly\napply all level 1 rules on the spot, which are rules that don't split the goal and are validity\npreserving: specifically, we drop `\u22a4` and `A \u2192 \u22a4` hypotheses, close the goal if we find a `\u22a5`\nhypothesis, split all conjunctions, and also simplify `\u22a5 \u2192 A` (drop), `\u22a4 \u2192 A` (simplify to `A`),\n`A \u2227 B \u2192 C` (curry to `A \u2192 B \u2192 C`) and `A \u2228 B \u2192 C` (rewrite to `(A \u2192 C) \u2227 (B \u2192 C)` and split)."}, {"name": "tactic.itauto.apply_proof", "description": " Once we have a proof object, we have to apply it to the goal. (Some of these cases are a bit\nannoying because `applyc` gets the arguments wrong sometimes so we have to use `to_expr` instead.)"}, {"name": "tactic.interactive.itauto", "description": " A decision procedure for intuitionistic propositional logic. Unlike `finish` and `tauto!` this\ntactic never uses the law of excluded middle (without the `!` option), and the proof search is\ntailored for this use case. (`itauto!` will work as a classical SAT solver, but the algorithm is\nnot very good in this situation.)\n\n```lean\nexample (p : Prop) : \u00ac (p \u2194 \u00ac p) := by itauto\n```\n\n`itauto [a, b]` will additionally attempt case analysis on `a` and `b` assuming that it can derive\n`decidable a` and `decidable b`. `itauto *` will case on all decidable propositions that it can\nfind among the atomic propositions, and `itauto! *` will case on all propositional atoms.\n*Warning:* This can blow up the proof search, so it should be used sparingly."}, {"name": "tactic.itauto.prove", "description": " The main prover. This receives a context of proven or assumed lemmas and a target proposition,\nand returns a proof or `none` (with state for the fresh variable generator).\nThe intuitionistic logic rules are separated into three groups:\n\n* level 1: No splitting, validity preserving: apply whenever you can.\n  Left rules in `context.add`, right rules in `prove`\n* level 2: Splitting rules, validity preserving: apply after level 1 rules. Done in `prove`\n* level 3: Splitting rules, not validity preserving: apply only if nothing else applies.\n  Done in `search`\n\nThe level 1 rules on the right of the turnstile are `\u0393 \u22a2 \u22a4` and `\u0393 \u22a2 A \u2192 B`, these are easy to\nhandle. The rule `\u0393 \u22a2 A \u2227 B` is a level 2 rule, also handled here. If none of these apply, we try\nthe level 2 rule `A \u2228 B \u22a2 C` by searching the context and splitting all ors we find. Finally, if\nwe don't make any more progress, we go to the search phase."}, {"name": "tactic.itauto.proof.app", "description": " A variant on `proof.app'` that performs opportunistic simplification.\n(This doesn't do full normalization because we don't want the proof size to blow up.)"}, {"name": "tactic.itauto.prop.has_to_format", "description": ""}, {"name": "tactic.itauto.proof.inhabited", "description": ""}, {"name": "tactic.itauto.context.to_format", "description": "Debug printer for the context."}, {"name": "tactic.itauto.prop.cmp", "description": "A comparator for propositions. (There should really be a derive handler for this.)"}, {"name": "tactic.itauto.prop.not", "description": "Constructor for `\u00ac p`."}, {"name": "tactic.itauto.prop.xor", "description": "Constructor for `xor p q`."}, {"name": "tactic.itauto.fresh_name", "description": "Get a new name in the pattern `h0, h1, h2, ...`"}, {"name": "tactic.itauto.prop.iff", "description": "Constructor for `p \u2194 q`."}, {"name": "tactic.itauto.and_kind.decidable_eq", "description": ""}, {"name": "tactic.itauto.and_kind.inhabited", "description": ""}, {"name": "tactic.itauto.prop.has_reflect", "description": ""}, {"name": "tactic.itauto.and_kind", "description": " Different propositional constructors that are variants of \"and\" for the purposes of the\ntheorem prover."}, {"name": "tactic.itauto.and_kind.and", "description": " Different propositional constructors that are variants of \"and\" for the purposes of the\ntheorem prover."}, {"name": "tactic.itauto.and_kind.iff", "description": " Different propositional constructors that are variants of \"and\" for the purposes of the\ntheorem prover."}, {"name": "tactic.itauto.and_kind.eq", "description": " Different propositional constructors that are variants of \"and\" for the purposes of the\ntheorem prover."}, {"name": "tactic.itauto.prop.to_format", "description": "Debugging printer for propositions."}, {"name": "tactic.itauto.proof", "description": "A reified inductive proof type for intuitionistic propositional logic."}, {"name": "tactic.itauto.proof.sorry", "description": "A reified inductive proof type for intuitionistic propositional logic."}, {"name": "tactic.itauto.proof.hyp", "description": "A reified inductive proof type for intuitionistic propositional logic."}, {"name": "tactic.itauto.proof.triv", "description": "A reified inductive proof type for intuitionistic propositional logic."}, {"name": "tactic.itauto.proof.exfalso'", "description": "A reified inductive proof type for intuitionistic propositional logic."}, {"name": "tactic.itauto.proof.intro", "description": "A reified inductive proof type for intuitionistic propositional logic."}, {"name": "tactic.itauto.proof.and_left", "description": "A reified inductive proof type for intuitionistic propositional logic."}, {"name": "tactic.itauto.proof.and_right", "description": "A reified inductive proof type for intuitionistic propositional logic."}, {"name": "tactic.itauto.proof.and_intro", "description": "A reified inductive proof type for intuitionistic propositional logic."}, {"name": "tactic.itauto.proof.curry", "description": "A reified inductive proof type for intuitionistic propositional logic."}, {"name": "tactic.itauto.proof.curry\u2082", "description": "A reified inductive proof type for intuitionistic propositional logic."}, {"name": "tactic.itauto.proof.app'", "description": "A reified inductive proof type for intuitionistic propositional logic."}, {"name": "tactic.itauto.proof.or_imp_left", "description": "A reified inductive proof type for intuitionistic propositional logic."}, {"name": "tactic.itauto.proof.or_imp_right", "description": "A reified inductive proof type for intuitionistic propositional logic."}, {"name": "tactic.itauto.proof.or_inl", "description": "A reified inductive proof type for intuitionistic propositional logic."}, {"name": "tactic.itauto.proof.or_inr", "description": "A reified inductive proof type for intuitionistic propositional logic."}, {"name": "tactic.itauto.proof.or_elim'", "description": "A reified inductive proof type for intuitionistic propositional logic."}, {"name": "tactic.itauto.proof.decidable_elim", "description": "A reified inductive proof type for intuitionistic propositional logic."}, {"name": "tactic.itauto.proof.em", "description": "A reified inductive proof type for intuitionistic propositional logic."}, {"name": "tactic.itauto.proof.imp_imp_simp", "description": "A reified inductive proof type for intuitionistic propositional logic."}, {"name": "pow_eq_zero", "description": ""}, {"name": "neg_one_pow_eq_or", "description": ""}, {"name": "coe_pow_monoid_with_zero_hom", "description": ""}, {"name": "neg_sq", "description": ""}, {"name": "units.eq_or_eq_neg_of_sq_eq_sq", "description": ""}, {"name": "sub_pow_two", "description": "**Alias** of `sub_sq`."}, {"name": "sub_sq", "description": ""}, {"name": "neg_one_pow_two", "description": "**Alias** of `neg_one_sq`."}, {"name": "sub_sq'", "description": ""}, {"name": "pow_eq_zero_of_le", "description": ""}, {"name": "ne_zero_pow", "description": ""}, {"name": "sq_ne_one_iff", "description": ""}, {"name": "min_pow_dvd_add", "description": ""}, {"name": "sq_sub_sq", "description": ""}, {"name": "pow_ne_zero", "description": ""}, {"name": "commute.sq_eq_sq_iff_eq_or_eq_neg", "description": ""}, {"name": "pow_ne_zero_iff", "description": ""}, {"name": "add_sq'", "description": ""}, {"name": "pow_dvd_pow_iff", "description": ""}, {"name": "neg_pow_bit0", "description": ""}, {"name": "neg_one_sq", "description": ""}, {"name": "pow_monoid_with_zero_hom_apply", "description": ""}, {"name": "pow_eq_zero_iff'", "description": ""}, {"name": "zero_pow", "description": ""}, {"name": "zero_pow_eq_zero", "description": ""}, {"name": "ring.inverse_pow", "description": ""}, {"name": "pow_two_sub_pow_two", "description": "**Alias** of `sq_sub_sq`."}, {"name": "ring_hom.map_pow", "description": ""}, {"name": "zero_pow_eq", "description": ""}, {"name": "add_pow_two", "description": "**Alias** of `add_sq`."}, {"name": "sq_eq_zero_iff", "description": ""}, {"name": "mul_neg_one_pow_eq_zero_iff", "description": ""}, {"name": "neg_pow_bit1", "description": ""}, {"name": "pow_monoid_with_zero_hom", "description": "We define `x \u21a6 x^n` (for positive `n : \u2115`) as a `monoid_with_zero_hom`"}, {"name": "eq_or_eq_neg_of_sq_eq_sq", "description": ""}, {"name": "units.sq_eq_sq_iff_eq_or_eq_neg", "description": ""}, {"name": "neg_pow", "description": ""}, {"name": "add_sq", "description": ""}, {"name": "commute.sq_sub_sq", "description": ""}, {"name": "sq_eq_one_iff", "description": ""}, {"name": "neg_one_pow_mul_eq_zero_iff", "description": ""}, {"name": "sq_eq_sq_iff_eq_or_eq_neg", "description": ""}, {"name": "neg_pow_two", "description": "**Alias** of `neg_sq`."}, {"name": "zero_pow'", "description": ""}, {"name": "pow_eq_zero_iff", "description": ""}, {"name": "set.pairwise.subtype", "description": "**Alias** of the reverse direction of `pairwise_subtype_iff_pairwise_set`."}, {"name": "set.pairwise.mono", "description": ""}, {"name": "set.pairwise_disjoint_union", "description": ""}, {"name": "pairwise", "description": "A relation `r` holds pairwise if `r i j` for all `i \u2260 j`."}, {"name": "set.inj_on.pairwise_disjoint_image", "description": ""}, {"name": "set.pairwise_disjoint_sUnion", "description": ""}, {"name": "set.pairwise.insert", "description": ""}, {"name": "set.pairwise.on_injective", "description": ""}, {"name": "set.pairwise_disjoint.union", "description": ""}, {"name": "set.pairwise_disjoint", "description": " A set is `pairwise_disjoint` under `f`, if the images of any distinct two elements under `f`\nare disjoint.\n\n`s.pairwise disjoint` is (definitionally) the same as `s.pairwise_disjoint id`. We prefer the latter\nin order to allow dot notation on `set.pairwise_disjoint`, even though the former unfolds more\nnicely."}, {"name": "pairwise_disjoint_on", "description": ""}, {"name": "symmetric.pairwise_on", "description": ""}, {"name": "reflexive.set_pairwise_iff", "description": ""}, {"name": "set.pairwise_iff_of_refl", "description": ""}, {"name": "pairwise.mono", "description": ""}, {"name": "set.bUnion_eq_sigma_of_disjoint", "description": "Equivalence between a disjoint bounded union and a dependent sum."}, {"name": "set.pairwise.eq", "description": ""}, {"name": "set.pairwise_union_of_symmetric", "description": ""}, {"name": "set.pairwise_disjoint.eq_of_le", "description": ""}, {"name": "set.pairwise_union", "description": ""}, {"name": "set.pairwise_disjoint.elim", "description": ""}, {"name": "set.pairwise_insert", "description": ""}, {"name": "set.nonempty.pairwise_iff_exists_forall", "description": ""}, {"name": "set.pairwise_of_forall", "description": ""}, {"name": "set.pairwise_disjoint_fiber", "description": ""}, {"name": "set.pairwise_disjoint.image_of_le", "description": ""}, {"name": "function.injective_iff_pairwise_ne", "description": ""}, {"name": "set.pairwise_insert_of_symmetric", "description": ""}, {"name": "set.pairwise_disjoint.bUnion", "description": " Bind operation for `set.pairwise_disjoint`. If you want to only consider finsets of indices, you\ncan use `set.pairwise_disjoint.bUnion_finset`."}, {"name": "set.pairwise_empty", "description": ""}, {"name": "set.pairwise_disjoint_singleton", "description": ""}, {"name": "set.pairwise.imp_on", "description": ""}, {"name": "set.pairwise_disjoint_image_left_iff", "description": " The partial images of a binary function `f` whose partial evaluations are injective are pairwise\ndisjoint iff `f` is injective ."}, {"name": "set.pairwise_disjoint_insert", "description": ""}, {"name": "set.pairwise.imp", "description": ""}, {"name": "set.pairwise_sUnion", "description": ""}, {"name": "set.pairwise_disjoint.mono_on", "description": ""}, {"name": "set.pairwise_disjoint.mono", "description": ""}, {"name": "set.pairwise.mono'", "description": ""}, {"name": "set.pairwise_top", "description": ""}, {"name": "set.pairwise_disjoint.elim_set", "description": ""}, {"name": "set.pairwise", "description": "The relation `r` holds pairwise on the set `s` if `r x y` for all *distinct* `x y \u2208 s`."}, {"name": "pairwise_on_bool", "description": ""}, {"name": "set.pairwise_disjoint.insert", "description": ""}, {"name": "set.pairwise_singleton", "description": ""}, {"name": "set.pairwise_disjoint_Union", "description": ""}, {"name": "set.pairwise_pair", "description": ""}, {"name": "set.pairwise_eq_iff_exists_eq", "description": " A function `f : \u03b1 \u2192 \u03b9` with nonempty codomain takes pairwise equal values on a set `s` if and\nonly if for some `z` in the codomain, `f` takes value `z` on all `x \u2208 s`. See also\n`set.nonempty.pairwise_eq_iff_exists_eq` for a version that assumes `set.nonempty s` instead of\n`[nonempty \u03b9]`."}, {"name": "set.pairwise_pair_of_symmetric", "description": ""}, {"name": "pairwise_disjoint_fiber", "description": ""}, {"name": "set.bUnion_diff_bUnion_eq", "description": ""}, {"name": "set.pairwise_disjoint_empty", "description": ""}, {"name": "pairwise.set_pairwise", "description": ""}, {"name": "function.injective.pairwise_ne", "description": "**Alias** of the forward direction of `function.injective_iff_pairwise_ne`."}, {"name": "set.pairwise_univ", "description": ""}, {"name": "set.pairwise_Union", "description": ""}, {"name": "pairwise.set_of_subtype", "description": "**Alias** of the forward direction of `pairwise_subtype_iff_pairwise_set`."}, {"name": "set.pairwise_disjoint_range_singleton", "description": ""}, {"name": "pairwise_subtype_iff_pairwise_set", "description": ""}, {"name": "pairwise_disjoint_on_bool", "description": ""}, {"name": "set.pairwise.of_refl", "description": "**Alias** of the forward direction of `set.pairwise_iff_of_refl`."}, {"name": "set.pairwise_disjoint_image_right_iff", "description": " The partial images of a binary function `f` whose partial evaluations are injective are pairwise\ndisjoint iff `f` is injective ."}, {"name": "set.pairwise_disjoint.elim'", "description": ""}, {"name": "set.pairwise.subsingleton", "description": "**Alias** of the forward direction of `set.pairwise_bot_iff`."}, {"name": "set.inj_on.pairwise_image", "description": ""}, {"name": "set.pairwise_iff_exists_forall", "description": ""}, {"name": "set.pairwise_bot_iff", "description": ""}, {"name": "set.pairwise.insert_of_symmetric", "description": ""}, {"name": "set.subsingleton.pairwise", "description": ""}, {"name": "set.pairwise_disjoint.range", "description": ""}, {"name": "pairwise_disjoint.mono", "description": ""}, {"name": "set.nonempty.pairwise_eq_iff_exists_eq", "description": " For a nonempty set `s`, a function `f` takes pairwise equal values on `s` if and only if\nfor some `z` in the codomain, `f` takes value `z` on all `x \u2208 s`. See also\n`set.pairwise_eq_iff_exists_eq` for a version that assumes `[nonempty \u03b9]` instead of\n`set.nonempty s`."}, {"name": "set.pairwise_disjoint.subset", "description": ""}, {"name": "category_theory.is_iso.eq_inv_comp", "description": ""}, {"name": "category_theory.iso.cancel_iso_inv_right_assoc", "description": ""}, {"name": "category_theory.is_iso.of_is_iso_comp_right", "description": ""}, {"name": "category_theory.is_iso.comp_is_iso", "description": ""}, {"name": "category_theory.iso.hom_inv_id_assoc", "description": ""}, {"name": "category_theory.hom_comp_eq_id", "description": ""}, {"name": "category_theory.functor.map_iso_inv", "description": ""}, {"name": "category_theory.is_iso.inv_hom_id", "description": ""}, {"name": "category_theory.iso.eq_inv_comp", "description": ""}, {"name": "category_theory.iso.symm_inv", "description": ""}, {"name": "category_theory.is_iso_of_comp_hom_eq_id", "description": ""}, {"name": "category_theory.is_iso.of_is_iso_fac_right", "description": ""}, {"name": "category_theory.iso.trans_refl", "description": ""}, {"name": "category_theory.iso.refl_trans", "description": ""}, {"name": "category_theory.iso.symm_self_id_assoc", "description": ""}, {"name": "category_theory.iso.inv_comp_eq", "description": ""}, {"name": "category_theory.is_iso.of_is_iso_fac_left", "description": ""}, {"name": "category_theory.is_iso.inv_id", "description": ""}, {"name": "category_theory.iso.symm_eq_iff", "description": ""}, {"name": "category_theory.functor.map_inv", "description": ""}, {"name": "category_theory.iso.refl", "description": "Identity isomorphism."}, {"name": "category_theory.iso.refl_hom", "description": ""}, {"name": "category_theory.is_iso.inv_comp_eq", "description": ""}, {"name": "category_theory.functor.map_is_iso", "description": ""}, {"name": "category_theory.functor.map_iso_refl", "description": ""}, {"name": "category_theory.iso.inhabited", "description": ""}, {"name": "category_theory.iso.refl_symm", "description": ""}, {"name": "category_theory.iso.hom_inv_id", "description": ""}, {"name": "category_theory.iso.self_symm_id", "description": ""}, {"name": "category_theory.iso.inv_eq_inv", "description": ""}, {"name": "category_theory.iso.trans_inv", "description": ""}, {"name": "category_theory.iso.cancel_iso_inv_left", "description": ""}, {"name": "category_theory.is_iso.epi_of_iso", "description": ""}, {"name": "category_theory.is_iso.inv_eq_inv", "description": ""}, {"name": "category_theory.iso.refl_inv", "description": ""}, {"name": "category_theory.is_iso.comp_inv_eq", "description": ""}, {"name": "category_theory.iso.inv_hom_id_assoc", "description": ""}, {"name": "category_theory.is_iso.eq_inv_of_hom_inv_id", "description": ""}, {"name": "category_theory.iso.trans_symm", "description": ""}, {"name": "category_theory.is_iso_of_hom_comp_eq_id", "description": ""}, {"name": "category_theory.as_iso_inv", "description": ""}, {"name": "category_theory.iso.eq_comp_inv", "description": ""}, {"name": "category_theory.iso.inv_ext'", "description": ""}, {"name": "category_theory.is_iso.mono_of_iso", "description": ""}, {"name": "category_theory.functor.map_iso", "description": "A functor `F : C \u2964 D` sends isomorphisms `i : X \u2245 Y` to isomorphisms `F.obj X \u2245 F.obj Y`"}, {"name": "category_theory.is_iso.id", "description": ""}, {"name": "category_theory.iso.self_symm_id_assoc", "description": ""}, {"name": "category_theory.iso.hom_eq_inv", "description": ""}, {"name": "category_theory.iso.inv_hom_id", "description": ""}, {"name": "category_theory.is_iso.inv_eq_of_hom_inv_id", "description": ""}, {"name": "category_theory.iso.comp_inv_eq_id", "description": ""}, {"name": "category_theory.inv_comp_eq_id", "description": ""}, {"name": "category_theory.iso.inv_comp_eq_id", "description": ""}, {"name": "category_theory.iso.trans_assoc", "description": ""}, {"name": "category_theory.functor.map_inv_hom", "description": ""}, {"name": "category_theory.iso.symm_mk", "description": ""}, {"name": "category_theory.iso", "description": "An isomorphism (a.k.a. an invertible morphism) between two objects of a category.\nThe inverse morphism is bundled.\n\nSee also `category_theory.core` for the category with the same objects and isomorphisms playing\nthe role of morphisms.\n\nSee <https://stacks.math.columbia.edu/tag/0017>."}, {"name": "category_theory.iso.hom", "description": "An isomorphism (a.k.a. an invertible morphism) between two objects of a category.\nThe inverse morphism is bundled.\n\nSee also `category_theory.core` for the category with the same objects and isomorphisms playing\nthe role of morphisms.\n\nSee <https://stacks.math.columbia.edu/tag/0017>."}, {"name": "category_theory.iso.inv", "description": "An isomorphism (a.k.a. an invertible morphism) between two objects of a category.\nThe inverse morphism is bundled.\n\nSee also `category_theory.core` for the category with the same objects and isomorphisms playing\nthe role of morphisms.\n\nSee <https://stacks.math.columbia.edu/tag/0017>."}, {"name": "category_theory.iso.hom_inv_id'", "description": "An isomorphism (a.k.a. an invertible morphism) between two objects of a category.\nThe inverse morphism is bundled.\n\nSee also `category_theory.core` for the category with the same objects and isomorphisms playing\nthe role of morphisms.\n\nSee <https://stacks.math.columbia.edu/tag/0017>."}, {"name": "category_theory.iso.inv_hom_id'", "description": "An isomorphism (a.k.a. an invertible morphism) between two objects of a category.\nThe inverse morphism is bundled.\n\nSee also `category_theory.core` for the category with the same objects and isomorphisms playing\nthe role of morphisms.\n\nSee <https://stacks.math.columbia.edu/tag/0017>."}, {"name": "category_theory.iso.cancel_iso_hom_right_assoc", "description": ""}, {"name": "category_theory.iso.symm_hom", "description": ""}, {"name": "category_theory.iso.comp_hom_eq_id", "description": ""}, {"name": "category_theory.iso.cancel_iso_hom_right", "description": ""}, {"name": "category_theory.functor.map_iso_trans", "description": ""}, {"name": "category_theory.comp_hom_eq_id", "description": ""}, {"name": "category_theory.eq_of_inv_eq_inv", "description": ""}, {"name": "category_theory.iso.ext", "description": ""}, {"name": "category_theory.is_iso.inv_eq_of_inv_hom_id", "description": ""}, {"name": "category_theory.functor.map_iso_symm", "description": ""}, {"name": "category_theory.comp_inv_eq_id", "description": ""}, {"name": "category_theory.iso.hom_comp_eq_id", "description": ""}, {"name": "category_theory.is_iso.of_iso", "description": ""}, {"name": "category_theory.is_iso.iso.inv_inv", "description": ""}, {"name": "category_theory.is_iso.eq_inv_of_inv_hom_id", "description": ""}, {"name": "category_theory.functor.map_hom_inv", "description": ""}, {"name": "category_theory.iso.comp_inv_eq", "description": ""}, {"name": "category_theory.is_iso.of_is_iso_comp_left", "description": ""}, {"name": "category_theory.iso.symm", "description": "Inverse isomorphism."}, {"name": "category_theory.iso.symm_self_id", "description": ""}, {"name": "category_theory.is_iso.inv_is_iso", "description": ""}, {"name": "category_theory.iso.symm_symm_eq", "description": ""}, {"name": "category_theory.as_iso", "description": "Reinterpret a morphism `f` with an `is_iso f` instance as an `iso`."}, {"name": "category_theory.iso.trans_hom", "description": ""}, {"name": "category_theory.is_iso.eq_comp_inv", "description": ""}, {"name": "category_theory.is_iso", "description": "`is_iso` typeclass expressing that a morphism is invertible."}, {"name": "category_theory.is_iso.out", "description": "`is_iso` typeclass expressing that a morphism is invertible."}, {"name": "category_theory.iso.cancel_iso_hom_left", "description": ""}, {"name": "category_theory.iso.inv_ext", "description": ""}, {"name": "category_theory.as_iso_hom", "description": ""}, {"name": "category_theory.iso.trans_mk", "description": ""}, {"name": "category_theory.is_iso.hom_inv_id", "description": ""}, {"name": "category_theory.is_iso.inv_inv", "description": ""}, {"name": "category_theory.is_iso.of_iso_inv", "description": ""}, {"name": "category_theory.is_iso.hom_inv_id_assoc", "description": ""}, {"name": "category_theory.iso.trans", "description": "Composition of two isomorphisms"}, {"name": "category_theory.is_iso.iso.inv_hom", "description": ""}, {"name": "category_theory.is_iso.inv_comp", "description": ""}, {"name": "category_theory.iso.cancel_iso_inv_right", "description": ""}, {"name": "category_theory.is_iso.inv_hom_id_assoc", "description": ""}, {"name": "category_theory.functor.map_iso_hom", "description": ""}, {"name": "category_theory.inv", "description": "The inverse of a morphism `f` when we have `[is_iso f]`."}, {"name": "vector.of_fn", "description": ""}, {"name": "vector.to_list_cons", "description": ""}, {"name": "vector.to_list_nil", "description": ""}, {"name": "vector.nil", "description": ""}, {"name": "vector.eq_nil", "description": ""}, {"name": "vector.map_accumr\u2082", "description": ""}, {"name": "vector.map_nil", "description": ""}, {"name": "vector.map", "description": ""}, {"name": "vector.to_list_drop", "description": ""}, {"name": "vector.to_list_append", "description": ""}, {"name": "vector.tail", "description": ""}, {"name": "vector.to_list_length", "description": ""}, {"name": "vector.to_list_take", "description": ""}, {"name": "vector.length", "description": ""}, {"name": "vector.remove_nth", "description": ""}, {"name": "vector.tail_cons", "description": ""}, {"name": "vector.cons", "description": ""}, {"name": "vector.map_cons", "description": ""}, {"name": "vector.append", "description": ""}, {"name": "vector.nth", "description": ""}, {"name": "vector.decidable_eq", "description": ""}, {"name": "vector.map\u2082", "description": ""}, {"name": "vector.repeat", "description": ""}, {"name": "vector.head", "description": ""}, {"name": "vector.map_accumr", "description": ""}, {"name": "vector.take", "description": ""}, {"name": "vector.elim", "description": ""}, {"name": "vector.eq", "description": ""}, {"name": "vector.to_list_mk", "description": ""}, {"name": "vector", "description": ""}, {"name": "vector.cons_head_tail", "description": ""}, {"name": "vector.head_cons", "description": ""}, {"name": "vector.drop", "description": ""}, {"name": "vector.to_list", "description": ""}, {"name": "order_iso.bdd_below_preimage", "description": ""}, {"name": "galois_insertion.l_binfi_u", "description": ""}, {"name": "Inf_image2_eq_Sup_Sup", "description": ""}, {"name": "galois_connection.monotone_intro", "description": ""}, {"name": "galois_insertion.l_inf_u", "description": ""}, {"name": "galois_coinsertion.lift_bounded_order", "description": "Lift the top, bottom, suprema, and infima along a Galois coinsertion"}, {"name": "galois_insertion.l_surjective", "description": ""}, {"name": "order_iso.to_galois_connection", "description": "Makes a Galois connection from an order-preserving bijection."}, {"name": "galois_coinsertion.u_bsupr_l", "description": ""}, {"name": "order_iso.bdd_above_preimage", "description": ""}, {"name": "galois_insertion.u_injective", "description": ""}, {"name": "galois_coinsertion.lift_semilattice_sup", "description": "Lift the suprema along a Galois coinsertion"}, {"name": "galois_insertion.l_bsupr_u", "description": ""}, {"name": "galois_insertion.l_infi_of_ul_eq_self", "description": ""}, {"name": "galois_connection.is_least_l", "description": ""}, {"name": "galois_insertion.left_inverse_l_u", "description": ""}, {"name": "galois_connection.l_comm_of_u_comm", "description": ""}, {"name": "galois_insertion.l_supr_u", "description": ""}, {"name": "galois_coinsertion.l_le_l_iff", "description": ""}, {"name": "Sup_image2_eq_Sup_Inf", "description": ""}, {"name": "galois_insertion.dual", "description": " Make a `galois_coinsertion` between `\u03b1\u1d52\u1d48` and `\u03b2\u1d52\u1d48` from a `galois_insertion` between `\u03b1` and\n`\u03b2`."}, {"name": "galois_insertion.lift_semilattice_sup", "description": "Lift the suprema along a Galois insertion"}, {"name": "galois_connection.u_infi\u2082", "description": ""}, {"name": "galois_insertion.l_binfi_of_ul_eq_self", "description": ""}, {"name": "with_bot.gi_get_or_else_bot", "description": " If `\u03b1` is a partial order with bottom element (e.g., `\u2115`, `\u211d\u22650`), then\n`\u03bb o : with_bot \u03b1, o.get_or_else \u22a5` and coercion form a Galois insertion."}, {"name": "galois_coinsertion.u_sup_l", "description": ""}, {"name": "galois_connection.lt_iff_lt", "description": ""}, {"name": "galois_insertion.l_u_eq", "description": ""}, {"name": "galois_coinsertion", "description": " A Galois coinsertion is a Galois connection where `u \u2218 l = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual to\n`galois_insertion`"}, {"name": "galois_coinsertion.choice", "description": " A Galois coinsertion is a Galois connection where `u \u2218 l = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual to\n`galois_insertion`"}, {"name": "galois_coinsertion.gc", "description": " A Galois coinsertion is a Galois connection where `u \u2218 l = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual to\n`galois_insertion`"}, {"name": "galois_coinsertion.u_l_le", "description": " A Galois coinsertion is a Galois connection where `u \u2218 l = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual to\n`galois_insertion`"}, {"name": "galois_coinsertion.choice_eq", "description": " A Galois coinsertion is a Galois connection where `u \u2218 l = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual to\n`galois_insertion`"}, {"name": "galois_connection.id", "description": ""}, {"name": "galois_connection.le_u_l", "description": ""}, {"name": "galois_coinsertion.dual", "description": " Make a `galois_insertion` between `\u03b1\u1d52\u1d48` and `\u03b2\u1d52\u1d48` from a `galois_coinsertion` between `\u03b1` and\n`\u03b2`."}, {"name": "galois_connection.le_u_l_trans", "description": " If `(l, u)` is a Galois connection, then the relation `x \u2264 u (l y)` is a transitive relation.\nIf `l` is a closure operator (`submodule.span`, `subgroup.closure`, ...) and `u` is the coercion to\n`set`, this reads as \"if `U` is in the closure of `V` and `V` is in the closure of `W` then `U` is\nin the closure of `W`\"."}, {"name": "galois_coinsertion.monotone_intro", "description": "A constructor for a Galois coinsertion with the trivial `choice` function."}, {"name": "galois_insertion.l_Inf_u_image", "description": ""}, {"name": "galois_connection.lift_order_bot", "description": "Lift the bottom along a Galois connection"}, {"name": "galois_insertion.l_infi_u", "description": ""}, {"name": "galois_connection.l_unique", "description": ""}, {"name": "galois_connection.is_lub_u", "description": ""}, {"name": "galois_coinsertion.lift_semilattice_inf", "description": "Lift the infima along a Galois coinsertion"}, {"name": "galois_insertion.strict_mono_u", "description": ""}, {"name": "galois_connection.u_inf", "description": ""}, {"name": "galois_connection.le_iff_le", "description": ""}, {"name": "galois_insertion.lift_complete_lattice", "description": "Lift all suprema and infima along a Galois insertion"}, {"name": "galois_insertion.is_lub_of_u_image", "description": ""}, {"name": "galois_coinsertion.is_glb_of_l_image", "description": ""}, {"name": "galois_coinsertion.strict_mono_l", "description": ""}, {"name": "galois_connection.l_le", "description": ""}, {"name": "galois_coinsertion.u_Inf_l_image", "description": ""}, {"name": "galois_connection.monotone_u", "description": ""}, {"name": "galois_connection.is_glb_u_image", "description": ""}, {"name": "galois_coinsertion.u_supr_l", "description": ""}, {"name": "galois_coinsertion.l_injective", "description": ""}, {"name": "galois_connection.l_bot", "description": ""}, {"name": "galois_connection.is_lub_l_image", "description": ""}, {"name": "galois_coinsertion.lift_lattice", "description": "Lift the suprema and infima along a Galois coinsertion"}, {"name": "galois_connection.bdd_above_l_image", "description": ""}, {"name": "order_iso.to_galois_insertion", "description": "Makes a Galois insertion from an order-preserving bijection."}, {"name": "galois_connection.u_Inf", "description": ""}, {"name": "galois_connection.u_unique", "description": ""}, {"name": "galois_connection.is_greatest_u", "description": ""}, {"name": "galois_connection.l_u_le", "description": ""}, {"name": "galois_connection.l_sup", "description": ""}, {"name": "galois_coinsertion.u_l_left_inverse", "description": ""}, {"name": "galois_insertion.lift_bounded_order", "description": "Lift the top, bottom, suprema, and infima along a Galois insertion"}, {"name": "order_iso.bdd_below_image", "description": ""}, {"name": "galois_coinsertion.u_l_eq", "description": ""}, {"name": "galois_insertion.of_dual", "description": " Make a `galois_coinsertion` between `\u03b1` and `\u03b2` from a `galois_insertion` between `\u03b1\u1d52\u1d48` and\n`\u03b2\u1d52\u1d48`."}, {"name": "galois_connection.exists_eq_u", "description": "If there exists a `b` such that `a = u a`, then `b = l a` is one such element."}, {"name": "Inf_image2_eq_Sup_Inf", "description": ""}, {"name": "galois_connection.bdd_below_u_image", "description": ""}, {"name": "Sup_image2_eq_Sup_Sup", "description": ""}, {"name": "galois_connection.l_supr", "description": ""}, {"name": "galois_connection.u_l_u_eq_u'", "description": ""}, {"name": "galois_connection.upper_bounds_l_image", "description": ""}, {"name": "galois_connection.u_l_u_eq_u", "description": ""}, {"name": "galois_connection.lower_bounds_u_image", "description": ""}, {"name": "galois_coinsertion.is_lub_of_l_image", "description": ""}, {"name": "galois_insertion.is_glb_of_u_image", "description": ""}, {"name": "galois_insertion.lift_order_top", "description": "Lift the top along a Galois insertion"}, {"name": "galois_connection.lift_order_top", "description": "Lift the top along a Galois connection"}, {"name": "order_iso.to_galois_coinsertion", "description": "Makes a Galois coinsertion from an order-preserving bijection."}, {"name": "galois_connection.le_u", "description": ""}, {"name": "galois_coinsertion.lift_order_bot", "description": "Lift the bot along a Galois coinsertion"}, {"name": "Sup_image2_eq_Inf_Inf", "description": ""}, {"name": "galois_connection.u_comm_of_l_comm", "description": ""}, {"name": "galois_coinsertion.u_Sup_l_image", "description": ""}, {"name": "galois_connection.u_infi", "description": ""}, {"name": "galois_connection.dfun", "description": ""}, {"name": "galois_connection", "description": "A Galois connection is a pair of functions `l` and `u` satisfying\n `l a \u2264 b \u2194 a \u2264 u b`. They are special cases of adjoint functors in category theory,\n   but do not depend on the category theory library in mathlib."}, {"name": "galois_insertion.l_sup_u", "description": ""}, {"name": "Sup_image2_eq_Inf_Sup", "description": ""}, {"name": "galois_coinsertion.u_supr_of_lu_eq_self", "description": ""}, {"name": "Inf_image2_eq_Inf_Inf", "description": ""}, {"name": "galois_coinsertion.u_infi_l", "description": ""}, {"name": "galois_connection.to_galois_coinsertion", "description": "Make a `galois_coinsertion l u` from a `galois_connection l u` such that `\u2200 b, b \u2264 l (u b)`"}, {"name": "galois_coinsertion.u_inf_l", "description": ""}, {"name": "galois_connection.l_comm_iff_u_comm", "description": ""}, {"name": "galois_connection.l_eq", "description": ""}, {"name": "galois_connection.l_u_l_eq_l'", "description": ""}, {"name": "galois_connection.dual", "description": ""}, {"name": "galois_coinsertion.u_surjective", "description": ""}, {"name": "galois_connection.monotone_l", "description": ""}, {"name": "galois_connection.to_galois_insertion", "description": "Make a `galois_insertion l u` from a `galois_connection l u` such that `\u2200 b, b \u2264 l (u b)`"}, {"name": "galois_connection.u_top", "description": ""}, {"name": "galois_connection.l_u_le_trans", "description": ""}, {"name": "galois_insertion.l_Sup_u_image", "description": ""}, {"name": "galois_insertion.lift_lattice", "description": "Lift the suprema and infima along a Galois insertion"}, {"name": "galois_connection.compose", "description": ""}, {"name": "order_iso.bdd_above_image", "description": ""}, {"name": "nat.galois_connection_mul_div", "description": ""}, {"name": "galois_insertion.monotone_intro", "description": "A constructor for a Galois insertion with the trivial `choice` function."}, {"name": "galois_coinsertion.lift_complete_lattice", "description": "Lift all suprema and infima along a Galois coinsertion"}, {"name": "galois_insertion", "description": " A Galois insertion is a Galois connection where `l \u2218 u = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual\nto `galois_coinsertion`"}, {"name": "galois_insertion.choice", "description": " A Galois insertion is a Galois connection where `l \u2218 u = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual\nto `galois_coinsertion`"}, {"name": "galois_insertion.gc", "description": " A Galois insertion is a Galois connection where `l \u2218 u = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual\nto `galois_coinsertion`"}, {"name": "galois_insertion.le_l_u", "description": " A Galois insertion is a Galois connection where `l \u2218 u = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual\nto `galois_coinsertion`"}, {"name": "galois_insertion.choice_eq", "description": " A Galois insertion is a Galois connection where `l \u2218 u = id`. It also contains a constructive\nchoice function, to give better definitional equalities when lifting order structures. Dual\nto `galois_coinsertion`"}, {"name": "galois_connection.l_u_l_eq_l", "description": ""}, {"name": "galois_insertion.lift_semilattice_inf", "description": "Lift the infima along a Galois insertion"}, {"name": "galois_coinsertion.of_dual", "description": " Make a `galois_insertion` between `\u03b1` and `\u03b2` from a `galois_coinsertion` between `\u03b1\u1d52\u1d48` and\n`\u03b2\u1d52\u1d48`."}, {"name": "galois_connection.l_supr\u2082", "description": ""}, {"name": "galois_connection.exists_eq_l", "description": "If there exists an `a` such that `b = l a`, then `a = u b` is one such element."}, {"name": "galois_connection.l_Sup", "description": ""}, {"name": "galois_coinsertion.u_bsupr_of_lu_eq_self", "description": ""}, {"name": "galois_connection.u_eq", "description": ""}, {"name": "Inf_image2_eq_Inf_Sup", "description": ""}, {"name": "galois_insertion.u_le_u_iff", "description": ""}, {"name": "galois_connection.is_glb_l", "description": ""}, {"name": "is_unit.inv_smul", "description": ""}, {"name": "units.smul_comm_class_left", "description": ""}, {"name": "add_units.add_action", "description": ""}, {"name": "units.mul_action", "description": ""}, {"name": "units.has_faithful_smul", "description": ""}, {"name": "add_units.has_faithful_vadd", "description": ""}, {"name": "units.mul_action'", "description": " If an action `G` associates and commutes with multiplication on `M`, then it lifts to an\naction on `M\u02e3`. Notably, this provides `mul_action M\u02e3 N\u02e3` under suitable\nconditions."}, {"name": "units.smul_inv", "description": "Note that this lemma exists more generally as the global `smul_inv`"}, {"name": "units.mul_distrib_mul_action", "description": ""}, {"name": "add_units.vadd_def", "description": ""}, {"name": "units.is_scalar_tower", "description": ""}, {"name": "add_units.has_vadd", "description": ""}, {"name": "units.mul_distrib_mul_action'", "description": "A stronger form of `units.mul_action'`."}, {"name": "units.smul_def", "description": ""}, {"name": "units.is_scalar_tower'", "description": "Transfer `is_scalar_tower G H M` to `is_scalar_tower G H M\u02e3`"}, {"name": "units.smul_comm_class_right", "description": ""}, {"name": "units.coe_smul", "description": ""}, {"name": "units.is_scalar_tower'_left", "description": "Transfer `is_scalar_tower G M \u03b1` to `is_scalar_tower G M\u02e3 \u03b1`"}, {"name": "is_unit.smul", "description": ""}, {"name": "units.has_smul", "description": ""}, {"name": "units.smul_comm_class'", "description": "Transfer `smul_comm_class G H M` to `smul_comm_class G H M\u02e3`"}, {"name": "units.distrib_mul_action", "description": ""}, {"name": "units.smul_is_unit", "description": ""}, {"name": "supr_unpair", "description": ""}, {"name": "nat.mkpair_eq_mkpair", "description": ""}, {"name": "nat.add_le_mkpair", "description": ""}, {"name": "nat.mkpair_equiv", "description": "An equivalence between `\u2115 \u00d7 \u2115` and `\u2115`."}, {"name": "nat.max_sq_add_min_le_mkpair", "description": ""}, {"name": "nat.surjective_unpair", "description": ""}, {"name": "nat.unpair_add_le", "description": ""}, {"name": "nat.unpair", "description": "Unpairing function for the natural numbers."}, {"name": "nat.unpair_lt", "description": ""}, {"name": "nat.mkpair_lt_mkpair_right", "description": ""}, {"name": "nat.unpair_zero", "description": ""}, {"name": "nat.left_le_mkpair", "description": ""}, {"name": "nat.unpair_right_le", "description": ""}, {"name": "nat.mkpair", "description": "Pairing function for the natural numbers."}, {"name": "set.Inter_unpair", "description": ""}, {"name": "nat.mkpair_unpair", "description": ""}, {"name": "nat.mkpair_lt_max_add_one_sq", "description": ""}, {"name": "set.Union_unpair", "description": ""}, {"name": "nat.unpair_left_le", "description": ""}, {"name": "set.Union_unpair_prod", "description": ""}, {"name": "nat.mkpair_lt_mkpair_left", "description": ""}, {"name": "nat.mkpair_unpair'", "description": ""}, {"name": "infi_unpair", "description": ""}, {"name": "nat.mkpair_equiv_symm_apply", "description": ""}, {"name": "nat.mkpair_equiv_apply", "description": ""}, {"name": "nat.right_le_mkpair", "description": ""}, {"name": "nat.unpair_mkpair", "description": ""}, {"name": "nat.le_total", "description": ""}, {"name": "nat.eq_zero_of_add_eq_zero", "description": ""}, {"name": "nat.pred_zero", "description": ""}, {"name": "nat.sub_succ", "description": ""}, {"name": "nat.pos_of_ne_zero", "description": ""}, {"name": "nat.mod_lt", "description": ""}, {"name": "nat.eq_zero_or_eq_succ_pred", "description": ""}, {"name": "nat.div_eq_of_lt", "description": ""}, {"name": "nat.one_ne_zero", "description": ""}, {"name": "nat.lt_le_antisymm", "description": ""}, {"name": "nat.lt_of_add_lt_add_right", "description": ""}, {"name": "nat.add_right_cancel", "description": ""}, {"name": "nat.lt.step", "description": ""}, {"name": "nat.add_mul_mod_self_right", "description": ""}, {"name": "nat.one_lt_bit0", "description": ""}, {"name": "nat.succ_lt_succ", "description": ""}, {"name": "nat.add_one_ne_zero", "description": ""}, {"name": "nat.lt_asymm", "description": ""}, {"name": "nat.mul_one", "description": ""}, {"name": "nat.mul_div_mul", "description": ""}, {"name": "nat.eq_zero_of_add_eq_zero_left", "description": ""}, {"name": "nat.succ_sub_sub_succ", "description": ""}, {"name": "nat.mul_div_assoc", "description": ""}, {"name": "nat.dvd_trans", "description": ""}, {"name": "nat.le_add_left", "description": ""}, {"name": "nat.lt_or_ge", "description": ""}, {"name": "nat.div_def", "description": ""}, {"name": "nat.sub_eq_zero_of_le", "description": ""}, {"name": "nat.sub_sub_self", "description": ""}, {"name": "nat.add_div_left", "description": ""}, {"name": "nat.sub_le_sub_left", "description": ""}, {"name": "nat.succ_mul_succ_eq", "description": ""}, {"name": "nat.add_mul_div_right", "description": ""}, {"name": "nat.eq_zero_of_zero_dvd", "description": ""}, {"name": "nat.zero_lt_one", "description": ""}, {"name": "nat.add_right_comm", "description": ""}, {"name": "nat.lt_trichotomy", "description": ""}, {"name": "nat.bit1_lt", "description": ""}, {"name": "nat.find_min'", "description": ""}, {"name": "nat.lt_add_of_pos_left", "description": ""}, {"name": "nat.mul_div_right", "description": ""}, {"name": "nat.mul_lt_mul'", "description": ""}, {"name": "nat.mod_one", "description": ""}, {"name": "nat.strong_induction_on", "description": ""}, {"name": "nat.eq_zero_or_pos", "description": ""}, {"name": "nat.pred_lt_pred", "description": ""}, {"name": "nat.lt_ge_by_cases", "description": ""}, {"name": "nat.find_min", "description": ""}, {"name": "nat.add_mul_div_left", "description": ""}, {"name": "nat.add_lt_add", "description": ""}, {"name": "nat.add_self_ne_one", "description": ""}, {"name": "nat.sub_eq_iff_eq_add", "description": ""}, {"name": "nat.le_of_eq", "description": ""}, {"name": "nat.sub_eq_sub_min", "description": ""}, {"name": "nat.sub_mul_mod", "description": ""}, {"name": "nat.mul_assoc", "description": ""}, {"name": "nat.sub_induction", "description": ""}, {"name": "nat.zero_mul", "description": ""}, {"name": "nat.succ_add_eq_succ_add", "description": ""}, {"name": "nat.bit0_inj", "description": ""}, {"name": "nat.mod_eq_of_lt", "description": ""}, {"name": "nat.add_comm", "description": ""}, {"name": "nat.one_le_bit0", "description": ""}, {"name": "nat.lt_of_sub_eq_succ", "description": ""}, {"name": "nat.one_le_bit1", "description": ""}, {"name": "nat.mul_le_mul_left", "description": ""}, {"name": "nat.linear_order", "description": ""}, {"name": "nat.le_lt_antisymm", "description": ""}, {"name": "nat.add_sub_assoc", "description": ""}, {"name": "nat.add_sub_cancel", "description": ""}, {"name": "nat.mul_zero", "description": ""}, {"name": "nat.mul_le_mul_of_nonneg_left", "description": ""}, {"name": "nat.div_le_of_le_mul", "description": ""}, {"name": "nat.lt_add_of_pos_right", "description": ""}, {"name": "nat.sub_pos_of_lt", "description": ""}, {"name": "nat.mul_mod_mul_left", "description": ""}, {"name": "nat.mod_le", "description": ""}, {"name": "nat.add_le_add_right", "description": ""}, {"name": "nat.zero_sub", "description": ""}, {"name": "nat.div_mul_cancel", "description": ""}, {"name": "nat.eq_zero_of_mul_eq_zero", "description": ""}, {"name": "nat.pos_of_dvd_of_pos", "description": ""}, {"name": "nat.lt_by_cases", "description": ""}, {"name": "nat.div_eq_of_eq_mul_right", "description": ""}, {"name": "nat.mul_div_cancel'", "description": ""}, {"name": "nat.mul_le_mul", "description": ""}, {"name": "nat.succ_sub_succ", "description": ""}, {"name": "nat.sub_self", "description": ""}, {"name": "nat.one_ne_bit1", "description": ""}, {"name": "nat.add_left_cancel", "description": ""}, {"name": "nat.zero_mod", "description": ""}, {"name": "nat.sub_lt_of_pos_le", "description": ""}, {"name": "nat.add_mod_right", "description": ""}, {"name": "nat.add_sub_add_right", "description": ""}, {"name": "nat.le_of_add_le_add_right", "description": ""}, {"name": "nat.add_sub_cancel_left", "description": ""}, {"name": "nat.bit1_ne_bit0", "description": ""}, {"name": "nat.eq_zero_of_le_zero", "description": ""}, {"name": "nat.mul_pos", "description": ""}, {"name": "nat.le_of_succ_le", "description": ""}, {"name": "nat.mul_pred_left", "description": ""}, {"name": "nat.zero_ne_bit1", "description": ""}, {"name": "nat.dvd_add_iff_right", "description": ""}, {"name": "nat.find", "description": "If `p` is a (decidable) predicate on `\u2115` and `hp : \u2203 (n : \u2115), p n` is a proof that\nthere exists some natural number satisfying `p`, then `nat.find hp` is the\nsmallest natural number satisfying `p`. Note that `nat.find` is protected,\nmeaning that you can't just write `find`, even if the `nat` namespace is open.\n\nThe API for `nat.find` is:\n\n* `nat.find_spec` is the proof that `nat.find hp` satisfies `p`.\n* `nat.find_min` is the proof that if `m < nat.find hp` then `m` does not satisfy `p`.\n* `nat.find_min'` is the proof that if `m` does satisfy `p` then `nat.find hp \u2264 m`."}, {"name": "nat.dvd_mod_iff", "description": ""}, {"name": "nat.dvd_sub", "description": ""}, {"name": "nat.dvd_add", "description": ""}, {"name": "nat.add_le_add_iff_right", "description": ""}, {"name": "nat.lt_succ_of_lt", "description": ""}, {"name": "nat.eq_one_of_dvd_one", "description": ""}, {"name": "nat.iterate", "description": ""}, {"name": "nat.case_strong_induction_on", "description": ""}, {"name": "nat.le.intro", "description": ""}, {"name": "nat.sub_self_add", "description": ""}, {"name": "nat.discriminate", "description": ""}, {"name": "nat.mul_lt_mul_of_pos_left", "description": ""}, {"name": "nat.sub_one_sub_lt", "description": ""}, {"name": "nat.mul_le_mul_right", "description": ""}, {"name": "nat.add_lt_add_right", "description": ""}, {"name": "nat.le_add_right", "description": ""}, {"name": "nat.dvd_of_mul_dvd_mul_right", "description": ""}, {"name": "nat.zero_min", "description": ""}, {"name": "nat.succ_ne_zero", "description": ""}, {"name": "nat.mul_mod_left", "description": ""}, {"name": "nat.add_div_right", "description": ""}, {"name": "nat.mul_lt_mul_of_pos_right", "description": ""}, {"name": "nat.div_lt_self", "description": ""}, {"name": "nat.mul_mod_right", "description": ""}, {"name": "nat.lt_iff_le_not_le", "description": ""}, {"name": "nat.mul_succ", "description": ""}, {"name": "nat.mod_zero", "description": ""}, {"name": "nat.le_succ_of_pred_le", "description": ""}, {"name": "nat.bit0_lt", "description": ""}, {"name": "nat.mul_div_left", "description": ""}, {"name": "nat.dvd_mul_right", "description": ""}, {"name": "nat.div_eq_of_lt_le", "description": ""}, {"name": "nat.le.dest", "description": ""}, {"name": "nat.one_succ_zero", "description": ""}, {"name": "nat.dvd_iff_mod_eq_zero", "description": ""}, {"name": "nat.mul_sub_left_distrib", "description": ""}, {"name": "nat.mul_pred_right", "description": ""}, {"name": "nat.one_pos", "description": ""}, {"name": "nat.bit0_ne_one", "description": ""}, {"name": "nat.sub_add_comm", "description": ""}, {"name": "nat.succ_sub", "description": ""}, {"name": "nat.div_le_self", "description": ""}, {"name": "nat.le_of_le_of_sub_le_sub_right", "description": ""}, {"name": "nat.le_sub_iff_right", "description": ""}, {"name": "nat.sub_mul_div", "description": ""}, {"name": "nat.bit0_ne_bit1", "description": ""}, {"name": "nat.exists_eq_succ_of_ne_zero", "description": ""}, {"name": "nat.sub.right_comm", "description": ""}, {"name": "nat.left_distrib", "description": ""}, {"name": "nat.mod_self", "description": ""}, {"name": "nat.mul_le_mul_of_nonneg_right", "description": ""}, {"name": "nat.le_succ_of_le", "description": ""}, {"name": "nat.strong_rec_on", "description": ""}, {"name": "nat.add_mod_left", "description": ""}, {"name": "nat.lt_of_le_and_ne", "description": ""}, {"name": "nat.right_distrib", "description": ""}, {"name": "nat.one_ne_bit0", "description": ""}, {"name": "nat.bit1_inj", "description": ""}, {"name": "nat.eq_or_lt_of_not_lt", "description": ""}, {"name": "nat.le_of_lt_succ", "description": ""}, {"name": "nat.zero_ne_one", "description": ""}, {"name": "nat.sub_sub", "description": ""}, {"name": "nat.lt_of_add_lt_add_left", "description": ""}, {"name": "nat.bit0_lt_bit1", "description": ""}, {"name": "nat.sub_zero", "description": ""}, {"name": "nat.mul_sub_right_distrib", "description": ""}, {"name": "nat.sub_add_min_cancel", "description": ""}, {"name": "nat.lt_of_succ_lt", "description": ""}, {"name": "nat.add_le_add_left", "description": ""}, {"name": "nat.le_of_sub_eq_zero", "description": ""}, {"name": "nat.succ_ne_self", "description": ""}, {"name": "nat.mul_self_sub_mul_self_eq", "description": ""}, {"name": "nat.zero_ne_bit0", "description": ""}, {"name": "nat.div_eq_sub_div", "description": ""}, {"name": "nat.lt_of_le_of_lt", "description": ""}, {"name": "nat.dvd_of_mod_eq_zero", "description": ""}, {"name": "nat.zero_div", "description": ""}, {"name": "nat.bit1_eq_succ_bit0", "description": ""}, {"name": "nat.mod_add_div", "description": ""}, {"name": "nat.two_step_induction", "description": ""}, {"name": "nat.mod_eq_sub_mod", "description": ""}, {"name": "nat.mul_div_cancel_left", "description": ""}, {"name": "nat.dvd_of_mul_dvd_mul_left", "description": ""}, {"name": "nat.min_zero", "description": ""}, {"name": "nat.succ_mul", "description": ""}, {"name": "nat.le_of_add_le_add_left", "description": ""}, {"name": "nat.find_spec", "description": ""}, {"name": "nat.div_self", "description": ""}, {"name": "nat.sub_le_sub_right", "description": ""}, {"name": "nat.div_mul_le_self", "description": ""}, {"name": "nat.bit1_ne_one", "description": ""}, {"name": "nat.sub_eq_zero_iff_le", "description": ""}, {"name": "nat.div_eq_of_eq_mul_left", "description": ""}, {"name": "nat.le_of_dvd", "description": ""}, {"name": "nat.mod_two_eq_zero_or_one", "description": ""}, {"name": "nat.mul_comm", "description": ""}, {"name": "nat.mul_lt_mul", "description": ""}, {"name": "nat.add_le_add", "description": ""}, {"name": "nat.eq_of_mul_eq_mul_left", "description": ""}, {"name": "nat.add_mul_mod_self_left", "description": ""}, {"name": "nat.lt_of_succ_le", "description": ""}, {"name": "nat.pred_inj", "description": ""}, {"name": "nat.bit1_succ_eq", "description": ""}, {"name": "nat.succ_le_of_lt", "description": ""}, {"name": "nat.sub_one", "description": ""}, {"name": "nat.bit1_ne", "description": ""}, {"name": "nat.add_left_comm", "description": ""}, {"name": "nat.add_lt_add_left", "description": ""}, {"name": "nat.one_mul", "description": ""}, {"name": "nat.succ_sub_one", "description": ""}, {"name": "nat.mod_def", "description": ""}, {"name": "nat.add_sub_of_le", "description": ""}, {"name": "nat.one_lt_bit1", "description": ""}, {"name": "nat.le_div_iff_mul_le", "description": ""}, {"name": "nat.div_lt_iff_lt_mul", "description": ""}, {"name": "nat.decidable_dvd", "description": ""}, {"name": "nat.lt_succ_self", "description": ""}, {"name": "nat.lt_of_succ_lt_succ", "description": ""}, {"name": "nat.sub_lt_succ", "description": ""}, {"name": "nat.bit0_ne", "description": ""}, {"name": "nat.sub_add_cancel", "description": ""}, {"name": "nat.dvd_add_iff_left", "description": ""}, {"name": "nat.pred_succ", "description": ""}, {"name": "nat.bit1_lt_bit0", "description": ""}, {"name": "nat.mul_mod_mul_right", "description": ""}, {"name": "nat.sub_le_sub_iff_right", "description": ""}, {"name": "nat.div_zero", "description": ""}, {"name": "nat.min_succ_succ", "description": ""}, {"name": "nat.cond_to_bool_mod_two", "description": ""}, {"name": "nat.div_div_eq_div_mul", "description": ""}, {"name": "nat.mul_sub_div", "description": ""}, {"name": "nat.find_x", "description": ""}, {"name": "nat.le_of_mul_le_mul_left", "description": ""}, {"name": "nat.div_one", "description": ""}, {"name": "nat.lt.base", "description": ""}, {"name": "nat.lt_trans", "description": ""}, {"name": "nat.succ_pred_eq_of_pos", "description": ""}, {"name": "nat.le_of_lt", "description": ""}, {"name": "nat.mod_eq_zero_of_dvd", "description": ""}, {"name": "nat.dvd_antisymm", "description": ""}, {"name": "nat.add_assoc", "description": ""}, {"name": "nat.add_sub_add_left", "description": ""}, {"name": "nat.mul_div_cancel", "description": ""}, {"name": "nat.eq_zero_of_add_eq_zero_right", "description": ""}, {"name": "nat.le_antisymm", "description": ""}, {"name": "list.enum", "description": ""}, {"name": "bin_tree.to_list", "description": ""}, {"name": "list.join", "description": ""}, {"name": "list.union", "description": ""}, {"name": "list.reverse", "description": ""}, {"name": "list.repeat", "description": ""}, {"name": "list.head", "description": ""}, {"name": "list.ilast", "description": ""}, {"name": "list.all", "description": ""}, {"name": "list.is_prefix_of", "description": "`is_prefix_of l\u2081 l\u2082` returns `tt` iff `l\u2081` is a prefix of `l\u2082`."}, {"name": "list.intersperse", "description": ""}, {"name": "list.filter", "description": ""}, {"name": "list.drop_while", "description": ""}, {"name": "list.lt", "description": ""}, {"name": "list.update_nth", "description": ""}, {"name": "list.insert", "description": ""}, {"name": "list.decidable_mem", "description": ""}, {"name": "list.zip_with", "description": ""}, {"name": "list.range_core", "description": ""}, {"name": "list.band", "description": ""}, {"name": "list.intercalate", "description": ""}, {"name": "list.append", "description": ""}, {"name": "list.unzip", "description": ""}, {"name": "list.remove_all", "description": ""}, {"name": "list.empty", "description": ""}, {"name": "list.has_dec_eq", "description": ""}, {"name": "list.take", "description": ""}, {"name": "list.map_with_index", "description": " Given a function `f : \u2115 \u2192 \u03b1 \u2192 \u03b2` and `as : list \u03b1`, `as = [a\u2080, a\u2081, ...]`, returns the list\n`[f 0 a\u2080, f 1 a\u2081, ...]`."}, {"name": "list.map\u2082", "description": ""}, {"name": "list.length", "description": ""}, {"name": "list.enum_from", "description": ""}, {"name": "list.has_emptyc", "description": ""}, {"name": "list.nth_le", "description": ""}, {"name": "list.has_singleton", "description": ""}, {"name": "list.lt_eq_not_ge", "description": ""}, {"name": "list.partition", "description": ""}, {"name": "list.reverse_core", "description": ""}, {"name": "list.has_decidable_le", "description": ""}, {"name": "list.range", "description": ""}, {"name": "list.nth", "description": ""}, {"name": "list.map_with_index_core", "description": ""}, {"name": "list.tail", "description": ""}, {"name": "list.bor", "description": ""}, {"name": "list.last", "description": ""}, {"name": "list.is_suffix_of", "description": "`is_suffix_of l\u2081 l\u2082` returns `tt` iff `l\u2081` is a suffix of `l\u2082`."}, {"name": "list.zip", "description": ""}, {"name": "list.init", "description": ""}, {"name": "list.has_append", "description": ""}, {"name": "list.after", "description": "`after p xs` is the suffix of `xs` after the first element that satisfies\n `p`, not including that element.\n\n ```lean\n after      (eq 1)       [0, 1, 2, 3] = [2, 3]\n drop_while (not \u2218 eq 1) [0, 1, 2, 3] = [1, 2, 3]\n ```"}, {"name": "list.has_le", "description": ""}, {"name": "list.has_union", "description": ""}, {"name": "list.ret", "description": ""}, {"name": "list.inter", "description": ""}, {"name": "list.has_mem", "description": ""}, {"name": "list.decidable_eq", "description": ""}, {"name": "list.has_lt", "description": ""}, {"name": "list.remove_nth", "description": ""}, {"name": "list.has_decidable_lt", "description": ""}, {"name": "list.span", "description": ""}, {"name": "list.iota", "description": ""}, {"name": "list.bag_inter", "description": ""}, {"name": "list.index_of", "description": ""}, {"name": "list.is_lawful_singleton", "description": ""}, {"name": "list.erase", "description": ""}, {"name": "list.find_index", "description": ""}, {"name": "list.has_insert", "description": ""}, {"name": "list.inhabited", "description": ""}, {"name": "list.drop", "description": ""}, {"name": "list.foldl", "description": ""}, {"name": "list.foldr", "description": ""}, {"name": "list.mem", "description": ""}, {"name": "list.diff", "description": ""}, {"name": "list.filter_map", "description": ""}, {"name": "list.any", "description": ""}, {"name": "list.map", "description": ""}, {"name": "list.le", "description": ""}, {"name": "list.le_eq_not_gt", "description": ""}, {"name": "list.has_inter", "description": ""}, {"name": "list.bind", "description": ""}, {"name": "set.image_sigma_mk_preimage_sigma_map", "description": ""}, {"name": "set.sigma_insert", "description": ""}, {"name": "set.sigma_eq_empty_iff", "description": ""}, {"name": "set.nonempty.sigma", "description": ""}, {"name": "set.sigma_empty", "description": ""}, {"name": "set.mk_preimage_sigma_eq_empty", "description": ""}, {"name": "set.sigma_mono", "description": ""}, {"name": "set.fst_image_sigma_subset", "description": ""}, {"name": "set.mk_mem_sigma", "description": ""}, {"name": "set.sigma_union", "description": ""}, {"name": "set.fst_image_sigma", "description": ""}, {"name": "set.mem_sigma_iff", "description": ""}, {"name": "set.sigma_singleton", "description": ""}, {"name": "set.image_sigma_mk_subset_sigma_right", "description": ""}, {"name": "set.mk_sigma_iff", "description": ""}, {"name": "set.singleton_sigma_singleton", "description": ""}, {"name": "set.sigma_diff_sigma", "description": ""}, {"name": "set.exists_sigma_iff", "description": ""}, {"name": "set.preimage_image_sigma_mk_of_ne", "description": ""}, {"name": "set.sigma_subset_iff", "description": ""}, {"name": "set.nonempty.sigma_fst", "description": ""}, {"name": "set.singleton_sigma", "description": ""}, {"name": "set.empty_sigma", "description": ""}, {"name": "set.sigma", "description": " Indexed sum of sets. `s.sigma t` is the set of dependent pairs `\u27e8i, a\u27e9` such that `i \u2208 s` and\n`a \u2208 t i`."}, {"name": "set.sigma_inter_sigma", "description": ""}, {"name": "set.sigma_preimage_eq", "description": ""}, {"name": "set.preimage_sigma_map_sigma", "description": ""}, {"name": "set.forall_sigma_iff", "description": ""}, {"name": "set.image_sigma_mk_preimage_sigma_map_subset", "description": ""}, {"name": "set.univ_sigma_univ", "description": ""}, {"name": "set.mk_preimage_sigma_eq_if", "description": ""}, {"name": "set.mk_preimage_sigma_fn_eq_if", "description": ""}, {"name": "set.sigma_univ_range_eq", "description": ""}, {"name": "set.image_sigma_mk_subset_sigma_left", "description": ""}, {"name": "set.sigma_preimage_left", "description": ""}, {"name": "set.sigma_nonempty_iff", "description": ""}, {"name": "set.union_sigma", "description": ""}, {"name": "set.range_sigma_mk", "description": ""}, {"name": "set.sigma_preimage_right", "description": ""}, {"name": "set.mk_preimage_sigma", "description": ""}, {"name": "set.sigma_univ", "description": ""}, {"name": "set.nonempty.sigma_snd", "description": ""}, {"name": "set.sigma_subset_preimage_fst", "description": ""}, {"name": "set.insert_sigma", "description": ""}, {"name": "transitive.comap", "description": ""}, {"name": "relation.trans_gen.trans_right", "description": ""}, {"name": "relation.flip_comp", "description": ""}, {"name": "reflexive.comap", "description": ""}, {"name": "relation.trans_gen.head_induction_on", "description": ""}, {"name": "relation.refl_trans_gen.cases_head", "description": ""}, {"name": "relation.refl_trans_gen_iff_eq_or_trans_gen", "description": ""}, {"name": "relation.trans_gen.trans", "description": ""}, {"name": "relation.refl_trans_gen.is_refl", "description": ""}, {"name": "is_refl.reflexive", "description": ""}, {"name": "flip_eq_iff", "description": ""}, {"name": "relation.trans_gen_idem", "description": ""}, {"name": "relation.trans_gen.swap", "description": ""}, {"name": "relation.refl_gen.is_refl", "description": ""}, {"name": "relation.join_of_equivalence", "description": ""}, {"name": "relation.comp", "description": "The composition of two relations, yielding a new relation.  The result\nrelates a term of `\u03b1` and a term of `\u03b3` if there is an intermediate\nterm of `\u03b2` related to both."}, {"name": "relation.equivalence_join_refl_trans_gen", "description": ""}, {"name": "relation.comp_eq", "description": ""}, {"name": "relation.trans_gen.lift", "description": ""}, {"name": "relation.trans_gen.mono", "description": ""}, {"name": "reflexive.ne_imp_iff", "description": " If a reflexive relation `r : \u03b1 \u2192 \u03b1 \u2192 Prop` holds over `x y : \u03b1`,\nthen it holds whether or not `x \u2260 y`."}, {"name": "relation.refl_trans_gen_eq_self", "description": ""}, {"name": "relation.trans_gen.closed", "description": ""}, {"name": "relation.trans_gen.tail'", "description": ""}, {"name": "relation.refl_trans_gen.cases_head_iff", "description": ""}, {"name": "reflexive.rel_of_ne_imp", "description": " To show a reflexive relation `r : \u03b1 \u2192 \u03b1 \u2192 Prop` holds over `x y : \u03b1`,\nit suffices to show it holds when `x \u2260 y`."}, {"name": "relation.reflexive_refl_trans_gen", "description": ""}, {"name": "equivalence.comap", "description": ""}, {"name": "equivalence.eqv_gen_eq", "description": ""}, {"name": "relation.trans_gen.head", "description": ""}, {"name": "relation.refl_trans_gen.head_induction_on", "description": ""}, {"name": "relation.refl_trans_gen_iff_eq", "description": ""}, {"name": "eqv_gen.mono", "description": ""}, {"name": "relation.refl_trans_gen.trans", "description": ""}, {"name": "relation.map", "description": "The map of a relation `r` through a pair of functions pushes the\nrelation to the codomains of the functions.  The resulting relation is\ndefined by having pairs of terms related if they have preimages\nrelated by `r`."}, {"name": "relation.eq_comp", "description": ""}, {"name": "relation.refl_trans_gen.head", "description": ""}, {"name": "relation.refl_trans_gen.cases_tail", "description": ""}, {"name": "symmetric.comap", "description": ""}, {"name": "relation.refl_gen.mono", "description": ""}, {"name": "relation.trans_gen.is_trans", "description": ""}, {"name": "relation.comp_iff", "description": ""}, {"name": "relation.refl_trans_gen_of_transitive_reflexive", "description": ""}, {"name": "relation.refl_gen", "description": "`refl_gen r`: reflexive closure of `r`"}, {"name": "relation.refl_gen.refl", "description": "`refl_gen r`: reflexive closure of `r`"}, {"name": "relation.refl_gen.single", "description": "`refl_gen r`: reflexive closure of `r`"}, {"name": "relation.join_of_single", "description": ""}, {"name": "relation.trans_gen", "description": "`trans_gen r`: transitive closure of `r`"}, {"name": "relation.trans_gen.single", "description": "`trans_gen r`: transitive closure of `r`"}, {"name": "relation.trans_gen.tail", "description": "`trans_gen r`: transitive closure of `r`"}, {"name": "relation.church_rosser", "description": "A sufficient condition for the Church-Rosser property."}, {"name": "relation.refl_trans_gen_closed", "description": ""}, {"name": "relation.refl_trans_gen_of_equivalence", "description": ""}, {"name": "relation.join", "description": "The join of a relation on a single type is a new relation for which\npairs of terms are related if there is a third term they are both\nrelated to.  For example, if `r` is a relation representing rewrites\nin a term rewriting system, then *confluence* is the property that if\n`a` rewrites to both `b` and `c`, then `join r` relates `b` and `c`\n(see `relation.church_rosser`)."}, {"name": "relation.trans_gen.to_refl", "description": ""}, {"name": "swap_eq_iff", "description": ""}, {"name": "relation.iff_comp", "description": ""}, {"name": "relation.trans_gen.head'_iff", "description": ""}, {"name": "relation.refl_trans_gen", "description": "`refl_trans_gen r`: reflexive transitive closure of `r`"}, {"name": "relation.refl_trans_gen.refl", "description": "`refl_trans_gen r`: reflexive transitive closure of `r`"}, {"name": "relation.refl_trans_gen.tail", "description": "`refl_trans_gen r`: reflexive transitive closure of `r`"}, {"name": "relation.refl_trans_gen_idem", "description": ""}, {"name": "relation.refl_gen.to_refl_trans_gen", "description": ""}, {"name": "relation.trans_gen.head'", "description": ""}, {"name": "relation.refl_trans_gen.total_of_right_unique", "description": ""}, {"name": "relation.trans_gen_swap", "description": ""}, {"name": "relation.refl_trans_gen.lift", "description": ""}, {"name": "relation.refl_trans_gen.trans_induction_on", "description": ""}, {"name": "relation.refl_gen_iff", "description": ""}, {"name": "well_founded.trans_gen", "description": ""}, {"name": "relation.trans_gen.trans_induction_on", "description": ""}, {"name": "relation.reflexive_join", "description": ""}, {"name": "relation.transitive_join", "description": ""}, {"name": "relation.transitive_refl_trans_gen", "description": ""}, {"name": "relation.refl_trans_gen.symmetric", "description": ""}, {"name": "relation.refl_trans_gen.lift'", "description": ""}, {"name": "relation.trans_gen.lift'", "description": ""}, {"name": "equivalence.eqv_gen_iff", "description": ""}, {"name": "relation.trans_gen.tail'_iff", "description": ""}, {"name": "symmetric.iff", "description": ""}, {"name": "relation.transitive_trans_gen", "description": ""}, {"name": "relation.refl_trans_gen.swap", "description": ""}, {"name": "relation.trans_gen_eq_self", "description": ""}, {"name": "relation.refl_trans_gen.mono", "description": ""}, {"name": "reflexive_ne_imp_iff", "description": " If a reflexive relation `r : \u03b1 \u2192 \u03b1 \u2192 Prop` holds over `x y : \u03b1`,\nthen it holds whether or not `x \u2260 y`. Unlike `reflexive.ne_imp_iff`, this uses `[is_refl \u03b1 r]`."}, {"name": "relation.refl_trans_gen.is_trans", "description": ""}, {"name": "relation.equivalence_join", "description": ""}, {"name": "relation.trans_gen.trans_left", "description": ""}, {"name": "relation.symmetric_join", "description": ""}, {"name": "acc.trans_gen", "description": ""}, {"name": "relation.trans_gen_iff", "description": ""}, {"name": "relation.refl_trans_gen.cases_tail_iff", "description": ""}, {"name": "relation.refl_trans_gen.single", "description": ""}, {"name": "symmetric.flip_eq", "description": ""}, {"name": "symmetric.swap_eq", "description": ""}, {"name": "relation.comp_assoc", "description": ""}, {"name": "relation.refl_trans_gen_swap", "description": ""}, {"name": "order_iso.map_inf", "description": ""}, {"name": "order_iso.fun_unique_symm_apply", "description": ""}, {"name": "order_hom.prod_iso", "description": " Order isomorphism between the space of monotone maps to `\u03b2 \u00d7 \u03b3` and the product of the spaces\nof monotone maps to `\u03b2` and `\u03b3`."}, {"name": "order_hom.has_coe_to_fun", "description": " Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`\ndirectly."}, {"name": "order_hom.with_top_map", "description": "Lift an order homomorphism `f : \u03b1 \u2192o \u03b2` to an order homomorphism `with_top \u03b1 \u2192o with_top \u03b2`."}, {"name": "order_hom.prod\u2098_coe_coe_coe", "description": ""}, {"name": "order_iso.to_fun_eq_coe", "description": ""}, {"name": "order_embedding.monotone", "description": ""}, {"name": "order_hom.fst", "description": "`prod.fst` as a `order_hom`."}, {"name": "order_hom.pi_iso_symm_apply", "description": ""}, {"name": "order_hom.comp_mono", "description": ""}, {"name": "order_hom.snd", "description": "`prod.snd` as a `order_hom`."}, {"name": "order_hom.snd_comp_prod", "description": ""}, {"name": "order_iso.map_sup", "description": ""}, {"name": "with_top.to_dual_bot_coe", "description": ""}, {"name": "order_hom.ext", "description": ""}, {"name": "order_hom.const_coe_coe", "description": ""}, {"name": "order_iso.lt_iff_lt", "description": ""}, {"name": "order_hom.dual", "description": "Reinterpret a bundled monotone function as a monotone function between dual orders."}, {"name": "order_hom.subtype.val_coe", "description": ""}, {"name": "order_iso.compl_apply", "description": ""}, {"name": "order_iso.symm_symm", "description": ""}, {"name": "order_iso.with_bot_congr_symm", "description": ""}, {"name": "order_iso.fun_unique", "description": "Order isomorphism between `\u03b1 \u2192 \u03b2` and `\u03b2`, where `\u03b1` has a unique element."}, {"name": "order_embedding.to_order_hom", "description": "Convert an `order_embedding` to a `order_hom`."}, {"name": "order_hom.dual_iso", "description": "`order_hom.dual` as an order isomorphism."}, {"name": "order_hom.id_coe", "description": ""}, {"name": "order_hom.comp_const", "description": ""}, {"name": "order_hom_class.monotone", "description": ""}, {"name": "map_lt_map_iff", "description": ""}, {"name": "codisjoint.map_order_iso", "description": "Note that this goal could also be stated `(codisjoint on f) a b`"}, {"name": "order_hom.id", "description": "The identity function as bundled monotone function."}, {"name": "codisjoint_map_order_iso_iff", "description": ""}, {"name": "order_iso.symm_image_image", "description": ""}, {"name": "order_hom.const", "description": "Constant function bundled as a `order_hom`."}, {"name": "order_hom.fst_prod_snd", "description": ""}, {"name": "order_hom.coe_fn_hom_coe", "description": ""}, {"name": "order_hom.subtype.val", "description": "`subtype.val` as a bundled monotone function."}, {"name": "order_iso", "description": " An order isomorphism is an equivalence such that `a \u2264 b \u2194 (f a) \u2264 (f b)`.\nThis definition is an abbreviation of `rel_iso (\u2264) (\u2264)`."}, {"name": "order_hom.fst_comp_prod", "description": ""}, {"name": "order_iso.to_order_embedding", "description": "Reinterpret an order isomorphism as an order embedding."}, {"name": "rel_embedding.order_embedding_of_lt_embedding_apply", "description": ""}, {"name": "order_hom.unique", "description": "There is a unique monotone map from a subsingleton to itself."}, {"name": "order_iso.apply_eq_iff_eq_symm_apply", "description": ""}, {"name": "order_iso.dual", "description": "An order isomorphism is also an order isomorphism between dual orders."}, {"name": "order_iso.ext", "description": ""}, {"name": "order_embedding.well_founded", "description": ""}, {"name": "order_iso.symm_apply_apply", "description": ""}, {"name": "order_iso.map_top'", "description": ""}, {"name": "order_hom.with_top_map_coe", "description": ""}, {"name": "order_iso.image_symm_image", "description": ""}, {"name": "order_iso.is_compl_iff", "description": ""}, {"name": "order_hom.symm_dual_id", "description": ""}, {"name": "order_hom.dual_apply_coe", "description": ""}, {"name": "order_hom.mono", "description": ""}, {"name": "order_iso.trans_refl", "description": ""}, {"name": "order_hom.prod\u2098", "description": " Given two bundled monotone maps `f`, `g`, `f.prod g` is the map `x \u21a6 (f x, g x)` bundled as a\n`order_hom`. This is a fully bundled version."}, {"name": "order_embedding.with_bot_map", "description": "A version of `with_bot.map` for order embeddings."}, {"name": "order_hom.order_hom_eq_id", "description": ""}, {"name": "with_top.to_dual_bot", "description": "Taking the dual then adding `\u22a4` is the same as adding `\u22a5` then taking the dual."}, {"name": "order_embedding.lt_embedding_apply", "description": ""}, {"name": "order_iso.trans", "description": "Composition of two order isomorphisms is an order isomorphism."}, {"name": "disjoint.map_order_iso", "description": "Note that this goal could also be stated `(disjoint on f) a b`"}, {"name": "order_hom.prod", "description": " Given two bundled monotone maps `f`, `g`, `f.prod g` is the map `x \u21a6 (f x, g x)` bundled as a\n`order_hom`."}, {"name": "order_hom.curry_apply", "description": ""}, {"name": "order_embedding.with_top_map_apply", "description": ""}, {"name": "order_iso.with_top_congr_apply", "description": ""}, {"name": "disjoint_map_order_iso_iff", "description": ""}, {"name": "order_iso.preimage_image", "description": ""}, {"name": "order_hom.pi", "description": " Construct a bundled monotone map `\u03b1 \u2192o \u03a0 i, \u03c0 i` from a family of monotone maps\n`f i : \u03b1 \u2192o \u03c0 i`."}, {"name": "order_hom.apply", "description": " Function application `\u03bb f, f a` (for fixed `a`) is a monotone function from the\nmonotone function space `\u03b1 \u2192o \u03b2` to `\u03b2`. See also `pi.eval_order_hom`."}, {"name": "order_iso.with_bot_congr_trans", "description": ""}, {"name": "order_iso.is_complemented", "description": ""}, {"name": "order_hom_class", "description": "`order_hom_class F \u03b1 b` asserts that `F` is a type of `\u2264`-preserving morphisms."}, {"name": "order_embedding.map_inf_le", "description": ""}, {"name": "strict_mono.order_iso_apply", "description": ""}, {"name": "order_embedding.coe_of_strict_mono", "description": ""}, {"name": "order_iso.refl", "description": "Identity order isomorphism."}, {"name": "order_hom.prod_mono", "description": ""}, {"name": "strict_mono.order_iso", "description": " A strictly monotone function from a linear order is an order isomorphism between its domain and\nits range."}, {"name": "order_hom.comp", "description": "The composition of two bundled monotone functions."}, {"name": "order_iso.symm_apply_le", "description": ""}, {"name": "order_iso.bijective", "description": ""}, {"name": "order_hom.on_diag_coe", "description": ""}, {"name": "order_iso.range_eq", "description": ""}, {"name": "order_iso.refl_trans", "description": ""}, {"name": "order_embedding.acc", "description": ""}, {"name": "order_iso.preimage_symm_preimage", "description": ""}, {"name": "rel_embedding.order_embedding_of_lt_embedding", "description": "Embeddings of partial orders that preserve `<` also preserve `\u2264`."}, {"name": "strict_mono.order_iso_of_surjective_self_symm_apply", "description": ""}, {"name": "order_hom.partial_order", "description": ""}, {"name": "order_hom.comp\u2098", "description": "The composition of two bundled monotone functions, a fully bundled version."}, {"name": "order_iso.apply_symm_apply", "description": ""}, {"name": "order_embedding.coe_of_map_le_iff", "description": ""}, {"name": "order_embedding.of_strict_mono", "description": "A strictly monotone map from a linear order is an order embedding. -"}, {"name": "order_hom.diag_coe", "description": ""}, {"name": "order_embedding.dual", "description": "An order embedding is also an order embedding between dual orders."}, {"name": "order_iso.map_bot'", "description": ""}, {"name": "order_iso.has_coe_t", "description": ""}, {"name": "order_embedding.with_top_map", "description": "A version of `with_top.map` for order embeddings."}, {"name": "order_iso.symm", "description": "Inverse of an order isomorphism."}, {"name": "order_iso.of_rel_iso_lt_symm", "description": ""}, {"name": "order_embedding.strict_mono", "description": ""}, {"name": "order_hom.const_comp", "description": ""}, {"name": "strict_mono.order_iso_of_right_inverse", "description": "A strictly monotone function with a right inverse is an order isomorphism."}, {"name": "order_hom.dual_comp", "description": ""}, {"name": "compl_antitone", "description": ""}, {"name": "order_embedding.subtype_apply", "description": ""}, {"name": "order_embedding.of_map_le_iff", "description": "To define an order embedding from a partial order to a preorder it suffices to give a function\ntogether with a proof that it satisfies `f a \u2264 f b \u2194 a \u2264 b`."}, {"name": "strict_mono.order_iso_of_right_inverse_symm_apply", "description": ""}, {"name": "order_iso.with_bot_congr", "description": "A version of `equiv.option_congr` for `with_bot`."}, {"name": "order_iso.set_congr", "description": "Order isomorphism between two equal sets."}, {"name": "order_hom.pi_iso_apply", "description": ""}, {"name": "order_hom.pi_iso", "description": " Order isomorphism between bundled monotone maps `\u03b1 \u2192o \u03a0 i, \u03c0 i` and families of bundled monotone\nmaps `\u03a0 i, \u03b1 \u2192o \u03c0 i`."}, {"name": "order_iso.is_complemented_iff", "description": ""}, {"name": "order_iso.to_rel_iso_lt_of_rel_iso_lt", "description": ""}, {"name": "order_iso.coe_to_order_embedding", "description": ""}, {"name": "order_iso.compl", "description": "Taking complements as an order isomorphism to the order dual."}, {"name": "order_embedding.to_order_hom_coe", "description": ""}, {"name": "order_iso.symm_injective", "description": ""}, {"name": "order_iso.monotone", "description": ""}, {"name": "order_iso.with_bot_congr_refl", "description": ""}, {"name": "order_iso.surjective", "description": ""}, {"name": "order_hom.prod_map", "description": "`prod.map` of two `order_hom`s as a `order_hom`."}, {"name": "order_hom.on_diag", "description": "Restriction of `f : \u03b1 \u2192o \u03b1 \u2192o \u03b2` to the diagonal."}, {"name": "order_iso.dual_dual_apply", "description": ""}, {"name": "order_hom.preorder", "description": "The preorder structure of `\u03b1 \u2192o \u03b2` is pointwise inequality: `f \u2264 g \u2194 \u2200 a, f a \u2264 g a`."}, {"name": "order_hom.order_hom_class", "description": ""}, {"name": "order_iso.dual_dual_symm_apply", "description": ""}, {"name": "order_iso.with_top_congr_trans", "description": ""}, {"name": "order_iso.symm_apply_eq", "description": ""}, {"name": "order_iso.of_hom_inv", "description": "To show that `f : \u03b1 \u2192o \u03b2` and `g : \u03b2 \u2192o \u03b1` make up an order isomorphism it is enough to show\n   that `g` is the inverse of `f`"}, {"name": "pi.eval_order_hom", "description": "Evaluation of an unbundled function at a point (`function.eval`) as a `order_hom`."}, {"name": "order_hom", "description": "Bundled monotone (aka, increasing) function"}, {"name": "order_hom.to_fun", "description": "Bundled monotone (aka, increasing) function"}, {"name": "order_hom.monotone'", "description": "Bundled monotone (aka, increasing) function"}, {"name": "order_iso.fun_unique_apply", "description": ""}, {"name": "rel_hom.to_order_hom", "description": " A bundled expression of the fact that a map between partial orders that is strictly monotone\nis weakly monotone."}, {"name": "order_iso.coe_dual_dual", "description": ""}, {"name": "strict_mono.coe_order_iso_of_surjective", "description": ""}, {"name": "order_iso.dual_dual", "description": "The order isomorphism between a type and its double dual."}, {"name": "order_hom.symm_dual_comp", "description": ""}, {"name": "order_iso.le_symm_apply", "description": ""}, {"name": "order_iso.to_rel_iso_lt", "description": "Converts an `order_iso` into a `rel_iso (<) (<)`."}, {"name": "order_hom.inhabited", "description": ""}, {"name": "order_hom.comp_prod_comp_same", "description": ""}, {"name": "order_iso.coe_dual_dual_symm", "description": ""}, {"name": "order_hom.dual_symm_apply_coe", "description": ""}, {"name": "equiv.coe_to_order_iso", "description": ""}, {"name": "order_iso.prod_comm", "description": "`prod.swap` as an `order_iso`."}, {"name": "order_hom.comp_coe", "description": ""}, {"name": "strict_mono_on.order_iso", "description": " If a function `f` is strictly monotone on a set `s`, then it defines an order isomorphism\nbetween `s` and its image."}, {"name": "order_hom.with_bot_map_coe", "description": ""}, {"name": "order_iso.map_top", "description": ""}, {"name": "order_iso.of_rel_iso_lt", "description": "Converts a `rel_iso (<) (<)` into an `order_iso`."}, {"name": "order_iso.with_top_congr", "description": "A version of `equiv.option_congr` for `with_top`."}, {"name": "with_bot.to_dual_top", "description": "Taking the dual then adding `\u22a5` is the same as adding `\u22a4` then taking the dual."}, {"name": "order_hom.coe_fun_mk", "description": ""}, {"name": "order_hom.with_bot_map", "description": "Lift an order homomorphism `f : \u03b1 \u2192o \u03b2` to an order homomorphism `with_bot \u03b1 \u2192o with_bot \u03b2`."}, {"name": "order_iso.injective", "description": ""}, {"name": "order_iso.image_preimage", "description": ""}, {"name": "order_iso.with_bot_congr_apply", "description": ""}, {"name": "order_iso.refl_to_equiv", "description": ""}, {"name": "order_hom.mk_le_mk", "description": ""}, {"name": "order_embedding.le_map_sup", "description": ""}, {"name": "order_iso.symm_preimage_preimage", "description": ""}, {"name": "order_iso.refl_apply", "description": ""}, {"name": "order_hom.comp_id", "description": ""}, {"name": "equiv.to_order_iso_to_equiv", "description": ""}, {"name": "order_hom.prod_iso_apply", "description": ""}, {"name": "order_hom.curry_symm_apply", "description": ""}, {"name": "order_iso.coe_trans", "description": ""}, {"name": "order_embedding.lt_embedding", "description": "`<` is preserved by order embeddings of preorders."}, {"name": "order_iso.image_eq_preimage", "description": ""}, {"name": "order_embedding.lt_iff_lt", "description": ""}, {"name": "le_map_inv_iff", "description": ""}, {"name": "order_iso.prod_comm_symm", "description": ""}, {"name": "order_hom_class.order_hom.has_coe_t", "description": ""}, {"name": "order_iso.coe_refl", "description": ""}, {"name": "order_embedding", "description": " An order embedding is an embedding `f : \u03b1 \u21aa \u03b2` such that `a \u2264 b \u2194 (f a) \u2264 (f b)`.\nThis definition is an abbreviation of `rel_embedding (\u2264) (\u2264)`."}, {"name": "map_inv_le_iff", "description": ""}, {"name": "order_hom.diag", "description": "Diagonal embedding of `\u03b1` into `\u03b1 \u00d7 \u03b1` as a `order_hom`."}, {"name": "strict_mono.order_iso_of_right_inverse_apply", "description": ""}, {"name": "order_iso.to_equiv_symm", "description": ""}, {"name": "order_iso.map_bot", "description": ""}, {"name": "order_hom.id_comp", "description": ""}, {"name": "order_hom.fst_coe", "description": ""}, {"name": "order_iso.of_cmp_eq_cmp", "description": "To show that `f : \u03b1 \u2192 \u03b2`, `g : \u03b2 \u2192 \u03b1` make up an order isomorphism of linear orders,\n   it suffices to prove `cmp a (g b) = cmp (f a) b`. -"}, {"name": "order_iso.to_rel_iso_lt_apply", "description": ""}, {"name": "with_bot.to_dual_top_coe", "description": ""}, {"name": "order_hom.coe_le_coe", "description": ""}, {"name": "map_inv_lt_iff", "description": ""}, {"name": "strict_mono.order_iso_of_surjective", "description": "A strictly monotone surjective function from a linear order is an order isomorphism."}, {"name": "order_hom.apply_coe", "description": ""}, {"name": "order_iso.to_rel_iso_lt_symm", "description": ""}, {"name": "order_iso.fun_unique_to_equiv", "description": ""}, {"name": "order_iso.coe_prod_comm", "description": ""}, {"name": "order_iso.le_iff_le", "description": ""}, {"name": "order_hom.curry", "description": "Curry/uncurry as an order isomorphism between `\u03b1 \u00d7 \u03b2 \u2192o \u03b3` and `\u03b1 \u2192o \u03b2 \u2192o \u03b3`."}, {"name": "order_iso.set.univ", "description": "Order isomorphism between `univ : set \u03b1` and `\u03b1`."}, {"name": "order_iso.strict_mono", "description": ""}, {"name": "order_iso.of_rel_iso_lt_to_rel_iso_lt", "description": ""}, {"name": "order_hom.to_fun_eq_coe", "description": ""}, {"name": "order_hom.snd_coe", "description": ""}, {"name": "rel_hom.to_order_hom_coe", "description": ""}, {"name": "pi.eval_order_hom_coe", "description": ""}, {"name": "compl_strict_anti", "description": ""}, {"name": "with_bot.to_dual_top_symm_coe", "description": ""}, {"name": "order_hom.prod_map_coe", "description": ""}, {"name": "rel_embedding.to_order_hom_injective", "description": ""}, {"name": "order_iso_class", "description": " `order_iso_class F \u03b1 \u03b2` states that `F` is a type of order isomorphisms.\n\nYou should extend this class when you extend `order_iso`."}, {"name": "order_iso_class.to_equiv_like", "description": " `order_iso_class F \u03b1 \u03b2` states that `F` is a type of order isomorphisms.\n\nYou should extend this class when you extend `order_iso`."}, {"name": "order_iso_class.map_le_map_iff", "description": " `order_iso_class F \u03b1 \u03b2` states that `F` is a type of order isomorphisms.\n\nYou should extend this class when you extend `order_iso`."}, {"name": "order_hom.prod_iso_symm_apply", "description": ""}, {"name": "order_iso.symm_refl", "description": ""}, {"name": "with_top.to_dual_bot_symm_coe", "description": ""}, {"name": "order_embedding.with_bot_map_apply", "description": ""}, {"name": "order_iso.compl_symm_apply", "description": ""}, {"name": "order_hom.coe_eq", "description": ""}, {"name": "order_hom.copy", "description": " Copy of an `order_hom` with a new `to_fun` equal to the old one. Useful to fix definitional\nequalities."}, {"name": "order_hom.dual_id", "description": ""}, {"name": "order_hom.le_def", "description": ""}, {"name": "order_hom.can_lift", "description": "One can lift an unbundled monotone function to a bundled one."}, {"name": "order_hom.pi_coe", "description": ""}, {"name": "order_embedding.is_well_order", "description": ""}, {"name": "order_iso_class.to_order_hom_class", "description": ""}, {"name": "order_iso.of_rel_iso_lt_apply", "description": ""}, {"name": "order_embedding.subtype", "description": "Embedding of a subtype into the ambient type as an `order_embedding`."}, {"name": "order_hom_class.mono", "description": ""}, {"name": "order_hom.monotone", "description": ""}, {"name": "order_hom.prod_coe", "description": ""}, {"name": "equiv.to_order_iso", "description": " If `e` is an equivalence with monotone forward and inverse maps, then `e` is an\norder isomorphism."}, {"name": "order_iso.is_compl", "description": ""}, {"name": "order_embedding.eq_iff_eq", "description": ""}, {"name": "strict_mono.order_iso_of_surjective_symm_apply_self", "description": ""}, {"name": "order_hom.apply_mono", "description": ""}, {"name": "lt_map_inv_iff", "description": ""}, {"name": "order_iso.with_top_congr_symm", "description": ""}, {"name": "order_iso.with_top_congr_refl", "description": ""}, {"name": "order_iso.order_iso_class", "description": ""}, {"name": "order_embedding.le_iff_le", "description": ""}, {"name": "order_iso.trans_apply", "description": ""}, {"name": "order_hom.coe_fn_hom", "description": " The \"forgetful functor\" from `\u03b1 \u2192o \u03b2` to `\u03b1 \u2192 \u03b2` that takes the underlying function,\nis monotone."}, {"name": "order_iso.apply_eq_iff_eq", "description": ""}, {"name": "order_hom.comp\u2098_coe_coe_coe", "description": ""}, {"name": "set.mem_diagonal_iff", "description": ""}, {"name": "set.pi_nonempty_iff", "description": ""}, {"name": "set.range_dcomp", "description": ""}, {"name": "set.prod_self_ssubset_prod_self", "description": ""}, {"name": "set.nonempty.snd", "description": ""}, {"name": "set.update_preimage_pi", "description": ""}, {"name": "set.mk_preimage_prod_right", "description": ""}, {"name": "set.mk_mem_prod", "description": ""}, {"name": "set.pi_inter_compl", "description": ""}, {"name": "set.eval_image_pi", "description": ""}, {"name": "set.eval_image_pi_subset", "description": ""}, {"name": "set.image_prod_mk_subset_prod_left", "description": ""}, {"name": "set.forall_prod_set", "description": ""}, {"name": "antitone.set_prod", "description": ""}, {"name": "set.snd_image_prod", "description": ""}, {"name": "set.univ_pi_singleton", "description": ""}, {"name": "set.prod_eq", "description": ""}, {"name": "set.prod_empty", "description": ""}, {"name": "set.nonempty.fst", "description": ""}, {"name": "set.update_preimage_univ_pi", "description": ""}, {"name": "set.nonempty.prod", "description": ""}, {"name": "set.mk_preimage_prod_right_eq_empty", "description": ""}, {"name": "set.univ_pi_eq_empty_iff", "description": ""}, {"name": "set.mem_pi", "description": ""}, {"name": "set.range_pair_subset", "description": ""}, {"name": "set.univ_pi_empty", "description": ""}, {"name": "set.eval_image_univ_pi", "description": ""}, {"name": "set.subset_pi_eval_image", "description": ""}, {"name": "set.mk_preimage_prod", "description": ""}, {"name": "set.mem_univ_pi", "description": ""}, {"name": "set.univ_pi_nonempty_iff", "description": ""}, {"name": "set.prod_preimage_left", "description": ""}, {"name": "monotone.set_prod", "description": ""}, {"name": "set.eval_preimage'", "description": ""}, {"name": "set.image2_mk_eq_prod", "description": ""}, {"name": "set.eval_image_univ_pi_subset", "description": ""}, {"name": "set.prod_inter_prod", "description": ""}, {"name": "set.fst_image_prod_subset", "description": ""}, {"name": "set.union_pi", "description": ""}, {"name": "set.prod_eq_empty_iff", "description": ""}, {"name": "set.prod_diff_prod", "description": ""}, {"name": "set.singleton_pi'", "description": ""}, {"name": "set.snd_image_prod_subset", "description": ""}, {"name": "set.pi_inter_distrib", "description": ""}, {"name": "set.preimage_coe_coe_diagonal", "description": ""}, {"name": "set.mk_preimage_prod_left_fn_eq_if", "description": ""}, {"name": "set.mk_preimage_prod_right_fn_eq_if", "description": ""}, {"name": "set.prod_preimage_eq", "description": ""}, {"name": "set.prod_subset_compl_diagonal_iff_disjoint", "description": ""}, {"name": "set.pi_update_of_mem", "description": ""}, {"name": "set.prod_image_image_eq", "description": ""}, {"name": "set.prod_subset_iff", "description": ""}, {"name": "set.prod_self_subset_prod_self", "description": ""}, {"name": "set.pi_update_of_not_mem", "description": ""}, {"name": "set.mk_preimage_prod_left_eq_if", "description": ""}, {"name": "set.prod_eq_iff_eq", "description": ""}, {"name": "set.univ_pi_ite", "description": ""}, {"name": "set.pi_eq_empty", "description": ""}, {"name": "set.eval_preimage", "description": ""}, {"name": "set.univ_pi_update_univ", "description": ""}, {"name": "set.mem_prod_eq", "description": ""}, {"name": "set.pi_eq_empty_iff", "description": ""}, {"name": "set.prod_subset_preimage_snd", "description": ""}, {"name": "set.mem_prod", "description": ""}, {"name": "set.empty_prod", "description": ""}, {"name": "set.univ_pi_eq_empty", "description": ""}, {"name": "set.mk_preimage_prod_right_eq_if", "description": ""}, {"name": "set.preimage_swap_prod", "description": ""}, {"name": "set.insert_prod", "description": ""}, {"name": "set.prod_range_range_eq", "description": ""}, {"name": "set.mk_preimage_prod_left", "description": ""}, {"name": "monotone_on.set_prod", "description": ""}, {"name": "set.univ_prod_univ", "description": ""}, {"name": "set.diag_preimage_prod", "description": ""}, {"name": "set.image_prod", "description": ""}, {"name": "set.has_set_prod", "description": "The cartesian product `prod s t` is the set of `(a, b)`\n such that `a \u2208 s` and `b \u2208 t`."}, {"name": "set.prod_mk_mem_set_prod_eq", "description": ""}, {"name": "has_set_prod", "description": "Notation class for product of subobjects (sets, submonoids, subgroups, etc)."}, {"name": "has_set_prod.prod", "description": "Notation class for product of subobjects (sets, submonoids, subgroups, etc)."}, {"name": "set.prod_sub_preimage_iff", "description": ""}, {"name": "set.fst_image_prod", "description": ""}, {"name": "set.exists_prod_set", "description": ""}, {"name": "set.prod_singleton", "description": ""}, {"name": "set.image_swap_prod", "description": ""}, {"name": "set.range_prod_map", "description": ""}, {"name": "set.range_diag", "description": ""}, {"name": "set.pi_univ", "description": ""}, {"name": "antitone_on.set_prod", "description": ""}, {"name": "set.union_prod", "description": ""}, {"name": "set.diagonal", "description": "`diagonal \u03b1` is the set of `\u03b1 \u00d7 \u03b1` consisting of all pairs of the form `(a, a)`."}, {"name": "set.singleton_prod_singleton", "description": ""}, {"name": "set.pi_congr", "description": ""}, {"name": "set.univ_prod", "description": ""}, {"name": "set.pi", "description": " Given an index set `\u03b9` and a family of sets `t : \u03a0 i, set (\u03b1 i)`, `pi s t`\nis the set of dependent functions `f : \u03a0a, \u03c0 a` such that `f a` belongs to `t a`\nwhenever `a \u2208 s`."}, {"name": "set.prod_range_univ_eq", "description": ""}, {"name": "set.prod_nonempty_iff", "description": ""}, {"name": "set.prod_mono", "description": ""}, {"name": "set.preimage_prod_map_prod", "description": ""}, {"name": "set.univ_pi_update", "description": ""}, {"name": "set.prod_eq_prod_iff_of_nonempty", "description": ""}, {"name": "set.prod_subset_prod_iff", "description": " A product set is included in a product set if and only factors are included, or a factor of the\nfirst set is empty."}, {"name": "set.image_prod_mk_subset_prod_right", "description": ""}, {"name": "set.insert_pi", "description": ""}, {"name": "set.pi_if", "description": ""}, {"name": "set.singleton_pi", "description": ""}, {"name": "set.prod_univ", "description": ""}, {"name": "set.singleton_prod", "description": ""}, {"name": "set.prod_union", "description": ""}, {"name": "set.empty_pi", "description": ""}, {"name": "set.mem_diagonal", "description": ""}, {"name": "set.prod_univ_range_eq", "description": ""}, {"name": "set.prod_eq_prod_iff", "description": ""}, {"name": "set.prod_subset_preimage_fst", "description": ""}, {"name": "set.prod_insert", "description": ""}, {"name": "set.mk_preimage_prod_left_eq_empty", "description": ""}, {"name": "set.prod_preimage_right", "description": ""}, {"name": "set.pi_mono", "description": ""}, {"name": "set.diag_preimage_prod_self", "description": ""}, {"name": "array.to_list_to_array", "description": ""}, {"name": "equiv.array_equiv_fin", "description": "The natural equivalence between length-`n` arrays and functions from `fin n`."}, {"name": "array.to_list_reverse", "description": ""}, {"name": "array.to_list_nth_le_aux", "description": ""}, {"name": "array.to_list_nth_le'", "description": ""}, {"name": "array.read_map\u2082", "description": ""}, {"name": "array.read_push_back_left", "description": ""}, {"name": "array.write_to_list", "description": ""}, {"name": "array.to_list_foldl", "description": ""}, {"name": "array.traversable", "description": ""}, {"name": "array.mem.def", "description": ""}, {"name": "equiv.vector_equiv_array", "description": "The natural equivalence between length-`n` vectors and length-`n` arrays."}, {"name": "array.to_list_nth", "description": ""}, {"name": "array.to_list_of_heq", "description": ""}, {"name": "array.rev_list_length_aux", "description": ""}, {"name": "array.mem_to_list", "description": ""}, {"name": "array.read_map", "description": ""}, {"name": "array.mem_rev_list", "description": ""}, {"name": "array.to_array_to_list", "description": ""}, {"name": "array.rev_list_reverse_aux", "description": ""}, {"name": "array.rev_list_reverse", "description": ""}, {"name": "array.to_list_length", "description": ""}, {"name": "array.read_foreach", "description": ""}, {"name": "array.rev_list_foldr", "description": ""}, {"name": "array.push_back_rev_list", "description": ""}, {"name": "array.rev_list_foldr_aux", "description": ""}, {"name": "array.mem_rev_list_aux", "description": ""}, {"name": "array.push_back_to_list", "description": ""}, {"name": "array.inhabited", "description": ""}, {"name": "array.rev_list_length", "description": ""}, {"name": "array.to_list_nth_le", "description": ""}, {"name": "equiv.d_array_equiv_fin", "description": " The natural equivalence between length-`n` heterogeneous arrays\nand dependent functions from `fin n`."}, {"name": "d_array.inhabited", "description": ""}, {"name": "array.is_lawful_traversable", "description": ""}, {"name": "array.push_back_rev_list_aux", "description": ""}, {"name": "array.mem_to_list_enum", "description": ""}, {"name": "array.read_push_back_right", "description": ""}, {"name": "non_unital_ring_hom.id", "description": "The identity non-unital ring homomorphism from a non-unital semiring to itself."}, {"name": "non_unital_ring_hom.comp_assoc", "description": "Composition of non-unital ring homomorphisms is associative."}, {"name": "ring_hom.coe_monoid_hom_injective", "description": ""}, {"name": "ring_hom.has_coe_monoid_hom", "description": ""}, {"name": "ring_hom.to_add_monoid_hom", "description": " Reinterpret a ring homomorphism `f : \u03b1 \u2192+* \u03b2` as an additive monoid homomorphism `\u03b1 \u2192+ \u03b2`.\nThe `simp`-normal form is `(f : \u03b1 \u2192+ \u03b2)`."}, {"name": "ring_hom.coe_monoid_hom_mk", "description": ""}, {"name": "non_unital_ring_hom.mk_coe", "description": ""}, {"name": "ring_hom.ring_hom_class", "description": ""}, {"name": "ring_hom.coe_inj", "description": ""}, {"name": "non_unital_ring_hom", "description": " Bundled non-unital semiring homomorphisms `\u03b1 \u2192\u2099+* \u03b2`; use this for bundled non-unital ring\nhomomorphisms too.\n\nWhen possible, instead of parametrizing results over `(f : \u03b1 \u2192\u2099+* \u03b2)`,\nyou should parametrize over `(F : Type*) [non_unital_ring_hom_class F \u03b1 \u03b2] (f : F)`.\n\nWhen you extend this structure, make sure to extend `non_unital_ring_hom_class`."}, {"name": "non_unital_ring_hom.to_fun", "description": " Bundled non-unital semiring homomorphisms `\u03b1 \u2192\u2099+* \u03b2`; use this for bundled non-unital ring\nhomomorphisms too.\n\nWhen possible, instead of parametrizing results over `(f : \u03b1 \u2192\u2099+* \u03b2)`,\nyou should parametrize over `(F : Type*) [non_unital_ring_hom_class F \u03b1 \u03b2] (f : F)`.\n\nWhen you extend this structure, make sure to extend `non_unital_ring_hom_class`."}, {"name": "non_unital_ring_hom.map_mul'", "description": " Bundled non-unital semiring homomorphisms `\u03b1 \u2192\u2099+* \u03b2`; use this for bundled non-unital ring\nhomomorphisms too.\n\nWhen possible, instead of parametrizing results over `(f : \u03b1 \u2192\u2099+* \u03b2)`,\nyou should parametrize over `(F : Type*) [non_unital_ring_hom_class F \u03b1 \u03b2] (f : F)`.\n\nWhen you extend this structure, make sure to extend `non_unital_ring_hom_class`."}, {"name": "non_unital_ring_hom.map_zero'", "description": " Bundled non-unital semiring homomorphisms `\u03b1 \u2192\u2099+* \u03b2`; use this for bundled non-unital ring\nhomomorphisms too.\n\nWhen possible, instead of parametrizing results over `(f : \u03b1 \u2192\u2099+* \u03b2)`,\nyou should parametrize over `(F : Type*) [non_unital_ring_hom_class F \u03b1 \u03b2] (f : F)`.\n\nWhen you extend this structure, make sure to extend `non_unital_ring_hom_class`."}, {"name": "non_unital_ring_hom.map_add'", "description": " Bundled non-unital semiring homomorphisms `\u03b1 \u2192\u2099+* \u03b2`; use this for bundled non-unital ring\nhomomorphisms too.\n\nWhen possible, instead of parametrizing results over `(f : \u03b1 \u2192\u2099+* \u03b2)`,\nyou should parametrize over `(F : Type*) [non_unital_ring_hom_class F \u03b1 \u03b2] (f : F)`.\n\nWhen you extend this structure, make sure to extend `non_unital_ring_hom_class`."}, {"name": "ring_hom.cancel_left", "description": ""}, {"name": "non_unital_ring_hom.comp", "description": "Composition of non-unital ring homomorphisms is a non-unital ring homomorphism."}, {"name": "non_unital_ring_hom.cancel_left", "description": ""}, {"name": "non_unital_ring_hom.comp_apply", "description": ""}, {"name": "non_unital_ring_hom.coe_mul_hom_id", "description": ""}, {"name": "ring_hom.monoid", "description": ""}, {"name": "ring_hom.coe_add_monoid_hom_id", "description": ""}, {"name": "ring_hom.map_bit1", "description": "Ring homomorphisms preserve `bit1`."}, {"name": "ring_hom.map_sub", "description": "Ring homomorphisms preserve subtraction."}, {"name": "non_unital_ring_hom.id_comp", "description": ""}, {"name": "non_unital_ring_hom.mul_def", "description": ""}, {"name": "ring_hom.to_monoid_hom", "description": " Reinterpret a ring homomorphism `f : \u03b1 \u2192+* \u03b2` as a monoid homomorphism `\u03b1 \u2192* \u03b2`.\nThe `simp`-normal form is `(f : \u03b1 \u2192* \u03b2)`."}, {"name": "ring_hom.coe_add_monoid_hom_mk", "description": ""}, {"name": "non_unital_ring_hom.comp_zero", "description": ""}, {"name": "function.injective.is_domain", "description": "Pullback `is_domain` instance along an injective function."}, {"name": "non_unital_ring_hom.coe_to_add_monoid_hom", "description": ""}, {"name": "ring_hom.comp_id", "description": ""}, {"name": "ring_hom.to_non_unital_ring_hom", "description": " Reinterpret a ring homomorphism `f : \u03b1 \u2192+* \u03b2` as a non-unital ring homomorphism `\u03b1 \u2192\u2099+* \u03b2`. The\n`simp`-normal form is `(f : \u03b1 \u2192\u2099+* \u03b2)`."}, {"name": "ring_hom_class.to_monoid_with_zero_hom_class", "description": ""}, {"name": "ring_hom", "description": " Bundled semiring homomorphisms; use this for bundled ring homomorphisms too.\n\nThis extends from both `monoid_hom` and `monoid_with_zero_hom` in order to put the fields in a\nsensible order, even though `monoid_with_zero_hom` already extends `monoid_hom`."}, {"name": "ring_hom.to_fun", "description": " Bundled semiring homomorphisms; use this for bundled ring homomorphisms too.\n\nThis extends from both `monoid_hom` and `monoid_with_zero_hom` in order to put the fields in a\nsensible order, even though `monoid_with_zero_hom` already extends `monoid_hom`."}, {"name": "ring_hom.map_one'", "description": " Bundled semiring homomorphisms; use this for bundled ring homomorphisms too.\n\nThis extends from both `monoid_hom` and `monoid_with_zero_hom` in order to put the fields in a\nsensible order, even though `monoid_with_zero_hom` already extends `monoid_hom`."}, {"name": "ring_hom.map_mul'", "description": " Bundled semiring homomorphisms; use this for bundled ring homomorphisms too.\n\nThis extends from both `monoid_hom` and `monoid_with_zero_hom` in order to put the fields in a\nsensible order, even though `monoid_with_zero_hom` already extends `monoid_hom`."}, {"name": "ring_hom.map_zero'", "description": " Bundled semiring homomorphisms; use this for bundled ring homomorphisms too.\n\nThis extends from both `monoid_hom` and `monoid_with_zero_hom` in order to put the fields in a\nsensible order, even though `monoid_with_zero_hom` already extends `monoid_hom`."}, {"name": "ring_hom.map_add'", "description": " Bundled semiring homomorphisms; use this for bundled ring homomorphisms too.\n\nThis extends from both `monoid_hom` and `monoid_with_zero_hom` in order to put the fields in a\nsensible order, even though `monoid_with_zero_hom` already extends `monoid_hom`."}, {"name": "non_unital_ring_hom.id_apply", "description": ""}, {"name": "non_unital_ring_hom.to_mul_hom", "description": " Reinterpret a non-unital ring homomorphism `f : \u03b1 \u2192\u2099+* \u03b2` as a semigroup\nhomomorphism `\u03b1 \u2192\u2099* \u03b2`. The `simp`-normal form is `(f : \u03b1 \u2192\u2099* \u03b2)`."}, {"name": "ring_hom.map_bit0", "description": "Ring homomorphisms preserve `bit0`."}, {"name": "ring_hom.coe_monoid_hom", "description": ""}, {"name": "ring_hom.coe_mk", "description": ""}, {"name": "ring_hom.codomain_trivial_iff_range_eq_singleton_zero", "description": "`f : \u03b1 \u2192+* \u03b2` has a trivial codomain iff its range is `{0}`."}, {"name": "non_unital_ring_hom.monoid_with_zero", "description": ""}, {"name": "ring_hom.to_monoid_hom_eq_coe", "description": ""}, {"name": "ring_hom.map_add", "description": "Ring homomorphisms preserve addition."}, {"name": "ring_hom.map_one_ne_zero", "description": "`f : \u03b1 \u2192+* \u03b2` doesn't map `1` to `0` if `\u03b2` is nontrivial"}, {"name": "non_unital_ring_hom.one_def", "description": ""}, {"name": "ring_hom_class.to_monoid_hom_class", "description": ""}, {"name": "ring_hom.has_coe_to_fun", "description": " Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`\ndirectly."}, {"name": "ring_hom.coe_coe", "description": ""}, {"name": "non_unital_ring_hom.coe_comp_mul_hom", "description": ""}, {"name": "non_unital_ring_hom.coe_zero", "description": ""}, {"name": "ring_hom.coe_mul", "description": ""}, {"name": "ring_hom.to_fun_eq_coe", "description": ""}, {"name": "ring_hom.to_monoid_with_zero_hom", "description": " Reinterpret a ring homomorphism `f : \u03b1 \u2192+* \u03b2` as a monoid with zero homomorphism `\u03b1 \u2192*\u2080 \u03b2`.\nThe `simp`-normal form is `(f : \u03b1 \u2192*\u2080 \u03b2)`."}, {"name": "ring_hom.congr_arg", "description": ""}, {"name": "non_unital_ring_hom.non_unital_ring_hom_class", "description": ""}, {"name": "non_unital_ring_hom.coe_mul", "description": ""}, {"name": "ring_hom.mk_coe", "description": ""}, {"name": "ring_hom.to_add_monoid_hom_eq_coe", "description": ""}, {"name": "ring_hom.map_zero", "description": "Ring homomorphisms map zero to zero."}, {"name": "ring_hom.codomain_trivial_iff_map_one_eq_zero", "description": "`f : \u03b1 \u2192+* \u03b2` has a trivial codomain iff `f 1 = 0`."}, {"name": "ring_hom_class.to_non_unital_ring_hom_class", "description": ""}, {"name": "non_unital_ring_hom.cancel_right", "description": ""}, {"name": "ring_hom.id_apply", "description": ""}, {"name": "ring_hom.inhabited", "description": ""}, {"name": "ring_hom.comp", "description": "Composition of ring homomorphisms is a ring homomorphism."}, {"name": "ring_hom.to_monoid_with_zero_hom_eq_coe", "description": ""}, {"name": "ring_hom.coe_add_monoid_hom", "description": ""}, {"name": "non_unital_ring_hom.coe_add_monoid_hom_id", "description": ""}, {"name": "ring_hom.mul_def", "description": ""}, {"name": "ring_hom.id", "description": "The identity ring homomorphism from a semiring to itself."}, {"name": "ring_hom.cancel_right", "description": ""}, {"name": "non_unital_ring_hom.has_coe_t", "description": ""}, {"name": "non_unital_ring_hom.coe_comp_add_monoid_hom", "description": ""}, {"name": "ring_hom.codomain_trivial_iff_range_trivial", "description": "`f : \u03b1 \u2192+* \u03b2` has a trivial codomain iff it has a trivial range."}, {"name": "add_monoid_hom.coe_fn_mk_ring_hom_of_mul_self_of_two_ne_zero", "description": ""}, {"name": "ring_hom.coe_monoid_hom_id", "description": ""}, {"name": "non_unital_ring_hom.coe_mk", "description": ""}, {"name": "non_unital_ring_hom.coe_add_monoid_hom_mk", "description": ""}, {"name": "ring_hom.map_neg", "description": "Ring homomorphisms preserve additive inverse."}, {"name": "ring_hom.coe_add_monoid_hom_injective", "description": ""}, {"name": "non_unital_ring_hom.coe_to_mul_hom", "description": ""}, {"name": "ring_hom.has_coe_t", "description": ""}, {"name": "non_unital_ring_hom.inhabited", "description": ""}, {"name": "ring_hom.ext_iff", "description": ""}, {"name": "non_unital_ring_hom.zero_comp", "description": ""}, {"name": "ring_hom.copy", "description": " Copy of a `ring_hom` with a new `to_fun` equal to the old one. Useful to fix definitional\nequalities."}, {"name": "ring_hom.map_one", "description": "Ring homomorphisms map one to one."}, {"name": "non_unital_ring_hom.comp_id", "description": ""}, {"name": "ring_hom.coe_comp", "description": ""}, {"name": "non_unital_ring_hom_class.to_add_monoid_hom_class", "description": ""}, {"name": "ring_hom.mk'", "description": "Makes a ring homomorphism from a monoid homomorphism of rings which preserves addition."}, {"name": "ring_hom.comp_assoc", "description": "Composition of semiring homomorphisms is associative."}, {"name": "ring_hom.ext", "description": ""}, {"name": "non_unital_ring_hom.coe_mul_hom_injective", "description": ""}, {"name": "non_unital_ring_hom.has_coe_to_fun", "description": " Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`\ndirectly."}, {"name": "non_unital_ring_hom.to_add_monoid_hom", "description": " Reinterpret a non-unital ring homomorphism `f : \u03b1 \u2192\u2099+* \u03b2` as an additive\nmonoid homomorphism `\u03b1 \u2192+ \u03b2`. The `simp`-normal form is `(f : \u03b1 \u2192+ \u03b2)`."}, {"name": "ring_hom.one_def", "description": ""}, {"name": "non_unital_ring_hom.has_zero", "description": ""}, {"name": "ring_hom_class", "description": " `ring_hom_class F \u03b1 \u03b2` states that `F` is a type of (semi)ring homomorphisms.\nYou should extend this class when you extend `ring_hom`.\n\nThis extends from both `monoid_hom_class` and `monoid_with_zero_hom_class` in\norder to put the fields in a sensible order, even though\n`monoid_with_zero_hom_class` already extends `monoid_hom_class`."}, {"name": "ring_hom_class.coe", "description": " `ring_hom_class F \u03b1 \u03b2` states that `F` is a type of (semi)ring homomorphisms.\nYou should extend this class when you extend `ring_hom`.\n\nThis extends from both `monoid_hom_class` and `monoid_with_zero_hom_class` in\norder to put the fields in a sensible order, even though\n`monoid_with_zero_hom_class` already extends `monoid_hom_class`."}, {"name": "ring_hom_class.coe_injective'", "description": " `ring_hom_class F \u03b1 \u03b2` states that `F` is a type of (semi)ring homomorphisms.\nYou should extend this class when you extend `ring_hom`.\n\nThis extends from both `monoid_hom_class` and `monoid_with_zero_hom_class` in\norder to put the fields in a sensible order, even though\n`monoid_with_zero_hom_class` already extends `monoid_hom_class`."}, {"name": "ring_hom_class.map_mul", "description": " `ring_hom_class F \u03b1 \u03b2` states that `F` is a type of (semi)ring homomorphisms.\nYou should extend this class when you extend `ring_hom`.\n\nThis extends from both `monoid_hom_class` and `monoid_with_zero_hom_class` in\norder to put the fields in a sensible order, even though\n`monoid_with_zero_hom_class` already extends `monoid_hom_class`."}, {"name": "ring_hom_class.map_one", "description": " `ring_hom_class F \u03b1 \u03b2` states that `F` is a type of (semi)ring homomorphisms.\nYou should extend this class when you extend `ring_hom`.\n\nThis extends from both `monoid_hom_class` and `monoid_with_zero_hom_class` in\norder to put the fields in a sensible order, even though\n`monoid_with_zero_hom_class` already extends `monoid_hom_class`."}, {"name": "ring_hom_class.map_add", "description": " `ring_hom_class F \u03b1 \u03b2` states that `F` is a type of (semi)ring homomorphisms.\nYou should extend this class when you extend `ring_hom`.\n\nThis extends from both `monoid_hom_class` and `monoid_with_zero_hom_class` in\norder to put the fields in a sensible order, even though\n`monoid_with_zero_hom_class` already extends `monoid_hom_class`."}, {"name": "ring_hom_class.map_zero", "description": " `ring_hom_class F \u03b1 \u03b2` states that `F` is a type of (semi)ring homomorphisms.\nYou should extend this class when you extend `ring_hom`.\n\nThis extends from both `monoid_hom_class` and `monoid_with_zero_hom_class` in\norder to put the fields in a sensible order, even though\n`monoid_with_zero_hom_class` already extends `monoid_hom_class`."}, {"name": "non_unital_ring_hom.copy", "description": " Copy of a `ring_hom` with a new `to_fun` equal to the old one. Useful to fix definitional\nequalities."}, {"name": "ring_hom.id_comp", "description": ""}, {"name": "map_bit1", "description": "Ring homomorphisms preserve `bit1`."}, {"name": "non_unital_ring_hom.coe_mul_hom_mk", "description": ""}, {"name": "non_unital_ring_hom.ext", "description": ""}, {"name": "ring_hom.map_dvd", "description": ""}, {"name": "non_unital_ring_hom_class.to_mul_hom_class", "description": ""}, {"name": "ring_hom.is_unit_map", "description": ""}, {"name": "ring_hom.coe_one", "description": ""}, {"name": "ring_hom.domain_nontrivial", "description": "If there is a homomorphism `f : \u03b1 \u2192+* \u03b2` and `\u03b2` is nontrivial, then `\u03b1` is nontrivial."}, {"name": "non_unital_ring_hom.coe_one", "description": ""}, {"name": "ring_hom.comp_apply", "description": ""}, {"name": "ring_hom.map_mul", "description": "Ring homomorphisms preserve multiplication."}, {"name": "non_unital_ring_hom.coe_add_monoid_hom_injective", "description": ""}, {"name": "non_unital_ring_hom.to_fun_eq_coe", "description": ""}, {"name": "ring_hom_class.to_add_monoid_hom_class", "description": ""}, {"name": "non_unital_ring_hom_class", "description": " `non_unital_ring_hom_class F \u03b1 \u03b2` states that `F` is a type of non-unital (semi)ring\nhomomorphisms. You should extend this class when you extend `non_unital_ring_hom`."}, {"name": "non_unital_ring_hom_class.coe", "description": " `non_unital_ring_hom_class F \u03b1 \u03b2` states that `F` is a type of non-unital (semi)ring\nhomomorphisms. You should extend this class when you extend `non_unital_ring_hom`."}, {"name": "non_unital_ring_hom_class.coe_injective'", "description": " `non_unital_ring_hom_class F \u03b1 \u03b2` states that `F` is a type of non-unital (semi)ring\nhomomorphisms. You should extend this class when you extend `non_unital_ring_hom`."}, {"name": "non_unital_ring_hom_class.map_mul", "description": " `non_unital_ring_hom_class F \u03b1 \u03b2` states that `F` is a type of non-unital (semi)ring\nhomomorphisms. You should extend this class when you extend `non_unital_ring_hom`."}, {"name": "non_unital_ring_hom_class.map_add", "description": " `non_unital_ring_hom_class F \u03b1 \u03b2` states that `F` is a type of non-unital (semi)ring\nhomomorphisms. You should extend this class when you extend `non_unital_ring_hom`."}, {"name": "non_unital_ring_hom_class.map_zero", "description": " `non_unital_ring_hom_class F \u03b1 \u03b2` states that `F` is a type of non-unital (semi)ring\nhomomorphisms. You should extend this class when you extend `non_unital_ring_hom`."}, {"name": "ring_hom.congr_fun", "description": ""}, {"name": "add_monoid_hom.mk_ring_hom_of_mul_self_of_two_ne_zero", "description": " Make a ring homomorphism from an additive group homomorphism from a commutative ring to an\nintegral domain that commutes with self multiplication, assumes that two is nonzero and `1` is sent\nto `1`."}, {"name": "non_unital_ring_hom.zero_apply", "description": ""}, {"name": "non_unital_ring_hom.ext_iff", "description": ""}, {"name": "non_unital_ring_hom.coe_coe", "description": ""}, {"name": "add_monoid_hom.coe_add_monoid_hom_mk_ring_hom_of_mul_self_of_two_ne_zero", "description": ""}, {"name": "non_unital_ring_hom.coe_comp", "description": ""}, {"name": "image2_lower_bounds_upper_bounds_subset_upper_bounds_image2", "description": ""}, {"name": "is_glb_iff_le_iff", "description": ""}, {"name": "is_glb_Ioo", "description": ""}, {"name": "bdd_above_Icc", "description": ""}, {"name": "union_lower_bounds_subset_lower_bounds_inter", "description": ""}, {"name": "monotone_on.mem_upper_bounds_image_self", "description": ""}, {"name": "upper_bounds_Ioo", "description": ""}, {"name": "is_glb_univ", "description": ""}, {"name": "nonempty_of_not_bdd_below", "description": ""}, {"name": "order_iso.is_glb_preimage'", "description": ""}, {"name": "mem_lower_bounds_image2_of_mem_upper_bounds", "description": ""}, {"name": "order_iso.is_glb_image'", "description": ""}, {"name": "bdd_below.image2_bdd_above", "description": ""}, {"name": "bdd_above.inter_of_right", "description": "If `t` is bounded, then so is `s \u2229 t`"}, {"name": "subset_lower_bounds_upper_bounds", "description": ""}, {"name": "glb_Ioi_eq_self_or_Ioi_eq_Ici", "description": ""}, {"name": "not_bdd_above_iff", "description": " A set `s` is not bounded above if and only if for each `x` there exists `y \u2208 s` that is greater\nthan `x`. A version for preorders is called `not_bdd_above_iff'`."}, {"name": "monotone_on.map_is_greatest", "description": "A monotone map sends a greatest element of a set to a greatest element of its image."}, {"name": "bdd_above_singleton", "description": ""}, {"name": "bdd_below.dual", "description": ""}, {"name": "is_lub.union", "description": " If `a` is the least upper bound of `s` and `b` is the least upper bound of `t`,\nthen `a \u2294 b` is the least upper bound of `s \u222a t`."}, {"name": "is_glb.of_image", "description": ""}, {"name": "is_lub", "description": "`a` is a least upper bound of a set `s`; for a partial order, it is unique if exists."}, {"name": "monotone_on.mem_lower_bounds_image", "description": ""}, {"name": "lower_bounds_mono", "description": ""}, {"name": "bdd_below_Ioc", "description": ""}, {"name": "is_greatest_singleton", "description": ""}, {"name": "mem_lower_bounds_image2", "description": ""}, {"name": "monotone.map_bdd_above", "description": " The image under a monotone function of a set which is bounded above is bounded above. See also\n`bdd_above.image2`."}, {"name": "bdd_below_singleton", "description": ""}, {"name": "is_glb_singleton", "description": ""}, {"name": "is_glb.nonempty", "description": ""}, {"name": "is_glb_pi", "description": ""}, {"name": "lt_is_glb_iff", "description": ""}, {"name": "upper_bounds_mono", "description": ""}, {"name": "monotone.map_is_greatest", "description": "A monotone map sends a greatest element of a set to a greatest element of its image."}, {"name": "upper_bounds_mono_mem", "description": ""}, {"name": "is_glb.dual", "description": ""}, {"name": "antitone.map_is_least", "description": "An antitone map sends a least element of a set to a greatest element of its image."}, {"name": "order_iso.is_lub_image", "description": ""}, {"name": "is_least.bdd_below", "description": "If `s` has a least element, then it is bounded below."}, {"name": "upper_bounds", "description": "The set of upper bounds of a set."}, {"name": "bdd_above_insert", "description": "Adding a point to a set preserves its boundedness above."}, {"name": "bdd_above.inter_of_left", "description": "If `s` is bounded, then so is `s \u2229 t`"}, {"name": "bdd_above", "description": "A set is bounded above if there exists an upper bound."}, {"name": "is_greatest.is_least_image2", "description": ""}, {"name": "is_glb_lt_is_lub_of_ne", "description": ""}, {"name": "is_glb.unique", "description": ""}, {"name": "monotone_on.map_is_least", "description": "A monotone map sends a least element of a set to a least element of its image."}, {"name": "is_glb.mono", "description": ""}, {"name": "bdd_above.exists_ge", "description": ""}, {"name": "is_greatest", "description": "`a` is a greatest element of a set `s`; for a partial order, it is unique if exists"}, {"name": "is_glb_Ico", "description": ""}, {"name": "is_lub_Icc", "description": ""}, {"name": "is_least.dual", "description": ""}, {"name": "is_glb_lt_iff", "description": ""}, {"name": "bdd_above.mono", "description": "If `s \u2286 t` and `t` is bounded above, then so is `s`."}, {"name": "monotone.image_lower_bounds_subset_lower_bounds_image", "description": ""}, {"name": "bdd_below.exists_le", "description": ""}, {"name": "is_greatest_top_iff", "description": ""}, {"name": "is_greatest.order_top", "description": "If `a` is the greatest element of a set `s`, then subtype `s` is an order with top element."}, {"name": "monotone.mem_lower_bounds_image", "description": ""}, {"name": "is_lub_lt_iff", "description": ""}, {"name": "is_glb_pair", "description": ""}, {"name": "is_lub.bdd_above", "description": "If `s` has a least upper bound, then it is bounded above."}, {"name": "lower_bounds_mono_mem", "description": ""}, {"name": "is_lub.of_image", "description": ""}, {"name": "is_least_singleton", "description": ""}, {"name": "set.subsingleton_of_is_lub_le_is_glb", "description": ""}, {"name": "is_glb_Ioi", "description": ""}, {"name": "upper_bounds_union", "description": ""}, {"name": "is_glb_Ici", "description": ""}, {"name": "is_glb.exists_between", "description": ""}, {"name": "bdd_above_iff_exists_ge", "description": ""}, {"name": "bdd_below.insert", "description": ""}, {"name": "monotone.map_is_least", "description": "A monotone map sends a least element of a set to a least element of its image."}, {"name": "is_greatest_Iic", "description": ""}, {"name": "image2_upper_bounds_upper_bounds_subset", "description": ""}, {"name": "is_least_Icc", "description": ""}, {"name": "is_glb.exists_between_self_add", "description": ""}, {"name": "is_glb.union", "description": " If `a` is the greatest lower bound of `s` and `b` is the greatest lower bound of `t`,\nthen `a \u2293 b` is the greatest lower bound of `s \u222a t`."}, {"name": "lt_is_lub_iff", "description": ""}, {"name": "is_greatest.upper_bounds_eq", "description": ""}, {"name": "is_glb_Ioc", "description": ""}, {"name": "lower_bounds", "description": "The set of lower bounds of a set."}, {"name": "is_glb.exists_between'", "description": ""}, {"name": "is_lub.mono", "description": ""}, {"name": "upper_bounds_mono_set", "description": ""}, {"name": "bdd_above_Ioo", "description": ""}, {"name": "le_glb_Ioi", "description": ""}, {"name": "is_greatest.union", "description": " If `a` is the greatest element of `s` and `b` is the greatest element of `t`,\nthen `max a b` is the greatest element of `s \u222a t`."}, {"name": "mem_upper_bounds_image2_of_mem_lower_bounds", "description": ""}, {"name": "order_top.upper_bounds_univ", "description": ""}, {"name": "bdd_above_Iic", "description": ""}, {"name": "is_least.lower_bounds_eq", "description": ""}, {"name": "is_lub.dual", "description": ""}, {"name": "is_least.order_bot", "description": "If `a` is the least element of a set `s`, then subtype `s` is an order with bottom element."}, {"name": "lub_Iio_eq_self_or_Iio_eq_Iic", "description": ""}, {"name": "is_lub_Iio", "description": ""}, {"name": "no_min_order.lower_bounds_univ", "description": ""}, {"name": "bdd_below_Ioo", "description": ""}, {"name": "is_glb.insert", "description": ""}, {"name": "order_top.bdd_above", "description": "When there is a global maximum, every set is bounded above."}, {"name": "mem_upper_bounds_image2_of_mem_upper_bounds_of_mem_lower_bounds", "description": ""}, {"name": "mem_upper_bounds_image2_of_mem_upper_bounds_of_mem_upper_bounds", "description": ""}, {"name": "is_lub_lower_bounds", "description": ""}, {"name": "order_iso.is_glb_image", "description": ""}, {"name": "bdd_above_empty", "description": ""}, {"name": "is_least.mono", "description": ""}, {"name": "bdd_above.image2_bdd_below", "description": ""}, {"name": "monotone_on.mem_upper_bounds_image", "description": ""}, {"name": "bdd_above_def", "description": ""}, {"name": "is_least.insert", "description": ""}, {"name": "lower_bounds_empty", "description": ""}, {"name": "is_lub_iff_le_iff", "description": ""}, {"name": "monotone_on.map_bdd_above", "description": "The image under a monotone function on a set `t` of a subset which has an upper bound in `t`\n is bounded above."}, {"name": "is_lub_singleton", "description": ""}, {"name": "bdd_below_Ici", "description": ""}, {"name": "no_max_order.upper_bounds_univ", "description": ""}, {"name": "upper_bounds_Iic", "description": ""}, {"name": "mem_lower_bounds_image2_of_mem_lower_bounds_of_mem_lower_bounds", "description": ""}, {"name": "bdd_above.image2", "description": "See also `monotone.map_bdd_above`."}, {"name": "monotone_on.image_upper_bounds_subset_upper_bounds_image", "description": ""}, {"name": "bot_mem_lower_bounds", "description": ""}, {"name": "monotone.image_upper_bounds_subset_upper_bounds_image", "description": ""}, {"name": "lower_bounds_le_upper_bounds", "description": ""}, {"name": "lower_bounds_Ici", "description": ""}, {"name": "is_least_union_iff", "description": ""}, {"name": "top_mem_upper_bounds", "description": ""}, {"name": "antitone_on.mem_upper_bounds_image", "description": ""}, {"name": "exists_lub_Iio", "description": ""}, {"name": "is_greatest_univ", "description": ""}, {"name": "bdd_below.inter_of_left", "description": "If `s` is bounded, then so is `s \u2229 t`"}, {"name": "upper_bounds_Ico", "description": ""}, {"name": "is_glb_prod", "description": ""}, {"name": "is_greatest.bdd_above", "description": "If `s` has a greatest element, then it is bounded above."}, {"name": "not_bdd_below_iff", "description": " A set `s` is not bounded below if and only if for each `x` there exists `y \u2208 s` that is less\nthan `x`. A version for preorders is called `not_bdd_below_iff'`."}, {"name": "image2_upper_bounds_upper_bounds_subset_upper_bounds_image2", "description": ""}, {"name": "antitone_on.image_lower_bounds_subset_upper_bounds_image", "description": ""}, {"name": "lub_Iio_le", "description": ""}, {"name": "is_greatest.is_greatest_iff_eq", "description": ""}, {"name": "subset_upper_bounds_lower_bounds", "description": ""}, {"name": "is_lub.nonempty", "description": ""}, {"name": "bdd_above_iff_subset_Iic", "description": ""}, {"name": "bdd_above_Ico", "description": ""}, {"name": "is_least.unique", "description": ""}, {"name": "is_least_pair", "description": ""}, {"name": "is_greatest_union_iff", "description": ""}, {"name": "antitone.mem_lower_bounds_image", "description": ""}, {"name": "order_iso.is_lub_image'", "description": ""}, {"name": "is_lub.exists_between", "description": ""}, {"name": "lower_bounds_Ico", "description": ""}, {"name": "bdd_below_Ico", "description": ""}, {"name": "bdd_below_iff_subset_Ici", "description": ""}, {"name": "is_glb_upper_bounds", "description": ""}, {"name": "not_bdd_above_iff'", "description": " A set `s` is not bounded above if and only if for each `x` there exists `y \u2208 s` such that `x`\nis not greater than or equal to `y`. This version only assumes `preorder` structure and uses\n`\u00ac(y \u2264 x)`. A version for linear orders is called `not_bdd_above_iff`."}, {"name": "upper_bounds_empty", "description": ""}, {"name": "upper_bounds_singleton", "description": ""}, {"name": "bdd_above_Ioc", "description": ""}, {"name": "order_bot.lower_bounds_univ", "description": ""}, {"name": "is_greatest.insert", "description": ""}, {"name": "bdd_below.inter_of_right", "description": "If `t` is bounded, then so is `s \u2229 t`"}, {"name": "bdd_above_Iio", "description": ""}, {"name": "bdd_below.bdd_above_image2_of_bdd_above", "description": ""}, {"name": "is_greatest.dual", "description": ""}, {"name": "is_least_univ", "description": ""}, {"name": "antitone.map_is_greatest", "description": "An antitone map sends a greatest element of a set to a least element of its image."}, {"name": "antitone_on.map_is_least", "description": "An antitone map sends a least element of a set to a greatest element of its image."}, {"name": "is_greatest_pair", "description": ""}, {"name": "bdd_below_insert", "description": "Adding a point to a set preserves its boundedness below."}, {"name": "monotone_on.mem_lower_bounds_image_self", "description": ""}, {"name": "is_lub_Iic", "description": ""}, {"name": "le_of_is_lub_le_is_glb", "description": ""}, {"name": "set.nonempty.bdd_above_lower_bounds", "description": ""}, {"name": "antitone_on.mem_lower_bounds_image_self", "description": ""}, {"name": "bdd_below_def", "description": ""}, {"name": "is_least.is_least_iff_eq", "description": ""}, {"name": "antitone_on.map_is_greatest", "description": "An antitone map sends a greatest element of a set to a least element of its image."}, {"name": "lower_bounds_mono_set", "description": ""}, {"name": "is_greatest.nonempty", "description": ""}, {"name": "is_greatest.is_least_image2_of_is_least", "description": ""}, {"name": "is_greatest.image2", "description": ""}, {"name": "upper_bounds_Ioc", "description": ""}, {"name": "bdd_below.union", "description": ""}, {"name": "upper_bounds_insert", "description": ""}, {"name": "bdd_below_empty", "description": ""}, {"name": "antitone_on.mem_upper_bounds_image_self", "description": ""}, {"name": "mem_lower_bounds", "description": ""}, {"name": "mem_lower_bounds_image2_of_mem_lower_bounds_of_mem_upper_bounds", "description": ""}, {"name": "is_least.image2", "description": ""}, {"name": "is_lub_pair", "description": ""}, {"name": "is_greatest_Ioc", "description": ""}, {"name": "is_glb.of_subset_of_superset", "description": " If `a` is a greatest lower bound for sets `s` and `p`, then it is a greater lower bound for any\nset `t`, `s \u2286 t \u2286 p`."}, {"name": "antitone_on.image_upper_bounds_subset_lower_bounds_image", "description": ""}, {"name": "is_least.union", "description": " If `a` is the least element of `s` and `b` is the least element of `t`,\nthen `min a b` is the least element of `s \u222a t`."}, {"name": "is_greatest.unique", "description": ""}, {"name": "monotone_on.image_lower_bounds_subset_lower_bounds_image", "description": ""}, {"name": "is_lub_empty", "description": ""}, {"name": "not_bdd_below_univ", "description": ""}, {"name": "monotone.mem_upper_bounds_image", "description": ""}, {"name": "is_greatest.is_greatest_image2_of_is_least", "description": ""}, {"name": "bdd_below.mono", "description": "If `s \u2286 t` and `t` is bounded below, then so is `s`."}, {"name": "bdd_above.insert", "description": ""}, {"name": "set.nonempty.bdd_below_upper_bounds", "description": ""}, {"name": "union_upper_bounds_subset_upper_bounds_inter", "description": ""}, {"name": "is_lub_Ioo", "description": ""}, {"name": "bdd_above.union", "description": "If `s` and `t` are bounded above sets in a `semilattice_sup`, then so is `s \u222a t`."}, {"name": "bdd_below_union", "description": "The union of two sets is bounded above if and only if each of the sets is."}, {"name": "is_glb_Icc", "description": ""}, {"name": "is_lub.insert", "description": ""}, {"name": "is_lub.exists_between_sub_self'", "description": ""}, {"name": "image2_lower_bounds_lower_bounds_subset_lower_bounds_image2", "description": ""}, {"name": "image2_lower_bounds_upper_bounds_subset_lower_bounds_image2", "description": ""}, {"name": "not_bdd_above_univ", "description": ""}, {"name": "is_glb", "description": "`a` is a greatest lower bound of a set `s`; for a partial order, it is unique if exists."}, {"name": "is_greatest_Icc", "description": ""}, {"name": "antitone_on.map_bdd_below", "description": "The image under an antitone function of a set which is bounded below is bounded above."}, {"name": "bdd_below.bdd_below_image2_of_bdd_above", "description": ""}, {"name": "is_greatest.is_lub", "description": ""}, {"name": "le_is_glb_iff", "description": ""}, {"name": "order_iso.is_lub_preimage", "description": ""}, {"name": "is_lub_Ico", "description": ""}, {"name": "antitone.map_bdd_above", "description": "The image under an antitone function of a set which is bounded above is bounded below."}, {"name": "bdd_below", "description": "A set is bounded below if there exists a lower bound."}, {"name": "bdd_above.bdd_above_image2_of_bdd_below", "description": ""}, {"name": "bdd_above.dual", "description": ""}, {"name": "lower_bounds_Ioo", "description": ""}, {"name": "not_bdd_below_iff'", "description": " A set `s` is not bounded below if and only if for each `x` there exists `y \u2208 s` such that `x`\nis not less than or equal to `y`. This version only assumes `preorder` structure and uses\n`\u00ac(x \u2264 y)`. A version for linear orders is called `not_bdd_below_iff`."}, {"name": "is_least.is_least_image2_of_is_greatest", "description": ""}, {"name": "upper_bounds_Icc", "description": ""}, {"name": "is_lub.upper_bounds_eq", "description": ""}, {"name": "bdd_above_union", "description": "The union of two sets is bounded above if and only if each of the sets is."}, {"name": "bdd_above.bdd_below_image2_of_bdd_above", "description": ""}, {"name": "is_lub_Ioc", "description": ""}, {"name": "bdd_below_iff_exists_le", "description": ""}, {"name": "is_glb_le_is_lub", "description": ""}, {"name": "image2_upper_bounds_lower_bounds_subset_lower_bounds_image2", "description": ""}, {"name": "is_least.is_greatest_image2", "description": ""}, {"name": "antitone_on.mem_lower_bounds_image", "description": ""}, {"name": "antitone.map_bdd_below", "description": "The image under an antitone function of a set which is bounded below is bounded above."}, {"name": "mem_upper_bounds", "description": ""}, {"name": "lower_bounds_singleton", "description": ""}, {"name": "lower_bounds_Icc", "description": ""}, {"name": "antitone.image_lower_bounds_subset_upper_bounds_image", "description": ""}, {"name": "is_glb.bdd_below", "description": "If `s` has a greatest lower bound, then it is bounded below."}, {"name": "is_lub.exists_between_sub_self", "description": ""}, {"name": "bdd_below_Ioi", "description": ""}, {"name": "order_iso.upper_bounds_image", "description": ""}, {"name": "is_lub.unique", "description": ""}, {"name": "is_greatest.mono", "description": ""}, {"name": "is_glb_empty", "description": ""}, {"name": "is_least.is_greatest_image2_of_is_greatest", "description": ""}, {"name": "bdd_below_bdd_above_iff_subset_Icc", "description": ""}, {"name": "monotone_on.map_bdd_below", "description": "The image under a monotone function on a set `t` of a subset which has a lower bound in `t`\n is bounded below."}, {"name": "is_lub.inter_Ici_of_mem", "description": ""}, {"name": "monotone.map_bdd_below", "description": " The image under a monotone function of a set which is bounded below is bounded below. See also\n`bdd_below.image2`."}, {"name": "exists_glb_Ioi", "description": ""}, {"name": "lower_bounds_Ioi", "description": ""}, {"name": "is_glb.exists_between_self_add'", "description": ""}, {"name": "order_iso.is_lub_preimage'", "description": ""}, {"name": "is_least_bot_iff", "description": ""}, {"name": "order_iso.lower_bounds_image", "description": ""}, {"name": "is_lub_le_iff", "description": ""}, {"name": "is_glb.inter_Iic_of_mem", "description": ""}, {"name": "is_lub_prod", "description": ""}, {"name": "is_least", "description": "`a` is a least element of a set `s`; for a partial order, it is unique if exists."}, {"name": "lower_bounds_union", "description": ""}, {"name": "lower_bounds_insert", "description": ""}, {"name": "upper_bounds_Iio", "description": ""}, {"name": "is_least.is_glb", "description": ""}, {"name": "image2_lower_bounds_lower_bounds_subset", "description": ""}, {"name": "lower_bound_Ioc", "description": ""}, {"name": "is_least_Ici", "description": ""}, {"name": "order_iso.is_glb_preimage", "description": ""}, {"name": "image2_upper_bounds_lower_bounds_subset_upper_bounds_image2", "description": ""}, {"name": "order_bot.bdd_below", "description": "When there is a global minimum, every set is bounded below."}, {"name": "is_least.nonempty", "description": ""}, {"name": "nonempty_of_not_bdd_above", "description": ""}, {"name": "bdd_below.image2", "description": "See also `monotone.map_bdd_below`."}, {"name": "is_lub.of_subset_of_superset", "description": " If `a` is a least upper bound for sets `s` and `p`, then it is a least upper bound for any\nset `t`, `s \u2286 t \u2286 p`."}, {"name": "is_lub_univ", "description": ""}, {"name": "is_lub_pi", "description": ""}, {"name": "antitone_on.map_bdd_above", "description": "The image under an antitone function of a set which is bounded above is bounded below."}, {"name": "is_least_Ico", "description": ""}, {"name": "is_glb.lower_bounds_eq", "description": ""}, {"name": "antitone.image_upper_bounds_subset_lower_bounds_image", "description": ""}, {"name": "is_lub.exists_between'", "description": ""}, {"name": "antitone.mem_upper_bounds_image", "description": ""}, {"name": "bdd_below_Icc", "description": ""}, {"name": "mem_upper_bounds_image2", "description": ""}, {"name": "monotone_on.const_add", "description": ""}, {"name": "left.mul_lt_mul", "description": "Only assumes left strict covariance."}, {"name": "add_lt_add_of_lt_of_le", "description": ""}, {"name": "lt_of_mul_lt_of_one_le_left", "description": ""}, {"name": "mul_lt_mul_of_lt_of_lt", "description": ""}, {"name": "strict_anti.add", "description": "The sum of two strictly antitone functions is strictly antitone."}, {"name": "le_add_of_nonneg_right", "description": ""}, {"name": "add_eq_zero_iff'", "description": ""}, {"name": "mul_le_of_le_one_right'", "description": ""}, {"name": "add_lt_of_lt_of_nonpos", "description": ""}, {"name": "strict_anti_on.add_antitone", "description": "The sum of a strictly antitone function and a antitone function is strictly antitone."}, {"name": "right.add_eq_add_iff_eq_and_eq", "description": ""}, {"name": "contravariant.to_right_cancel_add_semigroup", "description": "An additive semigroup with a partial order and satisfying `right_cancel_add_semigroup`\n(`a + c < b + c \u2192 a < b`) is a `right_cancel add_semigroup`."}, {"name": "mul_lt_one", "description": "**Alias** of `left.mul_lt_one`."}, {"name": "add_lt_of_le_of_neg", "description": ""}, {"name": "monotone_on.mul_const'", "description": ""}, {"name": "lt_of_lt_add_of_nonpos_right", "description": ""}, {"name": "right.add_neg_of_neg_of_nonpos", "description": "Assumes right covariance.\nThe lemma assuming left covariance is `left.add_neg_of_neg_of_nonpos`."}, {"name": "mul_lt_of_le_one_of_lt", "description": ""}, {"name": "antitone.mul_const'", "description": ""}, {"name": "left.mul_lt_one", "description": " Assumes left covariance.\nThe lemma assuming right covariance is `right.mul_lt_one`."}, {"name": "add_nonpos", "description": "**Alias** of `left.add_nonpos`."}, {"name": "mul_lt_one'", "description": "**Alias** of `left.mul_lt_one'`."}, {"name": "right.add_pos_of_nonneg_of_pos", "description": "Assumes right covariance.\nThe lemma assuming left covariance is `left.add_pos_of_nonneg_of_pos`."}, {"name": "mul_le_mul_three", "description": ""}, {"name": "right.mul_eq_mul_iff_eq_and_eq", "description": ""}, {"name": "mul_lt_one_of_lt_of_le", "description": "**Alias** of `left.mul_lt_one_of_lt_of_le`."}, {"name": "strict_anti.mul_antitone'", "description": "The product of a strictly antitone function and a antitone function is strictly antitone."}, {"name": "mul_lt_of_mul_lt_right", "description": ""}, {"name": "mul_lt_one_of_le_of_lt", "description": "**Alias** of `left.mul_lt_one_of_le_of_lt`."}, {"name": "strict_anti_on.const_add", "description": ""}, {"name": "mul_lt_of_lt_one_of_lt'", "description": ""}, {"name": "le_of_le_mul_of_le_one_right", "description": ""}, {"name": "right.mul_lt_one_of_lt_of_le", "description": " Assumes right covariance.\nThe lemma assuming left covariance is `left.mul_lt_one_of_lt_of_le`."}, {"name": "strict_mono.add_const", "description": ""}, {"name": "add_le_cancellable.add_le_iff_nonpos_left", "description": ""}, {"name": "right.mul_le_one", "description": " Assumes right covariance.\nThe lemma assuming left covariance is `left.mul_le_one`."}, {"name": "left.mul_lt_one'", "description": " Assumes left covariance.\nThe lemma assuming right covariance is `right.mul_lt_one'`."}, {"name": "lt_add_of_le_of_pos", "description": ""}, {"name": "add_le_iff_nonpos_right", "description": ""}, {"name": "right.add_pos_of_pos_of_nonneg", "description": "Assumes right covariance.\nThe lemma assuming left covariance is `left.add_pos_of_pos_of_nonneg`."}, {"name": "lt_of_mul_lt_of_one_le_right", "description": ""}, {"name": "add_lt_of_neg_of_lt'", "description": ""}, {"name": "add_le_of_add_le_left", "description": ""}, {"name": "le_add_of_le_of_nonneg", "description": ""}, {"name": "mul_le_of_le_of_le_one", "description": ""}, {"name": "add_le_cancellable.le_add_iff_nonneg_left", "description": ""}, {"name": "mul_le_of_mul_le_right", "description": ""}, {"name": "left.mul_lt_one_of_lt_of_le", "description": " Assumes left covariance.\nThe lemma assuming right covariance is `right.mul_lt_one_of_lt_of_le`."}, {"name": "strict_anti.const_add", "description": ""}, {"name": "add_lt_add_of_lt_of_lt", "description": ""}, {"name": "mul_eq_one_iff'", "description": ""}, {"name": "le_add_of_nonneg_of_le", "description": ""}, {"name": "antitone.add_const", "description": ""}, {"name": "add_lt_of_neg_left", "description": ""}, {"name": "le_mul_of_one_le_of_le", "description": ""}, {"name": "lt_of_add_lt_of_nonneg_right", "description": ""}, {"name": "strict_mono_on.add_monotone", "description": "The sum of a strictly monotone function and a monotone function is strictly monotone."}, {"name": "monotone.const_add", "description": ""}, {"name": "antitone_on.mul'", "description": "The product of two antitone functions is antitone."}, {"name": "add_lt_of_nonpos_of_lt", "description": ""}, {"name": "antitone_on.add", "description": "The sum of two antitone functions is antitone."}, {"name": "le_of_mul_le_mul_left'", "description": ""}, {"name": "mul_le_of_mul_le_left", "description": ""}, {"name": "add_lt_iff_neg_left", "description": ""}, {"name": "add_le_cancellable", "description": " An element `a : \u03b1` is `add_le_cancellable` if `x \u21a6 a + x` is order-reflecting.\nWe will make a separate version of many lemmas that require `[contravariant_class \u03b1 \u03b1 (+) (\u2264)]` with\n`mul_le_cancellable` assumptions instead. These lemmas can then be instantiated to specific types,\nlike `ennreal`, where we can replace the assumption `add_le_cancellable x` by `x \u2260 \u221e`."}, {"name": "left.one_lt_mul", "description": " Assumes left covariance.\nThe lemma assuming right covariance is `right.one_lt_mul`."}, {"name": "lt_add_of_pos_of_le", "description": ""}, {"name": "mul_le_mul_iff_right", "description": ""}, {"name": "monotone_on.add_strict_mono", "description": "The sum of a monotone function and a strictly monotone function is strictly monotone."}, {"name": "lt_of_add_lt_add_right", "description": ""}, {"name": "add_lt_of_neg_of_lt", "description": ""}, {"name": "one_lt_mul'", "description": "**Alias** of `left.one_lt_mul`."}, {"name": "lt_add_iff_pos_left", "description": ""}, {"name": "mul_le_mul_iff_left", "description": ""}, {"name": "mul_le_cancellable.mul_le_mul_iff_left", "description": ""}, {"name": "contravariant.to_left_cancel_semigroup", "description": "  A semigroup with a partial order and satisfying `left_cancel_semigroup`\n(i.e. `a * c < b * c \u2192 a < b`) is a `left_cancel semigroup`."}, {"name": "mul_lt_mul_iff_right", "description": ""}, {"name": "le_add_of_le_add_left", "description": ""}, {"name": "right.add_pos'", "description": "Assumes right covariance.\nThe lemma assuming left covariance is `left.add_pos'`."}, {"name": "strict_mono.mul'", "description": "The product of two strictly monotone functions is strictly monotone."}, {"name": "mul_lt_of_lt_one_of_le", "description": ""}, {"name": "lt_add_of_pos_of_lt'", "description": ""}, {"name": "lt_add_of_lt_of_pos'", "description": ""}, {"name": "lt_of_add_lt_add_left", "description": ""}, {"name": "lt_mul_of_one_le_of_lt", "description": ""}, {"name": "monotone.mul_strict_mono'", "description": "The product of a monotone function and a strictly monotone function is strictly monotone."}, {"name": "left.add_pos_of_pos_of_nonneg", "description": "Assumes left covariance.\nThe lemma assuming right covariance is `right.add_pos_of_pos_of_nonneg`."}, {"name": "add_neg_of_nonpos_of_neg", "description": "**Alias** of `left.add_neg_of_nonpos_of_neg`."}, {"name": "add_le_add_right", "description": ""}, {"name": "mul_lt_of_lt_of_lt_one", "description": ""}, {"name": "lt_add_of_nonneg_of_lt", "description": ""}, {"name": "add_le_cancellable.add_le_add_iff_left", "description": ""}, {"name": "lt_add_of_lt_add_right", "description": ""}, {"name": "left.one_le_mul", "description": " Assumes left covariance.\nThe lemma assuming right covariance is `right.one_le_mul`."}, {"name": "left.add_pos'", "description": "Assumes left covariance.\nThe lemma assuming right covariance is `right.add_pos'`."}, {"name": "mul_le_mul_left'", "description": ""}, {"name": "monotone.mul'", "description": "The product of two monotone functions is monotone."}, {"name": "le_mul_of_one_le_left'", "description": ""}, {"name": "mul_lt_of_lt_of_lt_one'", "description": ""}, {"name": "le_mul_of_le_mul_right", "description": ""}, {"name": "one_le_mul", "description": "**Alias** of `left.one_le_mul`."}, {"name": "right.mul_lt_one_of_le_of_lt", "description": " Assumes right covariance.\nThe lemma assuming left covariance is `left.mul_lt_one_of_le_of_lt`."}, {"name": "lt_of_lt_mul_of_le_one_right", "description": ""}, {"name": "lt_add_iff_pos_right", "description": ""}, {"name": "left.mul_eq_mul_iff_eq_and_eq", "description": ""}, {"name": "right.one_lt_mul_of_lt_of_le", "description": " Assumes right covariance.\nThe lemma assuming left covariance is `left.one_lt_mul_of_lt_of_le`."}, {"name": "left.add_eq_add_iff_eq_and_eq", "description": ""}, {"name": "lt_mul_iff_one_lt_left'", "description": ""}, {"name": "add_neg'", "description": "**Alias** of `left.add_neg'`."}, {"name": "add_le_cancellable.inj_left", "description": ""}, {"name": "add_lt_of_neg_right", "description": ""}, {"name": "add_lt_add", "description": "**Alias** of `add_lt_add_of_lt_of_lt`."}, {"name": "strict_mono_on.mul'", "description": "The product of two strictly monotone functions is strictly monotone."}, {"name": "lt_add_of_pos_left", "description": ""}, {"name": "le_of_le_add_of_nonpos_left", "description": ""}, {"name": "right.add_neg", "description": "Assumes right covariance.\nThe lemma assuming left covariance is `left.add_neg`."}, {"name": "le_of_add_le_add_left", "description": ""}, {"name": "mul_le_cancellable.mul_le_mul_iff_right", "description": ""}, {"name": "add_le_cancellable.injective_left", "description": ""}, {"name": "add_neg_of_neg_of_nonpos", "description": "**Alias** of `left.add_neg_of_neg_of_nonpos`."}, {"name": "lt_mul_of_lt_of_one_lt'", "description": ""}, {"name": "add_le_iff_nonpos_left", "description": ""}, {"name": "left.add_pos", "description": "Assumes left covariance.\nThe lemma assuming right covariance is `right.add_pos`."}, {"name": "antitone_on.mul_strict_anti'", "description": "The product of a antitone function and a strictly antitone function is strictly antitone."}, {"name": "add_le_of_nonpos_left", "description": ""}, {"name": "mul_lt_iff_lt_one_left'", "description": ""}, {"name": "one_lt_mul''", "description": "**Alias** of `left.one_lt_mul'`."}, {"name": "lt_mul_of_lt_mul_right", "description": ""}, {"name": "mul_lt_of_lt_one_of_lt", "description": ""}, {"name": "monotone.add_strict_mono", "description": "The sum of a monotone function and a strictly monotone function is strictly monotone."}, {"name": "le_of_le_mul_of_le_one_left", "description": ""}, {"name": "one_lt_mul_of_lt_of_le'", "description": "**Alias** of `left.one_lt_mul_of_lt_of_le`."}, {"name": "left.add_neg", "description": "Assumes left covariance.\nThe lemma assuming right covariance is `right.add_neg`."}, {"name": "strict_anti.mul_const'", "description": ""}, {"name": "mul_le_cancellable.inj_left", "description": ""}, {"name": "add_le_of_nonpos_of_le", "description": ""}, {"name": "monotone_on.mul'", "description": "The product of two monotone functions is monotone."}, {"name": "add_le_add_iff_left", "description": ""}, {"name": "add_le_cancellable.le_add_iff_nonneg_right", "description": ""}, {"name": "add_neg", "description": "**Alias** of `left.add_neg`."}, {"name": "monotone_on.const_mul'", "description": ""}, {"name": "add_right_cancel''", "description": ""}, {"name": "add_le_of_add_le_right", "description": ""}, {"name": "lt_of_lt_add_of_nonpos_left", "description": ""}, {"name": "add_pos'", "description": "**Alias** of `left.add_pos'`."}, {"name": "mul_le_cancellable.mul_le_iff_le_one_left", "description": ""}, {"name": "strict_mono_on.add_const", "description": ""}, {"name": "mul_le_of_le_one_of_le", "description": ""}, {"name": "mul_right_cancel''", "description": ""}, {"name": "mul_lt_of_le_of_lt_one", "description": ""}, {"name": "right.add_nonneg", "description": "Assumes right covariance.\nThe lemma assuming left covariance is `left.add_nonneg`."}, {"name": "strict_mono.const_add", "description": ""}, {"name": "mul_lt_mul_of_le_of_lt", "description": ""}, {"name": "strict_mono_on.const_mul'", "description": ""}, {"name": "add_le_add_three", "description": ""}, {"name": "strict_anti_on.add_const", "description": ""}, {"name": "mul_lt_of_mul_lt_left", "description": ""}, {"name": "strict_anti_on.mul'", "description": "The product of two strictly antitone functions is strictly antitone."}, {"name": "add_pos_of_nonneg_of_pos", "description": "**Alias** of `left.add_pos_of_nonneg_of_pos`."}, {"name": "contravariant.add_le_cancellable", "description": ""}, {"name": "left.add_nonneg", "description": "Assumes left covariance.\nThe lemma assuming right covariance is `right.add_nonneg`."}, {"name": "lt_mul_iff_one_lt_right'", "description": ""}, {"name": "strict_mono.add", "description": "The sum of two strictly monotone functions is strictly monotone."}, {"name": "monotone.add_const", "description": ""}, {"name": "one_lt_mul_of_le_of_lt'", "description": "**Alias** of `left.one_lt_mul_of_le_of_lt`."}, {"name": "add_le_cancellable.add_le_add_iff_right", "description": ""}, {"name": "le_mul_of_one_le_right'", "description": ""}, {"name": "mul_le_one'", "description": "**Alias** of `left.mul_le_one`."}, {"name": "monotone.const_mul'", "description": ""}, {"name": "lt_mul_of_one_lt_of_lt", "description": ""}, {"name": "strict_mono_on.const_add", "description": ""}, {"name": "add_le_add_left", "description": ""}, {"name": "strict_anti.const_mul'", "description": ""}, {"name": "antitone.mul_strict_anti'", "description": "The product of a antitone function and a strictly antitone function is strictly antitone."}, {"name": "monotone.add", "description": "The sum of two monotone functions is monotone."}, {"name": "le_add_iff_nonneg_right", "description": ""}, {"name": "left.mul_lt_one_of_le_of_lt", "description": " Assumes left covariance.\nThe lemma assuming right covariance is `right.mul_lt_one_of_le_of_lt`."}, {"name": "le_mul_of_le_of_one_le", "description": ""}, {"name": "add_eq_add_iff_eq_and_eq", "description": "**Alias** of `left.mul_eq_mul_iff_eq_and_eq`."}, {"name": "add_pos", "description": "**Alias** of `left.add_pos`."}, {"name": "strict_anti.mul'", "description": "The product of two strictly antitone functions is strictly antitone."}, {"name": "mul_le_of_le_one_left'", "description": ""}, {"name": "mul_le_mul_right'", "description": ""}, {"name": "mul_eq_mul_iff_eq_and_eq", "description": "**Alias** of `left.mul_eq_mul_iff_eq_and_eq`."}, {"name": "mul_le_cancellable.inj", "description": ""}, {"name": "mul_le_cancellable.injective", "description": ""}, {"name": "contravariant.to_right_cancel_semigroup", "description": "  A semigroup with a partial order and satisfying `right_cancel_semigroup`\n(i.e. `a * c < b * c \u2192 a < b`) is a `right_cancel semigroup`."}, {"name": "strict_mono.const_mul'", "description": ""}, {"name": "lt_mul_of_lt_of_one_le", "description": ""}, {"name": "contravariant.to_left_cancel_add_semigroup", "description": "An additive semigroup with a partial order and satisfying `left_cancel_add_semigroup`\n(i.e. `c + a < c + b \u2192 a < b`) is a `left_cancel add_semigroup`."}, {"name": "monotone.mul_const'", "description": ""}, {"name": "mul_lt_of_lt_one_left'", "description": ""}, {"name": "add_lt_iff_neg_right", "description": ""}, {"name": "right.mul_lt_one", "description": " Assumes right covariance.\nThe lemma assuming left covariance is `left.mul_lt_one`."}, {"name": "lt_add_of_lt_add_left", "description": ""}, {"name": "le_of_mul_le_of_one_le_left", "description": ""}, {"name": "add_nonneg", "description": "**Alias** of `left.add_nonneg`."}, {"name": "mul_le_cancellable", "description": "An element `a : \u03b1` is `mul_le_cancellable` if `x \u21a6 a * x` is order-reflecting.\nWe will make a separate version of many lemmas that require `[contravariant_class \u03b1 \u03b1 (*) (\u2264)]` with\n`mul_le_cancellable` assumptions instead. These lemmas can then be instantiated to specific types,\nlike `ennreal`, where we can replace the assumption `add_le_cancellable x` by `x \u2260 \u221e`."}, {"name": "lt_add_of_pos_of_lt", "description": ""}, {"name": "lt_mul_of_lt_mul_left", "description": ""}, {"name": "mul_lt_mul_right'", "description": ""}, {"name": "mul_le_cancellable.mul_le_iff_le_one_right", "description": ""}, {"name": "mul_lt_iff_lt_one_right'", "description": ""}, {"name": "add_lt_add_of_le_of_lt", "description": ""}, {"name": "add_le_add_iff_right", "description": ""}, {"name": "mul_lt_mul_iff_left", "description": ""}, {"name": "strict_anti.add_antitone", "description": "The sum of a strictly antitone function and a antitone function is strictly antitone."}, {"name": "lt_mul_of_lt_of_one_lt", "description": ""}, {"name": "left.add_nonpos", "description": "Assumes left covariance.\nThe lemma assuming right covariance is `right.add_nonpos`."}, {"name": "add_lt_add_right", "description": ""}, {"name": "strict_anti_on.mul_antitone'", "description": "The product of a strictly antitone function and a antitone function is strictly antitone."}, {"name": "lt_of_mul_lt_mul_right'", "description": ""}, {"name": "add_le_add", "description": ""}, {"name": "right.one_lt_mul_of_le_of_lt", "description": " Assumes right covariance.\nThe lemma assuming left covariance is `left.one_lt_mul_of_le_of_lt`."}, {"name": "left.add_lt_add", "description": "Only assumes left strict covariance"}, {"name": "add_le_cancellable.inj", "description": ""}, {"name": "antitone_on.add_strict_anti", "description": "The sum of a antitone function and a strictly antitone function is strictly antitone."}, {"name": "right.add_neg'", "description": "Assumes right covariance.\nThe lemma assuming left covariance is `left.add_neg'`."}, {"name": "strict_mono.add_monotone", "description": "The sum of a strictly monotone function and a monotone function is strictly monotone."}, {"name": "le_of_add_le_of_nonneg_left", "description": ""}, {"name": "right.add_pos", "description": "Assumes right covariance.\nThe lemma assuming left covariance is `left.add_pos`."}, {"name": "strict_mono.mul_monotone'", "description": "The product of a strictly monotone function and a monotone function is strictly monotone."}, {"name": "le_add_iff_nonneg_left", "description": ""}, {"name": "mul_lt_of_lt_of_le_one", "description": ""}, {"name": "le_add_of_le_add_right", "description": ""}, {"name": "le_of_le_add_of_nonpos_right", "description": ""}, {"name": "left.one_lt_mul_of_lt_of_le", "description": " Assumes left covariance.\nThe lemma assuming right covariance is `right.one_lt_mul_of_lt_of_le`."}, {"name": "exists_square_le", "description": ""}, {"name": "left.mul_le_one", "description": " Assumes left covariance.\nThe lemma assuming right covariance is `right.mul_le_one`."}, {"name": "add_lt_add_iff_right", "description": ""}, {"name": "le_of_mul_le_mul_right'", "description": ""}, {"name": "add_lt_add_iff_left", "description": ""}, {"name": "lt_add_of_pos_right", "description": ""}, {"name": "monotone_on.add_const", "description": ""}, {"name": "lt_add_of_lt_of_pos", "description": ""}, {"name": "lt_of_mul_lt_mul_left'", "description": ""}, {"name": "add_le_of_nonpos_right", "description": ""}, {"name": "mul_le_mul'", "description": ""}, {"name": "left.add_pos_of_nonneg_of_pos", "description": "Assumes left covariance.\nThe lemma assuming right covariance is `right.add_pos_of_nonneg_of_pos`."}, {"name": "left.one_lt_mul_of_le_of_lt", "description": " Assumes left covariance.\nThe lemma assuming right covariance is `right.one_lt_mul_of_le_of_lt`."}, {"name": "strict_anti_on.add", "description": "The sum of two strictly antitone functions is strictly antitone."}, {"name": "antitone.add_strict_anti", "description": "The sum of a antitone function and a strictly antitone function is strictly antitone."}, {"name": "lt_mul_of_one_lt_right'", "description": ""}, {"name": "right.one_lt_mul'", "description": " Assumes right covariance.\nThe lemma assuming left covariance is `left.one_lt_mul'`."}, {"name": "mul_le_cancellable_one", "description": ""}, {"name": "le_of_mul_le_of_one_le_right", "description": ""}, {"name": "antitone.add", "description": "The sum of two antitone functions is antitone."}, {"name": "le_mul_of_le_mul_left", "description": ""}, {"name": "lt_mul_of_one_lt_of_lt'", "description": ""}, {"name": "add_le_cancellable_zero", "description": ""}, {"name": "lt_mul_of_one_lt_left'", "description": ""}, {"name": "add_pos_of_pos_of_nonneg", "description": "**Alias** of `left.add_pos_of_pos_of_nonneg`."}, {"name": "add_left_cancel''", "description": ""}, {"name": "strict_mono_on.add", "description": "The sum of two strictly monotone functions is strictly monotone."}, {"name": "lt_mul_of_le_of_one_lt", "description": ""}, {"name": "add_lt_add_left", "description": ""}, {"name": "strict_mono_on.mul_monotone'", "description": "The product of a strictly monotone function and a monotone function is strictly monotone."}, {"name": "mul_lt_mul_of_lt_of_le", "description": ""}, {"name": "mul_left_cancel''", "description": ""}, {"name": "right.add_lt_add", "description": "Only assumes right strict covariance"}, {"name": "antitone_on.const_mul'", "description": ""}, {"name": "left.one_lt_mul'", "description": " Assumes left covariance.\nThe lemma assuming right covariance is `right.one_lt_mul'`."}, {"name": "antitone.const_add", "description": ""}, {"name": "strict_anti_on.const_mul'", "description": ""}, {"name": "add_lt_of_neg_of_le", "description": ""}, {"name": "lt_add_of_lt_of_nonneg", "description": ""}, {"name": "contravariant.mul_le_cancellable", "description": ""}, {"name": "mul_le_iff_le_one_right'", "description": ""}, {"name": "right.one_le_mul", "description": " Assumes right covariance.\nThe lemma assuming left covariance is `left.one_le_mul`."}, {"name": "antitone_on.mul_const'", "description": ""}, {"name": "add_lt_of_add_lt_left", "description": ""}, {"name": "antitone_on.const_add", "description": ""}, {"name": "monotone_on.add", "description": "The sum of two monotone functions is monotone."}, {"name": "mul_lt_of_lt_one_right'", "description": ""}, {"name": "mul_lt_mul_left'", "description": ""}, {"name": "strict_anti.add_const", "description": ""}, {"name": "antitone.mul'", "description": "The product of two antitone functions is antitone."}, {"name": "right.add_neg_of_nonpos_of_neg", "description": "Assumes right covariance.\nThe lemma assuming left covariance is `left.add_neg_of_nonpos_of_neg`."}, {"name": "left.add_neg'", "description": "Assumes left covariance.\nThe lemma assuming right covariance is `right.add_neg'`."}, {"name": "right.one_lt_mul", "description": " Assumes right covariance.\nThe lemma assuming left covariance is `left.one_lt_mul`."}, {"name": "left.add_neg_of_neg_of_nonpos", "description": "Assumes left covariance.\nThe lemma assuming right covariance is `right.add_neg_of_neg_of_nonpos`."}, {"name": "add_lt_of_lt_of_neg", "description": ""}, {"name": "strict_mono.mul_const'", "description": ""}, {"name": "add_lt_of_add_lt_right", "description": ""}, {"name": "mul_le_cancellable.le_mul_iff_one_le_left", "description": ""}, {"name": "add_lt_of_lt_of_neg'", "description": ""}, {"name": "right.mul_lt_mul", "description": "Only assumes right strict covariance."}, {"name": "lt_mul_of_one_lt_of_le", "description": ""}, {"name": "add_le_cancellable.injective", "description": ""}, {"name": "right.add_nonpos", "description": "Assumes right covariance.\nThe lemma assuming left covariance is `left.add_nonpos`."}, {"name": "antitone_on.add_const", "description": ""}, {"name": "le_of_add_le_of_nonneg_right", "description": ""}, {"name": "mul_le_cancellable.le_mul_iff_one_le_right", "description": ""}, {"name": "le_add_of_nonneg_left", "description": ""}, {"name": "monotone_on.mul_strict_mono'", "description": "The product of a monotone function and a strictly monotone function is strictly monotone."}, {"name": "left.add_neg_of_nonpos_of_neg", "description": "Assumes left covariance.\nThe lemma assuming right covariance is `right.add_neg_of_nonpos_of_neg`."}, {"name": "le_of_add_le_add_right", "description": ""}, {"name": "strict_anti_on.mul_const'", "description": ""}, {"name": "strict_mono_on.mul_const'", "description": ""}, {"name": "le_mul_iff_one_le_right'", "description": ""}, {"name": "right.mul_lt_one'", "description": " Assumes right covariance.\nThe lemma assuming left covariance is `left.mul_lt_one'`."}, {"name": "add_le_of_le_of_nonpos", "description": ""}, {"name": "lt_of_lt_mul_of_le_one_left", "description": ""}, {"name": "add_le_cancellable.add_le_iff_nonpos_right", "description": ""}, {"name": "mul_le_cancellable.injective_left", "description": ""}, {"name": "le_mul_iff_one_le_left'", "description": ""}, {"name": "mul_le_iff_le_one_left'", "description": ""}, {"name": "lt_of_add_lt_of_nonneg_left", "description": ""}, {"name": "antitone.const_mul'", "description": ""}, {"name": "tactic.interactive.monotonicity.attr", "description": ""}, {"name": "tactic.interactive.mono_key.has_lt", "description": ""}, {"name": "tactic.interactive.filter_instances", "description": ""}, {"name": "tactic.interactive.mono_selection.decidable_eq", "description": ""}, {"name": "tactic.interactive.mono_key", "description": ""}, {"name": "tactic.interactive.find_one_difference", "description": ""}, {"name": "tactic.interactive.mono_selection.has_to_format", "description": ""}, {"name": "tactic.interactive.get_operator", "description": ""}, {"name": "tactic.interactive.mono_head_candidates", "description": ""}, {"name": "tactic.interactive.compare", "description": ""}, {"name": "tactic.interactive.monotonicity.check_rel", "description": ""}, {"name": "tactic.interactive.side", "description": ""}, {"name": "tactic.interactive.mono_cfg", "description": ""}, {"name": "tactic.interactive.mono_cfg.unify", "description": ""}, {"name": "tactic.interactive.same_operator", "description": ""}, {"name": "tactic.interactive.get_monotonicity_lemmas", "description": ""}, {"name": "tactic.interactive.mono_cfg.inhabited", "description": ""}, {"name": "tactic.interactive.match_imp", "description": ""}, {"name": "tactic.interactive.mono_selection", "description": ""}, {"name": "tactic.interactive.mono_selection.left", "description": ""}, {"name": "tactic.interactive.mono_selection.right", "description": ""}, {"name": "tactic.interactive.mono_selection.both", "description": ""}, {"name": "tactic.interactive.last_two", "description": ""}, {"name": "tactic.interactive.mono_selection.inhabited", "description": ""}, {"name": "tactic.interactive.monotonicity.check", "description": ""}, {"name": "tactic.interactive.mono_selection.has_reflect", "description": ""}, {"name": "lean.parser.sep_by", "description": ""}, {"name": "lean.parser.run_with_input", "description": ""}, {"name": "lean.parser.run", "description": ""}, {"name": "lean.parser_state.cur_pos", "description": ""}, {"name": "lean.parser.many", "description": ""}, {"name": "lean.parser.reflectable.to_parser", "description": ""}, {"name": "lean.parser.reflectable.optional", "description": ""}, {"name": "lean.parser.list_include_var_names", "description": ""}, {"name": "lean.parser.of_tactic", "description": ""}, {"name": "lean.parser.with_input", "description": "Temporarily replace input of the parser state, run `p`, and return remaining input."}, {"name": "lean.parser_state.options", "description": ""}, {"name": "lean.parser", "description": ""}, {"name": "lean.parser.skip_info", "description": "Do not report info from content parsed by `p`."}, {"name": "lean.parser.val", "description": ""}, {"name": "lean.parser.set_goal_info_pos", "description": "Set goal info position of content parsed by `p` to current position. Nested calls take precedence."}, {"name": "lean.parser.reflectable", "description": ""}, {"name": "lean.parser.reflectable.full", "description": ""}, {"name": "lean.parser.set_env", "description": ""}, {"name": "lean.parser_result", "description": ""}, {"name": "lean.parser.small_nat", "description": "Make sure the next token is a small nat, consume it, and produce it"}, {"name": "lean.parser.tk", "description": "Check that the next token is `tk` and consume it. `tk` must be a registered token."}, {"name": "lean.parser.add_local", "description": "a variable to local scope"}, {"name": "lean.parser.pop_local_scope", "description": ""}, {"name": "lean.parser.ident", "description": "Make sure the next token is an identifier, consume it, and\n   produce the quoted name `t, where t is the identifier."}, {"name": "lean.parser.omit_var", "description": ""}, {"name": "lean.parser.reflectable.has_reflect", "description": ""}, {"name": "lean.parser.list_available_include_vars", "description": ""}, {"name": "lean.parser.has_coe", "description": ""}, {"name": "lean.parser.command_like", "description": "Parse a top-level command."}, {"name": "lean.parser.reflectable.cast", "description": ""}, {"name": "lean.parser.reflectable.expr", "description": ""}, {"name": "lean.parser_state.env", "description": ""}, {"name": "lean.parser.include_var", "description": ""}, {"name": "lean.parser.alternative", "description": ""}, {"name": "lean.parser.pexpr", "description": " Parse an unelaborated expression using the given right-binding power.\nWhen `pat := tt`, the expression is parsed as a pattern, i.e. local\nconstants are not checked."}, {"name": "lean.parser.itactic", "description": "Parse an interactive tactic block: `begin` .. `end`"}, {"name": "lean.parser_state", "description": ""}, {"name": "lean.parser.parser_orelse", "description": ""}, {"name": "lean.parser.add_local_level", "description": ""}, {"name": "lean.parser.push_local_scope", "description": ""}, {"name": "lean.parser.reflect", "description": ""}, {"name": "lean.parser.cur_pos", "description": "Return the current parser position without consuming any input."}, {"name": "lean.parser.get_env", "description": ""}, {"name": "lean.parser.itactic_reflected", "description": ""}, {"name": "lean.parser.with_local_scope", "description": "Run the parser in a local declaration scope.\n\nLocal declarations added via `add_local` do not propagate outside of this scope."}, {"name": "decidable_pred", "description": ""}, {"name": "and.elim_right", "description": ""}, {"name": "option.has_sizeof", "description": ""}, {"name": "default.sizeof", "description": ""}, {"name": "thunk", "description": "Gadget for defining thunks, thunk parameters have special treatment.\nExample: given\n      def f (s : string) (t : thunk nat) : nat\nan application\n     f \"hello\" 10\n is converted into\n     f \"hello\" (\u03bb _, 10)"}, {"name": "superset", "description": ""}, {"name": "has_ssubset", "description": ""}, {"name": "has_ssubset.ssubset", "description": ""}, {"name": "has_andthen", "description": ""}, {"name": "has_andthen.andthen", "description": ""}, {"name": "subtype", "description": ""}, {"name": "subtype.val", "description": ""}, {"name": "subtype.property", "description": ""}, {"name": "eq.symm", "description": ""}, {"name": "id_rhs", "description": ""}, {"name": "heq", "description": "Heterogeneous equality.\n\nIts purpose is to write down equalities between terms whose types are not definitionally equal.\nFor example, given `x : vector \u03b1 n` and `y : vector \u03b1 (0+n)`, `x = y` doesn't typecheck but `x == y` does.\n\nIf you have a goal `\u22a2 x == y`,\nyour first instinct should be to ask (either yourself, or on [zulip](https://leanprover.zulipchat.com/))\nif something has gone wrong already.\nIf you really do need to follow this route,\nyou may find the lemmas `eq_rec_heq` and `eq_mpr_heq` useful."}, {"name": "heq.refl", "description": "Heterogeneous equality.\n\nIts purpose is to write down equalities between terms whose types are not definitionally equal.\nFor example, given `x : vector \u03b1 n` and `y : vector \u03b1 (0+n)`, `x = y` doesn't typecheck but `x == y` does.\n\nIf you have a goal `\u22a2 x == y`,\nyour first instinct should be to ask (either yourself, or on [zulip](https://leanprover.zulipchat.com/))\nif something has gone wrong already.\nIf you really do need to follow this route,\nyou may find the lemmas `eq_rec_heq` and `eq_mpr_heq` useful."}, {"name": "id_delta", "description": "The kernel definitional equality test (t =?= s) has special support for id_delta applications.\nIt implements the following rules\n\n   1)   (id_delta t) =?= t\n   2)   t =?= (id_delta t)\n   3)   (id_delta t) =?= s  IF (unfold_of t) =?= s\n   4)   t =?= id_delta s    IF t =?= (unfold_of s)\n\nThis is mechanism for controlling the delta reduction (aka unfolding) used in the kernel.\n\nWe use id_delta applications to address performance problems when type checking\nlemmas generated by the equation compiler."}, {"name": "unification_constraint", "description": ""}, {"name": "unification_constraint.\u03b1", "description": ""}, {"name": "unification_constraint.lhs", "description": ""}, {"name": "unification_constraint.rhs", "description": ""}, {"name": "nat_add_zero", "description": ""}, {"name": "list.has_sizeof", "description": ""}, {"name": "has_pow", "description": ""}, {"name": "has_pow.pow", "description": ""}, {"name": "sizeof", "description": ""}, {"name": "has_div", "description": ""}, {"name": "has_div.div", "description": ""}, {"name": "has_mul", "description": ""}, {"name": "has_mul.mul", "description": ""}, {"name": "punit.has_sizeof", "description": ""}, {"name": "std.priority.default", "description": ""}, {"name": "bin_tree", "description": "Auxiliary datatype for #[ ... ] notation.\n   #[1, 2, 3, 4] is notation for\n\n   bin_tree.node\n     (bin_tree.node (bin_tree.leaf 1) (bin_tree.leaf 2))\n     (bin_tree.node (bin_tree.leaf 3) (bin_tree.leaf 4))\n\n   We use this notation to input long sequences without exhausting the system stack space.\n   Later, we define a coercion from `bin_tree` into `list`."}, {"name": "bin_tree.empty", "description": "Auxiliary datatype for #[ ... ] notation.\n   #[1, 2, 3, 4] is notation for\n\n   bin_tree.node\n     (bin_tree.node (bin_tree.leaf 1) (bin_tree.leaf 2))\n     (bin_tree.node (bin_tree.leaf 3) (bin_tree.leaf 4))\n\n   We use this notation to input long sequences without exhausting the system stack space.\n   Later, we define a coercion from `bin_tree` into `list`."}, {"name": "bin_tree.leaf", "description": "Auxiliary datatype for #[ ... ] notation.\n   #[1, 2, 3, 4] is notation for\n\n   bin_tree.node\n     (bin_tree.node (bin_tree.leaf 1) (bin_tree.leaf 2))\n     (bin_tree.node (bin_tree.leaf 3) (bin_tree.leaf 4))\n\n   We use this notation to input long sequences without exhausting the system stack space.\n   Later, we define a coercion from `bin_tree` into `list`."}, {"name": "bin_tree.node", "description": "Auxiliary datatype for #[ ... ] notation.\n   #[1, 2, 3, 4] is notation for\n\n   bin_tree.node\n     (bin_tree.node (bin_tree.leaf 1) (bin_tree.leaf 2))\n     (bin_tree.node (bin_tree.leaf 3) (bin_tree.leaf 4))\n\n   We use this notation to input long sequences without exhausting the system stack space.\n   Later, we define a coercion from `bin_tree` into `list`."}, {"name": "has_dvd", "description": ""}, {"name": "has_dvd.dvd", "description": ""}, {"name": "has_sep", "description": ""}, {"name": "has_sep.sep", "description": ""}, {"name": "has_union", "description": ""}, {"name": "has_union.union", "description": ""}, {"name": "has_sdiff", "description": ""}, {"name": "has_sdiff.sdiff", "description": ""}, {"name": "has_subset", "description": ""}, {"name": "has_subset.subset", "description": ""}, {"name": "nat.has_zero", "description": ""}, {"name": "sigma.has_sizeof", "description": ""}, {"name": "has_append", "description": ""}, {"name": "has_append.append", "description": ""}, {"name": "decidable_eq", "description": ""}, {"name": "eq_of_heq", "description": ""}, {"name": "combinator.I", "description": ""}, {"name": "combinator.S", "description": ""}, {"name": "has_singleton", "description": ""}, {"name": "has_singleton.singleton", "description": ""}, {"name": "has_add", "description": ""}, {"name": "has_add.add", "description": ""}, {"name": "nat.has_add", "description": ""}, {"name": "is_lawful_singleton", "description": ""}, {"name": "is_lawful_singleton.insert_emptyc_eq", "description": ""}, {"name": "bool", "description": ""}, {"name": "bool.ff", "description": ""}, {"name": "bool.tt", "description": ""}, {"name": "std.prec.arrow", "description": ""}, {"name": "ge", "description": ""}, {"name": "has_neg", "description": ""}, {"name": "has_neg.neg", "description": ""}, {"name": "has_insert", "description": ""}, {"name": "has_insert.insert", "description": ""}, {"name": "std.prec.max", "description": ""}, {"name": "or", "description": "Logical or.\n\n`or P Q`, with notation `P \u2228 Q`, is the proposition which is true if and only if `P` or `Q` is\ntrue.\n\nTo prove a goal `\u22a2 P \u2228 Q`, if you know which alternative you want to prove,\nyou can use the tactics `left` (which gives the goal `\u22a2 P`)\nor `right` (which gives the goal `\u22a2 Q`).\n\nGiven a hypothesis `h : P \u2228 Q` and goal `\u22a2 R`,\nthe tactic `cases h` will give you two copies of the goal `\u22a2 R`,\nwith the hypothesis `h : P` in the first, and the hypothesis `h : Q` in the second."}, {"name": "or.inl", "description": "Logical or.\n\n`or P Q`, with notation `P \u2228 Q`, is the proposition which is true if and only if `P` or `Q` is\ntrue.\n\nTo prove a goal `\u22a2 P \u2228 Q`, if you know which alternative you want to prove,\nyou can use the tactics `left` (which gives the goal `\u22a2 P`)\nor `right` (which gives the goal `\u22a2 Q`).\n\nGiven a hypothesis `h : P \u2228 Q` and goal `\u22a2 R`,\nthe tactic `cases h` will give you two copies of the goal `\u22a2 R`,\nwith the hypothesis `h : P` in the first, and the hypothesis `h : Q` in the second."}, {"name": "or.inr", "description": "Logical or.\n\n`or P Q`, with notation `P \u2228 Q`, is the proposition which is true if and only if `P` or `Q` is\ntrue.\n\nTo prove a goal `\u22a2 P \u2228 Q`, if you know which alternative you want to prove,\nyou can use the tactics `left` (which gives the goal `\u22a2 P`)\nor `right` (which gives the goal `\u22a2 Q`).\n\nGiven a hypothesis `h : P \u2228 Q` and goal `\u22a2 R`,\nthe tactic `cases h` will give you two copies of the goal `\u22a2 R`,\nwith the hypothesis `h : P` in the first, and the hypothesis `h : Q` in the second."}, {"name": "eq.subst", "description": ""}, {"name": "decidable_rel", "description": ""}, {"name": "gt", "description": ""}, {"name": "ssuperset", "description": ""}, {"name": "psigma", "description": ""}, {"name": "psigma.fst", "description": ""}, {"name": "psigma.snd", "description": ""}, {"name": "nat.has_sizeof", "description": ""}, {"name": "prod.has_sizeof", "description": ""}, {"name": "bit0", "description": ""}, {"name": "std.prec.max_plus", "description": ""}, {"name": "unit", "description": "An abbreviation for `punit.{0}`, its most common instantiation.\n   This type should be preferred over `punit` where possible to avoid\n   unnecessary universe parameters."}, {"name": "or.intro_left", "description": ""}, {"name": "has_inter", "description": ""}, {"name": "has_inter.inter", "description": ""}, {"name": "subtype.has_sizeof", "description": ""}, {"name": "out_param", "description": "Gadget for marking output parameters in type classes."}, {"name": "has_le", "description": ""}, {"name": "has_le.le", "description": ""}, {"name": "heq.rfl", "description": ""}, {"name": "and.elim_left", "description": ""}, {"name": "infer_instance", "description": "Like `by apply_instance`, but not dependent on the tactic framework."}, {"name": "nat", "description": ""}, {"name": "nat.zero", "description": ""}, {"name": "nat.succ", "description": ""}, {"name": "rfl", "description": ""}, {"name": "psum", "description": ""}, {"name": "psum.inl", "description": ""}, {"name": "psum.inr", "description": ""}, {"name": "has_sizeof", "description": ""}, {"name": "has_sizeof.sizeof", "description": ""}, {"name": "false", "description": ""}, {"name": "combinator.K", "description": ""}, {"name": "has_mod", "description": ""}, {"name": "has_mod.mod", "description": ""}, {"name": "pprod", "description": "Similar to `prod`, but \u03b1 and \u03b2 can be propositions.\n  We use this type internally to automatically generate the brec_on recursor."}, {"name": "pprod.fst", "description": "Similar to `prod`, but \u03b1 and \u03b2 can be propositions.\n  We use this type internally to automatically generate the brec_on recursor."}, {"name": "pprod.snd", "description": "Similar to `prod`, but \u03b1 and \u03b2 can be propositions.\n  We use this type internally to automatically generate the brec_on recursor."}, {"name": "nat.has_one", "description": ""}, {"name": "has_zero", "description": ""}, {"name": "has_zero.zero", "description": ""}, {"name": "sigma", "description": ""}, {"name": "sigma.fst", "description": ""}, {"name": "sigma.snd", "description": ""}, {"name": "psum.has_sizeof", "description": ""}, {"name": "punit", "description": ""}, {"name": "not", "description": "Logical not.\n\n`not P`, with notation `\u00ac P`, is the `Prop` which is true if and only if `P` is false. It is\ninternally represented as `P \u2192 false`, so one way to prove a goal `\u22a2 \u00ac P` is to use `intro h`,\nwhich gives you a new hypothesis `h : P` and the goal `\u22a2 false`.\n\nA hypothesis `h : \u00ac P` can be used in term mode as a function, so if `w : P` then `h w : false`.\n\nRelated mathlib tactic: `contrapose`."}, {"name": "nat.prio", "description": ""}, {"name": "opt_param", "description": "Gadget for optional parameter support."}, {"name": "list", "description": ""}, {"name": "list.nil", "description": ""}, {"name": "list.cons", "description": ""}, {"name": "has_emptyc", "description": ""}, {"name": "has_emptyc.emptyc", "description": ""}, {"name": "has_one", "description": ""}, {"name": "has_one.one", "description": ""}, {"name": "std.priority.max", "description": ""}, {"name": "nat.add", "description": ""}, {"name": "decidable", "description": ""}, {"name": "decidable.is_false", "description": ""}, {"name": "decidable.is_true", "description": ""}, {"name": "and", "description": "Logical and.\n\n`and P Q`, with notation `P \u2227 Q`, is the `Prop` which is true precisely when `P` and `Q` are\nboth true.\n\nTo prove a goal `\u22a2 P \u2227 Q`, you can use the tactic `split`,\nwhich gives two separate goals `\u22a2 P` and `\u22a2 Q`.\n\nGiven a hypothesis `h : P \u2227 Q`, you can use the tactic `cases h with hP hQ`\nto obtain two new hypotheses `hP : P` and `hQ : Q`. See also the `obtain` or `rcases` tactics in\nmathlib."}, {"name": "and.left", "description": "Logical and.\n\n`and P Q`, with notation `P \u2227 Q`, is the `Prop` which is true precisely when `P` and `Q` are\nboth true.\n\nTo prove a goal `\u22a2 P \u2227 Q`, you can use the tactic `split`,\nwhich gives two separate goals `\u22a2 P` and `\u22a2 Q`.\n\nGiven a hypothesis `h : P \u2227 Q`, you can use the tactic `cases h with hP hQ`\nto obtain two new hypotheses `hP : P` and `hQ : Q`. See also the `obtain` or `rcases` tactics in\nmathlib."}, {"name": "and.right", "description": "Logical and.\n\n`and P Q`, with notation `P \u2227 Q`, is the `Prop` which is true precisely when `P` and `Q` are\nboth true.\n\nTo prove a goal `\u22a2 P \u2227 Q`, you can use the tactic `split`,\nwhich gives two separate goals `\u22a2 P` and `\u22a2 Q`.\n\nGiven a hypothesis `h : P \u2227 Q`, you can use the tactic `cases h with hP hQ`\nto obtain two new hypotheses `hP : P` and `hQ : Q`. See also the `obtain` or `rcases` tactics in\nmathlib."}, {"name": "default_has_sizeof", "description": ""}, {"name": "sum.has_sizeof", "description": ""}, {"name": "true", "description": ""}, {"name": "has_inv", "description": ""}, {"name": "has_inv.inv", "description": ""}, {"name": "has_lt", "description": ""}, {"name": "has_lt.lt", "description": ""}, {"name": "bit1", "description": ""}, {"name": "or.intro_right", "description": ""}, {"name": "empty", "description": ""}, {"name": "unit.star", "description": ""}, {"name": "prod", "description": ""}, {"name": "prod.fst", "description": ""}, {"name": "prod.snd", "description": ""}, {"name": "option", "description": ""}, {"name": "option.none", "description": ""}, {"name": "option.some", "description": ""}, {"name": "eq.trans", "description": ""}, {"name": "has_mem", "description": ""}, {"name": "has_mem.mem", "description": ""}, {"name": "has_equiv", "description": ""}, {"name": "has_equiv.equiv", "description": ""}, {"name": "psigma.has_sizeof", "description": ""}, {"name": "eq", "description": ""}, {"name": "eq.refl", "description": ""}, {"name": "has_sub", "description": ""}, {"name": "has_sub.sub", "description": ""}, {"name": "bool.has_sizeof", "description": ""}, {"name": "sum", "description": ""}, {"name": "sum.inl", "description": ""}, {"name": "sum.inr", "description": ""}, {"name": "unification_hint", "description": ""}, {"name": "unification_hint.pattern", "description": ""}, {"name": "unification_hint.constraints", "description": ""}, {"name": "category_theory.functor.right_unitor_inv_app", "description": ""}, {"name": "category_theory.functor.associator_inv_app", "description": ""}, {"name": "category_theory.whisker_left_twice", "description": ""}, {"name": "category_theory.iso_whisker_right_inv", "description": ""}, {"name": "category_theory.whisker_right_comp", "description": ""}, {"name": "category_theory.whisker_right_twice", "description": ""}, {"name": "category_theory.functor.left_unitor_hom_app", "description": ""}, {"name": "category_theory.whisker_left_id'", "description": ""}, {"name": "category_theory.iso_whisker_right", "description": "If `\u03b1 : G \u2245 H` then\n`iso_whisker_right \u03b1 F : (G \u22d9 F) \u2245 (H \u22d9 F)` has components `F.map_iso (\u03b1.app X)`."}, {"name": "category_theory.whisker_right_left", "description": ""}, {"name": "category_theory.functor.left_unitor_inv_app", "description": ""}, {"name": "category_theory.whisker_right", "description": "If `\u03b1 : G \u27f6 H` then\n`whisker_right \u03b1 F : (G \u22d9 F) \u27f6 (G \u22d9 F)` has components `F.map (\u03b1.app X)`."}, {"name": "category_theory.functor.left_unitor", "description": "The left unitor, a natural isomorphism `((\ud835\udfed _) \u22d9 F) \u2245 F`."}, {"name": "category_theory.whisker_right_app", "description": ""}, {"name": "category_theory.whisker_left_app", "description": ""}, {"name": "category_theory.iso_whisker_right_hom", "description": ""}, {"name": "category_theory.whiskering_right_obj_map", "description": ""}, {"name": "category_theory.iso_whisker_left", "description": "If `\u03b1 : G \u2245 H` is a natural isomorphism then\n`iso_whisker_left F \u03b1 : (F \u22d9 G) \u2245 (F \u22d9 H)` has components `\u03b1.app (F.obj X)`."}, {"name": "category_theory.whiskering_left_obj_map", "description": ""}, {"name": "category_theory.functor.associator", "description": "The associator for functors, a natural isomorphism `((F \u22d9 G) \u22d9 H) \u2245 (F \u22d9 (G \u22d9 H))`.\n\n(In fact, `iso.refl _` will work here, but it tends to make Lean slow later,\nand it's usually best to insert explicit associators.)"}, {"name": "category_theory.functor.right_unitor", "description": "The right unitor, a natural isomorphism `(F \u22d9 (\ud835\udfed B)) \u2245 F`."}, {"name": "category_theory.functor.right_unitor_hom_app", "description": ""}, {"name": "category_theory.functor.associator_hom_app", "description": ""}, {"name": "category_theory.iso_whisker_left_hom", "description": ""}, {"name": "category_theory.whisker_right_id", "description": ""}, {"name": "category_theory.is_iso_whisker_left", "description": ""}, {"name": "category_theory.whiskering_left_obj_obj", "description": ""}, {"name": "category_theory.is_iso_whisker_right", "description": ""}, {"name": "category_theory.whiskering_left_map_app_app", "description": ""}, {"name": "category_theory.whiskering_left", "description": "Left-composition gives a functor `(C \u2964 D) \u2964 ((D \u2964 E) \u2964 (C \u2964 E))`.\n\n`(whiskering_left.obj F).obj G` is `F \u22d9 G`, and\n`(whiskering_left.obj F).map \u03b1` is `whisker_left F \u03b1`."}, {"name": "category_theory.iso_whisker_left_inv", "description": ""}, {"name": "category_theory.functor.pentagon", "description": ""}, {"name": "category_theory.whiskering_right", "description": "Right-composition gives a functor `(D \u2964 E) \u2964 ((C \u2964 D) \u2964 (C \u2964 E))`.\n\n`(whiskering_right.obj H).obj F` is `F \u22d9 H`, and\n`(whiskering_right.obj H).map \u03b1` is `whisker_right \u03b1 H`."}, {"name": "category_theory.whisker_left_comp", "description": ""}, {"name": "category_theory.whisker_left_id", "description": ""}, {"name": "category_theory.faithful_whiskering_right_obj", "description": ""}, {"name": "category_theory.whiskering_right_obj_obj", "description": ""}, {"name": "category_theory.whisker_left", "description": "If `\u03b1 : G \u27f6 H` then\n`whisker_left F \u03b1 : (F \u22d9 G) \u27f6 (F \u22d9 H)` has components `\u03b1.app (F.obj X)`."}, {"name": "category_theory.whisker_right_id'", "description": ""}, {"name": "category_theory.functor.triangle", "description": ""}, {"name": "category_theory.whiskering_right_map_app_app", "description": ""}, {"name": "smt_tactic.interactive.assume", "description": ""}, {"name": "smt_tactic.interactive.by_contradiction", "description": ""}, {"name": "smt_tactic.interactive.ematch", "description": "Produce new facts using heuristic lemma instantiation based on E-matching.\nThis tactic tries to match patterns from lemmas in the main goal with terms\nin the main goal. The set of lemmas is populated with theorems\ntagged with the attribute specified at smt_config.em_attr, and lemmas\nadded using tactics such as `smt_tactic.add_lemmas`.\nThe current set of lemmas can be retrieved using the tactic `smt_tactic.get_lemmas`."}, {"name": "smt_tactic.interactive.destruct", "description": ""}, {"name": "smt_tactic.execute_with", "description": ""}, {"name": "smt_tactic.interactive.induction", "description": ""}, {"name": "smt_tactic.interactive.guard_target", "description": ""}, {"name": "smt_tactic.interactive.intros", "description": ""}, {"name": "smt_tactic.interactive.have", "description": ""}, {"name": "smt_tactic.interactive.add_eqn_lemmas", "description": ""}, {"name": "smt_tactic.interactive.itactic", "description": ""}, {"name": "smt_tactic.interactive.trace", "description": ""}, {"name": "smt_tactic.interactive.add_eqn_lemmas_for", "description": ""}, {"name": "smt_tactic.interactive.dsimp", "description": ""}, {"name": "smt_tactic.interactive.trace_state", "description": ""}, {"name": "smt_tactic.interactive.eblast", "description": "Keep applying heuristic instantiation until the current goal is solved, or it fails."}, {"name": "smt_tactic.interactive.add_simp_lemmas", "description": ""}, {"name": "smt_tactic.interactive.let", "description": ""}, {"name": "smt_tactic.interactive.try", "description": "Try the given tactic, and do nothing if it fails."}, {"name": "smt_tactic.interactive.iterate", "description": "Keep applying the given tactic until it fails."}, {"name": "smt_tactic.interactive.add_lemma", "description": ""}, {"name": "smt_tactic.save_info", "description": ""}, {"name": "smt_tactic.execute", "description": ""}, {"name": "smt_tactic.istep", "description": ""}, {"name": "smt_tactic.interactive.apply", "description": ""}, {"name": "smt_tactic.interactive.close", "description": "Try to close main goal by using equalities implied by the congruence\nclosure module."}, {"name": "smt_tactic.interactive.eblast_using", "description": "Keep applying heuristic instantiation using the given lemmas until the current goal is solved, or it fails."}, {"name": "smt_tactic.step", "description": ""}, {"name": "smt_tactic.interactive.by_contra", "description": ""}, {"name": "smt_tactic.interactive.from", "description": ""}, {"name": "smt_tactic.interactive.rsimp", "description": ""}, {"name": "smt_tactic.interactive.simp", "description": "Simplify the target type of the main goal."}, {"name": "smt_tactic.interactive.apply_instance", "description": ""}, {"name": "smt_tactic.interactive.change", "description": ""}, {"name": "smt_tactic.interactive.ematch_using", "description": ""}, {"name": "smt_tactic.interactive.add_fact", "description": ""}, {"name": "smt_tactic.skip", "description": ""}, {"name": "smt_tactic.interactive.by_cases", "description": ""}, {"name": "smt_tactic.interactive.all_goals", "description": "Apply the given tactic to all remaining goals."}, {"name": "smt_tactic.interactive.add_lhs_lemma", "description": ""}, {"name": "smt_tactic.interactive.guard_expr_eq", "description": ""}, {"name": "smt_tactic.interactive.executor", "description": ""}, {"name": "smt_tactic.interactive.exact", "description": ""}, {"name": "smt_tactic.interactive.fapply", "description": ""}, {"name": "smt_tactic.solve_goals", "description": ""}, {"name": "list.zip_map", "description": ""}, {"name": "list.all\u2082_zip_with", "description": ""}, {"name": "list.zip_with_distrib_drop", "description": ""}, {"name": "list.lt_length_left_of_zip", "description": ""}, {"name": "list.unzip_nil", "description": ""}, {"name": "list.zip_with.is_symm_op", "description": ""}, {"name": "list.lt_length_right_of_zip", "description": ""}, {"name": "list.map_prod_left_eq_zip", "description": ""}, {"name": "list.map_zip_with", "description": ""}, {"name": "list.length_revzip", "description": ""}, {"name": "list.zip_with_distrib_tail", "description": ""}, {"name": "list.zip_nil_right", "description": ""}, {"name": "list.lt_length_left_of_zip_with", "description": ""}, {"name": "list.prod_mul_prod_eq_prod_zip_with_of_length_eq", "description": ""}, {"name": "list.zip_with_distrib_reverse", "description": ""}, {"name": "list.sum_add_sum_eq_sum_zip_with_add_sum_drop", "description": ""}, {"name": "list.zip_with_nil_left", "description": ""}, {"name": "list.mem_zip_inits_tails", "description": ""}, {"name": "list.zip_with_distrib_take", "description": ""}, {"name": "list.nth_zip_with_eq_some", "description": ""}, {"name": "list.lt_length_right_of_zip_with", "description": ""}, {"name": "list.map_fst_zip", "description": ""}, {"name": "list.zip_map'", "description": ""}, {"name": "list.length_zip_with", "description": ""}, {"name": "list.sum_add_sum_eq_sum_zip_with_of_length_eq", "description": ""}, {"name": "list.unzip_zip_left", "description": ""}, {"name": "list.zip_swap", "description": ""}, {"name": "list.nth_le_zip_with", "description": ""}, {"name": "list.unzip_cons", "description": ""}, {"name": "list.map_uncurry_zip_eq_zip_with", "description": ""}, {"name": "list.prod_mul_prod_eq_prod_zip_with_mul_prod_drop", "description": ""}, {"name": "list.length_zip", "description": ""}, {"name": "list.zip_with_nil_right", "description": ""}, {"name": "list.nth_zip_with", "description": ""}, {"name": "list.zip_with_cons_cons", "description": ""}, {"name": "list.zip_map_left", "description": ""}, {"name": "list.zip_with_append", "description": ""}, {"name": "list.zip_cons_cons", "description": ""}, {"name": "list.unzip_right", "description": ""}, {"name": "list.zip_append", "description": ""}, {"name": "list.unzip_swap", "description": ""}, {"name": "list.zip_with_eq_nil_iff", "description": ""}, {"name": "list.sum_zip_with_distrib_left", "description": ""}, {"name": "list.unzip_zip", "description": ""}, {"name": "list.zip_map_right", "description": ""}, {"name": "list.revzip_map_snd", "description": ""}, {"name": "list.zip_with_map", "description": ""}, {"name": "list.zip_of_prod", "description": ""}, {"name": "list.map_prod_right_eq_zip", "description": ""}, {"name": "list.revzip_map_fst", "description": ""}, {"name": "list.zip_nil_left", "description": ""}, {"name": "list.zip_with_map_left", "description": ""}, {"name": "list.nth_le_zip", "description": ""}, {"name": "list.mem_zip", "description": ""}, {"name": "list.zip_with_comm", "description": ""}, {"name": "list.revzip_swap", "description": ""}, {"name": "list.reverse_revzip", "description": ""}, {"name": "list.unzip_revzip", "description": ""}, {"name": "list.map_snd_zip", "description": ""}, {"name": "list.nth_zip_eq_some", "description": ""}, {"name": "list.zip_with_map_right", "description": ""}, {"name": "list.unzip_eq_map", "description": ""}, {"name": "list.zip_unzip", "description": ""}, {"name": "list.unzip_zip_right", "description": ""}, {"name": "list.unzip_left", "description": ""}, {"name": "interactive.loc.has_reflect", "description": ""}, {"name": "has_sizeof_derive_handler", "description": ""}, {"name": "prod.has_reflect", "description": ""}, {"name": "bool.has_reflect", "description": ""}, {"name": "sum.has_reflect", "description": ""}, {"name": "derive_handler", "description": "A handler that may or may not be able to implement the typeclass `cls` for `decl`.\n   It should return `tt` if it was able to derive `cls` and `ff` if it does not know\n   how to derive `cls`, in which case lower-priority handlers will be tried next."}, {"name": "derive_handler_attr", "description": ""}, {"name": "instance_derive_handler", "description": "Given a tactic `tac` that can solve an application of `cls` in the right context,\n   `instance_derive_handler` uses it to build an instance declaration of `cls n`."}, {"name": "option.has_reflect", "description": ""}, {"name": "has_reflect_derive_handler", "description": ""}, {"name": "pos.has_reflect", "description": ""}, {"name": "derive_attr", "description": ""}, {"name": "unary_relation_Inf_iff", "description": ""}, {"name": "Inf_eq_bot", "description": ""}, {"name": "supr_infi_le_infi_supr", "description": ""}, {"name": "supr_mono'", "description": ""}, {"name": "supr\u2082_comm", "description": ""}, {"name": "le_infi\u2082", "description": ""}, {"name": "supr_range'", "description": ""}, {"name": "is_lub.Sup_eq", "description": ""}, {"name": "Sup_le_Sup_of_subset_insert_bot", "description": ""}, {"name": "supr_eq_dif", "description": ""}, {"name": "supr_le_iff", "description": ""}, {"name": "infi_of_empty", "description": ""}, {"name": "lt_Sup_iff", "description": ""}, {"name": "supr_subtype'", "description": ""}, {"name": "supr_eq_top", "description": ""}, {"name": "is_glb_binfi", "description": ""}, {"name": "Inf_insert", "description": ""}, {"name": "inf_infi", "description": ""}, {"name": "le_supr\u2082", "description": ""}, {"name": "le_Sup_of_le", "description": ""}, {"name": "infi_false", "description": ""}, {"name": "Inf_eq_infi", "description": ""}, {"name": "supr_of_empty", "description": ""}, {"name": "infi_inf_eq", "description": ""}, {"name": "function.injective.complete_lattice", "description": "Pullback a `complete_lattice` along an injection."}, {"name": "function.surjective.infi_comp", "description": ""}, {"name": "sup_Inf_le_infi_sup", "description": "This is a weaker version of `sup_Inf_eq`"}, {"name": "infi_of_empty'", "description": ""}, {"name": "supr_const_mono", "description": ""}, {"name": "Inf_image", "description": ""}, {"name": "Inf_le_Inf_of_forall_exists_le", "description": ""}, {"name": "complete_semilattice_Sup", "description": "Note that we rarely use `complete_semilattice_Sup`\n(in fact, any such object is always a `complete_lattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions."}, {"name": "complete_semilattice_Sup.le", "description": "Note that we rarely use `complete_semilattice_Sup`\n(in fact, any such object is always a `complete_lattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions."}, {"name": "complete_semilattice_Sup.lt", "description": "Note that we rarely use `complete_semilattice_Sup`\n(in fact, any such object is always a `complete_lattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions."}, {"name": "complete_semilattice_Sup.le_refl", "description": "Note that we rarely use `complete_semilattice_Sup`\n(in fact, any such object is always a `complete_lattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions."}, {"name": "complete_semilattice_Sup.le_trans", "description": "Note that we rarely use `complete_semilattice_Sup`\n(in fact, any such object is always a `complete_lattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions."}, {"name": "complete_semilattice_Sup.lt_iff_le_not_le", "description": "Note that we rarely use `complete_semilattice_Sup`\n(in fact, any such object is always a `complete_lattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions."}, {"name": "complete_semilattice_Sup.le_antisymm", "description": "Note that we rarely use `complete_semilattice_Sup`\n(in fact, any such object is always a `complete_lattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions."}, {"name": "complete_semilattice_Sup.Sup", "description": "Note that we rarely use `complete_semilattice_Sup`\n(in fact, any such object is always a `complete_lattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions."}, {"name": "complete_semilattice_Sup.le_Sup", "description": "Note that we rarely use `complete_semilattice_Sup`\n(in fact, any such object is always a `complete_lattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions."}, {"name": "complete_semilattice_Sup.Sup_le", "description": "Note that we rarely use `complete_semilattice_Sup`\n(in fact, any such object is always a `complete_lattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions."}, {"name": "complete_semilattice_Sup.to_has_Sup", "description": ""}, {"name": "infi_true", "description": ""}, {"name": "Sup_eq_of_forall_le_of_forall_lt_exists_gt", "description": "Introduction rule to prove that `b` is the supremum of `s`: it suffices to check that `b`\nis larger than all elements of `s`, and that this is not the case of any `w < b`.\nSee `cSup_eq_of_forall_le_of_forall_lt_exists_gt` for a version in conditionally complete\nlattices."}, {"name": "infi_neg", "description": ""}, {"name": "infi_congr_Prop", "description": ""}, {"name": "infi_le", "description": ""}, {"name": "supr_insert", "description": ""}, {"name": "order_iso.map_Sup", "description": ""}, {"name": "supr_prod", "description": ""}, {"name": "binary_relation_Inf_iff", "description": ""}, {"name": "monotone.map_Inf_le", "description": ""}, {"name": "complete_linear_order", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.sup", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.le", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.lt", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.le_refl", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.le_trans", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.lt_iff_le_not_le", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.le_antisymm", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.le_sup_left", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.le_sup_right", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.sup_le", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.inf", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.inf_le_left", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.inf_le_right", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.le_inf", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.Sup", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.le_Sup", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.Sup_le", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.Inf", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.Inf_le", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.le_Inf", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.top", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.bot", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.le_top", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.bot_le", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.le_total", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.decidable_le", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.decidable_eq", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.decidable_lt", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.max_def", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "complete_linear_order.min_def", "description": "A complete linear order is a linear order whose lattice structure is complete."}, {"name": "infi_emptyset", "description": ""}, {"name": "supr_mono", "description": ""}, {"name": "supr_congr_Prop", "description": ""}, {"name": "supr_comm", "description": ""}, {"name": "Sup_le", "description": ""}, {"name": "supr_or", "description": ""}, {"name": "complete_linear_order.to_linear_order", "description": ""}, {"name": "antitone.le_map_infi\u2082", "description": ""}, {"name": "infi_ne_top_subtype", "description": " When taking the infimum of `f : \u03b9 \u2192 \u03b1`, the elements of `\u03b9` on which `f` gives `\u22a4` can be\ndropped, without changing the result."}, {"name": "monotone.map_infi\u2082_le", "description": ""}, {"name": "supr_sup", "description": ""}, {"name": "eq_singleton_top_of_Inf_eq_top_of_nonempty", "description": ""}, {"name": "Inf_le_Sup", "description": ""}, {"name": "antitone.map_supr_le", "description": ""}, {"name": "supr_sup_eq", "description": ""}, {"name": "supr_option_elim", "description": "A version of `supr_option` useful for rewriting right-to-left."}, {"name": "infi_sum", "description": ""}, {"name": "disjoint_Sup_left", "description": ""}, {"name": "Inf_le_Inf_of_subset_insert_top", "description": ""}, {"name": "le_infi\u2082_iff", "description": ""}, {"name": "supr_image", "description": ""}, {"name": "supr_union", "description": ""}, {"name": "supr_subtype", "description": ""}, {"name": "bsupr_prod", "description": ""}, {"name": "is_lub.supr_eq", "description": ""}, {"name": "Inf_le_Inf", "description": ""}, {"name": "monotone.supr_comp_eq", "description": ""}, {"name": "pi.has_Inf", "description": ""}, {"name": "infi_apply", "description": ""}, {"name": "infi_eq_bot", "description": ""}, {"name": "infi_inf", "description": ""}, {"name": "Inf_union", "description": ""}, {"name": "infi_eq_top", "description": ""}, {"name": "infi_option", "description": ""}, {"name": "supr_eq_of_forall_le_of_forall_lt_exists_gt", "description": "Introduction rule to prove that `b` is the supremum of `f`: it suffices to check that `b`\nis larger than `f i` for all `i`, and that this is not the case of any `w<b`.\nSee `csupr_eq_of_forall_le_of_forall_lt_exists_gt` for a version in conditionally complete\nlattices."}, {"name": "infi_image", "description": ""}, {"name": "supr_option", "description": ""}, {"name": "monotone_Inf_of_monotone", "description": ""}, {"name": "order_dual.complete_linear_order", "description": ""}, {"name": "is_glb.infi_eq", "description": ""}, {"name": "Sup_apply", "description": ""}, {"name": "supr_eq_bot", "description": ""}, {"name": "supr_ite", "description": ""}, {"name": "supr_supr_eq_right", "description": ""}, {"name": "infi", "description": "Indexed infimum"}, {"name": "complete_semilattice_Inf.to_has_Inf", "description": ""}, {"name": "order_dual.complete_lattice", "description": ""}, {"name": "eq_singleton_bot_of_Sup_eq_bot_of_nonempty", "description": ""}, {"name": "infi\u2082_comm", "description": ""}, {"name": "Sup_singleton", "description": ""}, {"name": "is_glb.Inf_eq", "description": ""}, {"name": "complete_lattice_of_complete_semilattice_Inf", "description": "Any `complete_semilattice_Inf` is in fact a `complete_lattice`.\n\nNote that this construction has bad definitional properties:\nsee the doc-string on `complete_lattice_of_Inf`."}, {"name": "Sup_empty", "description": ""}, {"name": "binfi_inf", "description": ""}, {"name": "supr\u2082_mono", "description": ""}, {"name": "function.surjective.supr_comp", "description": ""}, {"name": "supr_congr", "description": ""}, {"name": "Sup_range", "description": ""}, {"name": "Sup_union", "description": ""}, {"name": "Inf_Prop_eq", "description": ""}, {"name": "supr_singleton", "description": ""}, {"name": "le_Sup_iff", "description": ""}, {"name": "infi_lt_iff", "description": ""}, {"name": "Inf_diff_singleton_top", "description": ""}, {"name": "function.surjective.infi_congr", "description": ""}, {"name": "infi_exists", "description": ""}, {"name": "supr_true", "description": ""}, {"name": "supr_split_single", "description": ""}, {"name": "infi_and'", "description": "The symmetric case of `infi_and`, useful for rewriting into a infimum over a conjunction"}, {"name": "prod.has_Inf", "description": ""}, {"name": "supr_exists", "description": ""}, {"name": "infi_infi_eq_left", "description": ""}, {"name": "Inf_univ", "description": ""}, {"name": "supr_ne_bot_subtype", "description": " When taking the supremum of `f : \u03b9 \u2192 \u03b1`, the elements of `\u03b9` on which `f` gives `\u22a5` can be\ndropped, without changing the result."}, {"name": "function.surjective.supr_congr", "description": ""}, {"name": "infi_and", "description": ""}, {"name": "Inf_lt_iff", "description": ""}, {"name": "infi_eq_of_forall_ge_of_forall_gt_exists_lt", "description": "Introduction rule to prove that `b` is the infimum of `f`: it suffices to check that `b`\nis smaller than `f i` for all `i`, and that this is not the case of any `w>b`.\nSee `cinfi_eq_of_forall_ge_of_forall_gt_exists_lt` for a version in conditionally complete\nlattices."}, {"name": "infi_split_single", "description": ""}, {"name": "supr_le_supr_of_subset", "description": ""}, {"name": "antitone.map_Sup_le", "description": ""}, {"name": "infi_Prop_eq", "description": ""}, {"name": "le_supr_of_le", "description": ""}, {"name": "infi_pos", "description": ""}, {"name": "infi_top", "description": ""}, {"name": "monotone.le_map_supr\u2082", "description": ""}, {"name": "infi_bool_eq", "description": ""}, {"name": "is_lub_bsupr", "description": ""}, {"name": "disjoint_Sup_right", "description": ""}, {"name": "Sup_insert", "description": ""}, {"name": "is_lub_supr", "description": ""}, {"name": "supr_split", "description": ""}, {"name": "infi_sup_infi_le", "description": ""}, {"name": "supr_emptyset", "description": ""}, {"name": "infi\u2082_mono'", "description": ""}, {"name": "infi_univ", "description": ""}, {"name": "supr\u2082_le_iff", "description": ""}, {"name": "infi_or", "description": ""}, {"name": "inf_infi_nat_succ", "description": ""}, {"name": "supr_const_le", "description": ""}, {"name": "antitone.infi_nat_add", "description": ""}, {"name": "inf_binfi", "description": ""}, {"name": "Inf_empty", "description": ""}, {"name": "supr_pos", "description": ""}, {"name": "bsupr_mono", "description": ""}, {"name": "Inf_image2", "description": ""}, {"name": "infi_subtype", "description": ""}, {"name": "has_Sup_to_nonempty", "description": ""}, {"name": "le_infi_iff", "description": ""}, {"name": "supr_range", "description": ""}, {"name": "Inf_eq_infi'", "description": ""}, {"name": "infi_range'", "description": ""}, {"name": "Inf_eq_top", "description": ""}, {"name": "infi_le_infi_of_subset", "description": ""}, {"name": "supr_and'", "description": "The symmetric case of `supr_and`, useful for rewriting into a supremum over a conjunction"}, {"name": "infi_subtype'", "description": ""}, {"name": "Sup_eq_bot", "description": ""}, {"name": "order_dual.has_Sup", "description": ""}, {"name": "infi_mono'", "description": ""}, {"name": "monotone.le_map_Sup", "description": ""}, {"name": "supr\u2082_eq_bot", "description": ""}, {"name": "infi_eq_dif", "description": ""}, {"name": "unary_relation_Sup_iff", "description": ""}, {"name": "is_glb_Inf", "description": ""}, {"name": "le_Inf_iff", "description": ""}, {"name": "infi_range", "description": ""}, {"name": "Inf_range", "description": ""}, {"name": "infi_infi_eq_right", "description": ""}, {"name": "infi_pair", "description": ""}, {"name": "binfi_prod", "description": ""}, {"name": "equiv.infi_comp", "description": ""}, {"name": "has_Inf_to_nonempty", "description": ""}, {"name": "Inf_le", "description": ""}, {"name": "supr_and", "description": ""}, {"name": "Inf_sup_le_infi_sup", "description": "This is a weaker version of `Inf_sup_eq`"}, {"name": "Sup_Prop_eq", "description": ""}, {"name": "lt_supr_iff", "description": ""}, {"name": "complete_lattice_of_Inf", "description": " Create a `complete_lattice` from a `partial_order` and `Inf` function\nthat returns the greatest lower bound of a set. Usually this constructor provides\npoor definitional equalities.  If other fields are known explicitly, they should be\nprovided; for example, if `inf` is known explicitly, construct the `complete_lattice`\ninstance as\n```lean\ninstance : complete_lattice my_T :=\n{ inf := better_inf,\n  le_inf := ...,\n  inf_le_right := ...,\n  inf_le_left := ...\n  -- don't care to fix sup, Sup, bot, top\n  ..complete_lattice_of_Inf my_T _ }\n```"}, {"name": "supr_infi_ge_nat_add", "description": ""}, {"name": "supr_sum", "description": ""}, {"name": "monotone.le_map_supr", "description": ""}, {"name": "supr\u2082_le", "description": ""}, {"name": "Inf_singleton", "description": ""}, {"name": "infi_const_mono", "description": ""}, {"name": "is_lub_Sup", "description": ""}, {"name": "infi_sigma", "description": ""}, {"name": "le_supr\u2082_of_le", "description": ""}, {"name": "le_supr_inf_supr", "description": ""}, {"name": "supr_Prop_eq", "description": ""}, {"name": "supr_apply", "description": ""}, {"name": "complete_lattice", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.sup", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.le", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.lt", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.le_refl", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.le_trans", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.lt_iff_le_not_le", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.le_antisymm", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.le_sup_left", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.le_sup_right", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.sup_le", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.inf", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.inf_le_left", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.inf_le_right", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.le_inf", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.Sup", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.le_Sup", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.Sup_le", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.Inf", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.Inf_le", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.le_Inf", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.top", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.bot", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.le_top", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "complete_lattice.bot_le", "description": "A complete lattice is a bounded lattice which has suprema and infima for every subset."}, {"name": "pi.has_Sup", "description": ""}, {"name": "supr\u2082_le_supr", "description": ""}, {"name": "Inf_le_iff", "description": ""}, {"name": "Sup_le_Sup_of_forall_exists_le", "description": ""}, {"name": "infi_union", "description": ""}, {"name": "order_dual.has_Inf", "description": ""}, {"name": "equiv.infi_congr", "description": ""}, {"name": "le_supr_iff", "description": ""}, {"name": "supr_supr_eq_left", "description": ""}, {"name": "infi\u2082_le", "description": ""}, {"name": "le_infi_const", "description": ""}, {"name": "infi_comm", "description": ""}, {"name": "supr_inf_le_Sup_inf", "description": "This is a weaker version of `Sup_inf_eq`"}, {"name": "binfi_mono", "description": ""}, {"name": "complete_lattice.to_lattice", "description": ""}, {"name": "supr_lt_iff", "description": ""}, {"name": "supr_false", "description": ""}, {"name": "supr_bool_eq", "description": ""}, {"name": "supr_subtype''", "description": ""}, {"name": "Sup_eq_top", "description": ""}, {"name": "has_Inf", "description": "class for the `Inf` operator"}, {"name": "has_Inf.Inf", "description": "class for the `Inf` operator"}, {"name": "supr", "description": "Indexed supremum"}, {"name": "infi_const", "description": ""}, {"name": "monotone_Sup_of_monotone", "description": ""}, {"name": "Prop.complete_linear_order", "description": ""}, {"name": "supr_sigma", "description": ""}, {"name": "Inf_image'", "description": ""}, {"name": "complete_semilattice_Inf.to_partial_order", "description": ""}, {"name": "supr_ge_eq_supr_nat_add", "description": ""}, {"name": "complete_lattice_of_complete_semilattice_Sup", "description": "Any `complete_semilattice_Sup` is in fact a `complete_lattice`.\n\nNote that this construction has bad definitional properties:\nsee the doc-string on `complete_lattice_of_Sup`."}, {"name": "Sup_le_Sup", "description": ""}, {"name": "infi_le_iff", "description": ""}, {"name": "infi_mono", "description": ""}, {"name": "Sup_image'", "description": ""}, {"name": "antitone.le_map_Inf", "description": ""}, {"name": "infi_ge_eq_infi_nat_add", "description": ""}, {"name": "complete_lattice.to_bounded_order", "description": ""}, {"name": "infi_option_elim", "description": "A version of `infi_option` useful for rewriting right-to-left."}, {"name": "Inf_eq_of_forall_ge_of_forall_gt_exists_lt", "description": "Introduction rule to prove that `b` is the infimum of `s`: it suffices to check that `b`\nis smaller than all elements of `s`, and that this is not the case of any `w > b`.\nSee `cInf_eq_of_forall_ge_of_forall_gt_exists_lt` for a version in conditionally complete\nlattices."}, {"name": "monotone.supr_nat_add", "description": ""}, {"name": "infi_ite", "description": ""}, {"name": "infi_prod", "description": ""}, {"name": "complete_semilattice_Sup.to_partial_order", "description": ""}, {"name": "le_infi", "description": ""}, {"name": "Sup_le_iff", "description": ""}, {"name": "infi_congr", "description": ""}, {"name": "infi_eq_if", "description": ""}, {"name": "le_supr'", "description": ""}, {"name": "infi_subtype''", "description": ""}, {"name": "Sup_image2", "description": ""}, {"name": "sup_supr", "description": ""}, {"name": "infi\u2082_le_of_le", "description": ""}, {"name": "sup_supr_nat_succ", "description": ""}, {"name": "Prop.complete_lattice", "description": ""}, {"name": "supr_le", "description": ""}, {"name": "supr\u2082_mono'", "description": ""}, {"name": "complete_linear_order.to_complete_lattice", "description": ""}, {"name": "binary_relation_Sup_iff", "description": ""}, {"name": "infi_singleton", "description": ""}, {"name": "Sup_pair", "description": ""}, {"name": "le_supr", "description": ""}, {"name": "monotone.map_infi_le", "description": ""}, {"name": "prod.complete_lattice", "description": ""}, {"name": "supr_of_empty'", "description": ""}, {"name": "le_Inf_inter", "description": ""}, {"name": "sup_eq_supr", "description": ""}, {"name": "supr_const", "description": ""}, {"name": "complete_lattice.to_complete_semilattice_Sup", "description": ""}, {"name": "supr_extend_bot", "description": ""}, {"name": "lt_infi_iff", "description": ""}, {"name": "complete_lattice_of_Sup", "description": " Create a `complete_lattice` from a `partial_order` and `Sup` function\nthat returns the least upper bound of a set. Usually this constructor provides\npoor definitional equalities.  If other fields are known explicitly, they should be\nprovided; for example, if `inf` is known explicitly, construct the `complete_lattice`\ninstance as\n```lean\ninstance : complete_lattice my_T :=\n{ inf := better_inf,\n  le_inf := ...,\n  inf_le_right := ...,\n  inf_le_left := ...\n  -- don't care to fix sup, Inf, bot, top\n  ..complete_lattice_of_Sup my_T _ }\n```"}, {"name": "le_Sup", "description": ""}, {"name": "infi_le_of_le", "description": ""}, {"name": "complete_lattice.to_has_top", "description": ""}, {"name": "infi_dite", "description": ""}, {"name": "infi\u2082_eq_top", "description": ""}, {"name": "equiv.supr_congr", "description": ""}, {"name": "supr_eq_if", "description": ""}, {"name": "equiv.supr_comp", "description": ""}, {"name": "order_iso.map_Inf", "description": ""}, {"name": "Sup_eq_supr", "description": ""}, {"name": "prod.has_Sup", "description": ""}, {"name": "monotone.infi_comp_eq", "description": ""}, {"name": "complete_semilattice_Inf", "description": "Note that we rarely use `complete_semilattice_Inf`\n(in fact, any such object is always a `complete_lattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions."}, {"name": "complete_semilattice_Inf.le", "description": "Note that we rarely use `complete_semilattice_Inf`\n(in fact, any such object is always a `complete_lattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions."}, {"name": "complete_semilattice_Inf.lt", "description": "Note that we rarely use `complete_semilattice_Inf`\n(in fact, any such object is always a `complete_lattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions."}, {"name": "complete_semilattice_Inf.le_refl", "description": "Note that we rarely use `complete_semilattice_Inf`\n(in fact, any such object is always a `complete_lattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions."}, {"name": "complete_semilattice_Inf.le_trans", "description": "Note that we rarely use `complete_semilattice_Inf`\n(in fact, any such object is always a `complete_lattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions."}, {"name": "complete_semilattice_Inf.lt_iff_le_not_le", "description": "Note that we rarely use `complete_semilattice_Inf`\n(in fact, any such object is always a `complete_lattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions."}, {"name": "complete_semilattice_Inf.le_antisymm", "description": "Note that we rarely use `complete_semilattice_Inf`\n(in fact, any such object is always a `complete_lattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions."}, {"name": "complete_semilattice_Inf.Inf", "description": "Note that we rarely use `complete_semilattice_Inf`\n(in fact, any such object is always a `complete_lattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions."}, {"name": "complete_semilattice_Inf.Inf_le", "description": "Note that we rarely use `complete_semilattice_Inf`\n(in fact, any such object is always a `complete_lattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions."}, {"name": "complete_semilattice_Inf.le_Inf", "description": "Note that we rarely use `complete_semilattice_Inf`\n(in fact, any such object is always a `complete_lattice`, so it's usually best to start there).\n\nNevertheless it is sometimes a useful intermediate step in constructions."}, {"name": "inf_eq_infi", "description": ""}, {"name": "has_Sup", "description": "class for the `Sup` operator"}, {"name": "has_Sup.Sup", "description": "class for the `Sup` operator"}, {"name": "complete_lattice.to_complete_semilattice_Inf", "description": ""}, {"name": "complete_lattice.to_has_bot", "description": ""}, {"name": "Inf_pair", "description": ""}, {"name": "pi.complete_lattice", "description": ""}, {"name": "infi_split", "description": ""}, {"name": "infi_le_infi\u2082", "description": ""}, {"name": "supr_inf_le_inf_Sup", "description": "This is a weaker version of `inf_Sup_eq`"}, {"name": "Sup_image", "description": ""}, {"name": "supr_neg", "description": ""}, {"name": "Inf_le_of_le", "description": ""}, {"name": "Sup_inter_le", "description": ""}, {"name": "infi_extend_top", "description": ""}, {"name": "supr_dite", "description": ""}, {"name": "infi_le'", "description": ""}, {"name": "infi_insert", "description": ""}, {"name": "Sup_eq_supr'", "description": ""}, {"name": "supr_univ", "description": ""}, {"name": "infi_supr_ge_nat_add", "description": ""}, {"name": "antitone.map_supr\u2082_le", "description": ""}, {"name": "infi\u2082_mono", "description": ""}, {"name": "order_iso.map_supr", "description": ""}, {"name": "supr_bot", "description": ""}, {"name": "is_glb_infi", "description": ""}, {"name": "supr_comp_le", "description": ""}, {"name": "Sup_diff_singleton_bot", "description": ""}, {"name": "order_iso.map_infi", "description": ""}, {"name": "le_infi_comp", "description": ""}, {"name": "le_Inf", "description": ""}, {"name": "Inf_apply", "description": ""}, {"name": "antitone.le_map_infi", "description": ""}, {"name": "Sup_univ", "description": ""}, {"name": "supr_pair", "description": ""}, {"name": "equiv_like", "description": " The class `equiv_like E \u03b1 \u03b2` expresses that terms of type `E` have an\ninjective coercion to bijections between `\u03b1` and `\u03b2`.\n\nThis typeclass is used in the definition of the homomorphism typeclasses,\nsuch as `zero_equiv_class`, `mul_equiv_class`, `monoid_equiv_class`, ...."}, {"name": "equiv_like.coe", "description": " The class `equiv_like E \u03b1 \u03b2` expresses that terms of type `E` have an\ninjective coercion to bijections between `\u03b1` and `\u03b2`.\n\nThis typeclass is used in the definition of the homomorphism typeclasses,\nsuch as `zero_equiv_class`, `mul_equiv_class`, `monoid_equiv_class`, ...."}, {"name": "equiv_like.inv", "description": " The class `equiv_like E \u03b1 \u03b2` expresses that terms of type `E` have an\ninjective coercion to bijections between `\u03b1` and `\u03b2`.\n\nThis typeclass is used in the definition of the homomorphism typeclasses,\nsuch as `zero_equiv_class`, `mul_equiv_class`, `monoid_equiv_class`, ...."}, {"name": "equiv_like.left_inv", "description": " The class `equiv_like E \u03b1 \u03b2` expresses that terms of type `E` have an\ninjective coercion to bijections between `\u03b1` and `\u03b2`.\n\nThis typeclass is used in the definition of the homomorphism typeclasses,\nsuch as `zero_equiv_class`, `mul_equiv_class`, `monoid_equiv_class`, ...."}, {"name": "equiv_like.right_inv", "description": " The class `equiv_like E \u03b1 \u03b2` expresses that terms of type `E` have an\ninjective coercion to bijections between `\u03b1` and `\u03b2`.\n\nThis typeclass is used in the definition of the homomorphism typeclasses,\nsuch as `zero_equiv_class`, `mul_equiv_class`, `monoid_equiv_class`, ...."}, {"name": "equiv_like.coe_injective'", "description": " The class `equiv_like E \u03b1 \u03b2` expresses that terms of type `E` have an\ninjective coercion to bijections between `\u03b1` and `\u03b2`.\n\nThis typeclass is used in the definition of the homomorphism typeclasses,\nsuch as `zero_equiv_class`, `mul_equiv_class`, `monoid_equiv_class`, ...."}, {"name": "equiv_like.injective", "description": ""}, {"name": "equiv_like.to_embedding_like", "description": ""}, {"name": "equiv_like.apply_eq_iff_eq", "description": ""}, {"name": "equiv_like.surjective", "description": ""}, {"name": "equiv_like.surjective_comp", "description": ""}, {"name": "equiv_like.bijective", "description": ""}, {"name": "equiv_like.inv_injective", "description": ""}, {"name": "equiv_like.comp_surjective", "description": ""}, {"name": "equiv_like.bijective_comp", "description": ""}, {"name": "equiv_like.comp_injective", "description": ""}, {"name": "equiv_like.injective_comp", "description": ""}, {"name": "equiv_like.comp_bijective", "description": ""}, {"name": "finset.pi", "description": " Given a finset `s` of `\u03b1` and for all `a : \u03b1` a finset `t a` of `\u03b4 a`, then one can define the\nfinset `s.pi t` of all functions defined on elements of `s` taking values in `t a` for `a \u2208 s`.\nNote that the elements of `s.pi t` are only partially defined, on `s`."}, {"name": "finset.pi.cons_ne", "description": ""}, {"name": "finset.mem_pi", "description": ""}, {"name": "finset.pi_empty", "description": ""}, {"name": "finset.pi.cons_same", "description": ""}, {"name": "finset.pi.empty", "description": " The empty dependent product function, defined on the empty set. The assumption `a \u2208 \u2205` is never\nsatisfied."}, {"name": "finset.pi.cons", "description": " Given a function `f` defined on a finset `s`, define a new function on the finset `s \u222a {a}`,\nequal to `f` on `s` and sending `a` to a given value `b`. This function is denoted\n`s.pi.cons a b f`. If `a` already belongs to `s`, the new function takes the value `b` at `a`\nanyway."}, {"name": "finset.pi_const_singleton", "description": ""}, {"name": "finset.pi_subset", "description": ""}, {"name": "finset.pi_disjoint_of_disjoint", "description": ""}, {"name": "finset.pi_cons_injective", "description": ""}, {"name": "finset.pi_val", "description": ""}, {"name": "finset.pi_singletons", "description": ""}, {"name": "finset.pi_insert", "description": ""}, {"name": "sym_option_succ_equiv_apply", "description": ""}, {"name": "sym.has_mem", "description": "`\u03b1 \u2208 s` means that `a` appears as one of the factors in `s`."}, {"name": "sym.cons'", "description": "This is `cons` but for the alternative `sym'` definition."}, {"name": "sym.map_cons", "description": ""}, {"name": "sym.map_id", "description": ""}, {"name": "sym.coe_inj", "description": ""}, {"name": "sym.cons_of_coe_eq", "description": ""}, {"name": "sym.has_zero", "description": ""}, {"name": "sym_option_succ_equiv_symm_apply", "description": ""}, {"name": "sym.repeat", "description": "`repeat a n` is the sym containing only `a` with multiplicity `n`."}, {"name": "sym.sym'", "description": "Another definition of the nth symmetric power, using vectors modulo permutations. (See `sym`.)"}, {"name": "sym.map_map", "description": ""}, {"name": "sym.map_congr", "description": ""}, {"name": "sym.nil", "description": "The unique element in `sym \u03b1 0`."}, {"name": "sym.attach", "description": " \"Attach\" a proof that `a \u2208 s` to each element `a` in `s` to produce\nan element of the symmetric power on `{x // x \u2208 s}`."}, {"name": "sym", "description": "The nth symmetric power is n-tuples up to permutation.  We define it\nas a subtype of `multiset` since these are well developed in the\nlibrary.  We also give a definition `sym.sym'` in terms of vectors, and we\nshow these are equivalent in `sym.sym_equiv_sym'`."}, {"name": "sym.equiv_congr", "description": " Mapping an equivalence `\u03b1 \u2243 \u03b2` using `sym.map` gives an equivalence between `sym \u03b1 n` and\n`sym \u03b2 n`."}, {"name": "sym.eq_repeat_iff", "description": ""}, {"name": "sym.of_vector_cons", "description": ""}, {"name": "sym.exists_eq_cons_of_succ", "description": ""}, {"name": "sym.unique_zero", "description": ""}, {"name": "sym.exists_mem", "description": ""}, {"name": "sym.map_mk", "description": ""}, {"name": "sym.mem_cons_of_mem", "description": ""}, {"name": "sym.mem_map", "description": ""}, {"name": "sym_option_succ_equiv", "description": "The symmetric product over `option` is a disjoint union over simpler symmetric products."}, {"name": "sym.attach_nil", "description": ""}, {"name": "sym.erase_cons_head", "description": ""}, {"name": "sym.erase_mk", "description": ""}, {"name": "sym.equiv_congr_apply", "description": ""}, {"name": "vector.perm.is_setoid", "description": "This is the `list.perm` setoid lifted to `vector`.\n\nSee note [reducible non-instances]."}, {"name": "sym.of_vector_nil", "description": ""}, {"name": "sym.cons_inj_right", "description": ""}, {"name": "sym.mem_mk", "description": ""}, {"name": "sym.mem_attach", "description": ""}, {"name": "sym.cons_erase", "description": ""}, {"name": "sym.coe_attach", "description": ""}, {"name": "sym.map_injective", "description": ""}, {"name": "sym.nontrivial", "description": ""}, {"name": "sym_option_succ_equiv.decode", "description": "Inverse of `sym_option_succ_equiv.decode`."}, {"name": "sym.map", "description": " A function `\u03b1 \u2192 \u03b2` induces a function `sym \u03b1 n \u2192 sym \u03b2 n` by applying it to every element of\nthe underlying `n`-tuple."}, {"name": "sym.has_lift", "description": "This is the quotient map that takes a list of n elements as an n-tuple and produces an nth\nsymmetric power."}, {"name": "sym.mk_coe", "description": ""}, {"name": "sym_option_succ_equiv.encode", "description": " Function from the symmetric product over `option` splitting on whether or not\nit contains a `none`."}, {"name": "sym_option_succ_equiv.encode_decode", "description": ""}, {"name": "sym.mem_repeat", "description": ""}, {"name": "sym.mk", "description": "Construct an element of the `n`th symmetric power from a multiset of cardinality `n`."}, {"name": "sym.sound", "description": ""}, {"name": "sym.inhabited_sym", "description": ""}, {"name": "sym.is_empty", "description": ""}, {"name": "sym.sym_equiv_sym'", "description": "Multisets of cardinality n are equivalent to length-n vectors up to permutations."}, {"name": "sym.cons_swap", "description": ""}, {"name": "sym.mem_cons", "description": ""}, {"name": "sym_option_succ_equiv.decode_encode", "description": ""}, {"name": "sym.repeat_left_inj", "description": ""}, {"name": "sym_option_succ_equiv.encode_of_not_none_mem", "description": ""}, {"name": "sym.coe_repeat", "description": ""}, {"name": "sym.map_id'", "description": "Note: `sym.map_id` is not simp-normal, as simp ends up unfolding `id` with `sym.map_congr`"}, {"name": "sym.decidable_mem", "description": ""}, {"name": "sym.inhabited_sym'", "description": ""}, {"name": "sym.has_emptyc", "description": ""}, {"name": "sym.erase", "description": "`erase s a h` is the sym that subtracts 1 from the\n multiplicity of `a` if a is present in the sym."}, {"name": "sym.unique", "description": ""}, {"name": "sym.eq_nil_of_card_zero", "description": ""}, {"name": "sym_option_succ_equiv.encode_of_none_mem", "description": ""}, {"name": "sym.coe_erase", "description": ""}, {"name": "sym.cons_inj_left", "description": ""}, {"name": "sym.coe_injective", "description": ""}, {"name": "sym.has_coe", "description": ""}, {"name": "sym.cons_equiv_eq_equiv_cons", "description": ""}, {"name": "sym.mem_cons_self", "description": ""}, {"name": "sym.subsingleton", "description": ""}, {"name": "sym.attach_map_coe", "description": ""}, {"name": "sym.eq_repeat_of_subsingleton", "description": ""}, {"name": "sym.cons", "description": "Inserts an element into the term of `sym \u03b1 n`, increasing the length by one."}, {"name": "sym.attach_cons", "description": ""}, {"name": "sym.coe_map", "description": ""}, {"name": "sym.attach_mk", "description": ""}, {"name": "sym.repeat_left_injective", "description": ""}, {"name": "sym.coe_cons", "description": ""}, {"name": "sym.equiv_congr_symm_apply", "description": ""}, {"name": "sym.repeat_succ", "description": ""}, {"name": "sym.map_zero", "description": ""}, {"name": "sym.eq_repeat", "description": ""}, {"name": "function.injective.sigma_map", "description": ""}, {"name": "psigma.forall", "description": ""}, {"name": "psigma.elim", "description": "Nondependent eliminator for `psigma`."}, {"name": "sigma.curry", "description": " Interpret a function on `\u03a3 x : \u03b1, \u03b2 x` as a dependent function with two arguments.\n\nThis also exists as an `equiv` as `equiv.Pi_curry \u03b3`."}, {"name": "psigma.elim_val", "description": ""}, {"name": "function.injective.sigma_map_iff", "description": ""}, {"name": "sigma.uncurry", "description": " Interpret a dependent function with two arguments as a function on `\u03a3 x : \u03b1, \u03b2 x`.\n\nThis also exists as an `equiv` as `(equiv.Pi_curry \u03b3).symm`."}, {"name": "sigma_mk_injective", "description": ""}, {"name": "sigma.map", "description": "Map the left and right components of a sigma"}, {"name": "psigma.mk.inj_iff", "description": ""}, {"name": "psigma.decidable_eq", "description": ""}, {"name": "psigma.ext", "description": ""}, {"name": "sigma.ext", "description": ""}, {"name": "sigma.curry_uncurry", "description": ""}, {"name": "sigma.subtype_ext", "description": "A specialized ext lemma for equality of sigma types over an indexed subtype."}, {"name": "prod.to_sigma_mk", "description": ""}, {"name": "psigma.map", "description": "Map the left and right components of a sigma"}, {"name": "prod.to_sigma", "description": "Convert a product type to a \u03a3-type."}, {"name": "sigma.eta", "description": ""}, {"name": "psigma.inhabited", "description": ""}, {"name": "psigma.exists", "description": ""}, {"name": "sigma.inhabited", "description": ""}, {"name": "sigma.forall", "description": ""}, {"name": "sigma.exists", "description": ""}, {"name": "function.surjective.sigma_map", "description": ""}, {"name": "prod.fst_comp_to_sigma", "description": ""}, {"name": "sigma.decidable_eq", "description": ""}, {"name": "sigma.reflect", "description": ""}, {"name": "sigma.uncurry_curry", "description": ""}, {"name": "psigma.subtype_ext_iff", "description": ""}, {"name": "function.injective.of_sigma_map", "description": ""}, {"name": "psigma.subtype_ext", "description": "A specialized ext lemma for equality of psigma types over an indexed subtype."}, {"name": "sigma.mk.inj_iff", "description": ""}, {"name": "psigma.ext_iff", "description": ""}, {"name": "sigma.ext_iff", "description": ""}, {"name": "prod.fst_to_sigma", "description": ""}, {"name": "sigma.subtype_ext_iff", "description": ""}, {"name": "prod.snd_to_sigma", "description": ""}, {"name": "bitvec.has_add", "description": ""}, {"name": "bitvec.add", "description": "The sum of two bitvectors"}, {"name": "bitvec.cong", "description": "Create a bitvector from another with a provably equal length."}, {"name": "bitvec.and", "description": "bitwise and"}, {"name": "bitvec.one", "description": "Create a bitvector of length `n` whose `n-1`st entry is 1 and other entries are 0."}, {"name": "bitvec.add_lsb", "description": "`add_lsb r b` is `r + r + 1` if `b` is `tt` and `r + r` otherwise."}, {"name": "bitvec.carry", "description": "`carry x y c` is `x && y || x && c || y && c`."}, {"name": "bitvec.xor", "description": "bitwise xor"}, {"name": "bitvec.has_mul", "description": ""}, {"name": "bitvec.of_nat_succ", "description": ""}, {"name": "bitvec", "description": "`bitvec n` is a `vector` of `bool` with length `n`."}, {"name": "bitvec.uborrow", "description": " `uborrow x y` returns `tt` iff the \"subtract with borrow\" operation on `x`, `y` and `ff`\nrequired a borrow."}, {"name": "bitvec.has_repr", "description": ""}, {"name": "bitvec.ult.decidable", "description": ""}, {"name": "bitvec.slt", "description": "signed less-than proposition"}, {"name": "bitvec.ult", "description": "unsigned less-than proposition"}, {"name": "bitvec.or", "description": "bitwise or"}, {"name": "bitvec.bits_to_nat", "description": "Given a `list` of `bool`s, return the `nat` they represent as a list of binary digits."}, {"name": "bitvec.not", "description": "bitwise not"}, {"name": "bitvec.has_one", "description": ""}, {"name": "bitvec.to_nat", "description": "Return the natural number encoded by the input bitvector"}, {"name": "bitvec.fill_shr", "description": " `fill_shr x i fill` is the bitvector obtained by right-shifting `x` `i` times and then\npadding with `fill : bool`. If `x.length < i` then this will return the constant `fill`\nbitvector."}, {"name": "bitvec.ule", "description": "unsigned less-than-or-equal-to proposition"}, {"name": "bitvec.append", "description": "`bitvec` specific version of `vector.append`"}, {"name": "bitvec.to_int", "description": "Return the integer encoded by the input bitvector"}, {"name": "bitvec.sle", "description": "signed less-than-or-equal-to proposition"}, {"name": "bitvec.sgt", "description": "signed greater-than proposition"}, {"name": "bitvec.ugt", "description": "unsigned greater-than proposition"}, {"name": "bitvec.sge", "description": "signed greater-than-or-equal-to proposition"}, {"name": "bitvec.mul", "description": "The product of two bitvectors"}, {"name": "bitvec.ushr", "description": "unsigned shift right"}, {"name": "bitvec.sshr", "description": "signed shift right"}, {"name": "bitvec.sub", "description": "The difference of two bitvectors"}, {"name": "bitvec.adc", "description": "Add with carry (no overflow)"}, {"name": "bitvec.bits_to_nat_to_list", "description": ""}, {"name": "bitvec.ugt.decidable", "description": ""}, {"name": "bitvec.sbb", "description": "Subtract with borrow"}, {"name": "bitvec.has_sub", "description": ""}, {"name": "bitvec.of_int", "description": "Create a bitvector in the two's complement representation from an `int`"}, {"name": "bitvec.of_nat", "description": "Create a bitvector from a `nat`"}, {"name": "bitvec.has_neg", "description": ""}, {"name": "bitvec.to_nat_append", "description": ""}, {"name": "bitvec.uge", "description": "unsigned greater-than-or-equal-to proposition"}, {"name": "bitvec.neg", "description": "`neg x` is the two's complement of `x`."}, {"name": "bitvec.zero", "description": "Create a zero bitvector"}, {"name": "bitvec.shl", "description": " `shl x i` is the bitvector obtained by left-shifting `x` `i` times and padding with `ff`.\nIf `x.length < i` then this will return the all-`ff`s bitvector."}, {"name": "bitvec.to_nat_of_nat", "description": ""}, {"name": "bitvec.xor3", "description": "`xor3 x y c` is `((x XOR y) XOR c)`."}, {"name": "bitvec.sborrow", "description": "`sborrow x y` returns `tt` iff `x < y` as two's complement integers"}, {"name": "bitvec.bits_to_nat_to_bool", "description": ""}, {"name": "bitvec.has_zero", "description": ""}, {"name": "tactic.get_tagged_ancestors", "description": "Returns the parents of a structure added via the `ancestor` attribute.\n\nOn failure, the empty list is returned."}, {"name": "tactic_doc.attribute.ancestor", "description": " The `ancestor` attributes is used to record the names of structures which appear in the\nextends clause of a `structure` or `class` declared with `old_structure_cmd` set to true.\n\nAs an example:\n```lean\nset_option old_structure_cmd true\n\nstructure base_one := (one : \u2115)\n\nstructure base_two (\u03b1 : Type*) := (two : \u2115)\n\n@[ancestor base_one base_two]\nstructure bar extends base_one, base_two \u03b1\n```\n\nThe list of ancestors should be in the order they appear in the `extends` clause, and should\ncontain only the names of the ancestor structures, without any arguments."}, {"name": "tactic.ancestor_attr", "description": " The `ancestor` attributes is used to record the names of structures which appear in the\nextends clause of a `structure` or `class` declared with `old_structure_cmd` set to true.\n\nAs an example:\n```lean\nset_option old_structure_cmd true\n\nstructure base_one := (one : \u2115)\n\nstructure base_two (\u03b1 : Type*) := (two : \u2115)\n\n@[ancestor base_one base_two]\nstructure bar extends base_one, base_two \u03b1\n```\n\nThe list of ancestors should be in the order they appear in the `extends` clause, and should\ncontain only the names of the ancestor structures, without any arguments."}, {"name": "tactic.find_ancestors", "description": "Returns the (transitive) ancestors of a structure added via the `ancestor`\nattribute (or reachable via subobjects).\n\nOn failure, the empty list is returned."}, {"name": "tactic.get_ancestors", "description": "Returns the parents of a structure added via the `ancestor` attribute, as well as subobjects.\n\nOn failure, the empty list is returned."}, {"name": "list.nodup_permutations", "description": ""}, {"name": "list.permutations_perm_permutations'", "description": ""}, {"name": "list.perm_cons_erase", "description": ""}, {"name": "list.perm.product", "description": ""}, {"name": "list.perm.prod_eq", "description": ""}, {"name": "list.count_permutations'_aux_self", "description": ""}, {"name": "list.subperm.cons_left", "description": ""}, {"name": "list.perm.subset", "description": ""}, {"name": "list.perm.foldl_eq'", "description": ""}, {"name": "list.subperm_ext_iff", "description": "The list version of `multiset.le_iff_count`."}, {"name": "list.perm.slice_inter", "description": ""}, {"name": "list.nodup_permutations'_aux_of_not_mem", "description": ""}, {"name": "list.perm.union_right", "description": ""}, {"name": "list.subperm_singleton_iff", "description": ""}, {"name": "list.repeat_perm", "description": ""}, {"name": "list.nil_perm", "description": ""}, {"name": "list.perm_induction_on", "description": ""}, {"name": "list.perm.subperm_left", "description": ""}, {"name": "list.perm.eq_nil", "description": ""}, {"name": "list.subperm.count_le", "description": ""}, {"name": "list.perm_nil", "description": ""}, {"name": "list.perm.sizeof_eq_sizeof", "description": ""}, {"name": "list.sublists_cons_perm_append", "description": ""}, {"name": "list.perm.bag_inter_left", "description": ""}, {"name": "list.sublist.subperm", "description": ""}, {"name": "list.singleton_perm_singleton", "description": ""}, {"name": "list.perm_middle", "description": ""}, {"name": "list.perm.inter_right", "description": ""}, {"name": "list.perm.rec_heq", "description": ""}, {"name": "list.perm.pmap", "description": ""}, {"name": "list.perm.filter_map", "description": ""}, {"name": "list.nodup.sublist_ext", "description": ""}, {"name": "list.subperm_append_diff_self_of_count_le", "description": "The list version of `add_tsub_cancel_of_le` for multisets."}, {"name": "list.perm.inter_left", "description": ""}, {"name": "list.perm.sum_eq", "description": ""}, {"name": "list.perm.count_eq", "description": ""}, {"name": "list.perm.append_right", "description": ""}, {"name": "list.nth_le_permutations'_aux", "description": ""}, {"name": "list.perm_permutations'_iff", "description": ""}, {"name": "list.perm.product_right", "description": ""}, {"name": "list.perm.subperm_right", "description": ""}, {"name": "list.cons_subperm_of_mem", "description": ""}, {"name": "list.perm.dedup", "description": ""}, {"name": "list.subperm.antisymm", "description": ""}, {"name": "list.perm.inter_append", "description": ""}, {"name": "list.perm.symm", "description": ""}, {"name": "list.decidable_perm", "description": ""}, {"name": "list.subperm_append_right", "description": ""}, {"name": "list.perm_append_right_iff", "description": ""}, {"name": "list.nodup_permutations'_aux_iff", "description": ""}, {"name": "list.sum_reverse", "description": ""}, {"name": "list.reverse_perm", "description": ""}, {"name": "list.pairwise.perm", "description": ""}, {"name": "list.subperm_cons_erase", "description": ""}, {"name": "list.nil_subperm", "description": ""}, {"name": "list.perm_insert_swap", "description": ""}, {"name": "list.sublist.exists_perm_append", "description": ""}, {"name": "list.perm.map", "description": ""}, {"name": "list.filter_append_perm", "description": ""}, {"name": "list.perm_append_singleton", "description": ""}, {"name": "list.perm.pairwise", "description": ""}, {"name": "list.perm.bind_right", "description": ""}, {"name": "list.perm_insert_nth", "description": ""}, {"name": "list.mem_permutations", "description": ""}, {"name": "list.perm_option_to_list", "description": ""}, {"name": "list.subperm.subset", "description": ""}, {"name": "list.erase_subperm", "description": ""}, {"name": "list.injective_permutations'_aux", "description": ""}, {"name": "list.mem_permutations'", "description": ""}, {"name": "list.subperm_cons", "description": ""}, {"name": "list.subperm.of_cons", "description": "**Alias** of the forward direction of `list.subperm_cons`."}, {"name": "list.perm.erasep", "description": ""}, {"name": "list.perm.foldl_eq", "description": ""}, {"name": "list.not_perm_nil_cons", "description": ""}, {"name": "list.exists_perm_sublist", "description": ""}, {"name": "list.subperm.exists_of_length_lt", "description": ""}, {"name": "list.forall\u2082_comp_perm_eq_perm_comp_forall\u2082", "description": ""}, {"name": "list.perm.insert", "description": ""}, {"name": "list.cons_perm_iff_perm_erase", "description": ""}, {"name": "list.perm_singleton", "description": ""}, {"name": "list.perm.product_left", "description": ""}, {"name": "list.perm_cons_append_cons", "description": ""}, {"name": "list.perm.take_inter", "description": ""}, {"name": "list.erase_cons_subperm_cons_erase", "description": ""}, {"name": "list.subperm", "description": "`subperm l\u2081 l\u2082`, denoted `l\u2081 <+~ l\u2082`, means that `l\u2081` is a sublist of\n a permutation of `l\u2082`. This is an analogue of `l\u2081 \u2286 l\u2082` which respects\n multiplicities of elements, and is used for the `\u2264` relation on multisets."}, {"name": "list.perm.diff", "description": ""}, {"name": "list.perm.drop_inter", "description": ""}, {"name": "list.perm_cons", "description": ""}, {"name": "list.mem_permutations_aux_of_perm", "description": ""}, {"name": "list.subperm.trans", "description": ""}, {"name": "list.perm_permutations_iff", "description": ""}, {"name": "list.perm_repeat", "description": ""}, {"name": "list.perm.prod_eq'", "description": " If elements of a list commute with each other, then their product does not\ndepend on the order of elements"}, {"name": "list.perm.erase", "description": ""}, {"name": "list.perm.append", "description": ""}, {"name": "list.perm.sum_eq'", "description": ""}, {"name": "list.subperm.filter", "description": ""}, {"name": "list.perm_of_mem_permutations_aux", "description": ""}, {"name": "list.nodup.subperm", "description": ""}, {"name": "list.subperm.cons", "description": "**Alias** of the reverse direction of `list.subperm_cons`."}, {"name": "list.subperm.erase", "description": ""}, {"name": "list.revzip_sublists", "description": ""}, {"name": "list.perm", "description": "`perm l\u2081 l\u2082` or `l\u2081 ~ l\u2082` asserts that `l\u2081` and `l\u2082` are permutations\n of each other. This is defined by induction using pairwise swaps."}, {"name": "list.perm.nil", "description": "`perm l\u2081 l\u2082` or `l\u2081 ~ l\u2082` asserts that `l\u2081` and `l\u2082` are permutations\n of each other. This is defined by induction using pairwise swaps."}, {"name": "list.perm.cons", "description": "`perm l\u2081 l\u2082` or `l\u2081 ~ l\u2082` asserts that `l\u2081` and `l\u2082` are permutations\n of each other. This is defined by induction using pairwise swaps."}, {"name": "list.perm.swap", "description": "`perm l\u2081 l\u2082` or `l\u2081 ~ l\u2082` asserts that `l\u2081` and `l\u2082` are permutations\n of each other. This is defined by induction using pairwise swaps."}, {"name": "list.perm.trans", "description": "`perm l\u2081 l\u2082` or `l\u2081 ~ l\u2082` asserts that `l\u2081` and `l\u2082` are permutations\n of each other. This is defined by induction using pairwise swaps."}, {"name": "list.perm_of_mem_permutations", "description": ""}, {"name": "list.perm.filter", "description": ""}, {"name": "list.subperm.refl", "description": ""}, {"name": "list.perm_comp_forall\u2082", "description": ""}, {"name": "list.perm.foldr_eq", "description": ""}, {"name": "list.singleton_perm", "description": ""}, {"name": "list.perm.eq_singleton", "description": ""}, {"name": "list.perm_append_left_iff", "description": ""}, {"name": "list.perm.pairwise_iff", "description": ""}, {"name": "list.subperm.diff_right", "description": ""}, {"name": "list.perm.diff_right", "description": ""}, {"name": "list.subperm_cons_diff", "description": ""}, {"name": "list.perm_inv_core", "description": ""}, {"name": "list.perm.bag_inter_right", "description": ""}, {"name": "list.rel_perm_imp", "description": ""}, {"name": "list.perm.nodup_iff", "description": ""}, {"name": "list.perm.mem_iff", "description": ""}, {"name": "list.perm.length_eq", "description": ""}, {"name": "list.perm_append_comm", "description": ""}, {"name": "list.subperm.countp_le", "description": ""}, {"name": "list.perm.eqv", "description": ""}, {"name": "list.perm.cons_inv", "description": ""}, {"name": "list.perm_lookmap", "description": ""}, {"name": "list.subperm.length_le", "description": ""}, {"name": "list.perm.nil_eq", "description": ""}, {"name": "list.subperm_append_left", "description": ""}, {"name": "list.perm.countp_eq", "description": ""}, {"name": "list.permutations'_aux_nth_le_zero", "description": ""}, {"name": "list.perm.append_cons", "description": ""}, {"name": "list.perm.bind_left", "description": ""}, {"name": "list.perm.diff_left", "description": ""}, {"name": "list.perm_comp_perm", "description": ""}, {"name": "list.perm.append_left", "description": ""}, {"name": "list.perm_permutations'_aux_comm", "description": ""}, {"name": "list.bind_append_perm", "description": ""}, {"name": "list.perm.refl", "description": ""}, {"name": "list.perm.singleton_eq", "description": ""}, {"name": "list.sublists_perm_sublists'", "description": ""}, {"name": "list.length_permutations'_aux", "description": ""}, {"name": "list.perm.permutations", "description": ""}, {"name": "list.perm.fold_op_eq", "description": ""}, {"name": "list.rel_perm", "description": ""}, {"name": "list.perm_ext", "description": ""}, {"name": "list.length_permutations", "description": ""}, {"name": "list.revzip_sublists'", "description": ""}, {"name": "list.subperm.cons_right", "description": ""}, {"name": "list.length_permutations_aux", "description": ""}, {"name": "list.countp_eq_countp_filter_add", "description": ""}, {"name": "list.perm.subperm", "description": ""}, {"name": "list.perm.inter", "description": ""}, {"name": "list.subset_cons_diff", "description": ""}, {"name": "list.mem_permutations_of_perm_lemma", "description": ""}, {"name": "list.prod_reverse", "description": ""}, {"name": "list.perm.union", "description": ""}, {"name": "list.perm.union_left", "description": ""}, {"name": "list.concat_perm", "description": ""}, {"name": "list.is_setoid", "description": ""}, {"name": "list.perm.permutations'", "description": ""}, {"name": "list.perm_iff_count", "description": ""}, {"name": "list.subperm.perm_of_length_le", "description": ""}, {"name": "list.perm.swap'", "description": ""}, {"name": "list.perm.bag_inter", "description": ""}, {"name": "list.perm_comm", "description": ""}, {"name": "list.perm.countp_congr", "description": ""}, {"name": "zpow_bit0'", "description": ""}, {"name": "semiconj_by.cast_nat_mul_cast_nat_mul", "description": ""}, {"name": "zpow_add", "description": ""}, {"name": "semiconj_by.cast_int_mul_cast_int_mul", "description": ""}, {"name": "int.nat_abs_pow_two", "description": "**Alias** of `int.nat_abs_sq`."}, {"name": "one_lt_zpow'", "description": ""}, {"name": "zsmul_pos", "description": ""}, {"name": "zpowers_mul_hom_apply", "description": ""}, {"name": "commute.cast_int_right", "description": ""}, {"name": "zsmul_right_inj", "description": ""}, {"name": "zsmul_one", "description": ""}, {"name": "zpow_bit1", "description": ""}, {"name": "nsmul_one", "description": ""}, {"name": "int.abs_le_self_pow_two", "description": "**Alias** of `int.abs_le_self_sq`."}, {"name": "zpowers_hom_apply", "description": ""}, {"name": "units.conj_pow'", "description": ""}, {"name": "neg_one_pow_eq_pow_mod_two", "description": ""}, {"name": "zsmul_strict_mono_right", "description": ""}, {"name": "add_semiconj_by.add_units_zsmul_right", "description": ""}, {"name": "zsmul_le_zsmul_iff'", "description": ""}, {"name": "semiconj_by.units_zpow_right", "description": ""}, {"name": "commute.units_zpow_left", "description": ""}, {"name": "int.cast_pow", "description": ""}, {"name": "units.conj_pow", "description": ""}, {"name": "semiconj_by.cast_int_mul_left", "description": ""}, {"name": "bit0_mul", "description": ""}, {"name": "pow_le_of_le_one", "description": ""}, {"name": "semiconj_by.cast_nat_mul_right", "description": ""}, {"name": "zpow_add_one", "description": ""}, {"name": "powers_mul_hom", "description": "If `M` is commutative, `powers_hom` is a multiplicative equivalence."}, {"name": "bit0_zsmul", "description": ""}, {"name": "zsmul_le_zsmul", "description": ""}, {"name": "is_unit_pos_pow_iff", "description": ""}, {"name": "add_monoid_hom.apply_int", "description": ""}, {"name": "int.nat_abs_sq", "description": ""}, {"name": "zpow_le_zpow'", "description": ""}, {"name": "pow_le_pow_of_le_one", "description": ""}, {"name": "zsmul_lt_zsmul", "description": ""}, {"name": "zpow_mono_left", "description": ""}, {"name": "int.nat_abs_pow", "description": ""}, {"name": "commute.self_cast_int_mul_cast_int_mul", "description": ""}, {"name": "multiples_hom_apply", "description": ""}, {"name": "zpow_lt_zpow_iff'", "description": ""}, {"name": "int.pow_right_injective", "description": ""}, {"name": "zmultiples_add_hom_symm_apply", "description": ""}, {"name": "commute.cast_int_mul_left", "description": ""}, {"name": "smul_pow", "description": ""}, {"name": "nsmul_eq_mul'", "description": ""}, {"name": "mul_opposite.unop_pow", "description": ""}, {"name": "add_self_zsmul", "description": ""}, {"name": "zmultiples_add_hom", "description": "If `M` is commutative, `zmultiples_hom` is an additive equivalence."}, {"name": "int.le_self_sq", "description": ""}, {"name": "mul_zsmul'", "description": ""}, {"name": "zsmul_lt_zsmul'", "description": ""}, {"name": "int.le_self_pow_two", "description": "**Alias** of `int.le_self_sq`."}, {"name": "commute.self_cast_nat_mul", "description": ""}, {"name": "add_zsmul", "description": ""}, {"name": "zpow_lt_zpow_iff", "description": ""}, {"name": "commute.cast_int_mul_self", "description": ""}, {"name": "powers_mul_hom_symm_apply", "description": ""}, {"name": "zsmul_add_comm", "description": ""}, {"name": "int.coe_nat_pow", "description": ""}, {"name": "nat.of_add_mul", "description": ""}, {"name": "monoid_hom.ext_mnat", "description": ""}, {"name": "with_bot.coe_nsmul", "description": ""}, {"name": "mul_bit1", "description": ""}, {"name": "zpow_eq_zpow_iff'", "description": " Alias of `zsmul_right_inj`, for ease of discovery alongside `zsmul_le_zsmul_iff'` and\n`zsmul_lt_zsmul_iff'`."}, {"name": "non_unital_non_assoc_semiring.nat_is_scalar_tower", "description": "Note that `add_comm_monoid.nat_is_scalar_tower` requires stronger assumptions on `R`."}, {"name": "invertible_pow", "description": ""}, {"name": "inv_of_pow", "description": ""}, {"name": "multiples_hom_symm_apply", "description": ""}, {"name": "non_unital_non_assoc_ring.int_smul_comm_class", "description": "Note that `add_comm_group.int_smul_comm_class` requires stronger assumptions on `R`."}, {"name": "commute.self_cast_int_mul", "description": ""}, {"name": "zpow_bit0_neg", "description": ""}, {"name": "non_unital_non_assoc_ring.int_is_scalar_tower", "description": "Note that `add_comm_group.int_is_scalar_tower` requires stronger assumptions on `R`."}, {"name": "monoid_hom.apply_mnat", "description": ""}, {"name": "zmultiples_hom_apply", "description": ""}, {"name": "commute.units_zpow_right", "description": ""}, {"name": "one_add_mul_le_pow", "description": "Bernoulli's inequality for `n : \u2115`, `-2 \u2264 a`."}, {"name": "invertible_of_pow_eq_one", "description": "If `x ^ n = 1` then `x` has an inverse, `x^(n - 1)`."}, {"name": "pow_bit1_nonneg_iff", "description": ""}, {"name": "zmultiples_hom_symm_apply", "description": ""}, {"name": "smul_pow'", "description": ""}, {"name": "commute.cast_nat_mul_left", "description": ""}, {"name": "mul_self_zpow", "description": ""}, {"name": "int.units_pow_eq_pow_mod_two", "description": ""}, {"name": "powers_hom_apply", "description": ""}, {"name": "commute.cast_int_left", "description": ""}, {"name": "zsmul_eq_mul'", "description": ""}, {"name": "commute.cast_int_mul_cast_int_mul", "description": ""}, {"name": "add_monoid_hom.apply_nat", "description": ""}, {"name": "zsmul_mono_left", "description": ""}, {"name": "zsmul_int_one", "description": ""}, {"name": "zpow_mul_comm", "description": ""}, {"name": "mul_zpow_self", "description": ""}, {"name": "zsmul_eq_zsmul_iff'", "description": "Alias of `zsmul_right_inj`, for ease of discovery alongside `zsmul_le_zsmul_iff'` and\n`zsmul_lt_zsmul_iff'`."}, {"name": "nsmul_eq_mul", "description": ""}, {"name": "nat.to_add_pow", "description": ""}, {"name": "zsmul_le_zsmul'", "description": ""}, {"name": "commute.cast_nat_mul_cast_nat_mul", "description": ""}, {"name": "int.to_add_pow", "description": ""}, {"name": "multiples_hom", "description": "Additive homomorphisms from `\u2115` are defined by the image of `1`."}, {"name": "abs_add_eq_add_abs_le", "description": ""}, {"name": "multiples_add_hom_symm_apply", "description": ""}, {"name": "invertible_of_pow_succ_eq_one", "description": "If `x ^ n.succ = 1` then `x` has an inverse, `x^n`."}, {"name": "zpow_left_injective", "description": ""}, {"name": "zpowers_hom_symm_apply", "description": ""}, {"name": "zsmul_mono_right", "description": ""}, {"name": "zpow_sub_one", "description": ""}, {"name": "abs_nsmul", "description": ""}, {"name": "powers_hom_symm_apply", "description": ""}, {"name": "add_zsmul_self", "description": ""}, {"name": "zmultiples_add_hom_apply", "description": ""}, {"name": "sq_le", "description": ""}, {"name": "mul_bit0", "description": ""}, {"name": "zsmul_lt_zsmul_iff", "description": ""}, {"name": "powers_hom", "description": " Monoid homomorphisms from `multiplicative \u2115` are defined by the image\nof `multiplicative.of_add 1`."}, {"name": "commute.cast_nat_mul_right", "description": ""}, {"name": "zpow_bit0", "description": ""}, {"name": "zpow_le_zpow", "description": ""}, {"name": "zsmul_sub_one", "description": ""}, {"name": "mul_opposite.op_zpow", "description": "Moving to the opposite group or group_with_zero commutes with taking powers."}, {"name": "multiples_add_hom", "description": "If `M` is commutative, `multiples_hom` is an additive equivalence."}, {"name": "one_add_mul_sub_le_pow", "description": "Bernoulli's inequality reformulated to estimate `a^n`."}, {"name": "zpowers_hom", "description": " Monoid homomorphisms from `multiplicative \u2124` are defined by the image\nof `multiplicative.of_add 1`."}, {"name": "bit1_mul", "description": ""}, {"name": "int.to_add_zpow", "description": ""}, {"name": "zsmul_int_int", "description": ""}, {"name": "zpow_strict_mono_left", "description": ""}, {"name": "semiconj_by.cast_nat_mul_left", "description": ""}, {"name": "zsmul_strict_mono_left", "description": ""}, {"name": "commute.self_cast_nat_mul_cast_nat_mul", "description": ""}, {"name": "zpowers_mul_hom", "description": "If `M` is commutative, `zpowers_hom` is a multiplicative equivalence."}, {"name": "zpowers_mul_hom_symm_apply", "description": ""}, {"name": "bit0_zsmul'", "description": ""}, {"name": "one_add_zsmul", "description": ""}, {"name": "sign_cases_of_C_mul_pow_nonneg", "description": ""}, {"name": "abs_add_eq_add_abs_iff", "description": ""}, {"name": "mul_opposite.op_pow", "description": "Moving to the opposite monoid commutes with taking powers."}, {"name": "pow_bit1_pos_iff", "description": ""}, {"name": "zpow_mul", "description": ""}, {"name": "bit1_zsmul", "description": ""}, {"name": "zsmul_le_zsmul_iff", "description": ""}, {"name": "zpow_left_inj", "description": ""}, {"name": "int.units_pow_two", "description": "**Alias** of `int.units_sq`."}, {"name": "int.of_add_mul", "description": ""}, {"name": "zsmul_lt_zsmul_iff'", "description": ""}, {"name": "pow_bit1_neg_iff", "description": ""}, {"name": "add_commute.add_units_zsmul_right", "description": ""}, {"name": "zpow_lt_zpow'", "description": ""}, {"name": "powers_mul_hom_apply", "description": ""}, {"name": "mul_opposite.unop_zpow", "description": ""}, {"name": "sub_zsmul", "description": ""}, {"name": "commute.cast_int_mul_right", "description": ""}, {"name": "nat.cast_pow", "description": ""}, {"name": "pow_bit1_nonpos_iff", "description": ""}, {"name": "abs_pow", "description": ""}, {"name": "zpow_mono_right", "description": ""}, {"name": "multiples_add_hom_apply", "description": ""}, {"name": "zmultiples_hom", "description": "Additive homomorphisms from `\u2124` are defined by the image of `1`."}, {"name": "semiconj_by.cast_int_mul_right", "description": ""}, {"name": "zpow_mul'", "description": ""}, {"name": "abs_zsmul", "description": ""}, {"name": "zsmul_right_injective", "description": "See also `smul_right_injective`. TODO: provide a `no_zero_smul_divisors` instance. We can't do that\nhere because importing that definition would create import cycles."}, {"name": "strict_mono_pow_bit1", "description": ""}, {"name": "zpow_sub", "description": ""}, {"name": "zpow_le_zpow_iff'", "description": ""}, {"name": "is_unit.pow", "description": ""}, {"name": "is_unit_of_pow_eq_one", "description": ""}, {"name": "zpow_lt_zpow", "description": ""}, {"name": "mul_zsmul", "description": ""}, {"name": "zpow_le_zpow_iff", "description": ""}, {"name": "monoid_hom.apply_mint", "description": ""}, {"name": "zpow_one_add", "description": ""}, {"name": "add_commute.add_units_zsmul_left", "description": ""}, {"name": "add_one_zsmul", "description": ""}, {"name": "zpow_strict_mono_right", "description": ""}, {"name": "is_unit_pow_succ_iff", "description": ""}, {"name": "int.abs_le_self_sq", "description": ""}, {"name": "zsmul_eq_mul", "description": ""}, {"name": "non_unital_non_assoc_semiring.nat_smul_comm_class", "description": "Note that `add_comm_monoid.nat_smul_comm_class` requires stronger assumptions on `R`."}, {"name": "commute.cast_nat_mul_self", "description": ""}, {"name": "one_add_mul_le_pow'", "description": " Bernoulli's inequality. This version works for semirings but requires\nadditional hypotheses `0 \u2264 a * a` and `0 \u2264 (1 + a) * (1 + a)`."}, {"name": "string.pop_back", "description": ""}, {"name": "string.popn_back", "description": ""}, {"name": "string.iterator", "description": ""}, {"name": "string.iterator.extract", "description": ""}, {"name": "string.iterator.set_curr", "description": ""}, {"name": "string.back", "description": ""}, {"name": "string.iterator.next_to_string", "description": ""}, {"name": "string_imp", "description": ""}, {"name": "string_imp.data", "description": ""}, {"name": "string.empty", "description": ""}, {"name": "string.str", "description": ""}, {"name": "string.iterator.curr", "description": ""}, {"name": "string.fold", "description": ""}, {"name": "string.iterator.prevn", "description": ""}, {"name": "string.singleton", "description": ""}, {"name": "char.to_string", "description": ""}, {"name": "string.iterator.nextn", "description": ""}, {"name": "string.iterator.has_next", "description": ""}, {"name": "string.str_ne_empty", "description": ""}, {"name": "string.iterator.next", "description": ""}, {"name": "string.inhabited", "description": ""}, {"name": "string.iterator.extract_core", "description": ""}, {"name": "string.push", "description": ""}, {"name": "string.iterator.prev", "description": ""}, {"name": "string.has_sizeof", "description": ""}, {"name": "string.str_ne_str_right", "description": ""}, {"name": "string.to_list", "description": ""}, {"name": "string.intercalate", "description": ""}, {"name": "string.is_empty", "description": ""}, {"name": "string.backn", "description": ""}, {"name": "string.empty_ne_str", "description": ""}, {"name": "string.iterator.insert", "description": ""}, {"name": "string.iterator.remove", "description": ""}, {"name": "string.iterator.has_prev", "description": ""}, {"name": "string.has_decidable_eq", "description": ""}, {"name": "string.iterator.prev_to_string", "description": ""}, {"name": "list.as_string", "description": ""}, {"name": "string", "description": ""}, {"name": "string.str_ne_str_left", "description": ""}, {"name": "string.has_append", "description": ""}, {"name": "string.append", "description": ""}, {"name": "string.has_decidable_lt", "description": ""}, {"name": "string.iterator_imp", "description": ""}, {"name": "string.iterator_imp.fst", "description": ""}, {"name": "string.iterator_imp.snd", "description": ""}, {"name": "string.iterator.to_string", "description": ""}, {"name": "string.has_lt", "description": ""}, {"name": "string.front", "description": ""}, {"name": "string.join", "description": ""}, {"name": "string.length", "description": ""}, {"name": "string.iterator.to_end", "description": ""}, {"name": "string.to_nat", "description": ""}, {"name": "string.mk_iterator", "description": ""}, {"name": "tactic.simplify", "description": "`simplify s e cfg r prove` simplify `e` using `s` using bottom-up traversal.\n`discharger` is a tactic for dischaging new subgoals created by the simplifier.\n If it fails, the simplifier tries to discharge the subgoal by simplifying it to `true`.\n\n The parameter `to_unfold` specifies definitions that should be delta-reduced,\n and projection applications that should be unfolded."}, {"name": "tactic.delta", "description": "Delta reduce the given constant names"}, {"name": "tactic.to_simp_lemmas", "description": ""}, {"name": "simp.default_max_steps", "description": ""}, {"name": "mk_simp_attr_decl_name", "description": "Prefix the given `attr_name` with `\"simp_attr\"`."}, {"name": "tactic.simp_config", "description": ""}, {"name": "tactic.simp_config.max_steps", "description": ""}, {"name": "tactic.simp_config.contextual", "description": ""}, {"name": "tactic.simp_config.lift_eq", "description": ""}, {"name": "tactic.simp_config.canonize_instances", "description": ""}, {"name": "tactic.simp_config.canonize_proofs", "description": ""}, {"name": "tactic.simp_config.use_axioms", "description": ""}, {"name": "tactic.simp_config.zeta", "description": ""}, {"name": "tactic.simp_config.beta", "description": ""}, {"name": "tactic.simp_config.eta", "description": ""}, {"name": "tactic.simp_config.proj", "description": ""}, {"name": "tactic.simp_config.iota", "description": ""}, {"name": "tactic.simp_config.iota_eqn", "description": ""}, {"name": "tactic.simp_config.constructor_eq", "description": ""}, {"name": "tactic.simp_config.single_pass", "description": ""}, {"name": "tactic.simp_config.fail_if_unchanged", "description": ""}, {"name": "tactic.simp_config.memoize", "description": ""}, {"name": "tactic.simp_config.trace_lemmas", "description": ""}, {"name": "tactic.dsimplify", "description": ""}, {"name": "tactic.simplify_top_down", "description": ""}, {"name": "simp_lemmas.rewrite", "description": "`simp_lemmas.rewrite s e prove R` apply a simplification lemma from 's'\n\n  - 'e'     is the expression to be \"simplified\"\n  - 'prove' is used to discharge proof obligations.\n  - 'r'     is the equivalence relation being used (e.g., 'eq', 'iff')\n  - 'md'    is the transparency; how aggresively should the simplifier perform reductions.\n\n  Result (new_e, pr) is the new expression 'new_e' and a proof (pr : e R new_e)"}, {"name": "tactic.simp_all_entry", "description": ""}, {"name": "tactic.simp_all_entry.h", "description": ""}, {"name": "tactic.simp_all_entry.new_type", "description": ""}, {"name": "tactic.simp_all_entry.pr", "description": ""}, {"name": "tactic.simp_all_entry.s", "description": ""}, {"name": "simp_lemmas.erase_simp_lemmas", "description": "Remove all simp lemmas from the table."}, {"name": "tactic.dunfold_head", "description": "Tries to unfold `e` if it is a constant or a constant application.\n   Remark: this is not a recursive procedure."}, {"name": "tactic.non_dep_prop_hyps", "description": ""}, {"name": "simp_lemmas", "description": " Simp lemmas are used by the \"simplifier\" family of tactics.\n`simp_lemmas` is essentially a pair of tables `rb_map (expr_type \u00d7 name) (priority_list simp_lemma)`.\nOne of the tables is for congruences and one is for everything else.\nAn individual simp lemma is:\n- A kind which can be `Refl`, `Simp` or `Congr`.\n- A pair of `expr`s `l ~> r`. The rb map is indexed by the name of `get_app_fn(l)`.\n- A proof that `l = r` or `l \u2194 r`.\n- A list of the metavariables that must be filled before the proof can be applied.\n- A priority number"}, {"name": "tactic.mk_simp_attr", "description": ""}, {"name": "tactic.dsimp_hyp", "description": ""}, {"name": "tactic.join_user_simp_lemmas_core", "description": ""}, {"name": "tactic.mk_eq_simp_ext", "description": ""}, {"name": "tactic.delta_config", "description": ""}, {"name": "tactic.delta_config.max_steps", "description": ""}, {"name": "tactic.delta_config.visit_instances", "description": ""}, {"name": "tactic.delta_target", "description": ""}, {"name": "simp_lemmas.add", "description": " Add a simplification lemma by an expression `p`. Some conditions on `p` must hold for it to be added, see list below.\nIf your lemma is not being added, you can see the reasons by setting `set_option trace.simp_lemmas true`.\n\n- `p` must have the type `\u03a0 (h\u2081 : _) ... (h\u2099 : _), LHS ~ RHS` for some reflexive, transitive relation (usually `=`).\n- Any of the hypotheses `h\u1d62` should either be present in `LHS` or otherwise a `Prop` or a typeclass instance.\n- `LHS` should not occur within `RHS`.\n- `LHS` should not occur within a hypothesis `h\u1d62`."}, {"name": "tactic.dsimplify_core", "description": ""}, {"name": "tactic.ext_simplify_core", "description": "`ext_simplify_core a c s discharger pre post r e`:\n\n- `a : \u03b1` - initial user data\n- `c : simp_config` - simp configuration options\n- `s : simp_lemmas` - the set of simp_lemmas to use. Remark: the simplification lemmas are not applied automatically like in the simplify tactic. The caller must use them at pre/post.\n- `discharger : \u03b1 \u2192 tactic \u03b1` - tactic for dischaging hypothesis in conditional rewriting rules. The argument '\u03b1' is the current user data.\n- `pre a s r p e` is invoked before visiting the children of subterm 'e'.\n  + arguments:\n    - `a` is the current user data\n    - `s` is the updated set of lemmas if 'contextual' is `tt`,\n    - `r` is the simplification relation being used,\n    - `p` is the \"parent\" expression (if there is one).\n    - `e` is the current subexpression in question.\n  + if it succeeds the result is `(new_a, new_e, new_pr, flag)` where\n    - `new_a` is the new value for the user data\n    - `new_e` is a new expression s.t. `r e new_e`\n    - `new_pr` is a proof for `r e new_e`, If it is none, the proof is assumed to be by reflexivity\n    - `flag`  if tt `new_e` children should be visited, and `post` invoked.\n- `(post a s r p e)` is invoked after visiting the children of subterm `e`,\n  The output is similar to `(pre a r s p e)`, but the 'flag' indicates whether the new expression should be revisited or not.\n- `r` is the simplification relation. Usually `=` or `\u2194`.\n- `e` is the input expression to be simplified.\n\nThe method returns `(a,e,pr)` where\n\n - `a` is the final user data\n - `e` is the new expression\n - `pr` is the proof that the given expression equals the input expression.\n\nNote that `ext_simplify_core` will succeed even if `pre` and `post` fail, as failures are used to indicate that the method should move on to the next subterm.\nIf it is desirable to propagate errors from `pre`, they can be propagated through the \"user data\".\nAn easy way to do this is to call `tactic.capture (do ...)` in the parts of `pre`/`post` where errors matter, and then use `tactic.unwrap a` on the result.\n\nAdditionally, `ext_simplify_core` does not propagate changes made to the tactic state by `pre` and `post.\nIf it is desirable to propagate changes to the tactic state in addition to errors, use `tactic.resume` instead of `tactic.unwrap`."}, {"name": "tactic.id_tag.simp", "description": ""}, {"name": "simp_lemmas.add_congr", "description": " Adds a congruence simp lemma to simp_lemmas.\nA congruence simp lemma is a lemma that breaks the simplification down into separate problems.\nFor example, to simplify `a \u2227 b` to `c \u2227 d`, we should try to simp `a` to `c` and `b` to `d`.\nFor examples of congruence simp lemmas look for lemmas with the `@[congr]` attribute.\n```lean\nlemma if_simp_congr ... (h_c : b \u2194 c) (h_t : x = u) (h_e : y = v) : ite b x y = ite c u v := ...\nlemma imp_congr_right (h : a \u2192 (b \u2194 c)) : (a \u2192 b) \u2194 (a \u2192 c) := ...\nlemma and_congr (h\u2081 : a \u2194 c) (h\u2082 : b \u2194 d) : (a \u2227 b) \u2194 (c \u2227 d) := ...\n```"}, {"name": "simp_lemmas.add_simp", "description": "Add a simplification lemma by it's declaration name. See `simp_lemmas.add` for more information."}, {"name": "tactic.simp_top_down", "description": ""}, {"name": "simp_lemmas.append_with_symm", "description": "Add expressions to a set of simp lemmas using `simp_lemmas.add`.\n\n This is the new version of `simp_lemmas.append`,\n which also allows you to set the `symm` flag."}, {"name": "tactic.simp_intros_config", "description": ""}, {"name": "tactic.simp_intros_config.to_simp_config", "description": ""}, {"name": "tactic.simp_intros_config.use_hyps", "description": ""}, {"name": "tactic.get_simp_lemmas_or_default", "description": ""}, {"name": "tactic.simp_bottom_up", "description": ""}, {"name": "tactic.simp_intros_aux", "description": ""}, {"name": "simp_lemmas.mk_default", "description": "Makes the default simp_lemmas table which is composed of all lemmas tagged with `simp`."}, {"name": "tactic.unfold_proj_config", "description": ""}, {"name": "tactic.unfold_proj_config.to_dsimp_config", "description": ""}, {"name": "tactic.dunfold_target", "description": ""}, {"name": "simp_attr.norm", "description": ""}, {"name": "tactic.revert_and_transform", "description": "Revert a local constant, change its type using `transform`."}, {"name": "tactic.simplify_bottom_up", "description": ""}, {"name": "is_valid_simp_lemma", "description": ""}, {"name": "simp_lemmas.join", "description": "Merge the simp_lemma tables."}, {"name": "tactic.simp_intros", "description": ""}, {"name": "tactic.dunfold_hyp", "description": ""}, {"name": "simp_lemmas.rewrites", "description": ""}, {"name": "tactic.join_user_simp_lemmas", "description": ""}, {"name": "is_valid_simp_lemma_cnst", "description": ""}, {"name": "tactic.unfold_projs", "description": ""}, {"name": "tactic.dsimp_config", "description": ""}, {"name": "tactic.dsimp_config.md", "description": ""}, {"name": "tactic.dsimp_config.max_steps", "description": ""}, {"name": "tactic.dsimp_config.canonize_instances", "description": ""}, {"name": "tactic.dsimp_config.single_pass", "description": ""}, {"name": "tactic.dsimp_config.fail_if_unchanged", "description": ""}, {"name": "tactic.dsimp_config.eta", "description": ""}, {"name": "tactic.dsimp_config.zeta", "description": ""}, {"name": "tactic.dsimp_config.beta", "description": ""}, {"name": "tactic.dsimp_config.proj", "description": ""}, {"name": "tactic.dsimp_config.iota", "description": ""}, {"name": "tactic.dsimp_config.unfold_reducible", "description": ""}, {"name": "tactic.dsimp_config.memoize", "description": ""}, {"name": "simp_lemmas.erase", "description": "Remove the given lemmas from the table. Use the names of the lemmas."}, {"name": "tactic.unfold_proj", "description": "If `e` is a projection application, try to unfold it, otherwise fail."}, {"name": "tactic.collect_ctx_simps", "description": ""}, {"name": "tactic.delta_hyp", "description": ""}, {"name": "tactic.simp_hyp", "description": ""}, {"name": "tactic.dsimp_target", "description": ""}, {"name": "tactic.unfold_projs_target", "description": ""}, {"name": "tactic.simp_all", "description": ""}, {"name": "tactic.intro1_aux", "description": ""}, {"name": "simp_lemmas.append", "description": "Add expressions to a set of simp lemmas using `simp_lemmas.add`.\n\n This is the backwards-compatibility version of `simp_lemmas.append_with_symm`,\n and sets all `symm` flags to `ff`."}, {"name": "tactic.dunfold", "description": ""}, {"name": "tactic.trace_algebra_info", "description": ""}, {"name": "simp_lemmas.has_to_tactic_format", "description": ""}, {"name": "tactic.dunfold_config", "description": ""}, {"name": "tactic.dunfold_config.to_dsimp_config", "description": ""}, {"name": "simp_lemmas.mk", "description": "Make a new table of simp lemmas"}, {"name": "tactic.simp_target", "description": ""}, {"name": "simp_lemmas.pp", "description": ""}, {"name": "simp_lemmas.dsimplify", "description": "(Definitional) Simplify the given expression using *only* reflexivity equality lemmas from the given set of lemmas.\n  The resulting expression is definitionally equal to the input.\n\n  The list `u` contains defintions to be delta-reduced, and projections to be reduced."}, {"name": "tactic.get_user_simp_lemmas", "description": "### Example usage:\n```lean\n-- make a new simp attribute called \"my_reduction\"\nrun_cmd mk_simp_attr `my_reduction\n-- Add \"my_reduction\" attributes to these if-reductions\nattribute [my_reduction] if_pos if_neg dif_pos dif_neg\n\n-- will return the simp_lemmas with the `my_reduction` attribute.\n#eval get_user_simp_lemmas `my_reduction\n\n```"}, {"name": "simp_lemmas.drewrite", "description": "`simp_lemmas.drewrite s e` tries to rewrite 'e' using only refl lemmas in 's'"}, {"name": "tactic.unfold_projs_hyp", "description": ""}, {"name": "tactic.get_eqn_lemmas_for", "description": "`get_eqn_lemmas_for deps d` returns the automatically generated equational lemmas for definition d.\n  If deps is tt, then lemmas for automatically generated auxiliary declarations used to define d are also included."}, {"name": "native.rb_map.scale", "description": "`scale b m` multiplies every value in `m` by `b`."}, {"name": "expr_set.local_set_to_name_set", "description": "`local_set_to_name_set lcs` is the set of unique names of the local constants\n`lcs`. If any of the `lcs` are not local constants, the returned set will\ncontain bogus names."}, {"name": "native.rb_set.sdiff", "description": "`sdiff s1 s2` returns the set of elements that are in `s1` but not in `s2`.\nIt does so by folding over `s2`. If `s1` is significantly smaller than `s2`,\nit may be worth it to reverse the fold."}, {"name": "native.rb_map.add", "description": "Returns the pointwise sum of `m1` and `m2`, treating nonexistent values as 0."}, {"name": "native.rb_map.has_to_tactic_format", "description": ""}, {"name": "name_map.inhabited", "description": ""}, {"name": "native.rb_set.mfilter", "description": " `mfilter s P` returns the subset of elements of `s` satisfying `P`,\nwhere the check `P` is monadic."}, {"name": "native.rb_set.of_list", "description": "`of_list l` transforms a list `l : list key` into an `rb_set`,\ninferring an order on the type `key`."}, {"name": "list.to_rb_map", "description": "`to_rb_map as` is the map that associates each index `i` of `as` with the\ncorresponding element of `as`.\n\n```lean\nto_rb_map ['a', 'b', 'c'] = rb_map.of_list [(0, 'a'), (1, 'b'), (2, 'c')]\n```"}, {"name": "native.rb_set.insert_list", "description": "`insert_list s l` inserts each element of `l` into `s`."}, {"name": "name_set.local_list_to_name_set", "description": "`local_list_to_name_set lcs` is the set of unique names of the local\nconstants `lcs`. If any of the `lcs` are not local constants, the returned set\nwill contain bogus names."}, {"name": "name_set.mfilter", "description": " `mfilter P s` returns the subset of elements of `s` satisfying `P`,\nwhere the check `P` is monadic."}, {"name": "name_set.insert_list", "description": "`insert_list s l` inserts every element of `l` into `s`."}, {"name": "native.rb_lmap.values", "description": "Returns the list of values of an `rb_lmap`."}, {"name": "name_set.inhabited", "description": ""}, {"name": "native.rb_map.mfilter", "description": "`mfilter P s` filters `s` by the monadic predicate `P` on keys and values."}, {"name": "native.rb_set.union", "description": "`union s t` returns an rb_set containing every element that appears in either `s` or `t`."}, {"name": "native.rb_map.inhabited", "description": ""}, {"name": "native.rb_map.zfind", "description": " `zfind m key` returns the value corresponding to `key` in `m`, if it exists.\nOtherwise it returns 0."}, {"name": "native.rb_lmap.of_list", "description": "Construct a rb_lmap from a list of key-data pairs"}, {"name": "native.rb_map.mmap", "description": "`mmap f s` maps the monadic function `f` over values in `s`."}, {"name": "name_set.mmap", "description": "`mmap f s` maps the monadic function `f` over values in `s`."}, {"name": "native.rb_set.inhabited", "description": ""}, {"name": "native.rb_set.of_list_core", "description": "`of_list_core empty l` turns a list of keys into an `rb_set`.\nIt takes a user_provided `rb_set` to use for the base case.\nThis can be used to pre-seed the set with additional elements,\nand/or to use a custom comparison operator."}, {"name": "name_set.filter", "description": "`filter P s` returns the subset of elements of `s` satisfying `P`."}, {"name": "native.rb_lmap.inhabited", "description": ""}, {"name": "native.rb_map.find_def", "description": " `find_def default m k` returns the value corresponding to `k` in `m`, if it exists.\nOtherwise it returns `default`."}, {"name": "native.rb_set.filter", "description": "`filter s P` returns the subset of elements of `s` satisfying `P`."}, {"name": "native.rb_map.ifind", "description": " `ifind m key` returns the value corresponding to `key` in `m`, if it exists.\nOtherwise it returns the default value of `value`."}, {"name": "inv_pos_of_pos", "description": "**Alias** of the reverse direction of `inv_pos`."}, {"name": "one_div_le_of_neg", "description": ""}, {"name": "lt_of_one_div_lt_one_div", "description": ""}, {"name": "one_half_lt_one", "description": ""}, {"name": "div_lt_one_iff", "description": ""}, {"name": "mul_sub_mul_div_mul_nonpos", "description": "**Alias** of the reverse direction of `mul_sub_mul_div_mul_nonpos_iff`."}, {"name": "one_div_nonneg", "description": ""}, {"name": "div_lt_iff_of_neg", "description": ""}, {"name": "order_iso.mul_left\u2080", "description": "`equiv.mul_left\u2080` as an order_iso."}, {"name": "half_pos", "description": ""}, {"name": "inv_lt_of_neg", "description": ""}, {"name": "div_pos_of_neg_of_neg", "description": ""}, {"name": "one_div_le", "description": ""}, {"name": "linear_ordered_semifield.to_linear_ordered_semiring", "description": ""}, {"name": "function.injective.linear_ordered_field", "description": "Pullback a `linear_ordered_field` under an injective map."}, {"name": "inv_pow_lt_inv_pow_of_lt", "description": ""}, {"name": "inv_lt_one_iff_of_pos", "description": ""}, {"name": "one_div_le_one_div", "description": "For the single implications with fewer assumptions, see `one_div_le_one_div_of_le` and\n `le_of_one_div_le_one_div`"}, {"name": "one_half_pos", "description": ""}, {"name": "inv_lt_inv", "description": "See `inv_lt_inv_of_lt` for the implication from right-to-left with one fewer assumption."}, {"name": "div_le_one_of_le", "description": ""}, {"name": "inv_mul_le_iff'", "description": ""}, {"name": "abs_one_div", "description": ""}, {"name": "div_le_one_iff", "description": ""}, {"name": "div_le_div_iff", "description": ""}, {"name": "exists_add_lt_and_pos_of_lt", "description": ""}, {"name": "one_le_one_div", "description": ""}, {"name": "inv_nonneg", "description": ""}, {"name": "linear_ordered_field.to_densely_ordered", "description": ""}, {"name": "le_of_neg_of_one_div_le_one_div", "description": ""}, {"name": "linear_ordered_semifield", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.add", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.add_assoc", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.zero", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.zero_add", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.add_zero", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.nsmul", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.nsmul_zero'", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.nsmul_succ'", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.add_comm", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.mul", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.left_distrib", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.right_distrib", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.zero_mul", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.mul_zero", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.mul_assoc", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.one", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.one_mul", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.mul_one", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.nat_cast", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.nat_cast_zero", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.nat_cast_succ", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.npow", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.npow_zero'", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.npow_succ'", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.add_left_cancel", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.le", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.lt", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.le_refl", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.le_trans", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.lt_iff_le_not_le", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.le_antisymm", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.add_le_add_left", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.le_of_add_le_add_left", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.zero_le_one", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.mul_lt_mul_of_pos_left", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.mul_lt_mul_of_pos_right", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.le_total", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.decidable_le", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.decidable_eq", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.decidable_lt", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.max", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.max_def", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.min", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.min_def", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.exists_pair_ne", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.mul_comm", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.inv", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.div", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.div_eq_mul_inv", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.zpow", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.zpow_zero'", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.zpow_succ'", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.zpow_neg'", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.inv_zero", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.mul_inv_cancel", "description": "A linear ordered semifield is a field with a linear order respecting the operations."}, {"name": "one_le_div_of_neg", "description": ""}, {"name": "div_le_one", "description": ""}, {"name": "left_lt_add_div_two", "description": ""}, {"name": "pow_minus_two_nonneg", "description": ""}, {"name": "linear_ordered_field.to_field", "description": ""}, {"name": "div_lt_div_of_lt", "description": ""}, {"name": "order_iso.mul_left\u2080_apply", "description": ""}, {"name": "div_le_div_of_mul_sub_mul_div_nonpos", "description": "**Alias** of the forward direction of `mul_sub_mul_div_mul_nonpos_iff`."}, {"name": "inv_pos_lt_iff_one_lt_mul'", "description": ""}, {"name": "div_nonneg", "description": ""}, {"name": "one_div_lt_neg_one", "description": ""}, {"name": "inv_le_one_iff", "description": ""}, {"name": "div_two_sub_self", "description": ""}, {"name": "lt_one_div_of_neg", "description": ""}, {"name": "div_nonpos_of_nonpos_of_nonneg", "description": ""}, {"name": "inv_pos_le_iff_one_le_mul'", "description": ""}, {"name": "div_neg_of_pos_of_neg", "description": ""}, {"name": "div_le_one_of_neg", "description": ""}, {"name": "inv_lt_of_inv_lt", "description": ""}, {"name": "mul_le_mul_of_mul_div_le", "description": ""}, {"name": "one_lt_inv", "description": ""}, {"name": "order_iso.mul_right\u2080_symm_apply", "description": ""}, {"name": "div_lt_iff'", "description": ""}, {"name": "div_le_iff_of_neg", "description": ""}, {"name": "inv_lt_one_iff", "description": ""}, {"name": "div_nonneg_of_nonpos", "description": ""}, {"name": "max_div_div_right", "description": ""}, {"name": "add_div_two_lt_right", "description": ""}, {"name": "div_nonneg_iff", "description": ""}, {"name": "mul_inv_lt_iff", "description": ""}, {"name": "le_div_iff'", "description": ""}, {"name": "exists_pos_mul_lt", "description": ""}, {"name": "div_le_div_of_le_of_nonneg", "description": ""}, {"name": "le_one_div_of_neg", "description": ""}, {"name": "mul_sub_mul_div_mul_neg", "description": "**Alias** of the reverse direction of `mul_sub_mul_div_mul_neg_iff`."}, {"name": "linear_ordered_field.to_linear_ordered_semifield", "description": ""}, {"name": "inv_le_one", "description": ""}, {"name": "strict_mono.div_const", "description": ""}, {"name": "le_div_iff_of_neg'", "description": ""}, {"name": "order_iso.mul_left\u2080_symm_apply", "description": ""}, {"name": "le_one_div", "description": ""}, {"name": "one_lt_div_of_neg", "description": ""}, {"name": "order_iso.mul_right\u2080", "description": "`equiv.mul_right\u2080` as an order_iso."}, {"name": "div_pos_iff", "description": ""}, {"name": "div_le_iff", "description": ""}, {"name": "inv_pow_le_inv_pow_of_le", "description": ""}, {"name": "mul_sub_mul_div_mul_nonpos_iff", "description": ""}, {"name": "div_nonpos_of_nonneg_of_nonpos", "description": ""}, {"name": "inv_nonpos", "description": ""}, {"name": "is_lub.mul_right", "description": ""}, {"name": "div_lt_iff", "description": ""}, {"name": "mul_inv_lt_iff'", "description": ""}, {"name": "one_lt_inv_iff", "description": ""}, {"name": "lt_div_iff_of_neg", "description": ""}, {"name": "div_le_iff'", "description": ""}, {"name": "div_le_div_of_nonpos_of_le", "description": ""}, {"name": "is_lub.mul_left", "description": ""}, {"name": "inv_nonneg_of_nonneg", "description": "**Alias** of the reverse direction of `inv_nonneg`."}, {"name": "inv_lt_inv_of_neg", "description": ""}, {"name": "one_div_neg", "description": ""}, {"name": "lt_div_iff'", "description": ""}, {"name": "div_lt_div", "description": ""}, {"name": "le_of_one_div_le_one_div", "description": ""}, {"name": "div_le_div_left", "description": ""}, {"name": "div_lt_div_of_lt_left", "description": ""}, {"name": "le_div_self", "description": ""}, {"name": "mul_self_inj_of_nonneg", "description": ""}, {"name": "div_lt_iff_of_neg'", "description": ""}, {"name": "inv_pos_lt_iff_one_lt_mul", "description": ""}, {"name": "inv_le", "description": " In a linear ordered field, for positive `a` and `b` we have `a\u207b\u00b9 \u2264 b \u2194 b\u207b\u00b9 \u2264 a`.\nSee also `inv_le_of_inv_le` for a one-sided implication with one fewer assumption."}, {"name": "inv_pow_strict_anti", "description": ""}, {"name": "le_div_iff", "description": ""}, {"name": "div_lt_div_right_of_neg", "description": ""}, {"name": "monotone.div_const", "description": ""}, {"name": "one_le_inv", "description": ""}, {"name": "one_le_div_iff", "description": ""}, {"name": "add_self_div_two", "description": ""}, {"name": "max_div_div_right_of_nonpos", "description": ""}, {"name": "one_div_pow_strict_anti", "description": ""}, {"name": "div_le_div_of_le", "description": ""}, {"name": "abs_div", "description": ""}, {"name": "inv_pos_le_iff_one_le_mul", "description": ""}, {"name": "one_div_lt", "description": ""}, {"name": "div_lt_self", "description": ""}, {"name": "inv_le_inv", "description": "See `inv_le_inv_of_le` for the implication from right-to-left with one fewer assumption."}, {"name": "abs_inv", "description": ""}, {"name": "one_div_lt_one_div_of_lt", "description": ""}, {"name": "one_div_strict_anti_on", "description": ""}, {"name": "lt_inv", "description": ""}, {"name": "div_lt_div_right", "description": ""}, {"name": "inv_strict_anti_on", "description": ""}, {"name": "inv_lt_one", "description": ""}, {"name": "div_le_div", "description": ""}, {"name": "div_le_div_of_le_left", "description": ""}, {"name": "lt_of_neg_of_one_div_lt_one_div", "description": ""}, {"name": "min_div_div_right_of_nonpos", "description": ""}, {"name": "div_le_div_right", "description": ""}, {"name": "div_lt_div_iff", "description": ""}, {"name": "div_nonpos_iff", "description": ""}, {"name": "inv_mul_lt_iff", "description": ""}, {"name": "one_le_div", "description": ""}, {"name": "one_div_le_one_div_of_neg_of_le", "description": ""}, {"name": "le_inv", "description": ""}, {"name": "one_div_pos", "description": ""}, {"name": "one_lt_div_iff", "description": ""}, {"name": "div_self_le_one", "description": ""}, {"name": "div_lt_div'", "description": ""}, {"name": "div_lt_div_of_neg_of_lt", "description": ""}, {"name": "sub_one_div_inv_le_two", "description": "An inequality involving `2`."}, {"name": "sub_self_div_two", "description": ""}, {"name": "lt_div_iff_of_neg'", "description": ""}, {"name": "inv_lt_zero", "description": ""}, {"name": "lt_div_iff", "description": ""}, {"name": "one_div_le_one_div_of_le", "description": ""}, {"name": "lt_one_div", "description": ""}, {"name": "one_div_nonpos", "description": ""}, {"name": "min_div_div_right", "description": ""}, {"name": "add_halves", "description": ""}, {"name": "div_le_self", "description": ""}, {"name": "nat.cast_le_pow_sub_div_sub", "description": "Bernoulli's inequality reformulated to estimate `(n : \u03b1)`."}, {"name": "div_le_div_right_of_neg", "description": ""}, {"name": "inv_le_of_inv_le", "description": ""}, {"name": "div_pos", "description": ""}, {"name": "mul_inv_le_iff'", "description": ""}, {"name": "div_mul_le_div_mul_of_div_le_div", "description": ""}, {"name": "one_div_pow_lt_one_div_pow_of_lt", "description": ""}, {"name": "le_div_iff_of_neg", "description": ""}, {"name": "div_lt_one", "description": ""}, {"name": "one_lt_div", "description": ""}, {"name": "inv_le_inv_of_neg", "description": ""}, {"name": "one_div_lt_one_div", "description": "For the single implications with fewer assumptions, see `one_div_lt_one_div_of_lt` and\n `lt_of_one_div_lt_one_div`"}, {"name": "mul_inv_le_iff", "description": ""}, {"name": "function.injective.linear_ordered_semifield", "description": "Pullback a `linear_ordered_semifield` under an injective map."}, {"name": "order_iso.mul_right\u2080_apply", "description": ""}, {"name": "inv_le_inv_of_le", "description": ""}, {"name": "inv_le_of_neg", "description": ""}, {"name": "one_div_lt_one_div_of_neg_of_lt", "description": ""}, {"name": "linear_ordered_field", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.add", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.add_assoc", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.zero", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.zero_add", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.add_zero", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.nsmul", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.nsmul_zero'", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.nsmul_succ'", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.neg", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.sub", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.sub_eq_add_neg", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.zsmul", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.zsmul_zero'", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.zsmul_succ'", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.zsmul_neg'", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.add_left_neg", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.add_comm", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.int_cast", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.nat_cast", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.one", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.nat_cast_zero", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.nat_cast_succ", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.int_cast_of_nat", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.int_cast_neg_succ_of_nat", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.mul", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.mul_assoc", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.one_mul", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.mul_one", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.npow", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.npow_zero'", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.npow_succ'", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.left_distrib", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.right_distrib", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.le", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.lt", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.le_refl", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.le_trans", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.lt_iff_le_not_le", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.le_antisymm", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.add_le_add_left", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.zero_le_one", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.mul_pos", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.le_total", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.decidable_le", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.decidable_eq", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.decidable_lt", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.max", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.max_def", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.min", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.min_def", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.exists_pair_ne", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.mul_comm", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.inv", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.div", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.div_eq_mul_inv", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.zpow", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.zpow_zero'", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.zpow_succ'", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.zpow_neg'", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.rat_cast", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.mul_inv_cancel", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.inv_zero", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.rat_cast_mk", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.qsmul", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_field.qsmul_eq_mul'", "description": "A linear ordered field is a field with a linear order respecting the operations."}, {"name": "linear_ordered_semifield.to_semifield", "description": ""}, {"name": "div_lt_one_of_neg", "description": ""}, {"name": "one_div_pow_le_one_div_pow_of_le", "description": ""}, {"name": "div_le_iff_of_neg'", "description": ""}, {"name": "inv_lt_inv_of_lt", "description": ""}, {"name": "half_lt_self", "description": ""}, {"name": "le_inv_of_neg", "description": ""}, {"name": "nat.cast_le_pow_div_sub", "description": " For any `a > 1` and a natural `n` we have `n \u2264 a ^ n / (a - 1)`. See also\n`nat.cast_le_pow_sub_div_sub` for a stronger inequality with `a ^ n - 1` in the numerator."}, {"name": "one_le_inv_iff", "description": ""}, {"name": "one_div_pow_anti", "description": ""}, {"name": "one_div_lt_one_div_of_neg", "description": "For the single implications with fewer assumptions, see `one_div_lt_one_div_of_lt` and\n `lt_of_one_div_lt_one_div`"}, {"name": "inv_mul_lt_iff'", "description": ""}, {"name": "inv_pos", "description": ""}, {"name": "div_neg_of_neg_of_pos", "description": ""}, {"name": "is_glb.mul_left", "description": ""}, {"name": "div_neg_iff", "description": ""}, {"name": "le_of_forall_sub_le", "description": ""}, {"name": "one_div_lt_of_neg", "description": ""}, {"name": "half_le_self", "description": ""}, {"name": "inv_mul_le_iff", "description": ""}, {"name": "div_two_lt_of_pos", "description": ""}, {"name": "is_glb.mul_right", "description": ""}, {"name": "div_lt_div_left", "description": ""}, {"name": "one_lt_one_div", "description": ""}, {"name": "one_div_le_one_div_of_neg", "description": "For the single implications with fewer assumptions, see `one_div_lt_one_div_of_neg_of_lt` and\n `lt_of_one_div_lt_one_div`"}, {"name": "linear_ordered_field.to_linear_ordered_comm_ring", "description": ""}, {"name": "add_sub_div_two_lt", "description": ""}, {"name": "inv_lt", "description": " In a linear ordered field, for positive `a` and `b` we have `a\u207b\u00b9 < b \u2194 b\u207b\u00b9 < a`.\nSee also `inv_lt_of_inv_lt` for a one-sided implication with one fewer assumption."}, {"name": "mul_sub_mul_div_mul_neg_iff", "description": ""}, {"name": "one_div_le_neg_one", "description": ""}, {"name": "div_lt_div_of_mul_sub_mul_div_neg", "description": "**Alias** of the forward direction of `mul_sub_mul_div_mul_neg_iff`."}, {"name": "lt_inv_of_neg", "description": ""}, {"name": "inv_pow_anti", "description": ""}, {"name": "div_le_of_nonneg_of_le_mul", "description": "One direction of `div_le_iff` where `b` is allowed to be `0` (but `c` must be nonnegative)"}, {"name": "pnat.mk_coe", "description": ""}, {"name": "pnat.mod_div_aux", "description": "We define `m % k` and `m / k` in the same way as for `\u2115`\n except that when `m = n * k` we take `m % k = k` and\n `m / k = n - 1`.  This ensures that `m % k` is always positive\n and `m = (m % k) + k * (m / k)` in all cases.  Later we\n define a function `div_exact` which gives the usual `m / k`\n in the case where `k` divides `m`."}, {"name": "pnat.to_pnat'_coe", "description": ""}, {"name": "pnat.sub_coe", "description": ""}, {"name": "pnat.nat_pred_monotone", "description": ""}, {"name": "pnat.bit0_le_bit0", "description": ""}, {"name": "pnat.nat_pred_inj", "description": ""}, {"name": "pnat.has_well_founded", "description": ""}, {"name": "pnat.comm_monoid", "description": ""}, {"name": "pnat.fact_pos", "description": ""}, {"name": "pnat.one_le", "description": ""}, {"name": "pnat.nat_pred_le_nat_pred", "description": ""}, {"name": "pnat", "description": "`\u2115+` is the type of positive natural numbers. It is defined as a subtype,\n and the VM representation of `\u2115+` is the same as `\u2115` because the proof\n is not stored."}, {"name": "nat.can_lift_pnat", "description": ""}, {"name": "pnat.nat_pred_add_one", "description": ""}, {"name": "pnat.mod_coe", "description": ""}, {"name": "pnat.mod_add_div'", "description": ""}, {"name": "pnat.inhabited", "description": ""}, {"name": "pnat.order_bot", "description": ""}, {"name": "pnat.coe_add_hom", "description": "`pnat.coe` promoted to an `add_hom`, that is, a morphism which preserves addition."}, {"name": "pnat.coe_bit0", "description": ""}, {"name": "pnat.mk_le_mk", "description": ""}, {"name": "pnat.nat_pred_eq_pred", "description": ""}, {"name": "pnat.mk_one", "description": ""}, {"name": "nat.succ_pnat_inj", "description": ""}, {"name": "pnat.coe_eq_one_iff", "description": ""}, {"name": "pnat.rec_on_succ", "description": ""}, {"name": "pnat.mul_coe", "description": ""}, {"name": "pnat.eq", "description": ""}, {"name": "coe_pnat_nat", "description": ""}, {"name": "pnat.add_comm_semigroup", "description": ""}, {"name": "pnat.coe_le_coe", "description": ""}, {"name": "pnat.add_one_le_iff", "description": ""}, {"name": "pnat.add_sub_of_lt", "description": ""}, {"name": "equiv.pnat_equiv_nat_symm_apply", "description": ""}, {"name": "pnat.nat_pred_injective", "description": ""}, {"name": "pnat.has_mul", "description": ""}, {"name": "pnat.pos_of_div_pos", "description": ""}, {"name": "pnat.distrib", "description": ""}, {"name": "pnat.lt_add_left", "description": ""}, {"name": "pnat.nat_pred", "description": "Predecessor of a `\u2115+`, as a `\u2115`."}, {"name": "pnat.one_coe", "description": ""}, {"name": "order_iso.pnat_iso_nat", "description": "The order isomorphism between \u2115 and \u2115+ given by `succ`."}, {"name": "equiv.pnat_equiv_nat", "description": "An equivalence between `\u2115+` and `\u2115` given by `pnat.nat_pred` and `nat.succ_pnat`."}, {"name": "pnat.pow_coe", "description": ""}, {"name": "nat.to_pnat", "description": "Convert a natural number to a positive natural number. The\n positivity assumption is inferred by `dec_trivial`."}, {"name": "pnat.one_add_nat_pred", "description": ""}, {"name": "nat.to_pnat'", "description": "Convert a natural number to a pnat. `n+1` is mapped to itself,\n and `0` becomes `1`."}, {"name": "pnat.has_le.le.covariant_class", "description": ""}, {"name": "pnat.succ_pnat_nat_pred", "description": ""}, {"name": "pnat.bit1_le_bit1", "description": ""}, {"name": "pnat.not_lt_one", "description": ""}, {"name": "pnat.rec_on", "description": " An induction principle for `\u2115+`: it takes values in `Sort*`, so it applies also to Types,\nnot only to `Prop`."}, {"name": "pnat.case_strong_induction_on", "description": "Strong induction on `\u2115+`, with `n = 1` treated separately."}, {"name": "pnat.div_exact", "description": "If `h : k | m`, then `k * (div_exact m k) = m`. Note that this is not equal to `m / k`."}, {"name": "pnat.decidable_eq", "description": "We now define a long list of structures on \u2115+ induced by\nsimilar structures on \u2115. Most of these behave in a completely\nobvious way, but there are a few things to be said about\nsubtraction, division and powers."}, {"name": "pnat.nat_pred_strict_mono", "description": ""}, {"name": "pnat.div_add_mod'", "description": ""}, {"name": "pnat.has_add", "description": ""}, {"name": "pnat.coe_injective", "description": ""}, {"name": "pnat.le_one_iff", "description": ""}, {"name": "nat.succ_pnat_strict_mono", "description": ""}, {"name": "pnat.has_one", "description": ""}, {"name": "order_iso.pnat_iso_nat_apply", "description": ""}, {"name": "pnat.coe_monoid_hom", "description": "`pnat.coe` promoted to a `monoid_hom`."}, {"name": "pnat.mod_le", "description": ""}, {"name": "pnat.add_right_cancel_semigroup", "description": ""}, {"name": "pnat.mod_div_aux_spec", "description": ""}, {"name": "pnat.bot_eq_one", "description": ""}, {"name": "pnat.mod", "description": "We define `m % k` in the same way as for `\u2115`\n except that when `m = n * k` we take `m % k = k` This ensures that `m % k` is always positive."}, {"name": "pnat.lt_add_one_iff", "description": ""}, {"name": "pnat.mod_add_div", "description": ""}, {"name": "pnat.coe_lt_coe", "description": ""}, {"name": "pnat.nat_pred_lt_nat_pred", "description": ""}, {"name": "pnat.mk_lt_mk", "description": ""}, {"name": "nat.succ_pnat_le_succ_pnat", "description": ""}, {"name": "nat.succ_pnat_mono", "description": ""}, {"name": "pnat.mod_div", "description": "`mod_div m k = (m % k, m / k)`.\n We define `m % k` and `m / k` in the same way as for `\u2115`\n except that when `m = n * k` we take `m % k = k` and\n `m / k = n - 1`.  This ensures that `m % k` is always positive\n and `m = (m % k) + k * (m / k)` in all cases.  Later we\n define a function `div_exact` which gives the usual `m / k`\n in the case where `k` divides `m`."}, {"name": "equiv.pnat_equiv_nat_apply", "description": ""}, {"name": "pnat.exists_eq_succ_of_ne_one", "description": "If `n : \u2115+` is different from `1`, then it is the successor of some `k : \u2115+`."}, {"name": "pnat.le_of_dvd", "description": ""}, {"name": "pnat.mul_div_exact", "description": ""}, {"name": "pnat.add_left_cancel_semigroup", "description": ""}, {"name": "pnat.ne_zero", "description": ""}, {"name": "pnat.coe_to_pnat'", "description": ""}, {"name": "pnat.mk_bit0", "description": ""}, {"name": "pnat.div_coe", "description": ""}, {"name": "pnat.add_coe", "description": ""}, {"name": "pnat.pos", "description": ""}, {"name": "nat.nat_pred_succ_pnat", "description": ""}, {"name": "pnat.div_add_mod", "description": ""}, {"name": "pnat.linear_order", "description": ""}, {"name": "order_iso.pnat_iso_nat_symm_apply", "description": ""}, {"name": "pnat.has_repr", "description": ""}, {"name": "pnat.bit1_le_bit0", "description": ""}, {"name": "pnat.nat.has_pow", "description": ""}, {"name": "pnat.dvd_iff'", "description": ""}, {"name": "nat.succ_pnat", "description": "Write a successor as an element of `\u2115+`."}, {"name": "pnat.dvd_iff", "description": ""}, {"name": "pnat.has_sub", "description": "Subtraction a - b is defined in the obvious way when\n a > b, and by a - b = 1 if a \u2264 b."}, {"name": "nat.succ_pnat_lt_succ_pnat", "description": ""}, {"name": "pnat.ordered_cancel_comm_monoid", "description": ""}, {"name": "pnat.div", "description": "We define `m / k` in the same way as for `\u2115` except that when `m = n * k` we take\n `m / k = n - 1`. This ensures that `m = (m % k) + k * (m / k)` in all cases. Later we\n define a function `div_exact` which gives the usual `m / k` in the case where `k` divides `m`."}, {"name": "int.can_lift_pnat", "description": ""}, {"name": "nat.succ_pnat_coe", "description": ""}, {"name": "nat.to_pnat'_coe", "description": ""}, {"name": "pnat.coe_bit1", "description": ""}, {"name": "pnat.strong_induction_on", "description": "Strong induction on `\u2115+`."}, {"name": "pnat.lt_add_right", "description": ""}, {"name": "pnat.rec_on_one", "description": ""}, {"name": "pnat.coe_coe_monoid_hom", "description": ""}, {"name": "pnat.dvd_one_iff", "description": ""}, {"name": "pnat.bit0_le_bit1", "description": ""}, {"name": "nat.succ_pnat_injective", "description": ""}, {"name": "pnat.dvd_antisymm", "description": ""}, {"name": "pnat.coe_inj", "description": ""}, {"name": "pnat.mk_bit1", "description": ""}, {"name": "option.guard", "description": "`guard p a` returns `some a` if `p a` holds, otherwise `none`."}, {"name": "option.decidable_eq_none", "description": "`o = none` is decidable even if the wrapped type does not have decidable equality.\n\nThis is not an instance because it is not definitionally equal to `option.decidable_eq`.\nTry to use `o.is_none` or `o.is_some` instead."}, {"name": "option.lift_or_get_comm", "description": ""}, {"name": "option.lift_or_get_idem", "description": ""}, {"name": "option.melim", "description": "A monadic analogue of `option.elim`."}, {"name": "option.maybe", "description": " If you maybe have a monadic computation in a `[monad m]` which produces a term of type `\u03b1`, then\nthere is a naturally associated way to always perform a computation in `m` which maybe produces a\nresult."}, {"name": "option.some_inj", "description": ""}, {"name": "option.elim", "description": "An elimination principle for `option`. It is a nondependent version of `option.rec`."}, {"name": "option.filter", "description": "`filter p o` returns `some a` if `o` is `some a` and `p a` holds, otherwise `none`."}, {"name": "option.lift_or_get_is_left_id", "description": ""}, {"name": "option.pbind", "description": "Partial bind. If for some `x : option \u03b1`, `f : \u03a0 (a : \u03b1), a \u2208 x \u2192 option \u03b2` is a\n partial function defined on `a : \u03b1` giving an `option \u03b2`, where `some a = x`,\n then `pbind x f h` is essentially the same as `bind x f`\n but is defined only when all `x = some a`, using the proof to apply `f`."}, {"name": "option.has_mem", "description": ""}, {"name": "option.decidable_exists_mem", "description": ""}, {"name": "option.is_none_iff_eq_none", "description": ""}, {"name": "option.mget_or_else", "description": "A monadic analogue of `option.get_or_else`."}, {"name": "option.lift_or_get", "description": " Two arguments failsafe function. Returns `f a b` if the inputs are `some a` and `some b`, and\n\"does nothing\" otherwise."}, {"name": "option.iget", "description": "Inhabited `get` function. Returns `a` if the input is `some a`, otherwise returns `default`."}, {"name": "option.mem_iff", "description": ""}, {"name": "option.join", "description": "Flatten an `option` of `option`, a specialization of `mjoin`."}, {"name": "option.mem_some_iff", "description": ""}, {"name": "option.mem_to_list", "description": ""}, {"name": "option.rel", "description": " Lifts a relation `\u03b1 \u2192 \u03b2 \u2192 Prop` to a relation `option \u03b1 \u2192 option \u03b2 \u2192 Prop` by just adding\n`none ~ none`."}, {"name": "option.rel.some", "description": " Lifts a relation `\u03b1 \u2192 \u03b2 \u2192 Prop` to a relation `option \u03b1 \u2192 option \u03b2 \u2192 Prop` by just adding\n`none ~ none`."}, {"name": "option.rel.none", "description": " Lifts a relation `\u03b1 \u2192 \u03b2 \u2192 Prop` to a relation `option \u03b1 \u2192 option \u03b2 \u2192 Prop` by just adding\n`none ~ none`."}, {"name": "option.pmap", "description": " Partial map. If `f : \u03a0 a, p a \u2192 \u03b2` is a partial function defined on `a : \u03b1` satisfying `p`,\nthen `pmap f x h` is essentially the same as `map f x` but is defined only when all members of `x`\nsatisfy `p`, using the proof to apply `f`."}, {"name": "option.lift_or_get_is_right_id", "description": ""}, {"name": "option.traverse", "description": ""}, {"name": "option.mem_def", "description": ""}, {"name": "option.mmap", "description": "Map a monadic function `f : \u03b1 \u2192 m \u03b2` over an `o : option \u03b1`, maybe producing a result."}, {"name": "option.to_list", "description": " Cast of `option` to `list `. Returns `[a]` if the input is `some a`, and `[]` if it is\n`none`."}, {"name": "option.lift_or_get_assoc", "description": ""}, {"name": "option.iget_some", "description": ""}, {"name": "option.decidable_forall_mem", "description": ""}, {"name": "category_theory.functor.to_ess_image_comp_essential_image_inclusion_hom_app", "description": ""}, {"name": "category_theory.functor.to_ess_image_map", "description": ""}, {"name": "category_theory.functor.to_ess_image", "description": "Given a functor `F : C \u2964 D`, we have an (essentially surjective) functor from `C` to the essential\nimage of `F`."}, {"name": "category_theory.functor.ess_image.get_iso", "description": "Extract the isomorphism between `F.obj h.witness` and `Y` itself."}, {"name": "category_theory.faithful.to_ess_image", "description": "The induced functor of a faithful functor is faithful"}, {"name": "category_theory.functor.ess_image_eq_of_nat_iso", "description": "Isomorphic functors have equal essential images."}, {"name": "category_theory.functor.obj_mem_ess_image", "description": "An object in the image is in the essential image."}, {"name": "category_theory.functor.ess_image_inclusion.full", "description": ""}, {"name": "category_theory.functor.ess_image_inclusion", "description": "The essential image as a subcategory has a fully faithful inclusion into the target category."}, {"name": "category_theory.functor.ess_image.of_nat_iso", "description": "If `Y` is in the essential image of `F` then it is in the essential image of `F'` as long as\n`F \u2245 F'`."}, {"name": "category_theory.functor.to_ess_image_obj_obj", "description": ""}, {"name": "category_theory.functor.obj_preimage", "description": "Given an essentially surjective functor, we can find a preimage for every object `Y` in the\n   codomain. Applying the functor to this preimage will yield an object isomorphic to `Y`, see\n   `obj_obj_preimage_iso`."}, {"name": "category_theory.functor.ess_image_inclusion.faithful", "description": ""}, {"name": "category_theory.functor.to_ess_image_comp_essential_image_inclusion_inv_app", "description": ""}, {"name": "category_theory.functor.ess_image_inclusion_obj", "description": ""}, {"name": "category_theory.functor.to_ess_image.ess_surj", "description": ""}, {"name": "category_theory.functor.ess_image_subcategory.category", "description": ""}, {"name": "category_theory.functor.ess_image.of_iso", "description": "Being in the essential image is a \"hygenic\" property: it is preserved under isomorphism."}, {"name": "category_theory.functor.obj_obj_preimage_iso", "description": "Applying an essentially surjective functor to a preimage of `Y` yields an object that is\n   isomorphic to `Y`."}, {"name": "category_theory.functor.ess_image", "description": "The essential image of a functor `F` consists of those objects in the target category which are\nisomorphic to an object in the image of the function `F.obj`. In other words, this is the closure\nunder isomorphism of the function `F.obj`.\nThis is the \"non-evil\" way of describing the image of a functor."}, {"name": "category_theory.functor.ess_image_inclusion_map", "description": ""}, {"name": "category_theory.functor.to_ess_image_comp_essential_image_inclusion", "description": "The functor `F` factorises through its essential image, where the first functor is essentially\nsurjective and the second is fully faithful."}, {"name": "category_theory.ess_surj", "description": "A functor `F : C \u2964 D` is essentially surjective if every object of `D` is in the essential image\nof `F`. In other words, for every `Y : D`, there is some `X : C` with `F.obj X \u2245 Y`.\n\nSee <https://stacks.math.columbia.edu/tag/001C>."}, {"name": "category_theory.ess_surj.mem_ess_image", "description": "A functor `F : C \u2964 D` is essentially surjective if every object of `D` is in the essential image\nof `F`. In other words, for every `Y : D`, there is some `X : C` with `F.obj X \u2245 Y`.\n\nSee <https://stacks.math.columbia.edu/tag/001C>."}, {"name": "category_theory.functor.ess_image.witness", "description": "Get the witnessing object that `Y` is in the subcategory given by `F`."}, {"name": "category_theory.full.to_ess_image", "description": "The induced functor of a full functor is full"}, {"name": "category_theory.functor.ess_image_subcategory", "description": "The essential image of a functor, interpreted of a full subcategory of the target category."}, {"name": "equiv.perm.of_subtype_apply_of_not_mem", "description": ""}, {"name": "equiv.perm.via_embedding_apply_of_not_mem", "description": ""}, {"name": "equiv.perm.subtype_congr_hom_apply", "description": ""}, {"name": "equiv.perm.subtype_perm_apply", "description": ""}, {"name": "equiv.perm.via_embedding_apply", "description": ""}, {"name": "equiv.perm.sum_congr_inv", "description": ""}, {"name": "equiv.perm.via_embedding_hom", "description": "`via_embedding` as a group homomorphism"}, {"name": "equiv.perm.extend_domain_eq_one_iff", "description": ""}, {"name": "equiv.perm.of_subtype_apply_of_mem", "description": ""}, {"name": "equiv.perm.of_subtype", "description": "The inclusion map of permutations on a subtype of `\u03b1` into permutations of `\u03b1`,\n fixing the other points."}, {"name": "equiv.perm.self_trans_inv", "description": ""}, {"name": "equiv.perm.subtype_congr_hom_injective", "description": ""}, {"name": "equiv.perm.mul_def", "description": ""}, {"name": "equiv.perm.via_embedding_hom_apply", "description": ""}, {"name": "equiv.perm.subtype_perm", "description": "If the permutation `f` fixes the subtype `{x // p x}`, then this returns the permutation\n on `{x // p x}` induced by `f`."}, {"name": "equiv.perm.extend_domain_hom_apply", "description": ""}, {"name": "equiv.perm.sum_congr_hom_apply", "description": ""}, {"name": "equiv.perm.zpow_apply_comm", "description": ""}, {"name": "equiv.perm.extend_domain_inv", "description": ""}, {"name": "equiv.perm.sigma_congr_right_one", "description": ""}, {"name": "equiv.swap_eq_one_iff", "description": ""}, {"name": "equiv.mul_swap_eq_swap_mul", "description": ""}, {"name": "equiv.swap_mul_self", "description": ""}, {"name": "equiv.perm.extend_domain_one", "description": ""}, {"name": "equiv.perm.sigma_congr_right_hom_injective", "description": ""}, {"name": "equiv.perm.perm_congr_eq_mul", "description": " If `e` is also a permutation, we can write `perm_congr`\ncompletely in terms of the group structure."}, {"name": "equiv.perm.sum_congr_hom", "description": " `equiv.perm.sum_congr` as a `monoid_hom`, with its two arguments bundled into a single `prod`.\n\nThis is particularly useful for its `monoid_hom.range` projection, which is the subgroup of\npermutations which do not exchange elements between `\u03b1` and `\u03b2`."}, {"name": "equiv.swap_mul_involutive", "description": "A stronger version of `mul_right_injective`"}, {"name": "equiv.perm.subtype_perm_one", "description": ""}, {"name": "equiv.perm.sum_congr_mul", "description": ""}, {"name": "equiv.perm.sum_congr_hom_injective", "description": ""}, {"name": "equiv.perm.via_embedding_hom_injective", "description": ""}, {"name": "equiv.perm.of_subtype_apply_coe", "description": ""}, {"name": "equiv.perm.mul_refl", "description": ""}, {"name": "equiv.swap_mul_self_mul", "description": "Left-multiplying a permutation with `swap i j` twice gives the original permutation.\n\n This specialization of `swap_mul_self` is useful when using cosets of permutations."}, {"name": "equiv.mul_swap_involutive", "description": "A stronger version of `mul_left_injective`"}, {"name": "equiv.perm.inv_apply_self", "description": ""}, {"name": "equiv.perm.subtype_equiv_subtype_perm_apply_coe", "description": ""}, {"name": "equiv.perm.coe_one", "description": ""}, {"name": "equiv.perm.sigma_congr_right_inv", "description": ""}, {"name": "equiv.perm.sigma_congr_right_mul", "description": ""}, {"name": "equiv.perm.apply_inv_self", "description": ""}, {"name": "equiv.perm.one_apply", "description": ""}, {"name": "equiv.perm.trans_one", "description": ""}, {"name": "equiv.perm.extend_domain_hom", "description": "`extend_domain` as a group homomorphism"}, {"name": "equiv.perm.subtype_perm_of_subtype", "description": ""}, {"name": "equiv.perm.one_trans", "description": ""}, {"name": "equiv.perm.subtype_equiv_subtype_perm_apply_of_not_mem", "description": ""}, {"name": "equiv.perm.subtype_congr_hom", "description": "`equiv.perm.subtype_congr` as a `monoid_hom`."}, {"name": "equiv.perm.sum_congr_one_swap", "description": ""}, {"name": "equiv.perm.inv_eq_iff_eq", "description": ""}, {"name": "equiv.perm.symm_mul", "description": ""}, {"name": "equiv.swap_mul_swap_mul_swap", "description": ""}, {"name": "equiv.mul_swap_eq_iff", "description": ""}, {"name": "equiv.swap_mul_eq_iff", "description": ""}, {"name": "equiv.perm.refl_inv", "description": ""}, {"name": "equiv.perm.of_subtype_subtype_perm", "description": ""}, {"name": "equiv.perm.mul_symm", "description": ""}, {"name": "equiv.swap_inv", "description": ""}, {"name": "equiv.perm.extend_domain_hom_injective", "description": ""}, {"name": "equiv.perm.sigma_congr_right_hom_apply", "description": ""}, {"name": "equiv.perm.subtype_equiv_subtype_perm_symm_apply", "description": ""}, {"name": "equiv.perm.iterate_eq_pow", "description": ""}, {"name": "equiv.perm.inv_def", "description": ""}, {"name": "equiv.perm.perm_group", "description": ""}, {"name": "equiv.perm.eq_inv_iff_eq", "description": ""}, {"name": "equiv.perm.refl_mul", "description": ""}, {"name": "equiv.mul_swap_mul_self", "description": "Right-multiplying a permutation with `swap i j` twice gives the original permutation.\n\n This specialization of `swap_mul_self` is useful when using cosets of permutations."}, {"name": "equiv.perm.sum_congr_one", "description": ""}, {"name": "equiv.perm.extend_domain_mul", "description": ""}, {"name": "equiv.perm.sum_congr_swap_one", "description": ""}, {"name": "equiv.perm.sigma_congr_right_hom", "description": " `equiv.perm.sigma_congr_right` as a `monoid_hom`.\n\nThis is particularly useful for its `monoid_hom.range` projection, which is the subgroup of\npermutations which do not exchange elements between fibers."}, {"name": "equiv.perm.via_embedding", "description": "Noncomputable version of `equiv.perm.via_fintype_embedding` that does not assume `fintype`"}, {"name": "equiv.perm.mem_iff_of_subtype_apply_mem", "description": ""}, {"name": "equiv.perm.inv_trans_self", "description": ""}, {"name": "equiv.perm.one_def", "description": ""}, {"name": "equiv.perm.subtype_equiv_subtype_perm_apply_of_mem", "description": ""}, {"name": "equiv.perm.one_symm", "description": ""}, {"name": "equiv.perm.coe_mul", "description": ""}, {"name": "equiv.perm.subtype_equiv_subtype_perm", "description": " Permutations on a subtype are equivalent to permutations on the original type that fix pointwise\nthe rest."}, {"name": "equiv.swap_apply_apply", "description": ""}, {"name": "equiv.perm.mul_apply", "description": ""}, {"name": "equiv.perm.default_perm", "description": ""}, {"name": "equiv.swap_mul_eq_mul_swap", "description": ""}, {"name": "pi.eval_add_monoid_hom_apply", "description": ""}, {"name": "pi.mul_one_class", "description": ""}, {"name": "set.piecewise_add", "description": ""}, {"name": "pi.mul_single_mul", "description": ""}, {"name": "pi.mul_zero_class", "description": ""}, {"name": "pi.eval_mul_hom_apply", "description": ""}, {"name": "zero_hom.single_apply", "description": ""}, {"name": "add_hom.coe_fn_apply", "description": ""}, {"name": "pi.add_left_cancel_monoid", "description": ""}, {"name": "pi.comm_monoid_with_zero", "description": ""}, {"name": "function.update_add", "description": ""}, {"name": "add_hom.coe_add", "description": ""}, {"name": "mul_hom.single_apply", "description": ""}, {"name": "add_monoid_hom.comp_left", "description": "Additive monoid homomorphism between the function spaces `I \u2192 \u03b1` and `I \u2192 \u03b2`,\ninduced by an additive monoid homomorphism `f` between `\u03b1` and `\u03b2`"}, {"name": "function.extend_by_one.hom_apply", "description": ""}, {"name": "set.piecewise_inv", "description": ""}, {"name": "pi.update_eq_sub_add_single", "description": ""}, {"name": "pi.right_cancel_semigroup", "description": ""}, {"name": "pi.single_div", "description": ""}, {"name": "function.extend_by_zero.hom", "description": "`function.extend s f 0` as a bundled hom."}, {"name": "mul_hom.coe_mul", "description": ""}, {"name": "pi.mul_single_apply_commute", "description": "The injection into a pi group with the same values commutes."}, {"name": "monoid_hom.single", "description": " The monoid homomorphism including a single monoid into a dependent family of additive monoids,\nas functions supported at a point.\n\nThis is the `monoid_hom` version of `pi.mul_single`."}, {"name": "pi.semigroup_with_zero", "description": ""}, {"name": "mul_hom.coe_fn", "description": " Coercion of a `mul_hom` into a function is itself a `mul_hom`.\nSee also `mul_hom.eval`."}, {"name": "pi.const_add_monoid_hom", "description": "`function.const` as an `add_monoid_hom`."}, {"name": "pi.single_mul", "description": ""}, {"name": "pi.add_left_cancel_semigroup", "description": ""}, {"name": "one_hom.single", "description": " The one-preserving homomorphism including a single value\ninto a dependent family of values, as functions supported at a point.\n\nThis is the `one_hom` version of `pi.mul_single`."}, {"name": "pi.const_mul_hom", "description": "`function.const` as a `mul_hom`."}, {"name": "pi.monoid_with_zero", "description": ""}, {"name": "function.update_mul", "description": ""}, {"name": "monoid_hom.comp_left_apply", "description": ""}, {"name": "mul_hom.single", "description": " The multiplicative homomorphism including a single `mul_zero_class`\ninto a dependent family of `mul_zero_class`es, as functions supported at a point.\n\nThis is the `mul_hom` version of `pi.single`."}, {"name": "pi.comm_monoid", "description": ""}, {"name": "pi.comm_semigroup", "description": ""}, {"name": "pi.cancel_comm_monoid", "description": ""}, {"name": "pi.add_cancel_monoid", "description": ""}, {"name": "pi.left_cancel_monoid", "description": ""}, {"name": "set.piecewise_div", "description": ""}, {"name": "pi.add_group", "description": ""}, {"name": "pi.const_mul_hom_apply", "description": ""}, {"name": "pi.add_cancel_comm_monoid", "description": ""}, {"name": "pi.update_eq_div_mul_single", "description": ""}, {"name": "add_monoid_hom.single", "description": "The additive monoid homomorphism including a single additive\nmonoid into a dependent family of additive monoids, as functions supported at a point.\n\nThis is the `add_monoid_hom` version of `pi.single`."}, {"name": "pi.add_semigroup", "description": ""}, {"name": "pi.division_monoid", "description": ""}, {"name": "function.update_zero", "description": ""}, {"name": "pi.eval_add_hom_apply", "description": ""}, {"name": "add_hom.comp_left_apply", "description": ""}, {"name": "function.update_sub", "description": ""}, {"name": "monoid_hom.coe_fn", "description": " Coercion of a `monoid_hom` into a function is itself a `monoid_hom`.\n\nSee also `monoid_hom.eval`."}, {"name": "pi.const_monoid_hom", "description": "`function.const` as a `monoid_hom`."}, {"name": "pi.add_monoid", "description": ""}, {"name": "pi.add_comm_monoid", "description": ""}, {"name": "pi.has_involutive_neg", "description": ""}, {"name": "pi.division_comm_monoid", "description": ""}, {"name": "add_hom.comp_left", "description": "Additive semigroup homomorphism between the function spaces `I \u2192 \u03b1` and `I \u2192 \u03b2`,\ninduced by an additive semigroup homomorphism `f` between `\u03b1` and `\u03b2`"}, {"name": "set.piecewise_neg", "description": ""}, {"name": "zero_hom.single", "description": "The zero-preserving homomorphism including a single value\ninto a dependent family of values, as functions supported at a point.\n\nThis is the `zero_hom` version of `pi.single`."}, {"name": "one_hom.single_apply", "description": ""}, {"name": "pi.add_comm_group", "description": ""}, {"name": "add_hom.coe_fn", "description": "Coercion of an `add_hom` into a function is itself a `add_hom`.\nSee also `add_hom.eval`."}, {"name": "pi.add_right_cancel_semigroup", "description": ""}, {"name": "pi.eval_mul_hom", "description": " Evaluation of functions into an indexed collection of semigroups at a point is a semigroup\nhomomorphism.\nThis is `function.eval i` as a `mul_hom`."}, {"name": "pi.div_inv_monoid", "description": ""}, {"name": "pi.const_add_hom", "description": "`function.const` as an `add_hom`."}, {"name": "pi.const_monoid_hom_apply", "description": ""}, {"name": "add_monoid_hom.comp_left_apply", "description": ""}, {"name": "mul_hom.comp_left", "description": " Semigroup homomorphism between the function spaces `I \u2192 \u03b1` and `I \u2192 \u03b2`, induced by a semigroup\nhomomorphism `f` between `\u03b1` and `\u03b2`."}, {"name": "pi.comm_group", "description": ""}, {"name": "function.update_inv", "description": ""}, {"name": "pi.sub_neg_monoid", "description": ""}, {"name": "pi.const_add_monoid_hom_apply", "description": ""}, {"name": "pi.single_neg", "description": ""}, {"name": "pi.subtraction_comm_monoid", "description": ""}, {"name": "pi.single_sub", "description": ""}, {"name": "pi.eval_add_monoid_hom", "description": "Evaluation of functions into an indexed collection of additive monoids at a\npoint is an additive monoid homomorphism.\nThis is `function.eval i` as an `add_monoid_hom`."}, {"name": "pi.mul_single_commute", "description": " The injection into a pi group at different indices commutes.\n\nFor injections of commuting elements at the same index, see `commute.map`"}, {"name": "mul_hom.comp_left_apply", "description": ""}, {"name": "set.piecewise_mul", "description": ""}, {"name": "function.extend_by_zero.hom_apply", "description": ""}, {"name": "function.update_neg", "description": ""}, {"name": "pi.mul_single_mul_mul_single_eq_mul_single_mul_mul_single", "description": ""}, {"name": "pi.add_right_cancel_monoid", "description": ""}, {"name": "pi.cancel_monoid", "description": ""}, {"name": "pi.single_apply_commute", "description": "The injection into an additive pi group with the same values commutes."}, {"name": "add_monoid_hom.single_apply", "description": ""}, {"name": "pi.has_involutive_inv", "description": ""}, {"name": "function.extend_by_one.hom", "description": "`function.extend s f 1` as a bundled hom."}, {"name": "function.update_one", "description": ""}, {"name": "mul_hom.coe_fn_apply", "description": ""}, {"name": "pi.mul_single_inv", "description": ""}, {"name": "monoid_hom.coe_fn_apply", "description": ""}, {"name": "pi.left_cancel_semigroup", "description": ""}, {"name": "pi.eval_monoid_hom", "description": " Evaluation of functions into an indexed collection of monoids at a point is a monoid\nhomomorphism.\nThis is `function.eval i` as a `monoid_hom`."}, {"name": "pi.const_add_hom_apply", "description": ""}, {"name": "pi.right_cancel_monoid", "description": ""}, {"name": "pi.eval_add_hom", "description": "Evaluation of functions into an indexed collection of additive semigroups at a\npoint is an additive semigroup homomorphism.\nThis is `function.eval i` as an `add_hom`."}, {"name": "add_monoid_hom.coe_fn", "description": "Coercion of an `add_monoid_hom` into a function is itself a `add_monoid_hom`.\n\nSee also `add_monoid_hom.eval`."}, {"name": "monoid_hom.comp_left", "description": " Monoid homomorphism between the function spaces `I \u2192 \u03b1` and `I \u2192 \u03b2`, induced by a monoid\nhomomorphism `f` between `\u03b1` and `\u03b2`."}, {"name": "pi.eval_monoid_hom_apply", "description": ""}, {"name": "pi.add_zero_class", "description": ""}, {"name": "add_monoid_hom.coe_fn_apply", "description": ""}, {"name": "set.piecewise_sub", "description": ""}, {"name": "pi.single_add_single_eq_single_add_single", "description": ""}, {"name": "function.update_div", "description": ""}, {"name": "pi.single_commute", "description": "The injection into an additive pi group at different indices commutes.\n\nFor injections of commuting elements at the same index, see `add_commute.map`"}, {"name": "pi.mul_zero_one_class", "description": ""}, {"name": "pi.add_comm_semigroup", "description": ""}, {"name": "pi.single_add", "description": ""}, {"name": "pi.group", "description": ""}, {"name": "pi.monoid", "description": ""}, {"name": "pi.subtraction_monoid", "description": ""}, {"name": "monoid_hom.single_apply", "description": ""}, {"name": "pi.semigroup", "description": ""}, {"name": "finset.sigma_lift_nonempty", "description": ""}, {"name": "finset.mem_sigma_lift", "description": ""}, {"name": "finset.sigma_nonempty", "description": ""}, {"name": "finset.sigma_mono", "description": ""}, {"name": "finset.sigma_lift", "description": "Lifts maps `\u03b1 i \u2192 \u03b2 i \u2192 finset (\u03b3 i)` to a map `\u03a3 i, \u03b1 i \u2192 \u03a3 i, \u03b2 i \u2192 finset (\u03a3 i, \u03b3 i)`."}, {"name": "finset.sigma_eq_empty", "description": ""}, {"name": "finset.sigma_lift_mono", "description": ""}, {"name": "finset.card_sigma_lift", "description": ""}, {"name": "finset.mk_mem_sigma_lift", "description": ""}, {"name": "finset.inf_sigma", "description": ""}, {"name": "finset.sigma_eq_bUnion", "description": ""}, {"name": "finset.sup_sigma", "description": ""}, {"name": "finset.mem_sigma", "description": ""}, {"name": "finset.not_mem_sigma_lift_of_ne_right", "description": ""}, {"name": "finset.coe_sigma", "description": ""}, {"name": "finset.sigma", "description": "`s.sigma t` is the finset of dependent pairs `\u27e8i, a\u27e9` such that `i \u2208 s` and `a \u2208 t i`."}, {"name": "finset.sigma_lift_eq_empty", "description": ""}, {"name": "finset.not_mem_sigma_lift_of_ne_left", "description": ""}, {"name": "tactic.interactive.ac_refine", "description": ""}, {"name": "tactic.interactive.find_rule", "description": ""}, {"name": "tactic.interactive.mk_fun_app", "description": ""}, {"name": "tactic_doc.tactic.mono", "description": "- `mono` applies a monotonicity rule.\n- `mono*` applies monotonicity rules repetitively.\n- `mono with x \u2264 y` or `mono with [0 \u2264 x,0 \u2264 y]` creates an assertion for the listed\n  propositions. Those help to select the right monotonicity rule.\n- `mono left` or `mono right` is useful when proving strict orderings:\n   for `x + y < w + z` could be broken down into either\n    - left:  `x \u2264 w` and `y < z` or\n    - right: `x < w` and `y \u2264 z`\n- `mono using [rule1,rule2]` calls `simp [rule1,rule2]` before applying mono.\n- The general syntax is\n  `mono '*'? ('with' hyp | 'with' [hyp1,hyp2])? ('using' [hyp1,hyp2])? mono_cfg?`\n\nTo use it, first import `tactic.monotonicity`.\n\nHere is an example of mono:\n\n```lean\nexample (x y z k : \u2124)\n  (h : 3 \u2264 (4 : \u2124))\n  (h' : z \u2264 y) :\n  (k + 3 + x) - y \u2264 (k + 4 + x) - z :=\nbegin\n  mono, -- unfold `(-)`, apply add_le_add\n  { -- \u22a2 k + 3 + x \u2264 k + 4 + x\n    mono, -- apply add_le_add, refl\n    -- \u22a2 k + 3 \u2264 k + 4\n    mono },\n  { -- \u22a2 -y \u2264 -z\n    mono /- apply neg_le_neg -/ }\nend\n```\n\nMore succinctly, we can prove the same goal as:\n\n```lean\nexample (x y z k : \u2124)\n  (h : 3 \u2264 (4 : \u2124))\n  (h' : z \u2264 y) :\n  (k + 3 + x) - y \u2264 (k + 4 + x) - z :=\nby mono*\n```"}, {"name": "tactic.interactive.mono_function.decidable_eq", "description": ""}, {"name": "tactic.interactive.fold_assoc", "description": ""}, {"name": "tactic.interactive.find_lemma", "description": ""}, {"name": "tactic.interactive.hide_meta_vars'", "description": ""}, {"name": "tactic.interactive.side_conditions", "description": ""}, {"name": "tactic.interactive.assert_or_rule", "description": ""}, {"name": "tactic.interactive.pi_head", "description": ""}, {"name": "tactic.interactive.parse_ac_mono_function'", "description": ""}, {"name": "tactic.interactive.delete_expr", "description": ""}, {"name": "tactic.interactive.ac_mono_ctx'.traversable", "description": ""}, {"name": "tactic.interactive.unify_with_instance", "description": ""}, {"name": "tactic.interactive.match_assoc", "description": "`(prefix,left,right,suffix) \u2190 match_assoc unif l r` finds the\nlongest prefix and suffix common to `l` and `r` and\nreturns them along with the differences"}, {"name": "tactic.interactive.check_ac", "description": ""}, {"name": "tactic.interactive.match_prefix", "description": ""}, {"name": "tactic.interactive.as_goal", "description": ""}, {"name": "tactic.interactive.has_to_tactic_format_mono_law", "description": ""}, {"name": "tactic.interactive.mk_pattern", "description": ""}, {"name": "tactic.interactive.ac_mono_ctx'.traverse", "description": ""}, {"name": "tactic.interactive.mono", "description": "- `mono` applies a monotonicity rule.\n- `mono*` applies monotonicity rules repetitively.\n- `mono with x \u2264 y` or `mono with [0 \u2264 x,0 \u2264 y]` creates an assertion for the listed\n  propositions. Those help to select the right monotonicity rule.\n- `mono left` or `mono right` is useful when proving strict orderings:\n   for `x + y < w + z` could be broken down into either\n    - left:  `x \u2264 w` and `y < z` or\n    - right: `x < w` and `y \u2264 z`\n- `mono using [rule1,rule2]` calls `simp [rule1,rule2]` before applying mono.\n- The general syntax is\n  `mono '*'? ('with' hyp | 'with' [hyp1,hyp2])? ('using' [hyp1,hyp2])? mono_cfg?`\n\nTo use it, first import `tactic.monotonicity`.\n\nHere is an example of mono:\n\n```lean\nexample (x y z k : \u2124)\n  (h : 3 \u2264 (4 : \u2124))\n  (h' : z \u2264 y) :\n  (k + 3 + x) - y \u2264 (k + 4 + x) - z :=\nbegin\n  mono, -- unfold `(-)`, apply add_le_add\n  { -- \u22a2 k + 3 + x \u2264 k + 4 + x\n    mono, -- apply add_le_add, refl\n    -- \u22a2 k + 3 \u2264 k + 4\n    mono },\n  { -- \u22a2 -y \u2264 -z\n    mono /- apply neg_le_neg -/ }\nend\n```\n\nMore succinctly, we can prove the same goal as:\n\n```lean\nexample (x y z k : \u2124)\n  (h : 3 \u2264 (4 : \u2124))\n  (h' : z \u2264 y) :\n  (k + 3 + x) - y \u2264 (k + 4 + x) - z :=\nby mono*\n```"}, {"name": "tactic.interactive.parse_assoc_chain'", "description": ""}, {"name": "tactic.interactive.parse_assoc_chain", "description": ""}, {"name": "tactic.interactive.mk_congr_args", "description": ""}, {"name": "tactic.interactive.parse_ac_mono_function", "description": ""}, {"name": "tactic.interactive.match_ac'", "description": ""}, {"name": "tactic.interactive.ac_mono_ctx_ne", "description": ""}, {"name": "tactic.interactive.rep_arity.inhabited", "description": ""}, {"name": "tactic.interactive.match_rule", "description": ""}, {"name": "tactic.interactive.bin_op_left", "description": ""}, {"name": "tactic.interactive.ac_mono", "description": "`ac_mono` reduces the `f x \u2291 f y`, for some relation `\u2291` and a\nmonotonic function `f` to `x \u227a y`.\n\n`ac_mono*` unwraps monotonic functions until it can't.\n\n`ac_mono^k`, for some literal number `k` applies monotonicity `k`\ntimes.\n\n`ac_mono := h`, with `h` a hypothesis, unwraps monotonic functions and\nuses `h` to solve the remaining goal. Can be combined with `*` or `^k`:\n`ac_mono* := h`\n\n`ac_mono : p` asserts `p` and uses it to discharge the goal result\nunwrapping a series of monotonic functions. Can be combined with * or\n^k: `ac_mono* : p`\n\nIn the case where `f` is an associative or commutative operator,\n`ac_mono` will consider any possible permutation of its arguments and\nuse the one the minimizes the difference between the left-hand side\nand the right-hand side.\n\nTo use it, first import `tactic.monotonicity`.\n\n`ac_mono` can be used as follows:\n\n```lean\nexample (x y z k m n : \u2115)\n  (h\u2080 : z \u2265 0)\n  (h\u2081 : x \u2264 y) :\n  (m + x + n) * z + k \u2264 z * (y + n + m) + k :=\nbegin\n  ac_mono,\n  -- \u22a2 (m + x + n) * z \u2264 z * (y + n + m)\n  ac_mono,\n  -- \u22a2 m + x + n \u2264 y + n + m\n  ac_mono,\nend\n```\n\nAs with `mono*`, `ac_mono*` solves the goal in one go and so does\n`ac_mono* := h\u2081`. The latter syntax becomes especially interesting in the\nfollowing example:\n\n```lean\nexample (x y z k m n : \u2115)\n  (h\u2080 : z \u2265 0)\n  (h\u2081 : m + x + n \u2264 y + n + m) :\n  (m + x + n) * z + k \u2264 z * (y + n + m) + k :=\nby ac_mono* := h\u2081.\n```\n\nBy giving `ac_mono` the assumption `h\u2081`, we are asking `ac_refl` to\nstop earlier than it would normally would."}, {"name": "tactic.interactive.mono_aux", "description": ""}, {"name": "tactic.interactive.mono_function.to_tactic_format", "description": ""}, {"name": "tactic.interactive.rep_arity", "description": ""}, {"name": "tactic.interactive.rep_arity.one", "description": ""}, {"name": "tactic.interactive.rep_arity.exactly", "description": ""}, {"name": "tactic.interactive.rep_arity.many", "description": ""}, {"name": "tactic.interactive.bin_op", "description": ""}, {"name": "tactic.interactive.mono_law.to_tactic_format", "description": ""}, {"name": "tactic_doc.tactic.ac_mono", "description": "`ac_mono` reduces the `f x \u2291 f y`, for some relation `\u2291` and a\nmonotonic function `f` to `x \u227a y`.\n\n`ac_mono*` unwraps monotonic functions until it can't.\n\n`ac_mono^k`, for some literal number `k` applies monotonicity `k`\ntimes.\n\n`ac_mono := h`, with `h` a hypothesis, unwraps monotonic functions and\nuses `h` to solve the remaining goal. Can be combined with `*` or `^k`:\n`ac_mono* := h`\n\n`ac_mono : p` asserts `p` and uses it to discharge the goal result\nunwrapping a series of monotonic functions. Can be combined with * or\n^k: `ac_mono* : p`\n\nIn the case where `f` is an associative or commutative operator,\n`ac_mono` will consider any possible permutation of its arguments and\nuse the one the minimizes the difference between the left-hand side\nand the right-hand side.\n\nTo use it, first import `tactic.monotonicity`.\n\n`ac_mono` can be used as follows:\n\n```lean\nexample (x y z k m n : \u2115)\n  (h\u2080 : z \u2265 0)\n  (h\u2081 : x \u2264 y) :\n  (m + x + n) * z + k \u2264 z * (y + n + m) + k :=\nbegin\n  ac_mono,\n  -- \u22a2 (m + x + n) * z \u2264 z * (y + n + m)\n  ac_mono,\n  -- \u22a2 m + x + n \u2264 y + n + m\n  ac_mono,\nend\n```\n\nAs with `mono*`, `ac_mono*` solves the goal in one go and so does\n`ac_mono* := h\u2081`. The latter syntax becomes especially interesting in the\nfollowing example:\n\n```lean\nexample (x y z k m n : \u2115)\n  (h\u2080 : z \u2265 0)\n  (h\u2081 : m + x + n \u2264 y + n + m) :\n  (m + x + n) * z + k \u2264 z * (y + n + m) + k :=\nby ac_mono* := h\u2081.\n```\n\nBy giving `ac_mono` the assumption `h\u2081`, we are asking `ac_refl` to\nstop earlier than it would normally would."}, {"name": "tactic.interactive.apply_rel", "description": ""}, {"name": "tactic.interactive.repeat_until", "description": ""}, {"name": "tactic.interactive.list.minimum_on", "description": ""}, {"name": "tactic.interactive.solve_mvar", "description": ""}, {"name": "tactic.interactive.mk_congr_law", "description": ""}, {"name": "tactic.interactive.match_chaining_rules", "description": ""}, {"name": "tactic.interactive.has_to_tactic_format_mono_function", "description": ""}, {"name": "tactic.interactive.match_ac", "description": ""}, {"name": "tactic.interactive.mono_law", "description": ""}, {"name": "tactic.interactive.mono_law.assoc", "description": ""}, {"name": "tactic.interactive.mono_law.congr", "description": ""}, {"name": "tactic.interactive.mono_law.other", "description": ""}, {"name": "tactic.interactive.ac_mono_ctx.to_tactic_format", "description": ""}, {"name": "tactic.interactive.same_function_aux", "description": ""}, {"name": "tactic.interactive.repeat_until_or_at_most", "description": "(repeat_until_or_at_most n t u): repeat tactic `t` at most n times or until u succeeds"}, {"name": "tactic.interactive.best_match", "description": ""}, {"name": "tactic.interactive.ac_mono_ctx'.map", "description": ""}, {"name": "tactic.interactive.repeat_or_not", "description": ""}, {"name": "tactic.interactive.ac_monotonicity_goal", "description": ""}, {"name": "tactic.interactive.ac_mono_ctx", "description": ""}, {"name": "tactic.interactive.ac_mono_ctx'", "description": ""}, {"name": "tactic.interactive.ac_mono_ctx'.to_rel", "description": ""}, {"name": "tactic.interactive.ac_mono_ctx'.function", "description": ""}, {"name": "tactic.interactive.ac_mono_ctx'.left", "description": ""}, {"name": "tactic.interactive.ac_mono_ctx'.right", "description": ""}, {"name": "tactic.interactive.ac_mono_ctx'.rel_def", "description": ""}, {"name": "tactic.interactive.ac_mono_aux", "description": "transforms a goal of the form `f x \u227c f y` into `x \u2264 y` using lemmas\nmarked as `monotonic`.\n\nSpecial care is taken when `f` is the repeated application of an\nassociative operator and if the operator is commutative"}, {"name": "tactic.interactive.one_line", "description": ""}, {"name": "tactic.interactive.mk_rel", "description": ""}, {"name": "tactic.interactive.ac_mono_ctx'.functor", "description": ""}, {"name": "tactic.interactive.arity", "description": ""}, {"name": "tactic.interactive.mono_function", "description": ""}, {"name": "tactic.interactive.mono_function.non_assoc", "description": ""}, {"name": "tactic.interactive.mono_function.assoc", "description": ""}, {"name": "tactic.interactive.mono_function.assoc_comm", "description": ""}, {"name": "tactic.interactive.fold_assoc1", "description": ""}, {"name": "tactic.interactive.has_to_tactic_format_mono_ctx", "description": ""}, {"name": "tactic.interactive.bin_op_right", "description": ""}, {"name": "tactic.interactive.same_function", "description": ""}, {"name": "tactic.interactive.rep_arity.has_reflect", "description": ""}, {"name": "tactic.find_if_cond_at", "description": ""}, {"name": "tactic.interactive.split_ifs", "description": " Splits all if-then-else-expressions into multiple goals.\n\nGiven a goal of the form `g (if p then x else y)`, `split_ifs` will produce\ntwo goals: `p \u22a2 g x` and `\u00acp \u22a2 g y`.\n\nIf there are multiple ite-expressions, then `split_ifs` will split them all,\nstarting with a top-most one whose condition does not contain another\nite-expression.\n\n`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.\n\n`split_ifs with h\u2081 h\u2082 h\u2083` overrides the default names for the hypotheses."}, {"name": "tactic.find_if_cond", "description": ""}, {"name": "tactic.split_ifs", "description": ""}, {"name": "simp_attr.split_if_reduction", "description": "Simp set for if-then-else statements"}, {"name": "tactic_doc.tactic.split_ifs", "description": " Splits all if-then-else-expressions into multiple goals.\n\nGiven a goal of the form `g (if p then x else y)`, `split_ifs` will produce\ntwo goals: `p \u22a2 g x` and `\u00acp \u22a2 g y`.\n\nIf there are multiple ite-expressions, then `split_ifs` will split them all,\nstarting with a top-most one whose condition does not contain another\nite-expression.\n\n`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.\n\n`split_ifs with h\u2081 h\u2082 h\u2083` overrides the default names for the hypotheses."}, {"name": "tactic.split_if1", "description": ""}, {"name": "tactic.reduce_ifs_at", "description": ""}, {"name": "except_t.lift", "description": ""}, {"name": "except", "description": ""}, {"name": "except.error", "description": ""}, {"name": "except.ok", "description": ""}, {"name": "except_t.return", "description": ""}, {"name": "except.monad", "description": ""}, {"name": "except.bind", "description": ""}, {"name": "except_t.bind_cont", "description": ""}, {"name": "except_t.monad_map", "description": ""}, {"name": "except.to_option", "description": ""}, {"name": "monad_except.orelse", "description": ""}, {"name": "monad_except", "description": "An implementation of [MonadError](https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Except.html#t:MonadError)"}, {"name": "monad_except.throw", "description": "An implementation of [MonadError](https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Except.html#t:MonadError)"}, {"name": "monad_except.catch", "description": "An implementation of [MonadError](https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Except.html#t:MonadError)"}, {"name": "except_t.monad_run", "description": ""}, {"name": "except_t.adapt", "description": ""}, {"name": "except_t.monad_except", "description": ""}, {"name": "monad_except.orelse'", "description": "Alternative orelse operator that allows to select which exception should be used.\n   The default is to use the first exception since the standard `orelse` uses the second."}, {"name": "except.map", "description": ""}, {"name": "except_t.monad_functor", "description": ""}, {"name": "except.to_bool", "description": ""}, {"name": "except_t.bind", "description": ""}, {"name": "except_t.monad", "description": ""}, {"name": "monad_except_adapter", "description": "Adapt a monad stack, changing its top-most error type.\n\n   Note: This class can be seen as a simplification of the more \"principled\" definition\n   ```lean\n   class monad_except_functor (\u03b5 \u03b5' : out_param (Type u)) (n n' : Type u \u2192 Type u) :=\n   (map {\u03b1 : Type u} : (\u2200 {m : Type u \u2192 Type u} [monad m], except_t \u03b5 m \u03b1 \u2192 except_t \u03b5' m \u03b1) \u2192 n \u03b1 \u2192 n' \u03b1)\n   ```"}, {"name": "monad_except_adapter.adapt_except", "description": "Adapt a monad stack, changing its top-most error type.\n\n   Note: This class can be seen as a simplification of the more \"principled\" definition\n   ```lean\n   class monad_except_functor (\u03b5 \u03b5' : out_param (Type u)) (n n' : Type u \u2192 Type u) :=\n   (map {\u03b1 : Type u} : (\u2200 {m : Type u \u2192 Type u} [monad m], except_t \u03b5 m \u03b1 \u2192 except_t \u03b5' m \u03b1) \u2192 n \u03b1 \u2192 n' \u03b1)\n   ```"}, {"name": "except_t", "description": ""}, {"name": "except_t.run", "description": ""}, {"name": "except.return", "description": ""}, {"name": "monad_except_adapter_trans", "description": ""}, {"name": "except_t.catch", "description": ""}, {"name": "except.map_error", "description": ""}, {"name": "except_t.monad_except_adapter", "description": ""}, {"name": "except_t.has_monad_lift", "description": ""}, {"name": "vm_decl.to_name", "description": ""}, {"name": "vm_core.ret", "description": ""}, {"name": "vm_decl.olean", "description": "Return .olean file where the given VM declaration was imported from."}, {"name": "vm_obj.fields", "description": "For constructor vm_obj's, it returns the data stored in the object.\n  For closure vm_obj's, it returns the local arguments captured by the closure."}, {"name": "vm", "description": ""}, {"name": "vm.stack_obj", "description": "Return the vm_obj stored at the given position on the execution stack.\n  It fails if position >= vm.stack_size"}, {"name": "vm_obj.to_level", "description": "For level vm_obj's, it returns the universe level wrapped by the vm_obj."}, {"name": "vm_obj.fn_idx", "description": "For closure vm_obj's, it returns the internal function index."}, {"name": "vm.pp_expr", "description": "Pretty print the given expression."}, {"name": "vm.pc", "description": "Return the program counter."}, {"name": "vm.get_override", "description": ""}, {"name": "vm_decl_kind", "description": ""}, {"name": "vm_decl_kind.bytecode", "description": ""}, {"name": "vm_decl_kind.builtin", "description": ""}, {"name": "vm_decl_kind.cfun", "description": ""}, {"name": "vm.pp_stack_obj", "description": "Pretty print the vm_obj at the given position on the execution stack."}, {"name": "vm.call_stack_fn", "description": "Return the function name at the given stack frame.\n  Action fails if position >= vm.call_stack_size."}, {"name": "vm_obj_kind.decidable_eq", "description": ""}, {"name": "vm_decl", "description": ""}, {"name": "vm.bp", "description": "Return the base stack pointer for the frame on top of the call stack."}, {"name": "vm.get_attribute", "description": "Return the list of declarations tagged with the given attribute."}, {"name": "vm.eof", "description": "Return tt if end of the input stream has been reached.\n  For example, this can happen if the user presses Ctrl-D"}, {"name": "vm_obj.to_nat", "description": "For simple and mpz vm_obj's"}, {"name": "vm_obj", "description": ""}, {"name": "vm_core.map", "description": ""}, {"name": "vm_decl.arity", "description": "Number of arguments needed to execute the given VM declaration."}, {"name": "vm.call_stack_var_range", "description": "Return the range [start, end) for the given stack frame.\n  Action fails if position >= vm.call_stack_size.\n  The values start and end correspond to positions at the execution stack.\n  We have that 0 <= start < end <= vm.stack_size"}, {"name": "vm_decl.idx", "description": "Internal function index associated with the given VM declaration."}, {"name": "vm_obj.to_declaration", "description": "For declaration vm_obj's, it returns the declaration wrapped by the vm_obj."}, {"name": "vm.call_stack_size", "description": "Number of frames on the call stack."}, {"name": "vm_decl.override_idx", "description": "If the given declaration is overridden by another declaration using the vm_override attribute, then this returns the overriding declaration."}, {"name": "vm.stack_obj_info", "description": "Return (name, type) for the object at the given position on the execution stack.\n  It fails if position >= vm.stack_size.\n  The name is anonymous if vm_obj is a transient value created by the compiler.\n  Type information is only recorded if the type is a closed term at compilation time."}, {"name": "vm_obj.to_format", "description": "For format vm_obj's, it returns the format object wrapped by the vm_obj."}, {"name": "vm_obj.to_name", "description": "For name vm_obj's, it returns the name wrapped by the vm_obj."}, {"name": "vm.get_line", "description": ""}, {"name": "vm.curr_fn", "description": "Return the name of the function on top of the call stack."}, {"name": "vm.put_str", "description": ""}, {"name": "vm.trace", "description": ""}, {"name": "vm.get_options", "description": ""}, {"name": "vm_decl.pos", "description": "Return source position if available"}, {"name": "vm.get_decl", "description": "Returns the vm declaration associated with the given name. Remark: does _not_ return the vm_override if present."}, {"name": "vm.stack_size", "description": ""}, {"name": "vm_core.monad", "description": ""}, {"name": "vm_core.bind", "description": ""}, {"name": "vm_obj_kind", "description": ""}, {"name": "vm_obj_kind.simple", "description": ""}, {"name": "vm_obj_kind.constructor", "description": ""}, {"name": "vm_obj_kind.closure", "description": ""}, {"name": "vm_obj_kind.native_closure", "description": ""}, {"name": "vm_obj_kind.mpz", "description": ""}, {"name": "vm_obj_kind.name", "description": ""}, {"name": "vm_obj_kind.level", "description": ""}, {"name": "vm_obj_kind.expr", "description": ""}, {"name": "vm_obj_kind.declaration", "description": ""}, {"name": "vm_obj_kind.environment", "description": ""}, {"name": "vm_obj_kind.tactic_state", "description": ""}, {"name": "vm_obj_kind.format", "description": ""}, {"name": "vm_obj_kind.options", "description": ""}, {"name": "vm_obj_kind.other", "description": ""}, {"name": "vm_obj.kind", "description": ""}, {"name": "vm.get_env", "description": ""}, {"name": "vm_local_info", "description": "Information for local variables and arguments on the VM stack.\n  Remark: type is only available if it is a closed term at compilation time."}, {"name": "vm_local_info.id", "description": "Information for local variables and arguments on the VM stack.\n  Remark: type is only available if it is a closed term at compilation time."}, {"name": "vm_local_info.type", "description": "Information for local variables and arguments on the VM stack.\n  Remark: type is only available if it is a closed term at compilation time."}, {"name": "vm_monitor", "description": "A Lean VM monitor. Monitors are registered using the [vm_monitor] attribute.\n\n   If option 'debugger' is true, then the VM will initialize the vm_monitor state using the\n   'init' field, and will invoke the function 'step' before each instruction is invoked."}, {"name": "vm_monitor.init", "description": "A Lean VM monitor. Monitors are registered using the [vm_monitor] attribute.\n\n   If option 'debugger' is true, then the VM will initialize the vm_monitor state using the\n   'init' field, and will invoke the function 'step' before each instruction is invoked."}, {"name": "vm_monitor.step", "description": "A Lean VM monitor. Monitors are registered using the [vm_monitor] attribute.\n\n   If option 'debugger' is true, then the VM will initialize the vm_monitor state using the\n   'init' field, and will invoke the function 'step' before each instruction is invoked."}, {"name": "vm_core", "description": ""}, {"name": "vm_decl.args_info", "description": "Return names .olean file where the given VM declaration was imported from."}, {"name": "vm_obj.cidx", "description": "For simple and constructor vm_obj's, it returns the constructor tag/index.\n  Return 0 otherwise."}, {"name": "vm.decl_of_idx", "description": "Returns the vm declaration associated with the given index. Remark: does _not_ return the vm_override if present."}, {"name": "vm_decl.kind", "description": ""}, {"name": "vm_obj.to_environment", "description": "For environment vm_obj's, it returns the environment wrapped by the vm_obj."}, {"name": "vm_obj.to_expr", "description": "For expr vm_obj's, it returns the expression wrapped by the vm_obj."}, {"name": "vm.obj_to_string", "description": "Convert the given vm_obj into a string"}, {"name": "vm_obj.to_tactic_state", "description": "For tactic_state vm_obj's, it returns the tactic_state object wrapped by the vm_obj."}, {"name": "nat.has_mod", "description": ""}, {"name": "nat.mod", "description": ""}, {"name": "nat.mod_core", "description": ""}, {"name": "nat.div", "description": ""}, {"name": "nat.div_core", "description": ""}, {"name": "nat.has_div", "description": ""}, {"name": "int.neg_succ_of_nat_coe'", "description": ""}, {"name": "int.add_comm", "description": ""}, {"name": "int.of_nat_mul_of_nat", "description": ""}, {"name": "int.neg_add", "description": ""}, {"name": "int.sub_nat_nat_of_le", "description": ""}, {"name": "int.nat_abs_of_nat", "description": ""}, {"name": "int.coe_nat_add_out", "description": ""}, {"name": "int.has_add", "description": ""}, {"name": "int.neg_of_nat", "description": ""}, {"name": "int.repr", "description": ""}, {"name": "int.mod", "description": ""}, {"name": "int.add_assoc", "description": ""}, {"name": "int.has_div", "description": ""}, {"name": "int.nat_abs_mul_self", "description": ""}, {"name": "int.nat_abs_eq", "description": ""}, {"name": "int.has_zero", "description": ""}, {"name": "int.has_sub", "description": ""}, {"name": "int.zero_mul", "description": ""}, {"name": "int.sub_nat_nat_add_left", "description": ""}, {"name": "int.neg_of_nat_zero", "description": ""}, {"name": "int.of_nat_mul_neg_succ_of_nat", "description": ""}, {"name": "int.add_zero", "description": ""}, {"name": "int.rem", "description": ""}, {"name": "int.distrib_right", "description": ""}, {"name": "int.sub_nat_nat_add_add", "description": ""}, {"name": "int.neg_succ_of_nat_add_neg_succ_of_nat", "description": ""}, {"name": "int.of_nat_zero", "description": ""}, {"name": "int.mul_neg_succ_of_nat_neg_succ_of_nat", "description": ""}, {"name": "int.sub_nat_nat_elim", "description": ""}, {"name": "int.nat_abs_pos_of_ne_zero", "description": ""}, {"name": "int.sign_one", "description": ""}, {"name": "int.add", "description": ""}, {"name": "int.has_repr", "description": ""}, {"name": "int.sub_nat_nat_add_neg_succ_of_nat", "description": ""}, {"name": "int.neg_succ_of_nat_inj_iff", "description": ""}, {"name": "int.mul_one", "description": ""}, {"name": "int.eq_coe_or_neg", "description": ""}, {"name": "int.add_left_neg", "description": ""}, {"name": "int.coe_nat_mul_out", "description": ""}, {"name": "int.sub_nat_nat_eq_coe", "description": ""}, {"name": "int.of_nat_sub", "description": ""}, {"name": "int.coe_nat_zero", "description": ""}, {"name": "int.mul", "description": ""}, {"name": "int.distrib_left", "description": ""}, {"name": "int.of_nat_mul", "description": ""}, {"name": "int.sub_nat_nat_add_right", "description": ""}, {"name": "int.has_mul", "description": ""}, {"name": "int.coe_nat_add_one_out", "description": ""}, {"name": "int.neg_eq_neg_one_mul", "description": ""}, {"name": "int.has_to_string", "description": ""}, {"name": "int", "description": ""}, {"name": "int.of_nat", "description": ""}, {"name": "int.neg_succ_of_nat", "description": ""}, {"name": "int.quot", "description": ""}, {"name": "int.coe_nat_add", "description": ""}, {"name": "int.one_mul", "description": ""}, {"name": "int.zero", "description": ""}, {"name": "int.coe_nat_eq", "description": ""}, {"name": "int.of_nat_mul_sub_nat_nat", "description": ""}, {"name": "int.has_one", "description": ""}, {"name": "int.has_coe", "description": ""}, {"name": "int.add_right_neg", "description": ""}, {"name": "int.nat_abs_neg", "description": ""}, {"name": "int.neg_succ_of_nat_mul_sub_nat_nat", "description": ""}, {"name": "int.add_assoc_aux1", "description": ""}, {"name": "int.coe_nat_one", "description": ""}, {"name": "int.mul_zero", "description": ""}, {"name": "int.sub_nat_nat_add", "description": ""}, {"name": "int.sub_nat_nat", "description": ""}, {"name": "int.sign_neg_one", "description": ""}, {"name": "int.add_left_cancel", "description": ""}, {"name": "int.sign_zero", "description": ""}, {"name": "int.zero_add", "description": ""}, {"name": "int.neg_succ_of_nat_add_of_nat", "description": ""}, {"name": "int.one", "description": ""}, {"name": "int.neg_neg", "description": ""}, {"name": "int.fmod", "description": ""}, {"name": "int.coe_nat_succ", "description": ""}, {"name": "int.coe_nat_inj", "description": ""}, {"name": "int.mul_assoc", "description": ""}, {"name": "int.coe_nat_eq_coe_nat_iff", "description": ""}, {"name": "int.of_nat_eq_coe", "description": ""}, {"name": "int.coe_nat_sub", "description": ""}, {"name": "int.has_mod", "description": ""}, {"name": "int.neg_neg_of_nat_succ", "description": ""}, {"name": "int.sign", "description": ""}, {"name": "int.nat_mod", "description": ""}, {"name": "int.neg_inj", "description": ""}, {"name": "int.neg_succ_of_nat_coe", "description": ""}, {"name": "int.neg_succ_of_nat_eq", "description": ""}, {"name": "int.sign_mul_nat_abs", "description": ""}, {"name": "int.has_neg", "description": ""}, {"name": "int.neg_succ_of_nat_of_nat", "description": ""}, {"name": "int.neg_of_nat_mul_neg_succ_of_nat", "description": ""}, {"name": "int.sub_nat_nat_of_sub_eq_zero", "description": ""}, {"name": "int.sub_nat_nat_sub", "description": ""}, {"name": "int.neg", "description": ""}, {"name": "int.nat_abs_one", "description": ""}, {"name": "int.to_nat_sub", "description": ""}, {"name": "int.of_nat_one", "description": ""}, {"name": "int.of_nat_add", "description": ""}, {"name": "int.neg_succ_of_nat_mul_neg_of_nat", "description": ""}, {"name": "int.of_nat_add_neg_succ_of_nat", "description": ""}, {"name": "int.sub_nat_nat_of_sub_eq_succ", "description": ""}, {"name": "int.sub_nat_nat_of_lt", "description": ""}, {"name": "int.nat_abs", "description": ""}, {"name": "int.neg_of_nat_mul_of_nat", "description": ""}, {"name": "int.fdiv", "description": ""}, {"name": "int.of_nat_succ", "description": ""}, {"name": "int.to_nat", "description": ""}, {"name": "int.neg_of_nat_of_succ", "description": ""}, {"name": "int.decidable_eq", "description": ""}, {"name": "int.neg_zero", "description": ""}, {"name": "int.of_nat_eq_of_nat_iff", "description": ""}, {"name": "int.mul_comm", "description": ""}, {"name": "int.add_left_comm", "description": ""}, {"name": "int.sub_nat_self", "description": ""}, {"name": "int.neg_of_nat_eq_sub_nat_nat_zero", "description": ""}, {"name": "int.gcd", "description": ""}, {"name": "int.add_assoc_aux2", "description": ""}, {"name": "int.of_nat_add_of_nat", "description": ""}, {"name": "int.eq_zero_of_nat_abs_eq_zero", "description": ""}, {"name": "int.neg_of_nat_add", "description": ""}, {"name": "int.of_nat_mul_neg_of_nat", "description": ""}, {"name": "int.coe_nat_mul", "description": ""}, {"name": "int.sub", "description": ""}, {"name": "int.zero_ne_one", "description": ""}, {"name": "int.sub_eq_add_neg", "description": ""}, {"name": "int.nat_abs_zero", "description": ""}, {"name": "int.div", "description": ""}, {"name": "linear_ordered_comm_monoid_with_zero.to_comm_monoid_with_zero", "description": ""}, {"name": "le_of_mul_le_left", "description": ""}, {"name": "multiplicative.ordered_comm_monoid", "description": ""}, {"name": "with_top.add_comm_monoid_with_one", "description": ""}, {"name": "order_dual.covariant_class_mul_le", "description": ""}, {"name": "additive.to_mul_le", "description": ""}, {"name": "order_dual.add_monoid", "description": ""}, {"name": "min_mul_distrib'", "description": ""}, {"name": "with_top.contravariant_class_add_lt", "description": ""}, {"name": "max_add_add_left", "description": ""}, {"name": "with_bot.covariant_class_swap_add_le", "description": ""}, {"name": "units.min_coe", "description": ""}, {"name": "with_top.add_monoid_with_one", "description": ""}, {"name": "multiplicative.canonically_linear_ordered_monoid", "description": ""}, {"name": "zero_le_four", "description": ""}, {"name": "function.injective.ordered_comm_monoid", "description": " Pullback an `ordered_comm_monoid` under an injective map.\nSee note [reducible non-instances]."}, {"name": "min_add_max", "description": ""}, {"name": "multiplicative.canonically_ordered_monoid", "description": ""}, {"name": "ordered_cancel_add_comm_monoid", "description": " An ordered cancellative additive commutative monoid\nis an additive commutative monoid with a partial order,\nin which addition is cancellative and monotone."}, {"name": "ordered_cancel_add_comm_monoid.add", "description": " An ordered cancellative additive commutative monoid\nis an additive commutative monoid with a partial order,\nin which addition is cancellative and monotone."}, {"name": "ordered_cancel_add_comm_monoid.add_assoc", "description": " An ordered cancellative additive commutative monoid\nis an additive commutative monoid with a partial order,\nin which addition is cancellative and monotone."}, {"name": "ordered_cancel_add_comm_monoid.add_left_cancel", "description": " An ordered cancellative additive commutative monoid\nis an additive commutative monoid with a partial order,\nin which addition is cancellative and monotone."}, {"name": "ordered_cancel_add_comm_monoid.zero", "description": " An ordered cancellative additive commutative monoid\nis an additive commutative monoid with a partial order,\nin which addition is cancellative and monotone."}, {"name": "ordered_cancel_add_comm_monoid.zero_add", "description": " An ordered cancellative additive commutative monoid\nis an additive commutative monoid with a partial order,\nin which addition is cancellative and monotone."}, {"name": "ordered_cancel_add_comm_monoid.add_zero", "description": " An ordered cancellative additive commutative monoid\nis an additive commutative monoid with a partial order,\nin which addition is cancellative and monotone."}, {"name": "ordered_cancel_add_comm_monoid.nsmul", "description": " An ordered cancellative additive commutative monoid\nis an additive commutative monoid with a partial order,\nin which addition is cancellative and monotone."}, {"name": "ordered_cancel_add_comm_monoid.nsmul_zero'", "description": " An ordered cancellative additive commutative monoid\nis an additive commutative monoid with a partial order,\nin which addition is cancellative and monotone."}, {"name": "ordered_cancel_add_comm_monoid.nsmul_succ'", "description": " An ordered cancellative additive commutative monoid\nis an additive commutative monoid with a partial order,\nin which addition is cancellative and monotone."}, {"name": "ordered_cancel_add_comm_monoid.add_comm", "description": " An ordered cancellative additive commutative monoid\nis an additive commutative monoid with a partial order,\nin which addition is cancellative and monotone."}, {"name": "ordered_cancel_add_comm_monoid.le", "description": " An ordered cancellative additive commutative monoid\nis an additive commutative monoid with a partial order,\nin which addition is cancellative and monotone."}, {"name": "ordered_cancel_add_comm_monoid.lt", "description": " An ordered cancellative additive commutative monoid\nis an additive commutative monoid with a partial order,\nin which addition is cancellative and monotone."}, {"name": "ordered_cancel_add_comm_monoid.le_refl", "description": " An ordered cancellative additive commutative monoid\nis an additive commutative monoid with a partial order,\nin which addition is cancellative and monotone."}, {"name": "ordered_cancel_add_comm_monoid.le_trans", "description": " An ordered cancellative additive commutative monoid\nis an additive commutative monoid with a partial order,\nin which addition is cancellative and monotone."}, {"name": "ordered_cancel_add_comm_monoid.lt_iff_le_not_le", "description": " An ordered cancellative additive commutative monoid\nis an additive commutative monoid with a partial order,\nin which addition is cancellative and monotone."}, {"name": "ordered_cancel_add_comm_monoid.le_antisymm", "description": " An ordered cancellative additive commutative monoid\nis an additive commutative monoid with a partial order,\nin which addition is cancellative and monotone."}, {"name": "ordered_cancel_add_comm_monoid.add_le_add_left", "description": " An ordered cancellative additive commutative monoid\nis an additive commutative monoid with a partial order,\nin which addition is cancellative and monotone."}, {"name": "ordered_cancel_add_comm_monoid.le_of_add_le_add_left", "description": " An ordered cancellative additive commutative monoid\nis an additive commutative monoid with a partial order,\nin which addition is cancellative and monotone."}, {"name": "with_bot.coe_bit0", "description": ""}, {"name": "prod.has_exists_add_of_le", "description": ""}, {"name": "order_embedding.add_left_apply", "description": ""}, {"name": "with_top.le_of_add_le_add_right", "description": ""}, {"name": "function.injective.ordered_add_comm_monoid", "description": "Pullback an `ordered_add_comm_monoid` under an injective map."}, {"name": "min_le_add_of_nonneg_left", "description": ""}, {"name": "with_zero.coe_lt_coe", "description": ""}, {"name": "fn_min_mul_fn_max", "description": ""}, {"name": "order_dual.covariant_class_swap_mul_lt", "description": ""}, {"name": "with_bot.add_le_add_iff_left", "description": ""}, {"name": "le_self_mul", "description": ""}, {"name": "add_hom.with_bot_map_apply", "description": ""}, {"name": "le_add_left", "description": ""}, {"name": "with_zero.coe_le_coe", "description": ""}, {"name": "ordered_cancel_comm_monoid.to_contravariant_class_right", "description": ""}, {"name": "one_le", "description": ""}, {"name": "with_top.add_top", "description": ""}, {"name": "le_iff_exists_add", "description": ""}, {"name": "ordered_add_comm_monoid.to_partial_order", "description": ""}, {"name": "units.linear_order", "description": ""}, {"name": "exists_one_lt_mul_of_lt", "description": ""}, {"name": "order_dual.left_cancel_monoid", "description": ""}, {"name": "order_embedding.mul_right_apply", "description": ""}, {"name": "units.order_embedding_coe", "description": "`coe : \u03b1\u02e3 \u2192 \u03b1` as an order embedding."}, {"name": "zero_le_one", "description": ""}, {"name": "mul_lt_mul_iff_of_le_of_le", "description": ""}, {"name": "with_bot.add_ne_bot", "description": ""}, {"name": "with_bot.add_le_add_iff_right", "description": ""}, {"name": "ordered_comm_monoid.to_comm_monoid", "description": ""}, {"name": "with_bot.coe_one", "description": ""}, {"name": "with_zero.to_mul_bot_lt", "description": ""}, {"name": "with_bot.le_of_add_le_add_left", "description": ""}, {"name": "min_zero", "description": ""}, {"name": "ordered_cancel_add_comm_monoid.lt_of_add_lt_add_left", "description": ""}, {"name": "bot_eq_one'", "description": "In a linearly ordered monoid, we are happy for `bot_eq_one` to be a `@[simp]` lemma."}, {"name": "eq_zero_or_pos", "description": ""}, {"name": "prod.ordered_add_comm_monoid", "description": ""}, {"name": "linear_ordered_add_comm_monoid_with_top.to_linear_ordered_add_comm_monoid", "description": ""}, {"name": "with_top.covariant_class_swap_add_le", "description": ""}, {"name": "add_monoid_hom.with_bot_map", "description": "A version of `with_bot.map` for `add_monoid_hom`s."}, {"name": "linear_ordered_comm_monoid", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.le", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.lt", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.le_refl", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.le_trans", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.lt_iff_le_not_le", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.le_antisymm", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.le_total", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.decidable_le", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.decidable_eq", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.decidable_lt", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.max", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.max_def", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.min", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.min_def", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.mul", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.mul_assoc", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.one", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.one_mul", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.mul_one", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.npow", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.npow_zero'", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.npow_succ'", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.mul_comm", "description": "A linearly ordered commutative monoid."}, {"name": "linear_ordered_comm_monoid.mul_le_mul_left", "description": "A linearly ordered commutative monoid."}, {"name": "order_dual.has_add", "description": ""}, {"name": "add_units.coe_lt_coe", "description": ""}, {"name": "linear_ordered_comm_monoid_with_zero", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.le", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.lt", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.le_refl", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.le_trans", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.lt_iff_le_not_le", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.le_antisymm", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.le_total", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.decidable_le", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.decidable_eq", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.decidable_lt", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.max", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.max_def", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.min", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.min_def", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.mul", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.mul_assoc", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.one", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.one_mul", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.mul_one", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.npow", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.npow_zero'", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.npow_succ'", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.mul_comm", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.mul_le_mul_left", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.zero", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.zero_mul", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.mul_zero", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "linear_ordered_comm_monoid_with_zero.zero_le_one", "description": "A linearly ordered commutative monoid with a zero element."}, {"name": "additive.canonically_linear_ordered_add_monoid", "description": ""}, {"name": "additive.to_mul_lt", "description": ""}, {"name": "units.order_embedding_coe_apply", "description": ""}, {"name": "linear_ordered_cancel_add_comm_monoid", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.add", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.add_assoc", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.add_left_cancel", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.zero", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.zero_add", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.add_zero", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.nsmul", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.nsmul_zero'", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.nsmul_succ'", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.add_comm", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.le", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.lt", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.le_refl", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.le_trans", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.lt_iff_le_not_le", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.le_antisymm", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.add_le_add_left", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.le_of_add_le_add_left", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.le_total", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.decidable_le", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.decidable_eq", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.decidable_lt", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.max", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.max_def", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.min", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "linear_ordered_cancel_add_comm_monoid.min_def", "description": " A linearly ordered cancellative additive commutative monoid\nis an additive commutative monoid with a decidable linear order\nin which addition is cancellative and monotone."}, {"name": "additive.ordered_cancel_add_comm_monoid", "description": ""}, {"name": "with_bot.covariant_class_add_le", "description": ""}, {"name": "one_le_two'", "description": ""}, {"name": "additive.partial_order", "description": ""}, {"name": "with_top.add_ne_top", "description": ""}, {"name": "order_dual.linear_ordered_add_comm_monoid", "description": ""}, {"name": "has_exists_mul_of_le", "description": " An `ordered_comm_monoid` with one-sided 'division' in the sense that\nif `a \u2264 b`, there is some `c` for which `a * c = b`. This is a weaker version\nof the condition on canonical orderings defined by `canonically_ordered_monoid`."}, {"name": "has_exists_mul_of_le.exists_mul_of_le", "description": " An `ordered_comm_monoid` with one-sided 'division' in the sense that\nif `a \u2264 b`, there is some `c` for which `a * c = b`. This is a weaker version\nof the condition on canonical orderings defined by `canonically_ordered_monoid`."}, {"name": "canonically_linear_ordered_monoid.to_linear_order", "description": ""}, {"name": "canonically_ordered_monoid.to_order_bot", "description": ""}, {"name": "with_top.zero_eq_coe", "description": ""}, {"name": "ordered_cancel_add_comm_monoid.to_contravariant_class_right", "description": ""}, {"name": "linear_ordered_comm_monoid.to_linear_order", "description": ""}, {"name": "with_bot.add_lt_add_of_lt_of_le", "description": ""}, {"name": "order_dual.add_comm_semigroup", "description": ""}, {"name": "add_units.partial_order", "description": ""}, {"name": "with_top.has_one", "description": ""}, {"name": "self_le_mul_right", "description": ""}, {"name": "with_top.coe_eq_zero", "description": ""}, {"name": "order_dual.comm_monoid_with_zero", "description": ""}, {"name": "with_top.map_zero", "description": ""}, {"name": "function.injective.linear_ordered_comm_monoid", "description": " Pullback a `linear_ordered_comm_monoid` under an injective map.\nSee note [reducible non-instances]."}, {"name": "with_zero.linear_order", "description": ""}, {"name": "order_dual.comm_semigroup", "description": ""}, {"name": "add_hom.with_bot_map", "description": "A version of `with_bot.map` for `add_hom`s."}, {"name": "min_add_distrib", "description": ""}, {"name": "order_dual.covariant_class_swap_add_le", "description": ""}, {"name": "ordered_add_comm_monoid.to_add_comm_monoid", "description": ""}, {"name": "with_bot.coe_bit1", "description": ""}, {"name": "with_bot.add_zero_class", "description": ""}, {"name": "with_top.map_one", "description": ""}, {"name": "additive.has_le", "description": ""}, {"name": "order_dual.left_cancel_add_monoid", "description": ""}, {"name": "order_dual.mul_zero_class", "description": ""}, {"name": "order_embedding.mul_left", "description": " The order embedding sending `b` to `a * b`, for some fixed `a`.\nSee also `order_iso.mul_left` when working in an ordered group."}, {"name": "with_top.add_lt_add_iff_right", "description": ""}, {"name": "with_zero.canonically_ordered_add_monoid", "description": "Adding a new zero to a canonically ordered additive monoid produces another one."}, {"name": "with_zero.le_max_iff", "description": ""}, {"name": "with_zero.preorder", "description": ""}, {"name": "with_top.zero_ne_top", "description": ""}, {"name": "bot_eq_one", "description": ""}, {"name": "canonically_ordered_add_monoid.to_ordered_add_comm_monoid", "description": ""}, {"name": "order_embedding.mul_right", "description": " The order embedding sending `b` to `b * a`, for some fixed `a`.\nSee also `order_iso.mul_right` when working in an ordered group."}, {"name": "one_min", "description": ""}, {"name": "order_dual.contravariant_class_swap_mul_lt", "description": ""}, {"name": "add_monoid_hom.with_bot_map_apply", "description": ""}, {"name": "function.injective.linear_ordered_cancel_comm_monoid", "description": " Pullback a `linear_ordered_cancel_comm_monoid` under an injective map.\nSee note [reducible non-instances]."}, {"name": "le_of_add_le_right", "description": ""}, {"name": "order_dual.ordered_cancel_comm_monoid.to_contravariant_class", "description": ""}, {"name": "min_mul_mul_left", "description": ""}, {"name": "with_top.top_ne_one", "description": ""}, {"name": "multiplicative.partial_order", "description": ""}, {"name": "order_embedding.add_right_apply", "description": ""}, {"name": "with_bot.add_lt_add_right", "description": ""}, {"name": "canonically_linear_ordered_add_monoid.semilattice_sup", "description": ""}, {"name": "with_bot.add_eq_coe", "description": ""}, {"name": "pos_of_gt", "description": ""}, {"name": "prod.ordered_cancel_comm_monoid", "description": ""}, {"name": "with_top.canonically_linear_ordered_add_monoid", "description": ""}, {"name": "top_add", "description": ""}, {"name": "order_dual.covariant_class_swap_mul_le", "description": ""}, {"name": "ordered_cancel_comm_monoid.to_partial_order", "description": ""}, {"name": "has_add.to_covariant_class_right", "description": ""}, {"name": "multiplicative.of_add_lt", "description": ""}, {"name": "additive.linear_order", "description": ""}, {"name": "with_top.zero_le_one_class", "description": ""}, {"name": "add_units.preorder", "description": ""}, {"name": "with_bot.map_add", "description": ""}, {"name": "order_dual.cancel_add_comm_monoid", "description": ""}, {"name": "linear_ordered_add_comm_monoid_with_top.to_order_top", "description": ""}, {"name": "le_mul_self", "description": ""}, {"name": "order_dual.contravariant_class_swap_add_le", "description": ""}, {"name": "linear_ordered_add_comm_monoid.to_ordered_add_comm_monoid", "description": ""}, {"name": "one_lt_mul_iff", "description": ""}, {"name": "order_dual.monoid", "description": ""}, {"name": "with_top.coe_add_hom", "description": "Coercion from `\u03b1` to `with_top \u03b1` as an `add_monoid_hom`."}, {"name": "with_bot.add_comm_semigroup", "description": ""}, {"name": "with_top.ordered_add_comm_monoid", "description": ""}, {"name": "with_top.add_comm_monoid", "description": ""}, {"name": "ordered_cancel_comm_monoid.to_cancel_comm_monoid", "description": ""}, {"name": "mul_eq_one_iff", "description": ""}, {"name": "with_bot.add_lt_add_iff_left", "description": ""}, {"name": "with_bot.le_of_add_le_add_right", "description": ""}, {"name": "le_one_iff_eq_one", "description": ""}, {"name": "one_lt_iff_ne_one", "description": ""}, {"name": "min_le_add_of_nonneg_right", "description": ""}, {"name": "multiplicative.ordered_cancel_comm_monoid", "description": ""}, {"name": "with_bot.add_eq_bot", "description": ""}, {"name": "one_hom.with_bot_map", "description": "A version of `with_bot.map` for `one_hom`s."}, {"name": "multiplicative.has_exists_mul_of_le", "description": ""}, {"name": "with_bot.add_comm_monoid_with_one", "description": ""}, {"name": "one_hom.with_top_map", "description": "A version of `with_top.map` for `one_hom`s."}, {"name": "additive.of_mul_lt", "description": ""}, {"name": "order_dual.ordered_add_comm_monoid", "description": ""}, {"name": "with_bot.bot_add", "description": ""}, {"name": "zero_le_three", "description": ""}, {"name": "one_le_two", "description": ""}, {"name": "with_zero.ordered_add_comm_monoid", "description": "If `0` is the least element in `\u03b1`, then `with_zero \u03b1` is an `ordered_add_comm_monoid`.\nSee note [reducible non-instances]."}, {"name": "order_dual.covariant_class_swap_add_lt", "description": ""}, {"name": "additive.linear_ordered_add_comm_monoid", "description": ""}, {"name": "with_top.has_zero", "description": ""}, {"name": "linear_ordered_cancel_add_comm_monoid.to_ordered_cancel_add_comm_monoid", "description": ""}, {"name": "min_le_mul_of_one_le_left", "description": ""}, {"name": "zero_hom.with_top_map_apply", "description": ""}, {"name": "prod.canonically_ordered_add_monoid", "description": ""}, {"name": "with_bot.contravariant_class_add_lt", "description": ""}, {"name": "with_zero.to_mul_bot_zero", "description": ""}, {"name": "order_dual.mul_zero_one_class", "description": ""}, {"name": "min_add_add_right", "description": ""}, {"name": "order_dual.ordered_comm_monoid", "description": ""}, {"name": "min_le_mul_of_one_le_right", "description": ""}, {"name": "eq_one_or_one_lt", "description": ""}, {"name": "with_top.map_add", "description": ""}, {"name": "order_dual.linear_ordered_cancel_comm_monoid", "description": ""}, {"name": "self_le_add_left", "description": ""}, {"name": "min_add_add_left", "description": ""}, {"name": "le_iff_exists_mul", "description": ""}, {"name": "with_zero.order_bot", "description": ""}, {"name": "pos_iff_ne_zero", "description": ""}, {"name": "multiplicative.has_le", "description": ""}, {"name": "with_bot.coe_add", "description": ""}, {"name": "min_add_distrib'", "description": ""}, {"name": "additive.of_mul_le", "description": ""}, {"name": "additive.has_exists_add_of_le", "description": ""}, {"name": "function.injective.ordered_cancel_add_comm_monoid", "description": "Pullback an `ordered_cancel_add_comm_monoid` under an injective map."}, {"name": "order_dual.mul_one_class", "description": ""}, {"name": "order_dual.contravariant_class_mul_le", "description": ""}, {"name": "order_dual.ordered_cancel_comm_monoid", "description": ""}, {"name": "with_top.le_of_add_le_add_left", "description": ""}, {"name": "multiplicative.order_bot", "description": ""}, {"name": "add_hom.with_top_map", "description": "A version of `with_top.map` for `add_hom`s."}, {"name": "with_bot.has_add", "description": ""}, {"name": "order_dual.covariant_class_add_le", "description": ""}, {"name": "ordered_cancel_add_comm_monoid.to_add_cancel_comm_monoid", "description": ""}, {"name": "order_dual.covariant_class_add_lt", "description": ""}, {"name": "with_zero.min_le_iff", "description": ""}, {"name": "with_bot.has_one", "description": ""}, {"name": "ordered_cancel_comm_monoid.to_contravariant_class_left", "description": ""}, {"name": "add_units.linear_order", "description": ""}, {"name": "order_dual.contravariant_class_swap_mul_le", "description": ""}, {"name": "multiplicative.to_add_lt", "description": ""}, {"name": "with_top.coe_bit1", "description": ""}, {"name": "with_zero.has_exists_add_of_le", "description": ""}, {"name": "with_bot.contravariant_class_swap_add_lt", "description": ""}, {"name": "add_units.min_coe", "description": ""}, {"name": "linear_ordered_comm_monoid.to_ordered_comm_monoid", "description": ""}, {"name": "with_bot.add_comm_monoid", "description": ""}, {"name": "with_top.has_add", "description": ""}, {"name": "order_dual.ordered_cancel_add_comm_monoid", "description": ""}, {"name": "add_monoid_hom.with_top_map_apply", "description": ""}, {"name": "order_dual.cancel_comm_monoid_with_zero", "description": ""}, {"name": "with_bot.linear_ordered_add_comm_monoid", "description": ""}, {"name": "order_dual.linear_ordered_cancel_add_comm_monoid", "description": ""}, {"name": "min_mul_mul_right", "description": ""}, {"name": "max_mul_mul_right", "description": ""}, {"name": "bot_eq_zero", "description": ""}, {"name": "with_bot.coe_eq_zero", "description": ""}, {"name": "bit0_pos", "description": ""}, {"name": "with_top.top_add", "description": ""}, {"name": "prod.ordered_cancel_add_comm_monoid", "description": ""}, {"name": "zero_le", "description": ""}, {"name": "le_mul_left", "description": ""}, {"name": "ordered_comm_monoid.to_partial_order", "description": ""}, {"name": "order_embedding.add_left", "description": "The order embedding sending `b` to `a + b`, for some fixed `a`.\n  See also `order_iso.add_left` when working in an additive ordered group."}, {"name": "with_bot.add_coe_eq_bot_iff", "description": ""}, {"name": "le_self_add", "description": ""}, {"name": "additive.bounded_order", "description": ""}, {"name": "add_units.coe_le_coe", "description": ""}, {"name": "canonically_ordered_monoid.to_ordered_comm_monoid", "description": ""}, {"name": "with_top.add_le_add_iff_left", "description": ""}, {"name": "with_bot.bot_lt_add", "description": ""}, {"name": "min_mul_max", "description": ""}, {"name": "with_top.add_zero_class", "description": ""}, {"name": "with_top.coe_one", "description": ""}, {"name": "lt_or_lt_of_add_lt_add", "description": ""}, {"name": "prod.ordered_comm_monoid", "description": ""}, {"name": "additive.canonically_ordered_add_monoid", "description": ""}, {"name": "le_of_mul_le_right", "description": ""}, {"name": "order_dual.cancel_monoid", "description": ""}, {"name": "with_top.add_lt_add_right", "description": ""}, {"name": "multiplicative.linear_ordered_comm_monoid", "description": ""}, {"name": "order_dual.covariant_class_mul_lt", "description": ""}, {"name": "with_zero.zero_lt_coe", "description": ""}, {"name": "with_top.linear_ordered_add_comm_monoid_with_top", "description": ""}, {"name": "with_bot.add_lt_add_left", "description": ""}, {"name": "canonically_linear_ordered_add_monoid.to_linear_order", "description": ""}, {"name": "with_bot.coe_eq_one", "description": ""}, {"name": "with_top.has_exists_add_of_le", "description": ""}, {"name": "with_zero.covariant_class_add_le", "description": ""}, {"name": "order_dual.contravariant_class_mul_lt", "description": ""}, {"name": "with_zero.to_mul_bot_coe", "description": ""}, {"name": "zero_hom.with_bot_map_apply", "description": ""}, {"name": "canonically_linear_ordered_monoid.to_canonically_ordered_monoid", "description": ""}, {"name": "linear_ordered_cancel_comm_monoid.to_linear_ordered_comm_monoid", "description": ""}, {"name": "with_top.canonically_ordered_add_monoid", "description": ""}, {"name": "ordered_cancel_add_comm_monoid.to_partial_order", "description": ""}, {"name": "canonically_ordered_monoid.has_exists_mul_of_le", "description": ""}, {"name": "le_add_right", "description": ""}, {"name": "lt_or_lt_of_mul_lt_mul", "description": ""}, {"name": "with_top.add_eq_top", "description": ""}, {"name": "with_top.add_lt_add_iff_left", "description": ""}, {"name": "has_mul.to_covariant_class_right", "description": ""}, {"name": "with_bot.ordered_add_comm_monoid", "description": ""}, {"name": "multiplicative.of_add_le", "description": ""}, {"name": "le_add_self", "description": ""}, {"name": "with_zero.to_mul_bot_coe_of_add", "description": ""}, {"name": "max_le_mul_of_one_le", "description": ""}, {"name": "order_dual.contravariant_class_add_lt", "description": ""}, {"name": "multiplicative.bounded_order", "description": ""}, {"name": "with_top.one_ne_top", "description": ""}, {"name": "with_top.add_monoid", "description": ""}, {"name": "linear_ordered_cancel_add_comm_monoid.to_linear_ordered_add_comm_monoid", "description": ""}, {"name": "with_bot.has_zero", "description": ""}, {"name": "with_top.add_lt_add_of_lt_of_le", "description": ""}, {"name": "ordered_comm_monoid.to_covariant_class_right", "description": ""}, {"name": "add_eq_zero_iff", "description": ""}, {"name": "with_top.coe_eq_one", "description": ""}, {"name": "min_mul_distrib", "description": ""}, {"name": "bot_eq_zero'", "description": "In a linearly ordered monoid, we are happy for `bot_eq_zero` to be a `@[simp]` lemma"}, {"name": "ordered_cancel_add_comm_monoid.to_ordered_add_comm_monoid", "description": ""}, {"name": "order_dual.cancel_comm_monoid", "description": ""}, {"name": "order_dual.has_mul", "description": ""}, {"name": "additive.order_bot", "description": ""}, {"name": "with_top.add_coe_eq_top_iff", "description": ""}, {"name": "multiplicative.to_add_le", "description": ""}, {"name": "linear_ordered_add_comm_monoid_with_top", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.le", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.lt", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.le_refl", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.le_trans", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.lt_iff_le_not_le", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.le_antisymm", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.le_total", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.decidable_le", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.decidable_eq", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.decidable_lt", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.max", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.max_def", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.min", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.min_def", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.add", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.add_assoc", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.zero", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.zero_add", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.add_zero", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.nsmul", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.nsmul_zero'", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.nsmul_succ'", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.add_comm", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.add_le_add_left", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.top", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.le_top", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "linear_ordered_add_comm_monoid_with_top.top_add'", "description": "A linearly ordered commutative monoid with an additively absorbing `\u22a4` element.\n Instances should include number systems with an infinite element adjoined.`"}, {"name": "add_top", "description": ""}, {"name": "exists_pos_add_of_lt", "description": ""}, {"name": "with_top.add_lt_add_of_le_of_lt", "description": ""}, {"name": "with_top.covariant_class_add_le", "description": ""}, {"name": "with_top.add_comm_semigroup", "description": ""}, {"name": "order_dual.monoid_with_zero", "description": ""}, {"name": "max_mul_mul_left", "description": ""}, {"name": "add_units.order_embedding_coe_apply", "description": ""}, {"name": "order_embedding.add_right", "description": "The order embedding sending `b` to `b + a`, for some fixed `a`.\n  See also `order_iso.add_right` when working in an additive ordered group."}, {"name": "ordered_add_comm_monoid", "description": "An ordered (additive) commutative monoid is a commutative monoid\n with a partial order such that `a \u2264 b \u2192 c + a \u2264 c + b` (addition is monotone)"}, {"name": "ordered_add_comm_monoid.add", "description": "An ordered (additive) commutative monoid is a commutative monoid\n with a partial order such that `a \u2264 b \u2192 c + a \u2264 c + b` (addition is monotone)"}, {"name": "ordered_add_comm_monoid.add_assoc", "description": "An ordered (additive) commutative monoid is a commutative monoid\n with a partial order such that `a \u2264 b \u2192 c + a \u2264 c + b` (addition is monotone)"}, {"name": "ordered_add_comm_monoid.zero", "description": "An ordered (additive) commutative monoid is a commutative monoid\n with a partial order such that `a \u2264 b \u2192 c + a \u2264 c + b` (addition is monotone)"}, {"name": "ordered_add_comm_monoid.zero_add", "description": "An ordered (additive) commutative monoid is a commutative monoid\n with a partial order such that `a \u2264 b \u2192 c + a \u2264 c + b` (addition is monotone)"}, {"name": "ordered_add_comm_monoid.add_zero", "description": "An ordered (additive) commutative monoid is a commutative monoid\n with a partial order such that `a \u2264 b \u2192 c + a \u2264 c + b` (addition is monotone)"}, {"name": "ordered_add_comm_monoid.nsmul", "description": "An ordered (additive) commutative monoid is a commutative monoid\n with a partial order such that `a \u2264 b \u2192 c + a \u2264 c + b` (addition is monotone)"}, {"name": "ordered_add_comm_monoid.nsmul_zero'", "description": "An ordered (additive) commutative monoid is a commutative monoid\n with a partial order such that `a \u2264 b \u2192 c + a \u2264 c + b` (addition is monotone)"}, {"name": "ordered_add_comm_monoid.nsmul_succ'", "description": "An ordered (additive) commutative monoid is a commutative monoid\n with a partial order such that `a \u2264 b \u2192 c + a \u2264 c + b` (addition is monotone)"}, {"name": "ordered_add_comm_monoid.add_comm", "description": "An ordered (additive) commutative monoid is a commutative monoid\n with a partial order such that `a \u2264 b \u2192 c + a \u2264 c + b` (addition is monotone)"}, {"name": "ordered_add_comm_monoid.le", "description": "An ordered (additive) commutative monoid is a commutative monoid\n with a partial order such that `a \u2264 b \u2192 c + a \u2264 c + b` (addition is monotone)"}, {"name": "ordered_add_comm_monoid.lt", "description": "An ordered (additive) commutative monoid is a commutative monoid\n with a partial order such that `a \u2264 b \u2192 c + a \u2264 c + b` (addition is monotone)"}, {"name": "ordered_add_comm_monoid.le_refl", "description": "An ordered (additive) commutative monoid is a commutative monoid\n with a partial order such that `a \u2264 b \u2192 c + a \u2264 c + b` (addition is monotone)"}, {"name": "ordered_add_comm_monoid.le_trans", "description": "An ordered (additive) commutative monoid is a commutative monoid\n with a partial order such that `a \u2264 b \u2192 c + a \u2264 c + b` (addition is monotone)"}, {"name": "ordered_add_comm_monoid.lt_iff_le_not_le", "description": "An ordered (additive) commutative monoid is a commutative monoid\n with a partial order such that `a \u2264 b \u2192 c + a \u2264 c + b` (addition is monotone)"}, {"name": "ordered_add_comm_monoid.le_antisymm", "description": "An ordered (additive) commutative monoid is a commutative monoid\n with a partial order such that `a \u2264 b \u2192 c + a \u2264 c + b` (addition is monotone)"}, {"name": "ordered_add_comm_monoid.add_le_add_left", "description": "An ordered (additive) commutative monoid is a commutative monoid\n with a partial order such that `a \u2264 b \u2192 c + a \u2264 c + b` (addition is monotone)"}, {"name": "with_zero.contravariant_class_mul_lt", "description": ""}, {"name": "max_add_add_right", "description": ""}, {"name": "with_top.add_semigroup", "description": ""}, {"name": "order_dual.comm_monoid", "description": ""}, {"name": "ordered_add_comm_monoid.to_covariant_class_left", "description": ""}, {"name": "with_zero.zero_eq_bot", "description": ""}, {"name": "with_bot.map_zero", "description": ""}, {"name": "with_top.zero_lt_top", "description": ""}, {"name": "order_dual.add_semigroup", "description": ""}, {"name": "zero_min", "description": ""}, {"name": "has_mul.to_covariant_class_left", "description": ""}, {"name": "self_le_mul_left", "description": ""}, {"name": "units.partial_order", "description": ""}, {"name": "with_top.zero_lt_coe", "description": ""}, {"name": "le_mul_right", "description": ""}, {"name": "canonically_ordered_add_monoid.to_order_bot", "description": ""}, {"name": "ordered_comm_monoid.to_covariant_class_left", "description": ""}, {"name": "canonically_linear_ordered_add_monoid.to_canonically_ordered_add_monoid", "description": ""}, {"name": "ordered_add_comm_monoid.to_covariant_class_right", "description": ""}, {"name": "ordered_cancel_comm_monoid", "description": " An ordered cancellative commutative monoid\nis a commutative monoid with a partial order,\nin which multiplication is cancellative and monotone."}, {"name": "ordered_cancel_comm_monoid.mul", "description": " An ordered cancellative commutative monoid\nis a commutative monoid with a partial order,\nin which multiplication is cancellative and monotone."}, {"name": "ordered_cancel_comm_monoid.mul_assoc", "description": " An ordered cancellative commutative monoid\nis a commutative monoid with a partial order,\nin which multiplication is cancellative and monotone."}, {"name": "ordered_cancel_comm_monoid.mul_left_cancel", "description": " An ordered cancellative commutative monoid\nis a commutative monoid with a partial order,\nin which multiplication is cancellative and monotone."}, {"name": "ordered_cancel_comm_monoid.one", "description": " An ordered cancellative commutative monoid\nis a commutative monoid with a partial order,\nin which multiplication is cancellative and monotone."}, {"name": "ordered_cancel_comm_monoid.one_mul", "description": " An ordered cancellative commutative monoid\nis a commutative monoid with a partial order,\nin which multiplication is cancellative and monotone."}, {"name": "ordered_cancel_comm_monoid.mul_one", "description": " An ordered cancellative commutative monoid\nis a commutative monoid with a partial order,\nin which multiplication is cancellative and monotone."}, {"name": "ordered_cancel_comm_monoid.npow", "description": " An ordered cancellative commutative monoid\nis a commutative monoid with a partial order,\nin which multiplication is cancellative and monotone."}, {"name": "ordered_cancel_comm_monoid.npow_zero'", "description": " An ordered cancellative commutative monoid\nis a commutative monoid with a partial order,\nin which multiplication is cancellative and monotone."}, {"name": "ordered_cancel_comm_monoid.npow_succ'", "description": " An ordered cancellative commutative monoid\nis a commutative monoid with a partial order,\nin which multiplication is cancellative and monotone."}, {"name": "ordered_cancel_comm_monoid.mul_comm", "description": " An ordered cancellative commutative monoid\nis a commutative monoid with a partial order,\nin which multiplication is cancellative and monotone."}, {"name": "ordered_cancel_comm_monoid.le", "description": " An ordered cancellative commutative monoid\nis a commutative monoid with a partial order,\nin which multiplication is cancellative and monotone."}, {"name": "ordered_cancel_comm_monoid.lt", "description": " An ordered cancellative commutative monoid\nis a commutative monoid with a partial order,\nin which multiplication is cancellative and monotone."}, {"name": "ordered_cancel_comm_monoid.le_refl", "description": " An ordered cancellative commutative monoid\nis a commutative monoid with a partial order,\nin which multiplication is cancellative and monotone."}, {"name": "ordered_cancel_comm_monoid.le_trans", "description": " An ordered cancellative commutative monoid\nis a commutative monoid with a partial order,\nin which multiplication is cancellative and monotone."}, {"name": "ordered_cancel_comm_monoid.lt_iff_le_not_le", "description": " An ordered cancellative commutative monoid\nis a commutative monoid with a partial order,\nin which multiplication is cancellative and monotone."}, {"name": "ordered_cancel_comm_monoid.le_antisymm", "description": " An ordered cancellative commutative monoid\nis a commutative monoid with a partial order,\nin which multiplication is cancellative and monotone."}, {"name": "ordered_cancel_comm_monoid.mul_le_mul_left", "description": " An ordered cancellative commutative monoid\nis a commutative monoid with a partial order,\nin which multiplication is cancellative and monotone."}, {"name": "ordered_cancel_comm_monoid.le_of_mul_le_mul_left", "description": " An ordered cancellative commutative monoid\nis a commutative monoid with a partial order,\nin which multiplication is cancellative and monotone."}, {"name": "lt_iff_exists_mul", "description": ""}, {"name": "canonically_ordered_monoid.to_has_bot", "description": ""}, {"name": "with_zero.to_mul_bot_le", "description": ""}, {"name": "linear_ordered_cancel_comm_monoid.to_ordered_cancel_comm_monoid", "description": ""}, {"name": "order_dual.right_cancel_monoid", "description": ""}, {"name": "with_zero.zero_le", "description": ""}, {"name": "canonically_linear_ordered_monoid.semilattice_sup", "description": ""}, {"name": "with_bot.add_lt_add_of_le_of_lt", "description": ""}, {"name": "with_bot.add_monoid", "description": ""}, {"name": "with_top.one_eq_coe", "description": ""}, {"name": "with_zero.lattice", "description": ""}, {"name": "le_of_add_le_left", "description": ""}, {"name": "prod.has_exists_mul_of_le", "description": ""}, {"name": "with_zero.to_mul_bot_symm_bot", "description": ""}, {"name": "with_zero.to_mul_bot_strict_mono", "description": ""}, {"name": "one_hom.with_top_map_apply", "description": ""}, {"name": "units.coe_le_coe", "description": ""}, {"name": "additive.order_top", "description": ""}, {"name": "linear_ordered_add_comm_monoid.to_linear_order", "description": ""}, {"name": "add_hom.with_top_map_apply", "description": ""}, {"name": "add_units.order_embedding_coe", "description": "`coe : add_units \u03b1 \u2192 \u03b1` as an order embedding."}, {"name": "additive.preorder", "description": ""}, {"name": "zero_hom.with_top_map", "description": "A version of `with_top.map` for `zero_hom`s"}, {"name": "with_bot.coe_add_eq_bot_iff", "description": ""}, {"name": "lt_iff_exists_add", "description": ""}, {"name": "max_le_add_of_nonneg", "description": ""}, {"name": "with_zero.canonically_linear_ordered_add_monoid", "description": ""}, {"name": "multiplicative.order_top", "description": ""}, {"name": "add_pos_iff", "description": ""}, {"name": "order_dual.add_zero_class", "description": ""}, {"name": "canonically_ordered_add_monoid.to_has_bot", "description": ""}, {"name": "with_top.coe_coe_add_hom", "description": ""}, {"name": "le_iff_exists_add'", "description": ""}, {"name": "with_top.add_lt_add_left", "description": ""}, {"name": "order_dual.add_comm_monoid", "description": ""}, {"name": "order_dual.linear_ordered_comm_monoid", "description": ""}, {"name": "add_units.max_coe", "description": ""}, {"name": "fn_min_add_fn_max", "description": ""}, {"name": "order_dual.semigroup", "description": ""}, {"name": "with_bot.add_monoid_with_one", "description": ""}, {"name": "canonically_ordered_monoid", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "canonically_ordered_monoid.mul", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "canonically_ordered_monoid.mul_assoc", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "canonically_ordered_monoid.one", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "canonically_ordered_monoid.one_mul", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "canonically_ordered_monoid.mul_one", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "canonically_ordered_monoid.npow", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "canonically_ordered_monoid.npow_zero'", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "canonically_ordered_monoid.npow_succ'", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "canonically_ordered_monoid.mul_comm", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "canonically_ordered_monoid.le", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "canonically_ordered_monoid.lt", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "canonically_ordered_monoid.le_refl", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "canonically_ordered_monoid.le_trans", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "canonically_ordered_monoid.lt_iff_le_not_le", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "canonically_ordered_monoid.le_antisymm", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "canonically_ordered_monoid.mul_le_mul_left", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "canonically_ordered_monoid.bot", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "canonically_ordered_monoid.bot_le", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "canonically_ordered_monoid.exists_mul_of_le", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "canonically_ordered_monoid.le_self_mul", "description": "A canonically ordered monoid is an ordered commutative monoid\n in which the ordering coincides with the divisibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a * c`.\n Examples seem rare; it seems more likely that the `order_dual`\n of a naturally-occurring lattice satisfies this than the lattice\n itself (for example, dual of the lattice of ideals of a PID or\n Dedekind domain satisfy this; collections of all things \u2264 1 seem to\n be more natural that collections of all things \u2265 1)."}, {"name": "linear_ordered_cancel_comm_monoid", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.mul", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.mul_assoc", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.mul_left_cancel", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.one", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.one_mul", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.mul_one", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.npow", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.npow_zero'", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.npow_succ'", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.mul_comm", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.le", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.lt", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.le_refl", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.le_trans", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.lt_iff_le_not_le", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.le_antisymm", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.mul_le_mul_left", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.le_of_mul_le_mul_left", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.le_total", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.decidable_le", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.decidable_eq", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.decidable_lt", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.max", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.max_def", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.min", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "linear_ordered_cancel_comm_monoid.min_def", "description": " A linearly ordered cancellative commutative monoid\nis a commutative monoid with a linear order\nin which multiplication is cancellative and monotone."}, {"name": "with_zero.to_mul_bot", "description": " Making an additive monoid multiplicative then adding a zero is the same as adding a bottom\nelement then making it multiplicative."}, {"name": "function.injective.linear_ordered_cancel_add_comm_monoid", "description": "Pullback a `linear_ordered_cancel_add_comm_monoid` under an injective map."}, {"name": "prod.canonically_ordered_monoid", "description": ""}, {"name": "multiplicative.has_lt", "description": ""}, {"name": "zero_le_one_class", "description": "Typeclass for expressing that the `0` of a type is less or equal to its `1`."}, {"name": "zero_le_one_class.zero_le_one", "description": "Typeclass for expressing that the `0` of a type is less or equal to its `1`."}, {"name": "nonpos_iff_eq_zero", "description": ""}, {"name": "units.preorder", "description": ""}, {"name": "with_bot.map_one", "description": ""}, {"name": "ordered_cancel_add_comm_monoid.to_contravariant_class", "description": ""}, {"name": "linear_ordered_add_comm_monoid", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.le", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.lt", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.le_refl", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.le_trans", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.lt_iff_le_not_le", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.le_antisymm", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.le_total", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.decidable_le", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.decidable_eq", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.decidable_lt", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.max", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.max_def", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.min", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.min_def", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.add", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.add_assoc", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.zero", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.zero_add", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.add_zero", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.nsmul", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.nsmul_zero'", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.nsmul_succ'", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.add_comm", "description": "A linearly ordered additive commutative monoid."}, {"name": "linear_ordered_add_comm_monoid.add_le_add_left", "description": "A linearly ordered additive commutative monoid."}, {"name": "order_dual.right_cancel_add_monoid", "description": ""}, {"name": "zero_le_one'", "description": ""}, {"name": "with_top.coe_add", "description": ""}, {"name": "multiplicative.linear_order", "description": ""}, {"name": "additive.has_lt", "description": ""}, {"name": "has_add.to_covariant_class_left", "description": ""}, {"name": "function.injective.linear_ordered_add_comm_monoid", "description": "Pullback an `ordered_add_comm_monoid` under an injective map."}, {"name": "zero_le_two", "description": ""}, {"name": "ordered_cancel_add_comm_monoid.to_contravariant_class_left", "description": ""}, {"name": "canonically_ordered_add_monoid.has_exists_add_of_le", "description": ""}, {"name": "with_top.add_lt_top", "description": ""}, {"name": "canonically_linear_ordered_add_monoid", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.add", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.add_assoc", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.zero", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.zero_add", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.add_zero", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.nsmul", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.nsmul_zero'", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.nsmul_succ'", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.add_comm", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.le", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.lt", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.le_refl", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.le_trans", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.lt_iff_le_not_le", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.le_antisymm", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.add_le_add_left", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.bot", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.bot_le", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.exists_add_of_le", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.le_self_add", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.le_total", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.decidable_le", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.decidable_eq", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.decidable_lt", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.max", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.max_def", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.min", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_add_monoid.min_def", "description": "A canonically linear-ordered additive monoid is a canonically ordered additive monoid\n   whose ordering is a linear order."}, {"name": "linear_ordered_comm_monoid_with_zero.to_linear_ordered_comm_monoid", "description": ""}, {"name": "with_zero.ordered_comm_monoid", "description": ""}, {"name": "canonically_ordered_add_monoid", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "canonically_ordered_add_monoid.add", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "canonically_ordered_add_monoid.add_assoc", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "canonically_ordered_add_monoid.zero", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "canonically_ordered_add_monoid.zero_add", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "canonically_ordered_add_monoid.add_zero", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "canonically_ordered_add_monoid.nsmul", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "canonically_ordered_add_monoid.nsmul_zero'", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "canonically_ordered_add_monoid.nsmul_succ'", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "canonically_ordered_add_monoid.add_comm", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "canonically_ordered_add_monoid.le", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "canonically_ordered_add_monoid.lt", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "canonically_ordered_add_monoid.le_refl", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "canonically_ordered_add_monoid.le_trans", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "canonically_ordered_add_monoid.lt_iff_le_not_le", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "canonically_ordered_add_monoid.le_antisymm", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "canonically_ordered_add_monoid.add_le_add_left", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "canonically_ordered_add_monoid.bot", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "canonically_ordered_add_monoid.bot_le", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "canonically_ordered_add_monoid.exists_add_of_le", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "canonically_ordered_add_monoid.le_self_add", "description": "A canonically ordered additive monoid is an ordered commutative additive monoid\n in which the ordering coincides with the subtractibility relation,\n which is to say, `a \u2264 b` iff there exists `c` with `b = a + c`.\n This is satisfied by the natural numbers, for example, but not\n the integers or other nontrivial `ordered_add_comm_group`s."}, {"name": "ordered_cancel_comm_monoid.lt_of_mul_lt_mul_left", "description": ""}, {"name": "one_hom.with_bot_map_apply", "description": ""}, {"name": "with_top.top_ne_zero", "description": ""}, {"name": "order_dual.contravariant_class_swap_add_lt", "description": ""}, {"name": "add_lt_add_iff_of_le_of_le", "description": ""}, {"name": "units.coe_lt_coe", "description": ""}, {"name": "ordered_comm_monoid", "description": " An ordered commutative monoid is a commutative monoid\nwith a partial order such that `a \u2264 b \u2192 c * a \u2264 c * b` (multiplication is monotone)"}, {"name": "ordered_comm_monoid.mul", "description": " An ordered commutative monoid is a commutative monoid\nwith a partial order such that `a \u2264 b \u2192 c * a \u2264 c * b` (multiplication is monotone)"}, {"name": "ordered_comm_monoid.mul_assoc", "description": " An ordered commutative monoid is a commutative monoid\nwith a partial order such that `a \u2264 b \u2192 c * a \u2264 c * b` (multiplication is monotone)"}, {"name": "ordered_comm_monoid.one", "description": " An ordered commutative monoid is a commutative monoid\nwith a partial order such that `a \u2264 b \u2192 c * a \u2264 c * b` (multiplication is monotone)"}, {"name": "ordered_comm_monoid.one_mul", "description": " An ordered commutative monoid is a commutative monoid\nwith a partial order such that `a \u2264 b \u2192 c * a \u2264 c * b` (multiplication is monotone)"}, {"name": "ordered_comm_monoid.mul_one", "description": " An ordered commutative monoid is a commutative monoid\nwith a partial order such that `a \u2264 b \u2192 c * a \u2264 c * b` (multiplication is monotone)"}, {"name": "ordered_comm_monoid.npow", "description": " An ordered commutative monoid is a commutative monoid\nwith a partial order such that `a \u2264 b \u2192 c * a \u2264 c * b` (multiplication is monotone)"}, {"name": "ordered_comm_monoid.npow_zero'", "description": " An ordered commutative monoid is a commutative monoid\nwith a partial order such that `a \u2264 b \u2192 c * a \u2264 c * b` (multiplication is monotone)"}, {"name": "ordered_comm_monoid.npow_succ'", "description": " An ordered commutative monoid is a commutative monoid\nwith a partial order such that `a \u2264 b \u2192 c * a \u2264 c * b` (multiplication is monotone)"}, {"name": "ordered_comm_monoid.mul_comm", "description": " An ordered commutative monoid is a commutative monoid\nwith a partial order such that `a \u2264 b \u2192 c * a \u2264 c * b` (multiplication is monotone)"}, {"name": "ordered_comm_monoid.le", "description": " An ordered commutative monoid is a commutative monoid\nwith a partial order such that `a \u2264 b \u2192 c * a \u2264 c * b` (multiplication is monotone)"}, {"name": "ordered_comm_monoid.lt", "description": " An ordered commutative monoid is a commutative monoid\nwith a partial order such that `a \u2264 b \u2192 c * a \u2264 c * b` (multiplication is monotone)"}, {"name": "ordered_comm_monoid.le_refl", "description": " An ordered commutative monoid is a commutative monoid\nwith a partial order such that `a \u2264 b \u2192 c * a \u2264 c * b` (multiplication is monotone)"}, {"name": "ordered_comm_monoid.le_trans", "description": " An ordered commutative monoid is a commutative monoid\nwith a partial order such that `a \u2264 b \u2192 c * a \u2264 c * b` (multiplication is monotone)"}, {"name": "ordered_comm_monoid.lt_iff_le_not_le", "description": " An ordered commutative monoid is a commutative monoid\nwith a partial order such that `a \u2264 b \u2192 c * a \u2264 c * b` (multiplication is monotone)"}, {"name": "ordered_comm_monoid.le_antisymm", "description": " An ordered commutative monoid is a commutative monoid\nwith a partial order such that `a \u2264 b \u2192 c * a \u2264 c * b` (multiplication is monotone)"}, {"name": "ordered_comm_monoid.mul_le_mul_left", "description": " An ordered commutative monoid is a commutative monoid\nwith a partial order such that `a \u2264 b \u2192 c * a \u2264 c * b` (multiplication is monotone)"}, {"name": "le_iff_exists_mul'", "description": ""}, {"name": "with_bot.add_semigroup", "description": ""}, {"name": "units.max_coe", "description": ""}, {"name": "order_dual.cancel_add_monoid", "description": ""}, {"name": "add_monoid_hom.with_top_map", "description": "A version of `with_top.map` for `add_monoid_hom`s."}, {"name": "min_one", "description": ""}, {"name": "self_le_add_right", "description": ""}, {"name": "with_top.coe_add_eq_top_iff", "description": ""}, {"name": "multiplicative.preorder", "description": ""}, {"name": "linear_ordered_add_comm_monoid_with_top.to_has_top", "description": ""}, {"name": "linear_ordered_comm_monoid_with_zero.zero_le_one_class", "description": ""}, {"name": "with_zero.partial_order", "description": ""}, {"name": "function.injective.ordered_cancel_comm_monoid", "description": " Pullback an `ordered_cancel_comm_monoid` under an injective map.\nSee note [reducible non-instances]."}, {"name": "order_embedding.mul_left_apply", "description": ""}, {"name": "with_bot.add_bot", "description": ""}, {"name": "has_exists_add_of_le", "description": " An `ordered_add_comm_monoid` with one-sided 'subtraction' in the sense that\nif `a \u2264 b`, then there is some `c` for which `a + c = b`. This is a weaker version\nof the condition on canonical orderings defined by `canonically_ordered_add_monoid`."}, {"name": "has_exists_add_of_le.exists_add_of_le", "description": " An `ordered_add_comm_monoid` with one-sided 'subtraction' in the sense that\nif `a \u2264 b`, then there is some `c` for which `a + c = b`. This is a weaker version\nof the condition on canonical orderings defined by `canonically_ordered_add_monoid`."}, {"name": "with_top.coe_zero", "description": ""}, {"name": "with_top.add_eq_coe", "description": ""}, {"name": "with_bot.zero_le_one_class", "description": ""}, {"name": "with_zero.covariant_class_mul_le", "description": ""}, {"name": "with_bot.add_lt_add_iff_right", "description": ""}, {"name": "additive.ordered_add_comm_monoid", "description": ""}, {"name": "canonically_linear_ordered_monoid", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.mul", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.mul_assoc", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.one", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.one_mul", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.mul_one", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.npow", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.npow_zero'", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.npow_succ'", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.mul_comm", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.le", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.lt", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.le_refl", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.le_trans", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.lt_iff_le_not_le", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.le_antisymm", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.mul_le_mul_left", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.bot", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.bot_le", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.exists_mul_of_le", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.le_self_mul", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.le_total", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.decidable_le", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.decidable_eq", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.decidable_lt", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.max", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.max_def", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.min", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "canonically_linear_ordered_monoid.min_def", "description": "A canonically linear-ordered monoid is a canonically ordered monoid\n   whose ordering is a linear order."}, {"name": "ordered_cancel_comm_monoid.to_ordered_comm_monoid", "description": ""}, {"name": "with_top.coe_bit0", "description": ""}, {"name": "with_bot.coe_zero", "description": ""}, {"name": "order_dual.has_one", "description": ""}, {"name": "with_top.add_le_add_iff_right", "description": ""}, {"name": "with_top.contravariant_class_swap_add_lt", "description": ""}, {"name": "zero_hom.with_bot_map", "description": "A version of `with_bot.map` for `zero_hom`s"}, {"name": "order_dual.contravariant_class_add_le", "description": ""}, {"name": "option.mem_pmem", "description": ""}, {"name": "option.pmap_map", "description": ""}, {"name": "option.mem_map_of_mem", "description": ""}, {"name": "option.map_map", "description": ""}, {"name": "option.is_none_some", "description": ""}, {"name": "option.map_bind", "description": ""}, {"name": "option.bind_eq_none'", "description": ""}, {"name": "option.pmap_some", "description": ""}, {"name": "option.cases_on'", "description": " Given an element of `a : option \u03b1`, a default element `b : \u03b2` and a function `\u03b1 \u2192 \u03b2`, apply this\nfunction to `a` if it comes from `\u03b1`, and return `b` otherwise."}, {"name": "option.ne_none_iff_exists", "description": ""}, {"name": "option.cases_on'_none", "description": ""}, {"name": "option.bind_pmap", "description": ""}, {"name": "option.mem.left_unique", "description": ""}, {"name": "option.ext", "description": ""}, {"name": "option.pbind_map", "description": ""}, {"name": "option.coe_get", "description": ""}, {"name": "option.guard_eq_some'", "description": ""}, {"name": "option.cases_on'_coe", "description": ""}, {"name": "option.get_or_else_map", "description": ""}, {"name": "option.join_ne_none", "description": ""}, {"name": "option.get_or_else_some", "description": ""}, {"name": "option.pmap_none", "description": ""}, {"name": "option.orelse_none", "description": ""}, {"name": "option.get_of_mem", "description": ""}, {"name": "option.orelse_eq_none", "description": ""}, {"name": "option.map_none", "description": ""}, {"name": "option.cases_on'_some", "description": ""}, {"name": "option.get_mem", "description": ""}, {"name": "option.coe_def", "description": ""}, {"name": "option.iget_of_mem", "description": ""}, {"name": "option.map_eq_some", "description": ""}, {"name": "option.eq_some_iff_get_eq", "description": ""}, {"name": "option.lift_or_get_choice", "description": ""}, {"name": "option.join_eq_some", "description": ""}, {"name": "option.seq_some", "description": ""}, {"name": "option.some_bind", "description": ""}, {"name": "option.map_some'", "description": ""}, {"name": "option.comp_map", "description": ""}, {"name": "option.map_comp_map", "description": ""}, {"name": "option.get_some", "description": ""}, {"name": "option.some_orelse", "description": ""}, {"name": "option.get_or_else_coe", "description": ""}, {"name": "option.some_orelse'", "description": ""}, {"name": "option.pbind_eq_bind", "description": ""}, {"name": "option.pmap_eq_none_iff", "description": ""}, {"name": "option.get_or_else_none", "description": ""}, {"name": "option.bex_ne_none", "description": ""}, {"name": "option.bind_some", "description": ""}, {"name": "option.bind_eq_some", "description": ""}, {"name": "option.get_or_else_of_ne_none", "description": ""}, {"name": "option.cases_on'_none_coe", "description": ""}, {"name": "option.bind_eq_bind", "description": ""}, {"name": "option.pmap_bind", "description": ""}, {"name": "option.map_injective", "description": "`option.map f` is injective if `f` is injective."}, {"name": "option.map_coe", "description": ""}, {"name": "option.some_bind'", "description": ""}, {"name": "option.map_congr", "description": ""}, {"name": "option.some_get", "description": ""}, {"name": "option.map_some", "description": ""}, {"name": "option.join_eq_join", "description": ""}, {"name": "option.choice_eq", "description": ""}, {"name": "option.map_id'", "description": ""}, {"name": "option.map_eq_map", "description": ""}, {"name": "option.forall", "description": ""}, {"name": "option.orelse_eq_some'", "description": ""}, {"name": "option.is_none_none", "description": ""}, {"name": "option.to_list_none", "description": ""}, {"name": "option.mem_of_mem_join", "description": ""}, {"name": "option.iget_mem", "description": ""}, {"name": "option.bind_eq_none", "description": ""}, {"name": "option.is_some_some", "description": ""}, {"name": "option.choice_is_some_iff_nonempty", "description": ""}, {"name": "option.bind_assoc", "description": ""}, {"name": "option.is_some_none", "description": ""}, {"name": "option.not_is_some_iff_eq_none", "description": ""}, {"name": "option.join_ne_none'", "description": ""}, {"name": "option.lift_or_get_none_left", "description": ""}, {"name": "option.map_pbind", "description": ""}, {"name": "option.map_eq_none'", "description": ""}, {"name": "option.lift_or_get_some_some", "description": ""}, {"name": "option.mem_unique", "description": ""}, {"name": "option.join_map_eq_map_join", "description": ""}, {"name": "option.elim_none_some", "description": ""}, {"name": "option.join_eq_none", "description": ""}, {"name": "option.lift_or_get_none_right", "description": ""}, {"name": "option.choice_eq_none", "description": ""}, {"name": "option.join_pmap_eq_pmap_join", "description": ""}, {"name": "option.not_is_some", "description": ""}, {"name": "option.bind_map_comm", "description": ""}, {"name": "option.map_bind'", "description": ""}, {"name": "option.orelse_none'", "description": ""}, {"name": "option.some_injective", "description": ""}, {"name": "option.pmap_eq_map", "description": ""}, {"name": "option.pbind_eq_none", "description": ""}, {"name": "option.pmap_eq_some_iff", "description": ""}, {"name": "option.map_pmap", "description": ""}, {"name": "option.guard_eq_some", "description": ""}, {"name": "option.exists", "description": ""}, {"name": "option.none_orelse", "description": ""}, {"name": "option.none_orelse'", "description": ""}, {"name": "option.eq_none_iff_forall_not_mem", "description": ""}, {"name": "option.bind_eq_some'", "description": ""}, {"name": "option.none_bind'", "description": ""}, {"name": "option.ne_none_iff_is_some", "description": ""}, {"name": "option.choice", "description": "An arbitrary `some a` with `a : \u03b1` if `\u03b1` is nonempty, and otherwise `none`."}, {"name": "option.is_some_iff_exists", "description": ""}, {"name": "option.map_none'", "description": ""}, {"name": "option.some_ne_none", "description": ""}, {"name": "option.eq_of_mem_of_mem", "description": ""}, {"name": "option.get_or_else_default_eq_iget", "description": ""}, {"name": "option.ne_none_iff_exists'", "description": ""}, {"name": "option.to_list_some", "description": ""}, {"name": "option.pbind_eq_some", "description": ""}, {"name": "option.orelse_eq_none'", "description": ""}, {"name": "option.map_eq_some'", "description": ""}, {"name": "option.bind_id_eq_join", "description": ""}, {"name": "option.none_bind", "description": ""}, {"name": "option.not_mem_none", "description": ""}, {"name": "option.map_coe'", "description": ""}, {"name": "option.orelse_eq_some", "description": ""}, {"name": "option.join_join", "description": ""}, {"name": "option.map_eq_none", "description": ""}, {"name": "option.ball_ne_none", "description": ""}, {"name": "option.bind_comm", "description": ""}, {"name": "tactic.copy_attribute'", "description": "`copy_attribute' attr_name src tgt p d_name` copy (user) attribute `attr_name` from\n  `src` to `tgt` if it is defined for `src`; unlike `copy_attribute` the primed version also copies\n  the parameter of the user attribute, in the user attribute case. Make it persistent if `p` is\n  `tt`; if `p` is `none`, the copied attribute is made persistent iff it is persistent on `src`"}, {"name": "tactic.additive_test", "description": "`additive_test f replace_all ignore e` tests whether the expression `e` contains no constant\n`nm` that is not applied to any arguments, and such that `f nm = none`.\nThis is used in `@[to_additive]` for deciding which subexpressions to transform: we only transform\nconstants if `additive_test` applied to their first argument returns `tt`.\nThis means we will replace expression applied to e.g. `\u03b1` or `\u03b1 \u00d7 \u03b2`, but not when applied to\ne.g. `\u2115` or `\u211d \u00d7 \u03b1`.\n`f` is the dictionary of declarations that are in the `to_additive` dictionary.\nWe ignore all arguments specified in the `name_map` `ignore`.\nIf `replace_all` is `tt` the test always return `tt`."}, {"name": "tactic.additive_test_aux", "description": " Auxilliary function for `additive_test`. The bool argument *only* matters when applied\nto exactly a constant."}, {"name": "tactic.transform_decl_with_prefix_fun", "description": "Make a new copy of a declaration,\nreplacing fragments of the names of identifiers in the type and the body using the function `f`.\nThis is used to implement `@[to_additive]`."}, {"name": "tactic.transform_decl_with_prefix_fun_aux", "description": " transform the declaration `src` and all declarations `pre._proof_i` occurring in `src`\nusing the dictionary `f`.\n`replace_all`, `trace`, `ignore` and `reorder` are configuration options.\n`pre` is the declaration that got the `@[to_additive]` attribute and `tgt_pre` is the target of this\ndeclaration."}, {"name": "tactic.transform_decl_with_prefix_dict", "description": "Make a new copy of a declaration, replacing fragments of the names of identifiers in the type and\nthe body using the dictionary `dict`.\nThis is used to implement `@[to_additive]`."}, {"name": "tactic.tidy.ext1_wrapper", "description": ""}, {"name": "tactic.tidy_hole_cmd", "description": " Invoking the hole command `tidy` (\"Use `tidy` to complete the goal\") runs the tactic of\nthe same name, replacing the hole with the tactic script `tidy` produces."}, {"name": "tactic.tidy", "description": ""}, {"name": "tactic_doc.hole_command.tidy", "description": " Invoking the hole command `tidy` (\"Use `tidy` to complete the goal\") runs the tactic of\nthe same name, replacing the hole with the tactic script `tidy` produces."}, {"name": "tactic.tidy.default_tactics", "description": ""}, {"name": "tactic.tidy.cfg", "description": ""}, {"name": "tactic.tidy.cfg.trace_result", "description": ""}, {"name": "tactic.tidy.cfg.trace_result_prefix", "description": ""}, {"name": "tactic.tidy.cfg.tactics", "description": ""}, {"name": "tactic_doc.attribute.tidy", "description": " Tag interactive tactics (locally) with `[tidy]` to add them to the list of default tactics\ncalled by `tidy`."}, {"name": "tactic.tidy.tidy_attribute", "description": " Tag interactive tactics (locally) with `[tidy]` to add them to the list of default tactics\ncalled by `tidy`."}, {"name": "tactic.tidy.core", "description": ""}, {"name": "tactic_doc.tactic.tidy", "description": " Use a variety of conservative tactics to solve goals.\n\n`tidy?` reports back the tactic script it found. As an example\n```lean\nexample : \u2200 x : unit, x = unit.star :=\nbegin\n  tidy? -- Prints the trace message: \"Try this: intros x, exact dec_trivial\"\nend\n```\n\nThe default list of tactics is stored in `tactic.tidy.default_tidy_tactics`.\nThis list can be overridden using `tidy { tactics := ... }`.\n(The list must be a `list` of `tactic string`, so that `tidy?`\ncan report a usable tactic script.)\n\nTactics can also be added to the list by tagging them (locally) with the\n`[tidy]` attribute."}, {"name": "tactic.tidy.run_tactics", "description": ""}, {"name": "tactic.interactive.tidy", "description": " Use a variety of conservative tactics to solve goals.\n\n`tidy?` reports back the tactic script it found. As an example\n```lean\nexample : \u2200 x : unit, x = unit.star :=\nbegin\n  tidy? -- Prints the trace message: \"Try this: intros x, exact dec_trivial\"\nend\n```\n\nThe default list of tactics is stored in `tactic.tidy.default_tidy_tactics`.\nThis list can be overridden using `tidy { tactics := ... }`.\n(The list must be a `list` of `tactic string`, so that `tidy?`\ncan report a usable tactic script.)\n\nTactics can also be added to the list by tagging them (locally) with the\n`[tidy]` attribute."}, {"name": "category_theory.functor.map_surjective", "description": ""}, {"name": "category_theory.fully_faithful_cancel_right", "description": "Given a natural isomorphism between `F \u22d9 H` and `G \u22d9 H` for a fully faithful functor `H`, we\ncan 'cancel' it to give a natural iso between `F` and `G`."}, {"name": "category_theory.functor.preimage_iso_hom", "description": ""}, {"name": "category_theory.functor.preimage_iso", "description": "If `F : C \u2964 D` is fully faithful, every isomorphism `F.obj X \u2245 F.obj Y` has a preimage."}, {"name": "category_theory.faithful.id", "description": ""}, {"name": "category_theory.iso_equiv_of_fully_faithful", "description": "If `F` is fully faithful, we have an equivalence of iso-sets `X \u2245 Y` and `F X \u2245 F Y`."}, {"name": "category_theory.fully_faithful_cancel_right_inv_app", "description": ""}, {"name": "category_theory.equiv_of_fully_faithful", "description": "If `F` is fully faithful, we have an equivalence of hom-sets `X \u27f6 Y` and `F X \u27f6 F Y`."}, {"name": "category_theory.functor.map_iso_injective", "description": ""}, {"name": "category_theory.faithful.of_iso", "description": ""}, {"name": "category_theory.functor.preimage_iso_map_iso", "description": ""}, {"name": "category_theory.full.of_iso", "description": "If `F` is full, and naturally isomorphic to some `F'`, then `F'` is also full."}, {"name": "category_theory.equiv_of_fully_faithful_symm_apply", "description": ""}, {"name": "category_theory.faithful", "description": "A functor `F : C \u2964 D` is faithful if for each `X Y : C`, `F.map` is injective.\n\nSee <https://stacks.math.columbia.edu/tag/001C>."}, {"name": "category_theory.faithful.map_injective'", "description": "A functor `F : C \u2964 D` is faithful if for each `X Y : C`, `F.map` is injective.\n\nSee <https://stacks.math.columbia.edu/tag/001C>."}, {"name": "category_theory.functor.full_of_exists", "description": "Deduce that `F` is full from the existence of preimages, using choice."}, {"name": "category_theory.faithful.div_faithful", "description": ""}, {"name": "category_theory.functor.preimage", "description": "The specified preimage of a morphism under a full functor."}, {"name": "category_theory.nat_iso_of_comp_fully_faithful", "description": " We can construct a natural isomorphism between functors by constructing a natural isomorphism\nbetween those functors composed with a fully faithful functor."}, {"name": "category_theory.faithful.comp", "description": ""}, {"name": "category_theory.preimage_comp", "description": ""}, {"name": "category_theory.nat_iso_of_comp_fully_faithful_hom_app", "description": ""}, {"name": "category_theory.nat_trans_of_comp_fully_faithful_app", "description": ""}, {"name": "category_theory.full", "description": "A functor `F : C \u2964 D` is full if for each `X Y : C`, `F.map` is surjective.\nIn fact, we use a constructive definition, so the `full F` typeclass contains data,\nspecifying a particular preimage of each `f : F.obj X \u27f6 F.obj Y`.\n\nSee <https://stacks.math.columbia.edu/tag/001C>."}, {"name": "category_theory.full.preimage", "description": "A functor `F : C \u2964 D` is full if for each `X Y : C`, `F.map` is surjective.\nIn fact, we use a constructive definition, so the `full F` typeclass contains data,\nspecifying a particular preimage of each `f : F.obj X \u27f6 F.obj Y`.\n\nSee <https://stacks.math.columbia.edu/tag/001C>."}, {"name": "category_theory.full.witness'", "description": "A functor `F : C \u2964 D` is full if for each `X Y : C`, `F.map` is surjective.\nIn fact, we use a constructive definition, so the `full F` typeclass contains data,\nspecifying a particular preimage of each `f : F.obj X \u27f6 F.obj Y`.\n\nSee <https://stacks.math.columbia.edu/tag/001C>."}, {"name": "category_theory.is_iso_of_fully_faithful", "description": "If the image of a morphism under a fully faithful functor in an isomorphism,\nthen the original morphisms is also an isomorphism."}, {"name": "category_theory.equiv_of_fully_faithful_apply", "description": ""}, {"name": "category_theory.iso.faithful_of_comp", "description": "**Alias** of `category_theory.faithful.of_comp_iso`."}, {"name": "category_theory.iso_equiv_of_fully_faithful_symm_apply", "description": ""}, {"name": "category_theory.iso_equiv_of_fully_faithful_apply", "description": ""}, {"name": "category_theory.nat_iso_of_comp_fully_faithful_inv", "description": ""}, {"name": "category_theory.nat_iso_of_comp_fully_faithful_hom", "description": ""}, {"name": "category_theory.faithful.of_comp_iso", "description": ""}, {"name": "category_theory.faithful.of_comp_eq", "description": ""}, {"name": "category_theory.functor.full_of_surjective", "description": "Deduce that `F` is full from surjectivity of `F.map`, using choice."}, {"name": "category_theory.nat_iso_of_comp_fully_faithful_inv_app", "description": ""}, {"name": "category_theory.preimage_map", "description": ""}, {"name": "category_theory.functor.map_injective", "description": ""}, {"name": "category_theory.full.id", "description": ""}, {"name": "category_theory.full.comp", "description": ""}, {"name": "category_theory.faithful.map_injective", "description": ""}, {"name": "category_theory.nat_trans_of_comp_fully_faithful", "description": " We can construct a natural transformation between functors by constructing a\nnatural transformation between those functors composed with a fully faithful functor."}, {"name": "eq.faithful_of_comp", "description": "**Alias** of `category_theory.faithful.of_comp_eq`."}, {"name": "category_theory.full.witness", "description": ""}, {"name": "category_theory.full.of_comp_faithful", "description": "If `F \u22d9 G` is full and `G` is faithful, then `F` is full."}, {"name": "category_theory.faithful.div_comp", "description": ""}, {"name": "category_theory.functor.preimage_iso_inv", "description": ""}, {"name": "category_theory.faithful.div", "description": "\u201cDivide\u201d a functor by a faithful functor."}, {"name": "category_theory.full.of_comp_faithful_iso", "description": "If `F \u22d9 G` is full and `G` is faithful, then `F` is full."}, {"name": "category_theory.functor.image_preimage", "description": ""}, {"name": "category_theory.fully_faithful_cancel_right_hom_app", "description": ""}, {"name": "category_theory.faithful.of_comp", "description": ""}, {"name": "category_theory.preimage_id", "description": ""}, {"name": "add_add_monoid_hom", "description": "Addition as an additive monoid homomorphism."}, {"name": "add_equiv.coe_prod_comm", "description": ""}, {"name": "prod.mk_sub_mk", "description": ""}, {"name": "monoid_hom.inr_apply", "description": ""}, {"name": "div_monoid_hom_apply", "description": ""}, {"name": "prod.add_zero_class", "description": ""}, {"name": "prod.semigroup_with_zero", "description": ""}, {"name": "monoid_hom.coe_fst", "description": ""}, {"name": "mul_equiv.prod_congr", "description": "Product of multiplicative isomorphisms; the maps come from `equiv.prod_congr`."}, {"name": "monoid_hom.coprod_unique", "description": ""}, {"name": "add_equiv.unique_prod", "description": "Multiplying by the trivial monoid doesn't change the structure."}, {"name": "mul_hom.prod_comp_prod_map", "description": ""}, {"name": "add_monoid_hom.fst_comp_inr", "description": ""}, {"name": "add_hom.snd_comp_prod", "description": ""}, {"name": "monoid_hom.prod_apply", "description": ""}, {"name": "prod.one_eq_mk", "description": ""}, {"name": "prod.right_cancel_add_semigroup", "description": ""}, {"name": "mul_monoid_with_zero_hom", "description": "Multiplication as a multiplicative homomorphism with zero."}, {"name": "prod.add_comm_group", "description": ""}, {"name": "add_hom.prod_apply", "description": ""}, {"name": "prod.cancel_comm_monoid", "description": ""}, {"name": "prod.snd_div", "description": ""}, {"name": "units.embed_product_apply", "description": ""}, {"name": "prod.semigroup", "description": ""}, {"name": "prod.snd_add", "description": ""}, {"name": "mul_hom.coe_snd", "description": ""}, {"name": "mul_monoid_hom_apply", "description": ""}, {"name": "prod.mk_add_mk", "description": ""}, {"name": "prod.has_neg", "description": ""}, {"name": "add_monoid_hom.coe_fst", "description": ""}, {"name": "prod.snd_mul", "description": ""}, {"name": "mul_hom.coe_fst", "description": ""}, {"name": "add_equiv.prod_add_units", "description": "The additive monoid equivalence between additive units of a product\nof two additive monoids, and the product of the additive units of each additive monoid."}, {"name": "prod.fst_mul", "description": ""}, {"name": "prod.zero_eq_mk", "description": ""}, {"name": "units.embed_product", "description": " Canonical homomorphism of monoids from `\u03b1\u02e3` into `\u03b1 \u00d7 \u03b1\u1d50\u1d52\u1d56`.\nUsed mainly to define the natural topology of `\u03b1\u02e3`."}, {"name": "prod.cancel_add_comm_monoid", "description": ""}, {"name": "add_hom.coe_prod_map", "description": ""}, {"name": "add_monoid_hom.prod", "description": "Combine two `add_monoid_hom`s `f : M \u2192+ N`, `g : M \u2192+ P` into\n`f.prod g : M \u2192+ N \u00d7 P` given by `(f.prod g) x = (f x, g x)`"}, {"name": "prod.has_mul", "description": ""}, {"name": "mul_hom.prod", "description": " Combine two `monoid_hom`s `f : M \u2192\u2099* N`, `g : M \u2192\u2099* P` into\n`f.prod g : M \u2192\u2099* (N \u00d7 P)` given by `(f.prod g) x = (f x, g x)`."}, {"name": "add_hom.coe_prod", "description": ""}, {"name": "add_equiv.coe_prod_comm_symm", "description": ""}, {"name": "div_monoid_with_zero_hom", "description": "Division as a multiplicative homomorphism with zero."}, {"name": "prod.monoid", "description": ""}, {"name": "add_monoid_hom.snd_comp_inl", "description": ""}, {"name": "mul_hom.coe_prod_map", "description": ""}, {"name": "prod.mul_one_class", "description": ""}, {"name": "add_monoid_hom.snd_comp_prod", "description": ""}, {"name": "prod.swap_mul", "description": ""}, {"name": "prod.mul_zero_class", "description": ""}, {"name": "prod.has_div", "description": ""}, {"name": "monoid_hom.coprod_comp_inr", "description": ""}, {"name": "prod.fst_div", "description": ""}, {"name": "prod.div_inv_monoid", "description": ""}, {"name": "add_monoid_hom.coe_prod", "description": ""}, {"name": "monoid_hom.fst_comp_inr", "description": ""}, {"name": "mul_equiv.prod_units", "description": "The monoid equivalence between units of a product of two monoids, and the product of the\n   units of each monoid."}, {"name": "add_monoid_hom.coprod_unique", "description": ""}, {"name": "monoid_hom.fst_comp_inl", "description": ""}, {"name": "monoid_hom.fst", "description": "Given monoids `M`, `N`, the natural projection homomorphism from `M \u00d7 N` to `M`."}, {"name": "add_monoid_hom.prod_apply", "description": ""}, {"name": "prod.add_comm_monoid", "description": ""}, {"name": "prod.add_monoid", "description": ""}, {"name": "prod.right_cancel_add_monoid", "description": ""}, {"name": "add_units.embed_product", "description": "Canonical homomorphism of additive monoids from `add_units \u03b1` into `\u03b1 \u00d7 \u03b1\u1d43\u1d52\u1d56`.\nUsed mainly to define the natural topology of `add_units \u03b1`."}, {"name": "prod.has_one", "description": ""}, {"name": "monoid_hom.inl", "description": "Given monoids `M`, `N`, the natural inclusion homomorphism from `M` to `M \u00d7 N`."}, {"name": "prod.left_cancel_monoid", "description": ""}, {"name": "prod.inv_mk", "description": ""}, {"name": "mul_equiv.coe_prod_comm_symm", "description": ""}, {"name": "add_monoid_hom.snd_comp_inr", "description": ""}, {"name": "prod.add_group", "description": ""}, {"name": "prod.division_monoid", "description": ""}, {"name": "sub_add_monoid_hom", "description": "Subtraction as an additive monoid homomorphism."}, {"name": "add_monoid_hom.fst_comp_prod", "description": ""}, {"name": "prod.cancel_add_monoid", "description": ""}, {"name": "add_monoid_hom.coe_snd", "description": ""}, {"name": "add_monoid_hom.prod_map", "description": "`prod.map` as an `add_monoid_hom`"}, {"name": "add_hom.prod_map_def", "description": ""}, {"name": "add_hom.prod_comp_prod_map", "description": ""}, {"name": "add_hom.snd", "description": "Given additive magmas `A`, `B`, the natural projection homomorphism\nfrom `A \u00d7 B` to `B`"}, {"name": "add_monoid_hom.fst_comp_inl", "description": ""}, {"name": "monoid_hom.coe_prod_map", "description": ""}, {"name": "prod.has_involutive_inv", "description": ""}, {"name": "monoid_hom.snd", "description": "Given monoids `M`, `N`, the natural projection homomorphism from `M \u00d7 N` to `N`."}, {"name": "prod.fst_mul_snd", "description": ""}, {"name": "prod.fst_neg", "description": ""}, {"name": "add_hom.prod_map", "description": "`prod.map` as an `add_monoid_hom`"}, {"name": "add_monoid_hom.prod_map_def", "description": ""}, {"name": "mul_hom.coprod", "description": " Coproduct of two `mul_hom`s with the same codomain:\n`f.coprod g (p : M \u00d7 N) = f p.1 * g p.2`."}, {"name": "add_units.embed_product_injective", "description": ""}, {"name": "mul_hom.prod_map", "description": "`prod.map` as a `monoid_hom`."}, {"name": "prod.left_cancel_add_semigroup", "description": ""}, {"name": "prod.add_semigroup", "description": ""}, {"name": "add_equiv.prod_congr", "description": "Product of additive isomorphisms; the maps come from `equiv.prod_congr`."}, {"name": "monoid_hom.coe_snd", "description": ""}, {"name": "prod.neg_mk", "description": ""}, {"name": "prod.subtraction_comm_monoid", "description": ""}, {"name": "prod.has_zero", "description": ""}, {"name": "add_monoid_hom.prod_comp_prod_map", "description": ""}, {"name": "add_monoid_hom.inl", "description": "Given additive monoids `A`, `B`, the natural inclusion homomorphism\nfrom `A` to `A \u00d7 B`."}, {"name": "prod.monoid_with_zero", "description": ""}, {"name": "add_monoid_hom.coprod_comp_inl", "description": ""}, {"name": "prod.swap_div", "description": ""}, {"name": "add_hom.prod_unique", "description": ""}, {"name": "monoid_hom.coprod", "description": " Coproduct of two `monoid_hom`s with the same codomain:\n`f.coprod g (p : M \u00d7 N) = f p.1 * g p.2`."}, {"name": "prod.sub_neg_monoid", "description": ""}, {"name": "prod.mk_eq_zero", "description": ""}, {"name": "prod.right_cancel_semigroup", "description": ""}, {"name": "prod.comm_group", "description": ""}, {"name": "prod.fst_zero", "description": ""}, {"name": "prod.swap_neg", "description": ""}, {"name": "sub_add_monoid_hom_apply", "description": ""}, {"name": "prod.snd_one", "description": ""}, {"name": "prod.subtraction_monoid", "description": ""}, {"name": "prod.snd_zero", "description": ""}, {"name": "add_hom.coprod_apply", "description": ""}, {"name": "mul_hom.coprod_apply", "description": ""}, {"name": "prod.has_involutive_neg", "description": ""}, {"name": "prod.swap_sub", "description": ""}, {"name": "add_equiv.prod_unique", "description": "Multiplying by the trivial monoid doesn't change the structure."}, {"name": "mul_hom.prod_map_def", "description": ""}, {"name": "mul_mul_hom_apply", "description": ""}, {"name": "add_monoid_hom.coprod_inl_inr", "description": ""}, {"name": "add_monoid_hom.coprod", "description": "Coproduct of two `add_monoid_hom`s with the same codomain:\n`f.coprod g (p : M \u00d7 N) = f p.1 + g p.2`."}, {"name": "mul_equiv.coe_prod_comm", "description": ""}, {"name": "prod.comm_monoid", "description": ""}, {"name": "mul_hom.prod_unique", "description": ""}, {"name": "add_monoid_hom.coe_prod_map", "description": ""}, {"name": "monoid_hom.inl_apply", "description": ""}, {"name": "prod.swap_zero", "description": ""}, {"name": "add_monoid_hom.comp_coprod", "description": ""}, {"name": "prod.add_comm_semigroup", "description": ""}, {"name": "prod.swap_one", "description": ""}, {"name": "monoid_hom.snd_comp_inl", "description": ""}, {"name": "add_monoid_hom.inr", "description": "Given additive monoids `A`, `B`, the natural inclusion homomorphism\nfrom `B` to `A \u00d7 B`."}, {"name": "prod.snd_sub", "description": ""}, {"name": "prod.fst_add", "description": ""}, {"name": "add_hom.prod", "description": "Combine two `add_monoid_hom`s `f : add_hom M N`, `g : add_hom M P` into\n`f.prod g : add_hom M (N \u00d7 P)` given by `(f.prod g) x = (f x, g x)`"}, {"name": "mul_equiv.prod_comm", "description": " The equivalence between `M \u00d7 N` and `N \u00d7 M` given by swapping the components\nis multiplicative."}, {"name": "prod.cancel_monoid", "description": ""}, {"name": "add_monoid_hom.fst", "description": "Given additive monoids `A`, `B`, the natural projection homomorphism\nfrom `A \u00d7 B` to `A`"}, {"name": "prod.mk_eq_one", "description": ""}, {"name": "monoid_hom.prod_map", "description": "`prod.map` as a `monoid_hom`."}, {"name": "monoid_hom.snd_comp_inr", "description": ""}, {"name": "div_monoid_hom", "description": "Division as a monoid homomorphism."}, {"name": "monoid_hom.coprod_inl_inr", "description": ""}, {"name": "prod.snd_inv", "description": ""}, {"name": "monoid_hom.prod_unique", "description": ""}, {"name": "monoid_hom.coprod_apply", "description": ""}, {"name": "add_monoid_hom.coprod_apply", "description": ""}, {"name": "add_add_monoid_hom_apply", "description": ""}, {"name": "mul_equiv.unique_prod", "description": "Multiplying by the trivial monoid doesn't change the structure."}, {"name": "prod.has_sub", "description": ""}, {"name": "prod.left_cancel_add_monoid", "description": ""}, {"name": "add_monoid_hom.inl_apply", "description": ""}, {"name": "monoid_hom.inr", "description": "Given monoids `M`, `N`, the natural inclusion homomorphism from `N` to `M \u00d7 N`."}, {"name": "add_add_hom_apply", "description": ""}, {"name": "prod.swap_add", "description": ""}, {"name": "prod.swap_inv", "description": ""}, {"name": "mul_hom.fst", "description": "Given magmas `M`, `N`, the natural projection homomorphism from `M \u00d7 N` to `M`."}, {"name": "mul_hom.coe_prod", "description": ""}, {"name": "monoid_hom.coprod_comp_inl", "description": ""}, {"name": "prod.right_cancel_monoid", "description": ""}, {"name": "mul_mul_hom", "description": "Multiplication as a multiplicative homomorphism."}, {"name": "add_units.embed_product_apply", "description": ""}, {"name": "add_monoid_hom.snd", "description": "Given additive monoids `A`, `B`, the natural projection homomorphism\nfrom `A \u00d7 B` to `B`"}, {"name": "prod.snd_neg", "description": ""}, {"name": "monoid_hom.coe_prod", "description": ""}, {"name": "prod.fst_one", "description": ""}, {"name": "prod.mk_div_mk", "description": ""}, {"name": "prod.has_inv", "description": ""}, {"name": "mul_hom.fst_comp_prod", "description": ""}, {"name": "mul_monoid_hom", "description": "Multiplication as a monoid homomorphism."}, {"name": "prod.has_add", "description": ""}, {"name": "mul_hom.prod_apply", "description": ""}, {"name": "prod.division_comm_monoid", "description": ""}, {"name": "prod.mul_def", "description": ""}, {"name": "mul_hom.snd_comp_prod", "description": ""}, {"name": "monoid_hom.snd_comp_prod", "description": ""}, {"name": "prod.comm_semigroup", "description": ""}, {"name": "add_monoid_hom.inr_apply", "description": ""}, {"name": "div_monoid_with_zero_hom_apply", "description": ""}, {"name": "mul_hom.comp_coprod", "description": ""}, {"name": "monoid_hom.prod_map_def", "description": ""}, {"name": "prod.comm_monoid_with_zero", "description": ""}, {"name": "add_hom.coprod", "description": "Coproduct of two `add_hom`s with the same codomain:\n`f.coprod g (p : M \u00d7 N) = f p.1 + g p.2`."}, {"name": "monoid_hom.prod", "description": " Combine two `monoid_hom`s `f : M \u2192* N`, `g : M \u2192* P` into `f.prod g : M \u2192* N \u00d7 P`\ngiven by `(f.prod g) x = (f x, g x)`."}, {"name": "prod.group", "description": ""}, {"name": "monoid_hom.comp_coprod", "description": ""}, {"name": "mul_equiv.prod_unique", "description": "Multiplying by the trivial monoid doesn't change the structure."}, {"name": "add_hom.coe_fst", "description": ""}, {"name": "prod.add_def", "description": ""}, {"name": "add_add_hom", "description": "Addition as an additive homomorphism."}, {"name": "prod.fst_inv", "description": ""}, {"name": "units.embed_product_injective", "description": ""}, {"name": "mul_hom.snd", "description": "Given magmas `M`, `N`, the natural projection homomorphism from `M \u00d7 N` to `N`."}, {"name": "monoid_hom.prod_comp_prod_map", "description": ""}, {"name": "prod.mul_zero_one_class", "description": ""}, {"name": "add_monoid_hom.coprod_comp_inr", "description": ""}, {"name": "add_hom.fst", "description": "Given additive magmas `A`, `B`, the natural projection homomorphism\nfrom `A \u00d7 B` to `A`"}, {"name": "add_hom.fst_comp_prod", "description": ""}, {"name": "monoid_hom.fst_comp_prod", "description": ""}, {"name": "add_hom.coe_snd", "description": ""}, {"name": "add_monoid_hom.prod_unique", "description": ""}, {"name": "add_equiv.prod_comm", "description": "The equivalence between `M \u00d7 N` and `N \u00d7 M` given by swapping the\ncomponents is additive."}, {"name": "prod.fst_sub", "description": ""}, {"name": "prod.left_cancel_semigroup", "description": ""}, {"name": "prod.mk_mul_mk", "description": ""}, {"name": "add_hom.comp_coprod", "description": ""}, {"name": "mul_monoid_with_zero_hom_apply", "description": ""}, {"name": "prod.fst_add_snd", "description": ""}, {"name": "tactic.unsafe.type_context.get_env", "description": ""}, {"name": "tactic.unsafe.type_context.level.instantiate_mvars", "description": ""}, {"name": "tactic.unsafe.type_context.kabstract", "description": "Abstracts all occurrences of the term `t` in `e` using keyed matching.\n   If `unify` is `ff`, then matching is used instead of unification.\n   That is, metavariables occurring in `e` are not assigned."}, {"name": "tactic.unsafe.type_context.bind", "description": ""}, {"name": "tactic.unsafe.type_context.get_fun_info", "description": "Same as tactic.get_fun_info"}, {"name": "tactic.unsafe.type_context.whnf", "description": ""}, {"name": "tactic.unsafe.type_context.list_mvars", "description": ""}, {"name": "tactic.unsafe.type_context.fold_mvars", "description": "Iterate over all mvars in the mvar context."}, {"name": "tactic.unsafe.type_context.run", "description": " Runs the given type_context monad using the type context of the current tactic state.\nYou can use this to perform unsafe operations such as direct metavariable assignment and the use of temporary metavariables."}, {"name": "tactic.unsafe.type_context.level.tmp_get_assignment", "description": ""}, {"name": "tactic.unsafe.type_context.monad_fail", "description": ""}, {"name": "tactic.unsafe.type_context.mk_mvar", "description": "Create and declare a new metavariable. If the local context is not given then it will use the current local context."}, {"name": "tactic.unsafe.type_context.assign", "description": " Set the mvar to the following assignments.\nWorks for temporary metas too.\n[WARNING] `assign` does not perform certain checks:\n- No typecheck is done before assignment.\n- If the metavariable is already assigned this will clobber the assignment.\n- It will not stop you from assigning an metavariable to itself or creating cycles of metavariable assignments.\n  These will manifest as 'deep recursion' exceptions when `instantiate_mvars` is used.\n- It is not checked whether the assignment uses local constants outside the declaration's context.\n\nYou can avoid the unsafety by using `unify` instead."}, {"name": "tactic.unsafe.type_context.level.mk_tmp_mvar", "description": ""}, {"name": "tactic.unsafe.type_context.tmp_mode", "description": " Run the given `type_context` monad in a temporary mvar scope.\nDoing this twice will push the old tmp_mvar assignments to a stack.\nSo it is safe to do this whether or not you are already in tmp mode."}, {"name": "tactic.unsafe.type_context.get_assignment", "description": "Get the expression that is assigned to the given mvar expression. Fails if given a"}, {"name": "tactic.unsafe.type_context.is_stuck", "description": " A stuck expression `e` is an expression that _would_ reduce,\nexcept that a metavariable is present that prevents the reduction.\nReturns the metavariable which is causing the stuckage.\nFor example, `@has_add.add nat ?m a b` can't project because `?m` is not given."}, {"name": "tactic.unsafe.type_context.is_declared", "description": "Returns true if the given expression is a declared local constant or a declared metavariable."}, {"name": "tactic.unsafe.type_context.monad", "description": ""}, {"name": "tactic.unsafe.type_context.print_mvars", "description": ""}, {"name": "tactic.unsafe.type_context.unify", "description": ""}, {"name": "tactic.unsafe.type_context.is_regular_mvar", "description": ""}, {"name": "tactic.unsafe.type_context", "description": " A monad that exposes the functionality of the C++ class `type_context_old`.\nThe idea is that the methods to `type_context` are more powerful but _unsafe_ in the\nsense that you can create terms that do not typecheck or that are infinitely descending.\nUnder the hood, `type_context` is implemented as a reader monad, with a mutable `type_context` object."}, {"name": "tactic.unsafe.type_context.infer", "description": " Infer the type of the given expr. Inferring the type does not mean that it typechecks.\nWill fail if type can't be inferred."}, {"name": "tactic.unsafe.type_context.to_tmp_mvars", "description": "Replace each metavariable in the given expression with a temporary metavariable."}, {"name": "tactic.unsafe.type_context.is_tmp_mvar", "description": ""}, {"name": "tactic.unsafe.type_context.in_tmp_mode", "description": "Returns true when in temp mode."}, {"name": "tactic.unsafe.type_context.is_assigned", "description": ""}, {"name": "tactic.unsafe.type_context.instantiate_mvars", "description": ""}, {"name": "tactic.unsafe.type_context.orelse", "description": ""}, {"name": "tactic.unsafe.type_context.get_context", "description": "Given a metavariable, returns the local context that the metavariable was declared with."}, {"name": "tactic.unsafe.type_context.trace", "description": ""}, {"name": "tactic.unsafe.type_context.try", "description": " Run the provided type_context within a backtracking scope.\nThis means that any changes to the metavariable context will not be committed if the inner monad fails.\n[warning]: the local context modified by `push_local` and `pop_local` is not affected by `try`.\nAny unpopped locals will be present after the `try` even if the inner `type_context` failed."}, {"name": "tactic.unsafe.type_context.level.assign", "description": "Assigns a given level metavariable."}, {"name": "tactic.unsafe.type_context.tmp_get_assignment", "description": ""}, {"name": "tactic.unsafe.type_context.is_def_eq", "description": ""}, {"name": "tactic.unsafe.type_context.tmp_is_assigned", "description": ""}, {"name": "tactic.unsafe.type_context.failure", "description": ""}, {"name": "tactic.unsafe.type_context.kdepends_on", "description": "Return tt iff `t` \"occurs\" in `e`. The occurrence checking is performed using\n   keyed matching with the given transparency setting.\n\n   We say `t` occurs in `e` by keyed matching iff there is a subterm `s`\n   s.t. `t` and `s` have the same head, and `is_def_eq t s md`\n\n   The main idea is to minimize the number of `is_def_eq` checks\n   performed."}, {"name": "tactic.unsafe.type_context.fail", "description": ""}, {"name": "tactic.unsafe.type_context.level.tmp_is_assigned", "description": ""}, {"name": "tactic.unsafe.type_context.pop_local", "description": ""}, {"name": "tactic.unsafe.type_context.get_local_context", "description": "Get the local context of the type_context."}, {"name": "tactic.unsafe.type_context.mk_tmp_mvar", "description": ""}, {"name": "tactic.unsafe.type_context.push_local", "description": "Add a local to the tc local context."}, {"name": "tactic.unsafe.type_context.pure", "description": ""}, {"name": "tactic.unsafe.type_context.type_context_alternative", "description": ""}, {"name": "functor.const.mk'", "description": " `const.mk'` is `const.mk` but specialized to map `\u03b1` to\n`const \u03b1 punit`, where `punit` is the terminal object in `Type*`."}, {"name": "functor.map_comp_map", "description": ""}, {"name": "functor.supp", "description": " If we consider `x : F \u03b1` to, in some sense, contain values of type `\u03b1`, then\n`supp x` is the set of values of type `\u03b1` that `x` contains."}, {"name": "functor.comp.has_seq", "description": ""}, {"name": "functor.comp.applicative", "description": ""}, {"name": "functor.const", "description": " `const \u03b1` is the constant functor, mapping every type to `\u03b1`. When\n`\u03b1` has a monoid structure, `const \u03b1` has an `applicative` instance.\n(If `\u03b1` has an additive monoid structure, see `functor.add_const`.)"}, {"name": "functor.liftp", "description": " If we consider `x : F \u03b1` to, in some sense, contain values of type `\u03b1`,\npredicate `liftp p x` holds iff every value contained by `x` satisfies `p`."}, {"name": "functor.comp.ext", "description": ""}, {"name": "functor.comp.functor", "description": ""}, {"name": "functor.const.ext", "description": ""}, {"name": "functor.comp.comp_map", "description": ""}, {"name": "functor.const.is_lawful_functor", "description": ""}, {"name": "functor.comp.run_pure", "description": ""}, {"name": "functor.comp.map_mk", "description": ""}, {"name": "functor.add_const.inhabited", "description": ""}, {"name": "functor.comp.map", "description": "The map operation for the composition `comp F G` of functors `F` and `G`."}, {"name": "functor.add_const.functor", "description": ""}, {"name": "functor.comp.functor_id_comp", "description": ""}, {"name": "functor.comp.functor_comp_id", "description": ""}, {"name": "functor.add_const.is_lawful_functor", "description": ""}, {"name": "functor.comp", "description": "`functor.comp` is a wrapper around `function.comp` for types.\n   It prevents Lean's type class resolution mechanism from trying\n   a `functor (comp F id)` when `functor F` would do."}, {"name": "functor.const.mk", "description": " `const.mk` is the canonical map `\u03b1 \u2192 const \u03b1 \u03b2` (the identity), and\nit can be used as a pattern to extract this value."}, {"name": "functor.comp.seq", "description": "The `<*>` operation for the composition of applicative functors."}, {"name": "functor.map_id", "description": ""}, {"name": "functor.comp.run", "description": "Extract a term of `F (G \u03b1)` from a term of `comp F G \u03b1`, which is the same type."}, {"name": "functor.add_const.mk", "description": " `add_const.mk` is the canonical map `\u03b1 \u2192 add_const \u03b1 \u03b2`, which is the identity,\nwhere `add_const \u03b1 \u03b2 = const \u03b1 \u03b2`. It can be used as a pattern to extract this value."}, {"name": "id.mk", "description": " Introduce the `id` functor. Incidentally, this is `pure` for\n`id` as a `monad` and as an `applicative` functor."}, {"name": "functor.comp.is_lawful_functor", "description": ""}, {"name": "functor.add_const", "description": " `add_const \u03b1` is a synonym for constant functor `const \u03b1`, mapping\nevery type to `\u03b1`. When `\u03b1` has a additive monoid structure,\n`add_const \u03b1` has an `applicative` instance. (If `\u03b1` has a\nmultiplicative monoid structure, see `functor.const`.)"}, {"name": "functor.comp.run_map", "description": ""}, {"name": "functor.comp.has_pure", "description": ""}, {"name": "functor.const.inhabited", "description": ""}, {"name": "functor.of_mem_supp", "description": ""}, {"name": "functor.liftr", "description": " If we consider `x : F \u03b1` to, in some sense, contain values of type `\u03b1`, then\n`liftr r x y` relates `x` and `y` iff (1) `x` and `y` have the same shape and\n(2) we can pair values `a` from `x` and `b` from `y` so that `r a b` holds."}, {"name": "functor.const.functor", "description": ""}, {"name": "functor.const.run", "description": "Extract the element of `\u03b1` from the `const` functor."}, {"name": "functor.add_const.run", "description": "Extract the element of `\u03b1` from the constant functor."}, {"name": "functor.comp.mk", "description": " Construct a term of `comp F G \u03b1` from a term of `F (G \u03b1)`, which is the same type.\nCan be used as a pattern to extract a term of `F (G \u03b1)`."}, {"name": "functor.comp.id_map", "description": ""}, {"name": "functor.ext", "description": ""}, {"name": "functor.comp.run_seq", "description": ""}, {"name": "functor.const.map", "description": "The map operation of the `const \u03b3` functor."}, {"name": "functor.comp.inhabited", "description": ""}, {"name": "widget.mouse_event_kind", "description": ""}, {"name": "widget.mouse_event_kind.on_click", "description": ""}, {"name": "widget.mouse_event_kind.on_mouse_enter", "description": ""}, {"name": "widget.mouse_event_kind.on_mouse_leave", "description": ""}, {"name": "tactic.save_widget", "description": "Same as `tactic.save_info_thunk` except saves a widget to be displayed by a compatible infoviewer."}, {"name": "widget.as_element", "description": ""}, {"name": "widget.select_item", "description": ""}, {"name": "widget.select_item.result", "description": ""}, {"name": "widget.select_item.key", "description": ""}, {"name": "widget.select_item.view", "description": ""}, {"name": "widget.className", "description": ""}, {"name": "widget.with_attr", "description": "If the html is not an of_element it will wrap it in a div."}, {"name": "widget.on_click", "description": ""}, {"name": "widget.cn", "description": "Alias for className."}, {"name": "widget.key", "description": ""}, {"name": "widget.effects", "description": ""}, {"name": "widget.with_attrs", "description": "If the html is not an of_element it will wrap it in a div."}, {"name": "tactic.trace_widget_at", "description": "Outputs a widget trace position at the given position."}, {"name": "widget.with_cn", "description": ""}, {"name": "widget.effect", "description": " An effect is some change that the widget makes outside of its own state.\nUsually, giving instructions to the editor to perform some task.\n- `insert_text_relative` will insert at a line relative to the position of the widget.\n- `insert_text_absolute` will insert text at the precise position given.\n- `reveal_position` will move the editor to view the given position.\n- `highlight_position` will add a text highlight to the given position.\n- `clear_highlighting` will remove all highlights created with `highlight_position`.\n- `copy_text` will copy the given text to the clipboard.\n- `custom` can be used to pass custom effects to the client without having to recompile Lean."}, {"name": "widget.effect.insert_text_absolute", "description": " An effect is some change that the widget makes outside of its own state.\nUsually, giving instructions to the editor to perform some task.\n- `insert_text_relative` will insert at a line relative to the position of the widget.\n- `insert_text_absolute` will insert text at the precise position given.\n- `reveal_position` will move the editor to view the given position.\n- `highlight_position` will add a text highlight to the given position.\n- `clear_highlighting` will remove all highlights created with `highlight_position`.\n- `copy_text` will copy the given text to the clipboard.\n- `custom` can be used to pass custom effects to the client without having to recompile Lean."}, {"name": "widget.effect.insert_text_relative", "description": " An effect is some change that the widget makes outside of its own state.\nUsually, giving instructions to the editor to perform some task.\n- `insert_text_relative` will insert at a line relative to the position of the widget.\n- `insert_text_absolute` will insert text at the precise position given.\n- `reveal_position` will move the editor to view the given position.\n- `highlight_position` will add a text highlight to the given position.\n- `clear_highlighting` will remove all highlights created with `highlight_position`.\n- `copy_text` will copy the given text to the clipboard.\n- `custom` can be used to pass custom effects to the client without having to recompile Lean."}, {"name": "widget.effect.reveal_position", "description": " An effect is some change that the widget makes outside of its own state.\nUsually, giving instructions to the editor to perform some task.\n- `insert_text_relative` will insert at a line relative to the position of the widget.\n- `insert_text_absolute` will insert text at the precise position given.\n- `reveal_position` will move the editor to view the given position.\n- `highlight_position` will add a text highlight to the given position.\n- `clear_highlighting` will remove all highlights created with `highlight_position`.\n- `copy_text` will copy the given text to the clipboard.\n- `custom` can be used to pass custom effects to the client without having to recompile Lean."}, {"name": "widget.effect.highlight_position", "description": " An effect is some change that the widget makes outside of its own state.\nUsually, giving instructions to the editor to perform some task.\n- `insert_text_relative` will insert at a line relative to the position of the widget.\n- `insert_text_absolute` will insert text at the precise position given.\n- `reveal_position` will move the editor to view the given position.\n- `highlight_position` will add a text highlight to the given position.\n- `clear_highlighting` will remove all highlights created with `highlight_position`.\n- `copy_text` will copy the given text to the clipboard.\n- `custom` can be used to pass custom effects to the client without having to recompile Lean."}, {"name": "widget.effect.clear_highlighting", "description": " An effect is some change that the widget makes outside of its own state.\nUsually, giving instructions to the editor to perform some task.\n- `insert_text_relative` will insert at a line relative to the position of the widget.\n- `insert_text_absolute` will insert text at the precise position given.\n- `reveal_position` will move the editor to view the given position.\n- `highlight_position` will add a text highlight to the given position.\n- `clear_highlighting` will remove all highlights created with `highlight_position`.\n- `copy_text` will copy the given text to the clipboard.\n- `custom` can be used to pass custom effects to the client without having to recompile Lean."}, {"name": "widget.effect.copy_text", "description": " An effect is some change that the widget makes outside of its own state.\nUsually, giving instructions to the editor to perform some task.\n- `insert_text_relative` will insert at a line relative to the position of the widget.\n- `insert_text_absolute` will insert text at the precise position given.\n- `reveal_position` will move the editor to view the given position.\n- `highlight_position` will add a text highlight to the given position.\n- `clear_highlighting` will remove all highlights created with `highlight_position`.\n- `copy_text` will copy the given text to the clipboard.\n- `custom` can be used to pass custom effects to the client without having to recompile Lean."}, {"name": "widget.effect.custom", "description": " An effect is some change that the widget makes outside of its own state.\nUsually, giving instructions to the editor to perform some task.\n- `insert_text_relative` will insert at a line relative to the position of the widget.\n- `insert_text_absolute` will insert text at the precise position given.\n- `reveal_position` will move the editor to view the given position.\n- `highlight_position` will add a text highlight to the given position.\n- `clear_highlighting` will remove all highlights created with `highlight_position`.\n- `copy_text` will copy the given text to the clipboard.\n- `custom` can be used to pass custom effects to the client without having to recompile Lean."}, {"name": "widget.select", "description": "Choose from a dropdown selection list."}, {"name": "widget.on_mouse_enter", "description": ""}, {"name": "tactic.trace_widget", "description": "Outputs a widget trace position at the current default trace position."}, {"name": "widget.effect.insert_text", "description": ""}, {"name": "widget.textbox", "description": ""}, {"name": "widget.on_mouse_leave", "description": ""}, {"name": "widget.h", "description": "Alias for `html.element`."}, {"name": "widget.with_key", "description": ""}, {"name": "widget.with_style", "description": ""}, {"name": "widget.button", "description": ""}, {"name": "left_mul", "description": "`left_mul g` denotes left multiplication by `g`"}, {"name": "right_add", "description": "`right_add g` denotes right addition by `g`"}, {"name": "add_cancel_comm_monoid.to_add_left_cancel_monoid", "description": ""}, {"name": "neg_add_self", "description": ""}, {"name": "add_left_cancel_monoid.to_add_monoid", "description": ""}, {"name": "division_def", "description": "**Alias** of `div_eq_mul_inv`."}, {"name": "zsmul_neg_succ_of_nat", "description": ""}, {"name": "sub_neg_monoid.to_has_sub", "description": ""}, {"name": "group.to_division_monoid", "description": ""}, {"name": "simp_attr.field_simps", "description": "The simpset `field_simps` is used by the tactic `field_simp` to\nreduce an expression in a field to an expression of the form `n / d` where `n` and `d` are\ndivision-free."}, {"name": "right_cancel_semigroup.ext", "description": ""}, {"name": "add_assoc", "description": ""}, {"name": "semigroup.ext_iff", "description": ""}, {"name": "add_cancel_comm_monoid", "description": "Commutative version of `add_cancel_monoid`."}, {"name": "add_cancel_comm_monoid.add", "description": "Commutative version of `add_cancel_monoid`."}, {"name": "add_cancel_comm_monoid.add_assoc", "description": "Commutative version of `add_cancel_monoid`."}, {"name": "add_cancel_comm_monoid.add_left_cancel", "description": "Commutative version of `add_cancel_monoid`."}, {"name": "add_cancel_comm_monoid.zero", "description": "Commutative version of `add_cancel_monoid`."}, {"name": "add_cancel_comm_monoid.zero_add", "description": "Commutative version of `add_cancel_monoid`."}, {"name": "add_cancel_comm_monoid.add_zero", "description": "Commutative version of `add_cancel_monoid`."}, {"name": "add_cancel_comm_monoid.nsmul", "description": "Commutative version of `add_cancel_monoid`."}, {"name": "add_cancel_comm_monoid.nsmul_zero'", "description": "Commutative version of `add_cancel_monoid`."}, {"name": "add_cancel_comm_monoid.nsmul_succ'", "description": "Commutative version of `add_cancel_monoid`."}, {"name": "add_cancel_comm_monoid.add_comm", "description": "Commutative version of `add_cancel_monoid`."}, {"name": "npow_rec", "description": " The fundamental power operation in a monoid. `npow_rec n a = a*a*...*a` n times.\nUse instead `a ^ n`,  which has better definitional behavior."}, {"name": "add_zero_class.to_has_add", "description": ""}, {"name": "add_comm_semigroup.ext_iff", "description": ""}, {"name": "mul_inv_rev", "description": ""}, {"name": "add_comm_group", "description": "An additive commutative group is an additive group with commutative `(+)`."}, {"name": "add_comm_group.add", "description": "An additive commutative group is an additive group with commutative `(+)`."}, {"name": "add_comm_group.add_assoc", "description": "An additive commutative group is an additive group with commutative `(+)`."}, {"name": "add_comm_group.zero", "description": "An additive commutative group is an additive group with commutative `(+)`."}, {"name": "add_comm_group.zero_add", "description": "An additive commutative group is an additive group with commutative `(+)`."}, {"name": "add_comm_group.add_zero", "description": "An additive commutative group is an additive group with commutative `(+)`."}, {"name": "add_comm_group.nsmul", "description": "An additive commutative group is an additive group with commutative `(+)`."}, {"name": "add_comm_group.nsmul_zero'", "description": "An additive commutative group is an additive group with commutative `(+)`."}, {"name": "add_comm_group.nsmul_succ'", "description": "An additive commutative group is an additive group with commutative `(+)`."}, {"name": "add_comm_group.neg", "description": "An additive commutative group is an additive group with commutative `(+)`."}, {"name": "add_comm_group.sub", "description": "An additive commutative group is an additive group with commutative `(+)`."}, {"name": "add_comm_group.sub_eq_add_neg", "description": "An additive commutative group is an additive group with commutative `(+)`."}, {"name": "add_comm_group.zsmul", "description": "An additive commutative group is an additive group with commutative `(+)`."}, {"name": "add_comm_group.zsmul_zero'", "description": "An additive commutative group is an additive group with commutative `(+)`."}, {"name": "add_comm_group.zsmul_succ'", "description": "An additive commutative group is an additive group with commutative `(+)`."}, {"name": "add_comm_group.zsmul_neg'", "description": "An additive commutative group is an additive group with commutative `(+)`."}, {"name": "add_comm_group.add_left_neg", "description": "An additive commutative group is an additive group with commutative `(+)`."}, {"name": "add_comm_group.add_comm", "description": "An additive commutative group is an additive group with commutative `(+)`."}, {"name": "monoid.to_mul_one_class", "description": ""}, {"name": "add_comm_group.to_add_comm_monoid", "description": ""}, {"name": "add_left_cancel_semigroup", "description": " An `add_left_cancel_semigroup` is an additive semigroup such that\n`a + b = a + c` implies `b = c`."}, {"name": "add_left_cancel_semigroup.add", "description": " An `add_left_cancel_semigroup` is an additive semigroup such that\n`a + b = a + c` implies `b = c`."}, {"name": "add_left_cancel_semigroup.add_assoc", "description": " An `add_left_cancel_semigroup` is an additive semigroup such that\n`a + b = a + c` implies `b = c`."}, {"name": "add_left_cancel_semigroup.add_left_cancel", "description": " An `add_left_cancel_semigroup` is an additive semigroup such that\n`a + b = a + c` implies `b = c`."}, {"name": "comm_group.to_group", "description": ""}, {"name": "add_zero", "description": ""}, {"name": "mul_one_class.to_is_left_id", "description": ""}, {"name": "mul_right_cancel", "description": ""}, {"name": "comm_group", "description": "A commutative group is a group with commutative `(*)`."}, {"name": "comm_group.mul", "description": "A commutative group is a group with commutative `(*)`."}, {"name": "comm_group.mul_assoc", "description": "A commutative group is a group with commutative `(*)`."}, {"name": "comm_group.one", "description": "A commutative group is a group with commutative `(*)`."}, {"name": "comm_group.one_mul", "description": "A commutative group is a group with commutative `(*)`."}, {"name": "comm_group.mul_one", "description": "A commutative group is a group with commutative `(*)`."}, {"name": "comm_group.npow", "description": "A commutative group is a group with commutative `(*)`."}, {"name": "comm_group.npow_zero'", "description": "A commutative group is a group with commutative `(*)`."}, {"name": "comm_group.npow_succ'", "description": "A commutative group is a group with commutative `(*)`."}, {"name": "comm_group.inv", "description": "A commutative group is a group with commutative `(*)`."}, {"name": "comm_group.div", "description": "A commutative group is a group with commutative `(*)`."}, {"name": "comm_group.div_eq_mul_inv", "description": "A commutative group is a group with commutative `(*)`."}, {"name": "comm_group.zpow", "description": "A commutative group is a group with commutative `(*)`."}, {"name": "comm_group.zpow_zero'", "description": "A commutative group is a group with commutative `(*)`."}, {"name": "comm_group.zpow_succ'", "description": "A commutative group is a group with commutative `(*)`."}, {"name": "comm_group.zpow_neg'", "description": "A commutative group is a group with commutative `(*)`."}, {"name": "comm_group.mul_left_inv", "description": "A commutative group is a group with commutative `(*)`."}, {"name": "comm_group.mul_comm", "description": "A commutative group is a group with commutative `(*)`."}, {"name": "zsmul_eq_smul", "description": ""}, {"name": "mul_right_inj", "description": ""}, {"name": "mul_one", "description": ""}, {"name": "add_zero_class.to_is_left_id", "description": ""}, {"name": "mul_assoc", "description": ""}, {"name": "group.to_div_inv_monoid_injective", "description": ""}, {"name": "add_right_cancel_semigroup.ext", "description": ""}, {"name": "left_cancel_monoid", "description": "A monoid in which multiplication is left-cancellative."}, {"name": "left_cancel_monoid.mul", "description": "A monoid in which multiplication is left-cancellative."}, {"name": "left_cancel_monoid.mul_assoc", "description": "A monoid in which multiplication is left-cancellative."}, {"name": "left_cancel_monoid.mul_left_cancel", "description": "A monoid in which multiplication is left-cancellative."}, {"name": "left_cancel_monoid.one", "description": "A monoid in which multiplication is left-cancellative."}, {"name": "left_cancel_monoid.one_mul", "description": "A monoid in which multiplication is left-cancellative."}, {"name": "left_cancel_monoid.mul_one", "description": "A monoid in which multiplication is left-cancellative."}, {"name": "left_cancel_monoid.npow", "description": "A monoid in which multiplication is left-cancellative."}, {"name": "left_cancel_monoid.npow_zero'", "description": "A monoid in which multiplication is left-cancellative."}, {"name": "left_cancel_monoid.npow_succ'", "description": "A monoid in which multiplication is left-cancellative."}, {"name": "div_inv_monoid.has_pow", "description": ""}, {"name": "add_monoid.to_add_semigroup", "description": ""}, {"name": "right_mul", "description": "`right_mul g` denotes right multiplication by `g`"}, {"name": "has_smul.ext", "description": ""}, {"name": "div_inv_monoid.to_monoid", "description": ""}, {"name": "comm_group.to_cancel_comm_monoid", "description": ""}, {"name": "one_mul", "description": ""}, {"name": "mul_ne_mul_left", "description": ""}, {"name": "add_left_cancel_monoid", "description": " An additive monoid in which addition is left-cancellative.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_left_cancel_semigroup` is not enough."}, {"name": "add_left_cancel_monoid.add", "description": " An additive monoid in which addition is left-cancellative.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_left_cancel_semigroup` is not enough."}, {"name": "add_left_cancel_monoid.add_assoc", "description": " An additive monoid in which addition is left-cancellative.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_left_cancel_semigroup` is not enough."}, {"name": "add_left_cancel_monoid.add_left_cancel", "description": " An additive monoid in which addition is left-cancellative.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_left_cancel_semigroup` is not enough."}, {"name": "add_left_cancel_monoid.zero", "description": " An additive monoid in which addition is left-cancellative.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_left_cancel_semigroup` is not enough."}, {"name": "add_left_cancel_monoid.zero_add", "description": " An additive monoid in which addition is left-cancellative.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_left_cancel_semigroup` is not enough."}, {"name": "add_left_cancel_monoid.add_zero", "description": " An additive monoid in which addition is left-cancellative.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_left_cancel_semigroup` is not enough."}, {"name": "add_left_cancel_monoid.nsmul", "description": " An additive monoid in which addition is left-cancellative.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_left_cancel_semigroup` is not enough."}, {"name": "add_left_cancel_monoid.nsmul_zero'", "description": " An additive monoid in which addition is left-cancellative.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_left_cancel_semigroup` is not enough."}, {"name": "add_left_cancel_monoid.nsmul_succ'", "description": " An additive monoid in which addition is left-cancellative.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_left_cancel_semigroup` is not enough."}, {"name": "add_group.to_division_add_monoid", "description": ""}, {"name": "neg_eq_of_add_eq_zero_right", "description": ""}, {"name": "add_left_injective", "description": ""}, {"name": "has_vadd", "description": "Type class for the `+\u1d65` notation."}, {"name": "has_vadd.vadd", "description": "Type class for the `+\u1d65` notation."}, {"name": "comm_monoid.to_comm_semigroup", "description": ""}, {"name": "add_comm_monoid.to_add_monoid", "description": ""}, {"name": "add_comm_group.to_add_group", "description": ""}, {"name": "add_zero_class.to_has_zero", "description": ""}, {"name": "inv_eq_of_mul_eq_one_right", "description": ""}, {"name": "zsmul_rec", "description": " The fundamental scalar multiplication in an additive group. `zsmul_rec n a = a+a+...+a` n\ntimes, for integer `n`. Use instead `n \u2022 a`, which has better definitional behavior."}, {"name": "semigroup.ext", "description": ""}, {"name": "add_left_cancel_semigroup.ext_iff", "description": ""}, {"name": "subtraction_comm_monoid.to_subtraction_monoid", "description": ""}, {"name": "add_monoid.has_smul_nat", "description": ""}, {"name": "has_involutive_inv", "description": "Auxiliary typeclass for types with an involutive `has_inv`."}, {"name": "has_involutive_inv.inv", "description": "Auxiliary typeclass for types with an involutive `has_inv`."}, {"name": "has_involutive_inv.inv_inv", "description": "Auxiliary typeclass for types with an involutive `has_inv`."}, {"name": "zero_zsmul", "description": ""}, {"name": "add_semigroup.to_is_associative", "description": ""}, {"name": "add_comm_group.to_division_add_comm_monoid", "description": ""}, {"name": "add_right_cancel_semigroup.ext_iff", "description": ""}, {"name": "subtraction_monoid.to_has_involutive_neg", "description": ""}, {"name": "add_comm_semigroup.to_add_semigroup", "description": ""}, {"name": "semigroup.to_has_mul", "description": ""}, {"name": "neg_add_cancel_right", "description": ""}, {"name": "left_cancel_monoid.to_left_cancel_semigroup", "description": ""}, {"name": "monoid.has_pow", "description": ""}, {"name": "add_left_inj", "description": ""}, {"name": "subtraction_comm_monoid.to_add_comm_monoid", "description": ""}, {"name": "mul_one_class.to_is_right_id", "description": ""}, {"name": "div_inv_monoid.to_has_div", "description": ""}, {"name": "npow_eq_pow", "description": ""}, {"name": "right_cancel_monoid.to_monoid", "description": ""}, {"name": "zpow_zero", "description": ""}, {"name": "add_semigroup.to_has_add", "description": ""}, {"name": "div_inv_monoid", "description": " A `div_inv_monoid` is a `monoid` with operations `/` and `\u207b\u00b9` satisfying\n`div_eq_mul_inv : \u2200 a b, a / b = a * b\u207b\u00b9`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b\u207b\u00b9` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b\u207b\u00b9` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_div (foo X)` instance but no\n`\u2200 X, has_inv (foo X)`, e.g. when `foo X` is a `euclidean_domain`. Suppose we\nalso have an instance `\u2200 X [cromulent X], group_with_zero (foo X)`. Then the\n`(/)` coming from `group_with_zero_has_div` cannot be definitionally equal to\nthe `(/)` coming from `foo.has_div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "div_inv_monoid.mul", "description": " A `div_inv_monoid` is a `monoid` with operations `/` and `\u207b\u00b9` satisfying\n`div_eq_mul_inv : \u2200 a b, a / b = a * b\u207b\u00b9`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b\u207b\u00b9` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b\u207b\u00b9` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_div (foo X)` instance but no\n`\u2200 X, has_inv (foo X)`, e.g. when `foo X` is a `euclidean_domain`. Suppose we\nalso have an instance `\u2200 X [cromulent X], group_with_zero (foo X)`. Then the\n`(/)` coming from `group_with_zero_has_div` cannot be definitionally equal to\nthe `(/)` coming from `foo.has_div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "div_inv_monoid.mul_assoc", "description": " A `div_inv_monoid` is a `monoid` with operations `/` and `\u207b\u00b9` satisfying\n`div_eq_mul_inv : \u2200 a b, a / b = a * b\u207b\u00b9`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b\u207b\u00b9` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b\u207b\u00b9` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_div (foo X)` instance but no\n`\u2200 X, has_inv (foo X)`, e.g. when `foo X` is a `euclidean_domain`. Suppose we\nalso have an instance `\u2200 X [cromulent X], group_with_zero (foo X)`. Then the\n`(/)` coming from `group_with_zero_has_div` cannot be definitionally equal to\nthe `(/)` coming from `foo.has_div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "div_inv_monoid.one", "description": " A `div_inv_monoid` is a `monoid` with operations `/` and `\u207b\u00b9` satisfying\n`div_eq_mul_inv : \u2200 a b, a / b = a * b\u207b\u00b9`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b\u207b\u00b9` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b\u207b\u00b9` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_div (foo X)` instance but no\n`\u2200 X, has_inv (foo X)`, e.g. when `foo X` is a `euclidean_domain`. Suppose we\nalso have an instance `\u2200 X [cromulent X], group_with_zero (foo X)`. Then the\n`(/)` coming from `group_with_zero_has_div` cannot be definitionally equal to\nthe `(/)` coming from `foo.has_div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "div_inv_monoid.one_mul", "description": " A `div_inv_monoid` is a `monoid` with operations `/` and `\u207b\u00b9` satisfying\n`div_eq_mul_inv : \u2200 a b, a / b = a * b\u207b\u00b9`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b\u207b\u00b9` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b\u207b\u00b9` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_div (foo X)` instance but no\n`\u2200 X, has_inv (foo X)`, e.g. when `foo X` is a `euclidean_domain`. Suppose we\nalso have an instance `\u2200 X [cromulent X], group_with_zero (foo X)`. Then the\n`(/)` coming from `group_with_zero_has_div` cannot be definitionally equal to\nthe `(/)` coming from `foo.has_div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "div_inv_monoid.mul_one", "description": " A `div_inv_monoid` is a `monoid` with operations `/` and `\u207b\u00b9` satisfying\n`div_eq_mul_inv : \u2200 a b, a / b = a * b\u207b\u00b9`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b\u207b\u00b9` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b\u207b\u00b9` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_div (foo X)` instance but no\n`\u2200 X, has_inv (foo X)`, e.g. when `foo X` is a `euclidean_domain`. Suppose we\nalso have an instance `\u2200 X [cromulent X], group_with_zero (foo X)`. Then the\n`(/)` coming from `group_with_zero_has_div` cannot be definitionally equal to\nthe `(/)` coming from `foo.has_div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "div_inv_monoid.npow", "description": " A `div_inv_monoid` is a `monoid` with operations `/` and `\u207b\u00b9` satisfying\n`div_eq_mul_inv : \u2200 a b, a / b = a * b\u207b\u00b9`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b\u207b\u00b9` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b\u207b\u00b9` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_div (foo X)` instance but no\n`\u2200 X, has_inv (foo X)`, e.g. when `foo X` is a `euclidean_domain`. Suppose we\nalso have an instance `\u2200 X [cromulent X], group_with_zero (foo X)`. Then the\n`(/)` coming from `group_with_zero_has_div` cannot be definitionally equal to\nthe `(/)` coming from `foo.has_div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "div_inv_monoid.npow_zero'", "description": " A `div_inv_monoid` is a `monoid` with operations `/` and `\u207b\u00b9` satisfying\n`div_eq_mul_inv : \u2200 a b, a / b = a * b\u207b\u00b9`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b\u207b\u00b9` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b\u207b\u00b9` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_div (foo X)` instance but no\n`\u2200 X, has_inv (foo X)`, e.g. when `foo X` is a `euclidean_domain`. Suppose we\nalso have an instance `\u2200 X [cromulent X], group_with_zero (foo X)`. Then the\n`(/)` coming from `group_with_zero_has_div` cannot be definitionally equal to\nthe `(/)` coming from `foo.has_div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "div_inv_monoid.npow_succ'", "description": " A `div_inv_monoid` is a `monoid` with operations `/` and `\u207b\u00b9` satisfying\n`div_eq_mul_inv : \u2200 a b, a / b = a * b\u207b\u00b9`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b\u207b\u00b9` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b\u207b\u00b9` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_div (foo X)` instance but no\n`\u2200 X, has_inv (foo X)`, e.g. when `foo X` is a `euclidean_domain`. Suppose we\nalso have an instance `\u2200 X [cromulent X], group_with_zero (foo X)`. Then the\n`(/)` coming from `group_with_zero_has_div` cannot be definitionally equal to\nthe `(/)` coming from `foo.has_div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "div_inv_monoid.inv", "description": " A `div_inv_monoid` is a `monoid` with operations `/` and `\u207b\u00b9` satisfying\n`div_eq_mul_inv : \u2200 a b, a / b = a * b\u207b\u00b9`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b\u207b\u00b9` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b\u207b\u00b9` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_div (foo X)` instance but no\n`\u2200 X, has_inv (foo X)`, e.g. when `foo X` is a `euclidean_domain`. Suppose we\nalso have an instance `\u2200 X [cromulent X], group_with_zero (foo X)`. Then the\n`(/)` coming from `group_with_zero_has_div` cannot be definitionally equal to\nthe `(/)` coming from `foo.has_div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "div_inv_monoid.div", "description": " A `div_inv_monoid` is a `monoid` with operations `/` and `\u207b\u00b9` satisfying\n`div_eq_mul_inv : \u2200 a b, a / b = a * b\u207b\u00b9`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b\u207b\u00b9` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b\u207b\u00b9` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_div (foo X)` instance but no\n`\u2200 X, has_inv (foo X)`, e.g. when `foo X` is a `euclidean_domain`. Suppose we\nalso have an instance `\u2200 X [cromulent X], group_with_zero (foo X)`. Then the\n`(/)` coming from `group_with_zero_has_div` cannot be definitionally equal to\nthe `(/)` coming from `foo.has_div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "div_inv_monoid.div_eq_mul_inv", "description": " A `div_inv_monoid` is a `monoid` with operations `/` and `\u207b\u00b9` satisfying\n`div_eq_mul_inv : \u2200 a b, a / b = a * b\u207b\u00b9`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b\u207b\u00b9` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b\u207b\u00b9` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_div (foo X)` instance but no\n`\u2200 X, has_inv (foo X)`, e.g. when `foo X` is a `euclidean_domain`. Suppose we\nalso have an instance `\u2200 X [cromulent X], group_with_zero (foo X)`. Then the\n`(/)` coming from `group_with_zero_has_div` cannot be definitionally equal to\nthe `(/)` coming from `foo.has_div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "div_inv_monoid.zpow", "description": " A `div_inv_monoid` is a `monoid` with operations `/` and `\u207b\u00b9` satisfying\n`div_eq_mul_inv : \u2200 a b, a / b = a * b\u207b\u00b9`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b\u207b\u00b9` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b\u207b\u00b9` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_div (foo X)` instance but no\n`\u2200 X, has_inv (foo X)`, e.g. when `foo X` is a `euclidean_domain`. Suppose we\nalso have an instance `\u2200 X [cromulent X], group_with_zero (foo X)`. Then the\n`(/)` coming from `group_with_zero_has_div` cannot be definitionally equal to\nthe `(/)` coming from `foo.has_div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "div_inv_monoid.zpow_zero'", "description": " A `div_inv_monoid` is a `monoid` with operations `/` and `\u207b\u00b9` satisfying\n`div_eq_mul_inv : \u2200 a b, a / b = a * b\u207b\u00b9`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b\u207b\u00b9` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b\u207b\u00b9` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_div (foo X)` instance but no\n`\u2200 X, has_inv (foo X)`, e.g. when `foo X` is a `euclidean_domain`. Suppose we\nalso have an instance `\u2200 X [cromulent X], group_with_zero (foo X)`. Then the\n`(/)` coming from `group_with_zero_has_div` cannot be definitionally equal to\nthe `(/)` coming from `foo.has_div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "div_inv_monoid.zpow_succ'", "description": " A `div_inv_monoid` is a `monoid` with operations `/` and `\u207b\u00b9` satisfying\n`div_eq_mul_inv : \u2200 a b, a / b = a * b\u207b\u00b9`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b\u207b\u00b9` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b\u207b\u00b9` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_div (foo X)` instance but no\n`\u2200 X, has_inv (foo X)`, e.g. when `foo X` is a `euclidean_domain`. Suppose we\nalso have an instance `\u2200 X [cromulent X], group_with_zero (foo X)`. Then the\n`(/)` coming from `group_with_zero_has_div` cannot be definitionally equal to\nthe `(/)` coming from `foo.has_div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "div_inv_monoid.zpow_neg'", "description": " A `div_inv_monoid` is a `monoid` with operations `/` and `\u207b\u00b9` satisfying\n`div_eq_mul_inv : \u2200 a b, a / b = a * b\u207b\u00b9`.\n\nThis deduplicates the name `div_eq_mul_inv`.\nThe default for `div` is such that `a / b = a * b\u207b\u00b9` holds by definition.\n\nAdding `div` as a field rather than defining `a / b := a * b\u207b\u00b9` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_div (foo X)` instance but no\n`\u2200 X, has_inv (foo X)`, e.g. when `foo X` is a `euclidean_domain`. Suppose we\nalso have an instance `\u2200 X [cromulent X], group_with_zero (foo X)`. Then the\n`(/)` coming from `group_with_zero_has_div` cannot be definitionally equal to\nthe `(/)` coming from `foo.has_div`.\n\nIn the same way, adding a `zpow` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "add_monoid.to_add_zero_class", "description": ""}, {"name": "add_group.to_sub_neg_add_monoid_injective", "description": ""}, {"name": "add_right_cancel_semigroup", "description": " An `add_right_cancel_semigroup` is an additive semigroup such that\n`a + b = c + b` implies `a = c`."}, {"name": "add_right_cancel_semigroup.add", "description": " An `add_right_cancel_semigroup` is an additive semigroup such that\n`a + b = c + b` implies `a = c`."}, {"name": "add_right_cancel_semigroup.add_assoc", "description": " An `add_right_cancel_semigroup` is an additive semigroup such that\n`a + b = c + b` implies `a = c`."}, {"name": "add_right_cancel_semigroup.add_right_cancel", "description": " An `add_right_cancel_semigroup` is an additive semigroup such that\n`a + b = c + b` implies `a = c`."}, {"name": "add_neg_self", "description": ""}, {"name": "mul_inv_cancel_left", "description": ""}, {"name": "add_right_cancel", "description": ""}, {"name": "right_cancel_monoid", "description": "A monoid in which multiplication is right-cancellative."}, {"name": "right_cancel_monoid.mul", "description": "A monoid in which multiplication is right-cancellative."}, {"name": "right_cancel_monoid.mul_assoc", "description": "A monoid in which multiplication is right-cancellative."}, {"name": "right_cancel_monoid.mul_right_cancel", "description": "A monoid in which multiplication is right-cancellative."}, {"name": "right_cancel_monoid.one", "description": "A monoid in which multiplication is right-cancellative."}, {"name": "right_cancel_monoid.one_mul", "description": "A monoid in which multiplication is right-cancellative."}, {"name": "right_cancel_monoid.mul_one", "description": "A monoid in which multiplication is right-cancellative."}, {"name": "right_cancel_monoid.npow", "description": "A monoid in which multiplication is right-cancellative."}, {"name": "right_cancel_monoid.npow_zero'", "description": "A monoid in which multiplication is right-cancellative."}, {"name": "right_cancel_monoid.npow_succ'", "description": "A monoid in which multiplication is right-cancellative."}, {"name": "mul_left_cancel", "description": ""}, {"name": "cancel_comm_monoid.to_comm_monoid", "description": ""}, {"name": "add_group", "description": " An `add_group` is an `add_monoid` with a unary `-` satisfying `-a + a = 0`.\n\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition."}, {"name": "add_group.add", "description": " An `add_group` is an `add_monoid` with a unary `-` satisfying `-a + a = 0`.\n\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition."}, {"name": "add_group.add_assoc", "description": " An `add_group` is an `add_monoid` with a unary `-` satisfying `-a + a = 0`.\n\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition."}, {"name": "add_group.zero", "description": " An `add_group` is an `add_monoid` with a unary `-` satisfying `-a + a = 0`.\n\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition."}, {"name": "add_group.zero_add", "description": " An `add_group` is an `add_monoid` with a unary `-` satisfying `-a + a = 0`.\n\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition."}, {"name": "add_group.add_zero", "description": " An `add_group` is an `add_monoid` with a unary `-` satisfying `-a + a = 0`.\n\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition."}, {"name": "add_group.nsmul", "description": " An `add_group` is an `add_monoid` with a unary `-` satisfying `-a + a = 0`.\n\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition."}, {"name": "add_group.nsmul_zero'", "description": " An `add_group` is an `add_monoid` with a unary `-` satisfying `-a + a = 0`.\n\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition."}, {"name": "add_group.nsmul_succ'", "description": " An `add_group` is an `add_monoid` with a unary `-` satisfying `-a + a = 0`.\n\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition."}, {"name": "add_group.neg", "description": " An `add_group` is an `add_monoid` with a unary `-` satisfying `-a + a = 0`.\n\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition."}, {"name": "add_group.sub", "description": " An `add_group` is an `add_monoid` with a unary `-` satisfying `-a + a = 0`.\n\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition."}, {"name": "add_group.sub_eq_add_neg", "description": " An `add_group` is an `add_monoid` with a unary `-` satisfying `-a + a = 0`.\n\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition."}, {"name": "add_group.zsmul", "description": " An `add_group` is an `add_monoid` with a unary `-` satisfying `-a + a = 0`.\n\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition."}, {"name": "add_group.zsmul_zero'", "description": " An `add_group` is an `add_monoid` with a unary `-` satisfying `-a + a = 0`.\n\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition."}, {"name": "add_group.zsmul_succ'", "description": " An `add_group` is an `add_monoid` with a unary `-` satisfying `-a + a = 0`.\n\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition."}, {"name": "add_group.zsmul_neg'", "description": " An `add_group` is an `add_monoid` with a unary `-` satisfying `-a + a = 0`.\n\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition."}, {"name": "add_group.add_left_neg", "description": " An `add_group` is an `add_monoid` with a unary `-` satisfying `-a + a = 0`.\n\nThere is also a binary operation `-` such that `a - b = a + -b`,\nwith a default so that `a - b = a + -b` holds by definition."}, {"name": "add_comm", "description": ""}, {"name": "mul_right_inv", "description": ""}, {"name": "add_comm_group.to_add_group_injective", "description": ""}, {"name": "mul_one_class", "description": " Typeclass for expressing that a type `M` with multiplication and a one satisfies\n`1 * a = a` and `a * 1 = a` for all `a : M`."}, {"name": "mul_one_class.one", "description": " Typeclass for expressing that a type `M` with multiplication and a one satisfies\n`1 * a = a` and `a * 1 = a` for all `a : M`."}, {"name": "mul_one_class.mul", "description": " Typeclass for expressing that a type `M` with multiplication and a one satisfies\n`1 * a = a` and `a * 1 = a` for all `a : M`."}, {"name": "mul_one_class.one_mul", "description": " Typeclass for expressing that a type `M` with multiplication and a one satisfies\n`1 * a = a` and `a * 1 = a` for all `a : M`."}, {"name": "mul_one_class.mul_one", "description": " Typeclass for expressing that a type `M` with multiplication and a one satisfies\n`1 * a = a` and `a * 1 = a` for all `a : M`."}, {"name": "mul_inv_self", "description": ""}, {"name": "add_right_injective", "description": ""}, {"name": "add_comm_semigroup.ext", "description": ""}, {"name": "cancel_comm_monoid.to_cancel_monoid", "description": ""}, {"name": "comm_monoid", "description": "A commutative monoid is a monoid with commutative `(*)`."}, {"name": "comm_monoid.mul", "description": "A commutative monoid is a monoid with commutative `(*)`."}, {"name": "comm_monoid.mul_assoc", "description": "A commutative monoid is a monoid with commutative `(*)`."}, {"name": "comm_monoid.one", "description": "A commutative monoid is a monoid with commutative `(*)`."}, {"name": "comm_monoid.one_mul", "description": "A commutative monoid is a monoid with commutative `(*)`."}, {"name": "comm_monoid.mul_one", "description": "A commutative monoid is a monoid with commutative `(*)`."}, {"name": "comm_monoid.npow", "description": "A commutative monoid is a monoid with commutative `(*)`."}, {"name": "comm_monoid.npow_zero'", "description": "A commutative monoid is a monoid with commutative `(*)`."}, {"name": "comm_monoid.npow_succ'", "description": "A commutative monoid is a monoid with commutative `(*)`."}, {"name": "comm_monoid.mul_comm", "description": "A commutative monoid is a monoid with commutative `(*)`."}, {"name": "has_involutive_neg", "description": "Auxiliary typeclass for types with an involutive `has_neg`."}, {"name": "has_involutive_neg.neg", "description": "Auxiliary typeclass for types with an involutive `has_neg`."}, {"name": "has_involutive_neg.neg_neg", "description": "Auxiliary typeclass for types with an involutive `has_neg`."}, {"name": "inv_mul_cancel_left", "description": ""}, {"name": "group", "description": " A `group` is a `monoid` with an operation `\u207b\u00b9` satisfying `a\u207b\u00b9 * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b\u207b\u00b9`,\nwith a default so that `a / b = a * b\u207b\u00b9` holds by definition."}, {"name": "group.mul", "description": " A `group` is a `monoid` with an operation `\u207b\u00b9` satisfying `a\u207b\u00b9 * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b\u207b\u00b9`,\nwith a default so that `a / b = a * b\u207b\u00b9` holds by definition."}, {"name": "group.mul_assoc", "description": " A `group` is a `monoid` with an operation `\u207b\u00b9` satisfying `a\u207b\u00b9 * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b\u207b\u00b9`,\nwith a default so that `a / b = a * b\u207b\u00b9` holds by definition."}, {"name": "group.one", "description": " A `group` is a `monoid` with an operation `\u207b\u00b9` satisfying `a\u207b\u00b9 * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b\u207b\u00b9`,\nwith a default so that `a / b = a * b\u207b\u00b9` holds by definition."}, {"name": "group.one_mul", "description": " A `group` is a `monoid` with an operation `\u207b\u00b9` satisfying `a\u207b\u00b9 * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b\u207b\u00b9`,\nwith a default so that `a / b = a * b\u207b\u00b9` holds by definition."}, {"name": "group.mul_one", "description": " A `group` is a `monoid` with an operation `\u207b\u00b9` satisfying `a\u207b\u00b9 * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b\u207b\u00b9`,\nwith a default so that `a / b = a * b\u207b\u00b9` holds by definition."}, {"name": "group.npow", "description": " A `group` is a `monoid` with an operation `\u207b\u00b9` satisfying `a\u207b\u00b9 * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b\u207b\u00b9`,\nwith a default so that `a / b = a * b\u207b\u00b9` holds by definition."}, {"name": "group.npow_zero'", "description": " A `group` is a `monoid` with an operation `\u207b\u00b9` satisfying `a\u207b\u00b9 * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b\u207b\u00b9`,\nwith a default so that `a / b = a * b\u207b\u00b9` holds by definition."}, {"name": "group.npow_succ'", "description": " A `group` is a `monoid` with an operation `\u207b\u00b9` satisfying `a\u207b\u00b9 * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b\u207b\u00b9`,\nwith a default so that `a / b = a * b\u207b\u00b9` holds by definition."}, {"name": "group.inv", "description": " A `group` is a `monoid` with an operation `\u207b\u00b9` satisfying `a\u207b\u00b9 * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b\u207b\u00b9`,\nwith a default so that `a / b = a * b\u207b\u00b9` holds by definition."}, {"name": "group.div", "description": " A `group` is a `monoid` with an operation `\u207b\u00b9` satisfying `a\u207b\u00b9 * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b\u207b\u00b9`,\nwith a default so that `a / b = a * b\u207b\u00b9` holds by definition."}, {"name": "group.div_eq_mul_inv", "description": " A `group` is a `monoid` with an operation `\u207b\u00b9` satisfying `a\u207b\u00b9 * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b\u207b\u00b9`,\nwith a default so that `a / b = a * b\u207b\u00b9` holds by definition."}, {"name": "group.zpow", "description": " A `group` is a `monoid` with an operation `\u207b\u00b9` satisfying `a\u207b\u00b9 * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b\u207b\u00b9`,\nwith a default so that `a / b = a * b\u207b\u00b9` holds by definition."}, {"name": "group.zpow_zero'", "description": " A `group` is a `monoid` with an operation `\u207b\u00b9` satisfying `a\u207b\u00b9 * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b\u207b\u00b9`,\nwith a default so that `a / b = a * b\u207b\u00b9` holds by definition."}, {"name": "group.zpow_succ'", "description": " A `group` is a `monoid` with an operation `\u207b\u00b9` satisfying `a\u207b\u00b9 * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b\u207b\u00b9`,\nwith a default so that `a / b = a * b\u207b\u00b9` holds by definition."}, {"name": "group.zpow_neg'", "description": " A `group` is a `monoid` with an operation `\u207b\u00b9` satisfying `a\u207b\u00b9 * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b\u207b\u00b9`,\nwith a default so that `a / b = a * b\u207b\u00b9` holds by definition."}, {"name": "group.mul_left_inv", "description": " A `group` is a `monoid` with an operation `\u207b\u00b9` satisfying `a\u207b\u00b9 * a = 1`.\n\nThere is also a division operation `/` such that `a / b = a * b\u207b\u00b9`,\nwith a default so that `a / b = a * b\u207b\u00b9` holds by definition."}, {"name": "add_neg_cancel_right", "description": ""}, {"name": "sub_neg_monoid.to_add_monoid", "description": ""}, {"name": "division_comm_monoid.to_comm_monoid", "description": ""}, {"name": "mul_ne_mul_right", "description": ""}, {"name": "zero_nsmul", "description": ""}, {"name": "mul_right_cancel_iff", "description": ""}, {"name": "cancel_comm_monoid", "description": "Commutative version of `cancel_monoid`."}, {"name": "cancel_comm_monoid.mul", "description": "Commutative version of `cancel_monoid`."}, {"name": "cancel_comm_monoid.mul_assoc", "description": "Commutative version of `cancel_monoid`."}, {"name": "cancel_comm_monoid.mul_left_cancel", "description": "Commutative version of `cancel_monoid`."}, {"name": "cancel_comm_monoid.one", "description": "Commutative version of `cancel_monoid`."}, {"name": "cancel_comm_monoid.one_mul", "description": "Commutative version of `cancel_monoid`."}, {"name": "cancel_comm_monoid.mul_one", "description": "Commutative version of `cancel_monoid`."}, {"name": "cancel_comm_monoid.npow", "description": "Commutative version of `cancel_monoid`."}, {"name": "cancel_comm_monoid.npow_zero'", "description": "Commutative version of `cancel_monoid`."}, {"name": "cancel_comm_monoid.npow_succ'", "description": "Commutative version of `cancel_monoid`."}, {"name": "cancel_comm_monoid.mul_comm", "description": "Commutative version of `cancel_monoid`."}, {"name": "comm_group.to_division_comm_monoid", "description": ""}, {"name": "sub_neg_monoid", "description": " A `sub_neg_monoid` is an `add_monoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : \u2200 a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_sub (foo X)` instance but no\n`\u2200 X, has_neg (foo X)`. Suppose we also have an instance\n`\u2200 X [cromulent X], add_group (foo X)`. Then the `(-)` coming from\n`add_group.has_sub` cannot be definitionally equal to the `(-)` coming from\n`foo.has_sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `add_monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "sub_neg_monoid.add", "description": " A `sub_neg_monoid` is an `add_monoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : \u2200 a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_sub (foo X)` instance but no\n`\u2200 X, has_neg (foo X)`. Suppose we also have an instance\n`\u2200 X [cromulent X], add_group (foo X)`. Then the `(-)` coming from\n`add_group.has_sub` cannot be definitionally equal to the `(-)` coming from\n`foo.has_sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `add_monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "sub_neg_monoid.add_assoc", "description": " A `sub_neg_monoid` is an `add_monoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : \u2200 a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_sub (foo X)` instance but no\n`\u2200 X, has_neg (foo X)`. Suppose we also have an instance\n`\u2200 X [cromulent X], add_group (foo X)`. Then the `(-)` coming from\n`add_group.has_sub` cannot be definitionally equal to the `(-)` coming from\n`foo.has_sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `add_monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "sub_neg_monoid.zero", "description": " A `sub_neg_monoid` is an `add_monoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : \u2200 a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_sub (foo X)` instance but no\n`\u2200 X, has_neg (foo X)`. Suppose we also have an instance\n`\u2200 X [cromulent X], add_group (foo X)`. Then the `(-)` coming from\n`add_group.has_sub` cannot be definitionally equal to the `(-)` coming from\n`foo.has_sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `add_monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "sub_neg_monoid.zero_add", "description": " A `sub_neg_monoid` is an `add_monoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : \u2200 a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_sub (foo X)` instance but no\n`\u2200 X, has_neg (foo X)`. Suppose we also have an instance\n`\u2200 X [cromulent X], add_group (foo X)`. Then the `(-)` coming from\n`add_group.has_sub` cannot be definitionally equal to the `(-)` coming from\n`foo.has_sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `add_monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "sub_neg_monoid.add_zero", "description": " A `sub_neg_monoid` is an `add_monoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : \u2200 a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_sub (foo X)` instance but no\n`\u2200 X, has_neg (foo X)`. Suppose we also have an instance\n`\u2200 X [cromulent X], add_group (foo X)`. Then the `(-)` coming from\n`add_group.has_sub` cannot be definitionally equal to the `(-)` coming from\n`foo.has_sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `add_monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "sub_neg_monoid.nsmul", "description": " A `sub_neg_monoid` is an `add_monoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : \u2200 a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_sub (foo X)` instance but no\n`\u2200 X, has_neg (foo X)`. Suppose we also have an instance\n`\u2200 X [cromulent X], add_group (foo X)`. Then the `(-)` coming from\n`add_group.has_sub` cannot be definitionally equal to the `(-)` coming from\n`foo.has_sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `add_monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "sub_neg_monoid.nsmul_zero'", "description": " A `sub_neg_monoid` is an `add_monoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : \u2200 a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_sub (foo X)` instance but no\n`\u2200 X, has_neg (foo X)`. Suppose we also have an instance\n`\u2200 X [cromulent X], add_group (foo X)`. Then the `(-)` coming from\n`add_group.has_sub` cannot be definitionally equal to the `(-)` coming from\n`foo.has_sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `add_monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "sub_neg_monoid.nsmul_succ'", "description": " A `sub_neg_monoid` is an `add_monoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : \u2200 a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_sub (foo X)` instance but no\n`\u2200 X, has_neg (foo X)`. Suppose we also have an instance\n`\u2200 X [cromulent X], add_group (foo X)`. Then the `(-)` coming from\n`add_group.has_sub` cannot be definitionally equal to the `(-)` coming from\n`foo.has_sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `add_monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "sub_neg_monoid.neg", "description": " A `sub_neg_monoid` is an `add_monoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : \u2200 a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_sub (foo X)` instance but no\n`\u2200 X, has_neg (foo X)`. Suppose we also have an instance\n`\u2200 X [cromulent X], add_group (foo X)`. Then the `(-)` coming from\n`add_group.has_sub` cannot be definitionally equal to the `(-)` coming from\n`foo.has_sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `add_monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "sub_neg_monoid.sub", "description": " A `sub_neg_monoid` is an `add_monoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : \u2200 a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_sub (foo X)` instance but no\n`\u2200 X, has_neg (foo X)`. Suppose we also have an instance\n`\u2200 X [cromulent X], add_group (foo X)`. Then the `(-)` coming from\n`add_group.has_sub` cannot be definitionally equal to the `(-)` coming from\n`foo.has_sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `add_monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "sub_neg_monoid.sub_eq_add_neg", "description": " A `sub_neg_monoid` is an `add_monoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : \u2200 a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_sub (foo X)` instance but no\n`\u2200 X, has_neg (foo X)`. Suppose we also have an instance\n`\u2200 X [cromulent X], add_group (foo X)`. Then the `(-)` coming from\n`add_group.has_sub` cannot be definitionally equal to the `(-)` coming from\n`foo.has_sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `add_monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "sub_neg_monoid.zsmul", "description": " A `sub_neg_monoid` is an `add_monoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : \u2200 a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_sub (foo X)` instance but no\n`\u2200 X, has_neg (foo X)`. Suppose we also have an instance\n`\u2200 X [cromulent X], add_group (foo X)`. Then the `(-)` coming from\n`add_group.has_sub` cannot be definitionally equal to the `(-)` coming from\n`foo.has_sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `add_monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "sub_neg_monoid.zsmul_zero'", "description": " A `sub_neg_monoid` is an `add_monoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : \u2200 a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_sub (foo X)` instance but no\n`\u2200 X, has_neg (foo X)`. Suppose we also have an instance\n`\u2200 X [cromulent X], add_group (foo X)`. Then the `(-)` coming from\n`add_group.has_sub` cannot be definitionally equal to the `(-)` coming from\n`foo.has_sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `add_monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "sub_neg_monoid.zsmul_succ'", "description": " A `sub_neg_monoid` is an `add_monoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : \u2200 a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_sub (foo X)` instance but no\n`\u2200 X, has_neg (foo X)`. Suppose we also have an instance\n`\u2200 X [cromulent X], add_group (foo X)`. Then the `(-)` coming from\n`add_group.has_sub` cannot be definitionally equal to the `(-)` coming from\n`foo.has_sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `add_monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "sub_neg_monoid.zsmul_neg'", "description": " A `sub_neg_monoid` is an `add_monoid` with unary `-` and binary `-` operations\nsatisfying `sub_eq_add_neg : \u2200 a b, a - b = a + -b`.\n\nThe default for `sub` is such that `a - b = a + -b` holds by definition.\n\nAdding `sub` as a field rather than defining `a - b := a + -b` allows us to\navoid certain classes of unification failures, for example:\nLet `foo X` be a type with a `\u2200 X, has_sub (foo X)` instance but no\n`\u2200 X, has_neg (foo X)`. Suppose we also have an instance\n`\u2200 X [cromulent X], add_group (foo X)`. Then the `(-)` coming from\n`add_group.has_sub` cannot be definitionally equal to the `(-)` coming from\n`foo.has_sub`.\n\nIn the same way, adding a `zsmul` field makes it possible to avoid definitional failures\nin diamonds. See the definition of `add_monoid` and Note [forgetful inheritance] for more\nexplanations on this."}, {"name": "cancel_monoid.to_right_cancel_monoid", "description": ""}, {"name": "mul_one_class.ext", "description": ""}, {"name": "succ_nsmul", "description": ""}, {"name": "add_cancel_monoid.to_add_right_cancel_monoid", "description": ""}, {"name": "add_left_cancel_semigroup.to_add_semigroup", "description": ""}, {"name": "group.to_cancel_monoid", "description": ""}, {"name": "subtraction_comm_monoid", "description": "Commutative `subtraction_monoid`."}, {"name": "subtraction_comm_monoid.add", "description": "Commutative `subtraction_monoid`."}, {"name": "subtraction_comm_monoid.add_assoc", "description": "Commutative `subtraction_monoid`."}, {"name": "subtraction_comm_monoid.zero", "description": "Commutative `subtraction_monoid`."}, {"name": "subtraction_comm_monoid.zero_add", "description": "Commutative `subtraction_monoid`."}, {"name": "subtraction_comm_monoid.add_zero", "description": "Commutative `subtraction_monoid`."}, {"name": "subtraction_comm_monoid.nsmul", "description": "Commutative `subtraction_monoid`."}, {"name": "subtraction_comm_monoid.nsmul_zero'", "description": "Commutative `subtraction_monoid`."}, {"name": "subtraction_comm_monoid.nsmul_succ'", "description": "Commutative `subtraction_monoid`."}, {"name": "subtraction_comm_monoid.neg", "description": "Commutative `subtraction_monoid`."}, {"name": "subtraction_comm_monoid.sub", "description": "Commutative `subtraction_monoid`."}, {"name": "subtraction_comm_monoid.sub_eq_add_neg", "description": "Commutative `subtraction_monoid`."}, {"name": "subtraction_comm_monoid.zsmul", "description": "Commutative `subtraction_monoid`."}, {"name": "subtraction_comm_monoid.zsmul_zero'", "description": "Commutative `subtraction_monoid`."}, {"name": "subtraction_comm_monoid.zsmul_succ'", "description": "Commutative `subtraction_monoid`."}, {"name": "subtraction_comm_monoid.zsmul_neg'", "description": "Commutative `subtraction_monoid`."}, {"name": "subtraction_comm_monoid.neg_neg", "description": "Commutative `subtraction_monoid`."}, {"name": "subtraction_comm_monoid.neg_add_rev", "description": "Commutative `subtraction_monoid`."}, {"name": "subtraction_comm_monoid.neg_eq_of_add", "description": "Commutative `subtraction_monoid`."}, {"name": "subtraction_comm_monoid.add_comm", "description": "Commutative `subtraction_monoid`."}, {"name": "add_group.to_add_monoid", "description": "Abbreviation for `@sub_neg_monoid.to_add_monoid _ (@add_group.to_sub_neg_monoid _ _)`.\n\nUseful because it corresponds to the fact that `AddGroup` is a subcategory of `AddMon`.\nNot an instance since it duplicates\n`@sub_neg_monoid.to_add_monoid _ (@add_group.to_sub_neg_monoid _ _)`."}, {"name": "left_cancel_semigroup.ext", "description": ""}, {"name": "group.to_monoid", "description": " Abbreviation for `@div_inv_monoid.to_monoid _ (@group.to_div_inv_monoid _ _)`.\n\nUseful because it corresponds to the fact that `Grp` is a subcategory of `Mon`.\nNot an instance since it duplicates `@div_inv_monoid.to_monoid _ (@group.to_div_inv_monoid _ _)`.\nSee note [reducible non-instances]."}, {"name": "add_cancel_comm_monoid.to_add_comm_monoid", "description": ""}, {"name": "division_monoid", "description": " A `division_monoid` is a `div_inv_monoid` with involutive inversion and such that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9` and `a * b = 1 \u2192 a\u207b\u00b9 = b`.\n\nThis is the immediate common ancestor of `group` and `group_with_zero`."}, {"name": "division_monoid.mul", "description": " A `division_monoid` is a `div_inv_monoid` with involutive inversion and such that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9` and `a * b = 1 \u2192 a\u207b\u00b9 = b`.\n\nThis is the immediate common ancestor of `group` and `group_with_zero`."}, {"name": "division_monoid.mul_assoc", "description": " A `division_monoid` is a `div_inv_monoid` with involutive inversion and such that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9` and `a * b = 1 \u2192 a\u207b\u00b9 = b`.\n\nThis is the immediate common ancestor of `group` and `group_with_zero`."}, {"name": "division_monoid.one", "description": " A `division_monoid` is a `div_inv_monoid` with involutive inversion and such that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9` and `a * b = 1 \u2192 a\u207b\u00b9 = b`.\n\nThis is the immediate common ancestor of `group` and `group_with_zero`."}, {"name": "division_monoid.one_mul", "description": " A `division_monoid` is a `div_inv_monoid` with involutive inversion and such that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9` and `a * b = 1 \u2192 a\u207b\u00b9 = b`.\n\nThis is the immediate common ancestor of `group` and `group_with_zero`."}, {"name": "division_monoid.mul_one", "description": " A `division_monoid` is a `div_inv_monoid` with involutive inversion and such that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9` and `a * b = 1 \u2192 a\u207b\u00b9 = b`.\n\nThis is the immediate common ancestor of `group` and `group_with_zero`."}, {"name": "division_monoid.npow", "description": " A `division_monoid` is a `div_inv_monoid` with involutive inversion and such that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9` and `a * b = 1 \u2192 a\u207b\u00b9 = b`.\n\nThis is the immediate common ancestor of `group` and `group_with_zero`."}, {"name": "division_monoid.npow_zero'", "description": " A `division_monoid` is a `div_inv_monoid` with involutive inversion and such that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9` and `a * b = 1 \u2192 a\u207b\u00b9 = b`.\n\nThis is the immediate common ancestor of `group` and `group_with_zero`."}, {"name": "division_monoid.npow_succ'", "description": " A `division_monoid` is a `div_inv_monoid` with involutive inversion and such that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9` and `a * b = 1 \u2192 a\u207b\u00b9 = b`.\n\nThis is the immediate common ancestor of `group` and `group_with_zero`."}, {"name": "division_monoid.inv", "description": " A `division_monoid` is a `div_inv_monoid` with involutive inversion and such that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9` and `a * b = 1 \u2192 a\u207b\u00b9 = b`.\n\nThis is the immediate common ancestor of `group` and `group_with_zero`."}, {"name": "division_monoid.div", "description": " A `division_monoid` is a `div_inv_monoid` with involutive inversion and such that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9` and `a * b = 1 \u2192 a\u207b\u00b9 = b`.\n\nThis is the immediate common ancestor of `group` and `group_with_zero`."}, {"name": "division_monoid.div_eq_mul_inv", "description": " A `division_monoid` is a `div_inv_monoid` with involutive inversion and such that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9` and `a * b = 1 \u2192 a\u207b\u00b9 = b`.\n\nThis is the immediate common ancestor of `group` and `group_with_zero`."}, {"name": "division_monoid.zpow", "description": " A `division_monoid` is a `div_inv_monoid` with involutive inversion and such that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9` and `a * b = 1 \u2192 a\u207b\u00b9 = b`.\n\nThis is the immediate common ancestor of `group` and `group_with_zero`."}, {"name": "division_monoid.zpow_zero'", "description": " A `division_monoid` is a `div_inv_monoid` with involutive inversion and such that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9` and `a * b = 1 \u2192 a\u207b\u00b9 = b`.\n\nThis is the immediate common ancestor of `group` and `group_with_zero`."}, {"name": "division_monoid.zpow_succ'", "description": " A `division_monoid` is a `div_inv_monoid` with involutive inversion and such that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9` and `a * b = 1 \u2192 a\u207b\u00b9 = b`.\n\nThis is the immediate common ancestor of `group` and `group_with_zero`."}, {"name": "division_monoid.zpow_neg'", "description": " A `division_monoid` is a `div_inv_monoid` with involutive inversion and such that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9` and `a * b = 1 \u2192 a\u207b\u00b9 = b`.\n\nThis is the immediate common ancestor of `group` and `group_with_zero`."}, {"name": "division_monoid.inv_inv", "description": " A `division_monoid` is a `div_inv_monoid` with involutive inversion and such that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9` and `a * b = 1 \u2192 a\u207b\u00b9 = b`.\n\nThis is the immediate common ancestor of `group` and `group_with_zero`."}, {"name": "division_monoid.mul_inv_rev", "description": " A `division_monoid` is a `div_inv_monoid` with involutive inversion and such that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9` and `a * b = 1 \u2192 a\u207b\u00b9 = b`.\n\nThis is the immediate common ancestor of `group` and `group_with_zero`."}, {"name": "division_monoid.inv_eq_of_mul", "description": " A `division_monoid` is a `div_inv_monoid` with involutive inversion and such that\n`(a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9` and `a * b = 1 \u2192 a\u207b\u00b9 = b`.\n\nThis is the immediate common ancestor of `group` and `group_with_zero`."}, {"name": "sub_neg_monoid.to_has_neg", "description": ""}, {"name": "zpow_rec", "description": " The fundamental power operation in a group. `zpow_rec n a = a*a*...*a` n times, for integer `n`.\nUse instead `a ^ n`,  which has better definitional behavior."}, {"name": "comm_semigroup", "description": "A commutative semigroup is a type with an associative commutative `(*)`."}, {"name": "comm_semigroup.mul", "description": "A commutative semigroup is a type with an associative commutative `(*)`."}, {"name": "comm_semigroup.mul_assoc", "description": "A commutative semigroup is a type with an associative commutative `(*)`."}, {"name": "comm_semigroup.mul_comm", "description": "A commutative semigroup is a type with an associative commutative `(*)`."}, {"name": "add_right_neg", "description": ""}, {"name": "add_ne_add_left", "description": ""}, {"name": "add_cancel_monoid", "description": " An additive monoid in which addition is cancellative on both sides.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "add_cancel_monoid.add", "description": " An additive monoid in which addition is cancellative on both sides.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "add_cancel_monoid.add_assoc", "description": " An additive monoid in which addition is cancellative on both sides.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "add_cancel_monoid.add_left_cancel", "description": " An additive monoid in which addition is cancellative on both sides.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "add_cancel_monoid.zero", "description": " An additive monoid in which addition is cancellative on both sides.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "add_cancel_monoid.zero_add", "description": " An additive monoid in which addition is cancellative on both sides.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "add_cancel_monoid.add_zero", "description": " An additive monoid in which addition is cancellative on both sides.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "add_cancel_monoid.nsmul", "description": " An additive monoid in which addition is cancellative on both sides.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "add_cancel_monoid.nsmul_zero'", "description": " An additive monoid in which addition is cancellative on both sides.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "add_cancel_monoid.nsmul_succ'", "description": " An additive monoid in which addition is cancellative on both sides.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "add_cancel_monoid.add_right_cancel", "description": " An additive monoid in which addition is cancellative on both sides.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "nsmul_rec", "description": " The fundamental scalar multiplication in an additive monoid. `nsmul_rec n a = a+a+...+a` n\ntimes. Use instead `n \u2022 a`, which has better definitional behavior."}, {"name": "comm_monoid.to_monoid", "description": ""}, {"name": "has_involutive_inv.to_has_inv", "description": ""}, {"name": "add_comm_semigroup", "description": "A commutative additive semigroup is a type with an associative commutative `(+)`."}, {"name": "add_comm_semigroup.add", "description": "A commutative additive semigroup is a type with an associative commutative `(+)`."}, {"name": "add_comm_semigroup.add_assoc", "description": "A commutative additive semigroup is a type with an associative commutative `(+)`."}, {"name": "add_comm_semigroup.add_comm", "description": "A commutative additive semigroup is a type with an associative commutative `(+)`."}, {"name": "mul_one_class.to_has_one", "description": ""}, {"name": "div_eq_mul_inv", "description": " Dividing by an element is the same as multiplying by its inverse.\n\nThis is a duplicate of `div_inv_monoid.div_eq_mul_inv` ensuring that the types unfold better."}, {"name": "has_vsub", "description": "Type class for the `-\u1d65` notation."}, {"name": "has_vsub.vsub", "description": "Type class for the `-\u1d65` notation."}, {"name": "of_nat_zsmul", "description": ""}, {"name": "add_comm_monoid", "description": "An additive commutative monoid is an additive monoid with commutative `(+)`."}, {"name": "add_comm_monoid.add", "description": "An additive commutative monoid is an additive monoid with commutative `(+)`."}, {"name": "add_comm_monoid.add_assoc", "description": "An additive commutative monoid is an additive monoid with commutative `(+)`."}, {"name": "add_comm_monoid.zero", "description": "An additive commutative monoid is an additive monoid with commutative `(+)`."}, {"name": "add_comm_monoid.zero_add", "description": "An additive commutative monoid is an additive monoid with commutative `(+)`."}, {"name": "add_comm_monoid.add_zero", "description": "An additive commutative monoid is an additive monoid with commutative `(+)`."}, {"name": "add_comm_monoid.nsmul", "description": "An additive commutative monoid is an additive monoid with commutative `(+)`."}, {"name": "add_comm_monoid.nsmul_zero'", "description": "An additive commutative monoid is an additive monoid with commutative `(+)`."}, {"name": "add_comm_monoid.nsmul_succ'", "description": "An additive commutative monoid is an additive monoid with commutative `(+)`."}, {"name": "add_comm_monoid.add_comm", "description": "An additive commutative monoid is an additive monoid with commutative `(+)`."}, {"name": "mul_left_injective", "description": ""}, {"name": "semigroup.to_is_associative", "description": ""}, {"name": "add_left_neg", "description": ""}, {"name": "left_cancel_semigroup.to_semigroup", "description": ""}, {"name": "monoid.to_semigroup", "description": ""}, {"name": "comm_semigroup.to_is_commutative", "description": ""}, {"name": "add_neg_cancel_left", "description": ""}, {"name": "division_monoid.to_div_inv_monoid", "description": ""}, {"name": "neg_add_rev", "description": ""}, {"name": "zero_add", "description": ""}, {"name": "monoid", "description": "A `monoid` is a `semigroup` with an element `1` such that `1 * a = a * 1 = a`."}, {"name": "monoid.mul", "description": "A `monoid` is a `semigroup` with an element `1` such that `1 * a = a * 1 = a`."}, {"name": "monoid.mul_assoc", "description": "A `monoid` is a `semigroup` with an element `1` such that `1 * a = a * 1 = a`."}, {"name": "monoid.one", "description": "A `monoid` is a `semigroup` with an element `1` such that `1 * a = a * 1 = a`."}, {"name": "monoid.one_mul", "description": "A `monoid` is a `semigroup` with an element `1` such that `1 * a = a * 1 = a`."}, {"name": "monoid.mul_one", "description": "A `monoid` is a `semigroup` with an element `1` such that `1 * a = a * 1 = a`."}, {"name": "monoid.npow", "description": "A `monoid` is a `semigroup` with an element `1` such that `1 * a = a * 1 = a`."}, {"name": "monoid.npow_zero'", "description": "A `monoid` is a `semigroup` with an element `1` such that `1 * a = a * 1 = a`."}, {"name": "monoid.npow_succ'", "description": "A `monoid` is a `semigroup` with an element `1` such that `1 * a = a * 1 = a`."}, {"name": "division_comm_monoid", "description": " Commutative `division_monoid`.\n\nThis is the immediate common ancestor of `comm_group` and `comm_group_with_zero`."}, {"name": "division_comm_monoid.mul", "description": " Commutative `division_monoid`.\n\nThis is the immediate common ancestor of `comm_group` and `comm_group_with_zero`."}, {"name": "division_comm_monoid.mul_assoc", "description": " Commutative `division_monoid`.\n\nThis is the immediate common ancestor of `comm_group` and `comm_group_with_zero`."}, {"name": "division_comm_monoid.one", "description": " Commutative `division_monoid`.\n\nThis is the immediate common ancestor of `comm_group` and `comm_group_with_zero`."}, {"name": "division_comm_monoid.one_mul", "description": " Commutative `division_monoid`.\n\nThis is the immediate common ancestor of `comm_group` and `comm_group_with_zero`."}, {"name": "division_comm_monoid.mul_one", "description": " Commutative `division_monoid`.\n\nThis is the immediate common ancestor of `comm_group` and `comm_group_with_zero`."}, {"name": "division_comm_monoid.npow", "description": " Commutative `division_monoid`.\n\nThis is the immediate common ancestor of `comm_group` and `comm_group_with_zero`."}, {"name": "division_comm_monoid.npow_zero'", "description": " Commutative `division_monoid`.\n\nThis is the immediate common ancestor of `comm_group` and `comm_group_with_zero`."}, {"name": "division_comm_monoid.npow_succ'", "description": " Commutative `division_monoid`.\n\nThis is the immediate common ancestor of `comm_group` and `comm_group_with_zero`."}, {"name": "division_comm_monoid.inv", "description": " Commutative `division_monoid`.\n\nThis is the immediate common ancestor of `comm_group` and `comm_group_with_zero`."}, {"name": "division_comm_monoid.div", "description": " Commutative `division_monoid`.\n\nThis is the immediate common ancestor of `comm_group` and `comm_group_with_zero`."}, {"name": "division_comm_monoid.div_eq_mul_inv", "description": " Commutative `division_monoid`.\n\nThis is the immediate common ancestor of `comm_group` and `comm_group_with_zero`."}, {"name": "division_comm_monoid.zpow", "description": " Commutative `division_monoid`.\n\nThis is the immediate common ancestor of `comm_group` and `comm_group_with_zero`."}, {"name": "division_comm_monoid.zpow_zero'", "description": " Commutative `division_monoid`.\n\nThis is the immediate common ancestor of `comm_group` and `comm_group_with_zero`."}, {"name": "division_comm_monoid.zpow_succ'", "description": " Commutative `division_monoid`.\n\nThis is the immediate common ancestor of `comm_group` and `comm_group_with_zero`."}, {"name": "division_comm_monoid.zpow_neg'", "description": " Commutative `division_monoid`.\n\nThis is the immediate common ancestor of `comm_group` and `comm_group_with_zero`."}, {"name": "division_comm_monoid.inv_inv", "description": " Commutative `division_monoid`.\n\nThis is the immediate common ancestor of `comm_group` and `comm_group_with_zero`."}, {"name": "division_comm_monoid.mul_inv_rev", "description": " Commutative `division_monoid`.\n\nThis is the immediate common ancestor of `comm_group` and `comm_group_with_zero`."}, {"name": "division_comm_monoid.inv_eq_of_mul", "description": " Commutative `division_monoid`.\n\nThis is the immediate common ancestor of `comm_group` and `comm_group_with_zero`."}, {"name": "division_comm_monoid.mul_comm", "description": " Commutative `division_monoid`.\n\nThis is the immediate common ancestor of `comm_group` and `comm_group_with_zero`."}, {"name": "add_cancel_comm_monoid.to_cancel_add_monoid", "description": ""}, {"name": "add_cancel_monoid.to_add_left_cancel_monoid", "description": ""}, {"name": "zpow_neg_succ_of_nat", "description": ""}, {"name": "comm_semigroup.to_semigroup", "description": ""}, {"name": "inv_mul_self", "description": ""}, {"name": "neg_add_cancel_left", "description": ""}, {"name": "add_left_cancel_iff", "description": ""}, {"name": "add_semigroup.ext_iff", "description": ""}, {"name": "add_comm_group.to_cancel_add_comm_monoid", "description": ""}, {"name": "mul_comm", "description": ""}, {"name": "add_group.to_sub_neg_monoid", "description": ""}, {"name": "add_semigroup.ext", "description": ""}, {"name": "inv_inv", "description": ""}, {"name": "has_involutive_neg.to_has_neg", "description": ""}, {"name": "zpow_of_nat", "description": ""}, {"name": "add_left_cancel_monoid.to_add_left_cancel_semigroup", "description": ""}, {"name": "left_add", "description": "`left_add g` denotes left addition by `g`"}, {"name": "add_right_cancel_semigroup.to_add_semigroup", "description": ""}, {"name": "add_right_inj", "description": ""}, {"name": "add_group.to_cancel_add_monoid", "description": ""}, {"name": "add_left_cancel_semigroup.ext", "description": ""}, {"name": "division_monoid.to_has_involutive_inv", "description": ""}, {"name": "neg_neg", "description": ""}, {"name": "comm_group.to_comm_monoid", "description": ""}, {"name": "try_refl_tac", "description": " `try_refl_tac` solves goals of the form `\u2200 a b, f a b = g a b`,\nif they hold by definition."}, {"name": "has_smul.ext_iff", "description": ""}, {"name": "right_cancel_semigroup", "description": "A `right_cancel_semigroup` is a semigroup such that `a * b = c * b` implies `a = c`."}, {"name": "right_cancel_semigroup.mul", "description": "A `right_cancel_semigroup` is a semigroup such that `a * b = c * b` implies `a = c`."}, {"name": "right_cancel_semigroup.mul_assoc", "description": "A `right_cancel_semigroup` is a semigroup such that `a * b = c * b` implies `a = c`."}, {"name": "right_cancel_semigroup.mul_right_cancel", "description": "A `right_cancel_semigroup` is a semigroup such that `a * b = c * b` implies `a = c`."}, {"name": "coe_nat_zsmul", "description": ""}, {"name": "add_zero_class.to_is_right_id", "description": ""}, {"name": "left_inv_eq_right_inv", "description": ""}, {"name": "mul_left_inv", "description": ""}, {"name": "mul_left_cancel_iff", "description": ""}, {"name": "cancel_monoid", "description": "A monoid in which multiplication is cancellative."}, {"name": "cancel_monoid.mul", "description": "A monoid in which multiplication is cancellative."}, {"name": "cancel_monoid.mul_assoc", "description": "A monoid in which multiplication is cancellative."}, {"name": "cancel_monoid.mul_left_cancel", "description": "A monoid in which multiplication is cancellative."}, {"name": "cancel_monoid.one", "description": "A monoid in which multiplication is cancellative."}, {"name": "cancel_monoid.one_mul", "description": "A monoid in which multiplication is cancellative."}, {"name": "cancel_monoid.mul_one", "description": "A monoid in which multiplication is cancellative."}, {"name": "cancel_monoid.npow", "description": "A monoid in which multiplication is cancellative."}, {"name": "cancel_monoid.npow_zero'", "description": "A monoid in which multiplication is cancellative."}, {"name": "cancel_monoid.npow_succ'", "description": "A monoid in which multiplication is cancellative."}, {"name": "cancel_monoid.mul_right_cancel", "description": "A monoid in which multiplication is cancellative."}, {"name": "sub_eq_add_neg", "description": "Subtracting an element is the same as adding by its negative.\n\nThis is a duplicate of `sub_neg_monoid.sub_eq_mul_neg` ensuring that the types unfold better."}, {"name": "left_cancel_semigroup", "description": "A `left_cancel_semigroup` is a semigroup such that `a * b = a * c` implies `b = c`."}, {"name": "left_cancel_semigroup.mul", "description": "A `left_cancel_semigroup` is a semigroup such that `a * b = a * c` implies `b = c`."}, {"name": "left_cancel_semigroup.mul_assoc", "description": "A `left_cancel_semigroup` is a semigroup such that `a * b = a * c` implies `b = c`."}, {"name": "left_cancel_semigroup.mul_left_cancel", "description": "A `left_cancel_semigroup` is a semigroup such that `a * b = a * c` implies `b = c`."}, {"name": "sub_neg_monoid.has_smul_int", "description": ""}, {"name": "comm_semigroup.ext_iff", "description": ""}, {"name": "subtraction_monoid.to_sub_neg_monoid", "description": ""}, {"name": "semigroup", "description": "A semigroup is a type with an associative `(*)`."}, {"name": "semigroup.mul", "description": "A semigroup is a type with an associative `(*)`."}, {"name": "semigroup.mul_assoc", "description": "A semigroup is a type with an associative `(*)`."}, {"name": "right_cancel_semigroup.ext_iff", "description": ""}, {"name": "has_smul", "description": "Typeclass for types with a scalar multiplication operation, denoted `\u2022` (`\\bu`)"}, {"name": "has_smul.smul", "description": "Typeclass for types with a scalar multiplication operation, denoted `\u2022` (`\\bu`)"}, {"name": "mul_right_injective", "description": ""}, {"name": "add_zero_class", "description": " Typeclass for expressing that a type `M` with addition and a zero satisfies\n`0 + a = a` and `a + 0 = a` for all `a : M`."}, {"name": "add_zero_class.zero", "description": " Typeclass for expressing that a type `M` with addition and a zero satisfies\n`0 + a = a` and `a + 0 = a` for all `a : M`."}, {"name": "add_zero_class.add", "description": " Typeclass for expressing that a type `M` with addition and a zero satisfies\n`0 + a = a` and `a + 0 = a` for all `a : M`."}, {"name": "add_zero_class.zero_add", "description": " Typeclass for expressing that a type `M` with addition and a zero satisfies\n`0 + a = a` and `a + 0 = a` for all `a : M`."}, {"name": "add_zero_class.add_zero", "description": " Typeclass for expressing that a type `M` with addition and a zero satisfies\n`0 + a = a` and `a + 0 = a` for all `a : M`."}, {"name": "pow_succ", "description": ""}, {"name": "mul_one_class.to_has_mul", "description": ""}, {"name": "mul_inv_cancel_right", "description": ""}, {"name": "division_comm_monoid.to_division_monoid", "description": ""}, {"name": "add_right_cancel_monoid.to_add_right_cancel_semigroup", "description": ""}, {"name": "comm_group.to_group_injective", "description": ""}, {"name": "mul_left_inj", "description": ""}, {"name": "add_comm_monoid.to_add_comm_semigroup", "description": ""}, {"name": "add_monoid", "description": "An `add_monoid` is an `add_semigroup` with an element `0` such that `0 + a = a + 0 = a`."}, {"name": "add_monoid.add", "description": "An `add_monoid` is an `add_semigroup` with an element `0` such that `0 + a = a + 0 = a`."}, {"name": "add_monoid.add_assoc", "description": "An `add_monoid` is an `add_semigroup` with an element `0` such that `0 + a = a + 0 = a`."}, {"name": "add_monoid.zero", "description": "An `add_monoid` is an `add_semigroup` with an element `0` such that `0 + a = a + 0 = a`."}, {"name": "add_monoid.zero_add", "description": "An `add_monoid` is an `add_semigroup` with an element `0` such that `0 + a = a + 0 = a`."}, {"name": "add_monoid.add_zero", "description": "An `add_monoid` is an `add_semigroup` with an element `0` such that `0 + a = a + 0 = a`."}, {"name": "add_monoid.nsmul", "description": "An `add_monoid` is an `add_semigroup` with an element `0` such that `0 + a = a + 0 = a`."}, {"name": "add_monoid.nsmul_zero'", "description": "An `add_monoid` is an `add_semigroup` with an element `0` such that `0 + a = a + 0 = a`."}, {"name": "add_monoid.nsmul_succ'", "description": "An `add_monoid` is an `add_semigroup` with an element `0` such that `0 + a = a + 0 = a`."}, {"name": "pow_zero", "description": ""}, {"name": "add_left_cancel", "description": ""}, {"name": "subtraction_monoid", "description": " A `subtraction_monoid` is a `sub_neg_monoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 \u2192 -a = b`."}, {"name": "subtraction_monoid.add", "description": " A `subtraction_monoid` is a `sub_neg_monoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 \u2192 -a = b`."}, {"name": "subtraction_monoid.add_assoc", "description": " A `subtraction_monoid` is a `sub_neg_monoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 \u2192 -a = b`."}, {"name": "subtraction_monoid.zero", "description": " A `subtraction_monoid` is a `sub_neg_monoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 \u2192 -a = b`."}, {"name": "subtraction_monoid.zero_add", "description": " A `subtraction_monoid` is a `sub_neg_monoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 \u2192 -a = b`."}, {"name": "subtraction_monoid.add_zero", "description": " A `subtraction_monoid` is a `sub_neg_monoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 \u2192 -a = b`."}, {"name": "subtraction_monoid.nsmul", "description": " A `subtraction_monoid` is a `sub_neg_monoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 \u2192 -a = b`."}, {"name": "subtraction_monoid.nsmul_zero'", "description": " A `subtraction_monoid` is a `sub_neg_monoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 \u2192 -a = b`."}, {"name": "subtraction_monoid.nsmul_succ'", "description": " A `subtraction_monoid` is a `sub_neg_monoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 \u2192 -a = b`."}, {"name": "subtraction_monoid.neg", "description": " A `subtraction_monoid` is a `sub_neg_monoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 \u2192 -a = b`."}, {"name": "subtraction_monoid.sub", "description": " A `subtraction_monoid` is a `sub_neg_monoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 \u2192 -a = b`."}, {"name": "subtraction_monoid.sub_eq_add_neg", "description": " A `subtraction_monoid` is a `sub_neg_monoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 \u2192 -a = b`."}, {"name": "subtraction_monoid.zsmul", "description": " A `subtraction_monoid` is a `sub_neg_monoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 \u2192 -a = b`."}, {"name": "subtraction_monoid.zsmul_zero'", "description": " A `subtraction_monoid` is a `sub_neg_monoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 \u2192 -a = b`."}, {"name": "subtraction_monoid.zsmul_succ'", "description": " A `subtraction_monoid` is a `sub_neg_monoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 \u2192 -a = b`."}, {"name": "subtraction_monoid.zsmul_neg'", "description": " A `subtraction_monoid` is a `sub_neg_monoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 \u2192 -a = b`."}, {"name": "subtraction_monoid.neg_neg", "description": " A `subtraction_monoid` is a `sub_neg_monoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 \u2192 -a = b`."}, {"name": "subtraction_monoid.neg_add_rev", "description": " A `subtraction_monoid` is a `sub_neg_monoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 \u2192 -a = b`."}, {"name": "subtraction_monoid.neg_eq_of_add", "description": " A `subtraction_monoid` is a `sub_neg_monoid` with involutive negation and such that\n`-(a + b) = -b + -a` and `a + b = 0 \u2192 -a = b`."}, {"name": "right_cancel_monoid.to_right_cancel_semigroup", "description": ""}, {"name": "cancel_comm_monoid.to_left_cancel_monoid", "description": ""}, {"name": "nsmul_eq_smul", "description": ""}, {"name": "comm_semigroup.ext", "description": ""}, {"name": "left_neg_eq_right_neg", "description": ""}, {"name": "add_right_cancel_iff", "description": ""}, {"name": "add_comm_semigroup.to_is_commutative", "description": ""}, {"name": "group.to_div_inv_monoid", "description": ""}, {"name": "left_cancel_semigroup.ext_iff", "description": ""}, {"name": "div_inv_monoid.to_has_inv", "description": ""}, {"name": "add_right_cancel_monoid", "description": " An additive monoid in which addition is right-cancellative.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "add_right_cancel_monoid.add", "description": " An additive monoid in which addition is right-cancellative.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "add_right_cancel_monoid.add_assoc", "description": " An additive monoid in which addition is right-cancellative.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "add_right_cancel_monoid.add_right_cancel", "description": " An additive monoid in which addition is right-cancellative.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "add_right_cancel_monoid.zero", "description": " An additive monoid in which addition is right-cancellative.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "add_right_cancel_monoid.zero_add", "description": " An additive monoid in which addition is right-cancellative.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "add_right_cancel_monoid.add_zero", "description": " An additive monoid in which addition is right-cancellative.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "add_right_cancel_monoid.nsmul", "description": " An additive monoid in which addition is right-cancellative.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "add_right_cancel_monoid.nsmul_zero'", "description": " An additive monoid in which addition is right-cancellative.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "add_right_cancel_monoid.nsmul_succ'", "description": " An additive monoid in which addition is right-cancellative.\nMain examples are `\u2115` and groups. This is the right typeclass for many sum lemmas, as having a zero\nis useful to define the sum over the empty set, so `add_right_cancel_semigroup` is not enough."}, {"name": "add_zero_class.ext", "description": ""}, {"name": "zpow_eq_pow", "description": ""}, {"name": "library_note.forgetful inheritance", "description": " Suppose that one can put two mathematical structures on a type, a rich one `R` and a poor one\n`P`, and that one can deduce the poor structure from the rich structure through a map `F` (called a\nforgetful functor) (think `R = metric_space` and `P = topological_space`). A possible\nimplementation would be to have a type class `rich` containing a field `R`, a type class `poor`\ncontaining a field `P`, and an instance from `rich` to `poor`. However, this creates diamond\nproblems, and a better approach is to let `rich` extend `poor` and have a field saying that\n`F R = P`.\n\nTo illustrate this, consider the pair `metric_space` / `topological_space`. Consider the topology\non a product of two metric spaces. With the first approach, it could be obtained by going first from\neach metric space to its topology, and then taking the product topology. But it could also be\nobtained by considering the product metric space (with its sup distance) and then the topology\ncoming from this distance. These would be the same topology, but not definitionally, which means\nthat from the point of view of Lean's kernel, there would be two different `topological_space`\ninstances on the product. This is not compatible with the way instances are designed and used:\nthere should be at most one instance of a kind on each type. This approach has created an instance\ndiamond that does not commute definitionally.\n\nThe second approach solves this issue. Now, a metric space contains both a distance, a topology, and\na proof that the topology coincides with the one coming from the distance. When one defines the\nproduct of two metric spaces, one uses the sup distance and the product topology, and one has to\ngive the proof that the sup distance induces the product topology. Following both sides of the\ninstance diamond then gives rise (definitionally) to the product topology on the product space.\n\nAnother approach would be to have the rich type class take the poor type class as an instance\nparameter. It would solve the diamond problem, but it would lead to a blow up of the number\nof type classes one would need to declare to work with complicated classes, say a real inner\nproduct space, and would create exponential complexity when working with products of\nsuch complicated spaces, that are avoided by bundling things carefully as above.\n\nNote that this description of this specific case of the product of metric spaces is oversimplified\ncompared to mathlib, as there is an intermediate typeclass between `metric_space` and\n`topological_space` called `uniform_space`. The above scheme is used at both levels, embedding a\ntopology in the uniform space structure, and a uniform structure in the metric space structure.\n\nNote also that, when `P` is a proposition, there is no such issue as any two proofs of `P` are\ndefinitionally equivalent in Lean.\n\nTo avoid boilerplate, there are some designs that can automatically fill the poor fields when\ncreating a rich structure if one doesn't want to do something special about them. For instance,\nin the definition of metric spaces, default tactics fill the uniform space fields if they are\nnot given explicitly. One can also have a helper function creating the rich structure from a\nstructure with fewer fields, where the helper function fills the remaining fields. See for instance\n`uniform_space.of_core` or `real_inner_product.of_core`.\n\nFor more details on this question, called the forgetful inheritance pattern, see [Competing\ninheritance paths in dependent type theory: a case study in functional\nanalysis](https://hal.inria.fr/hal-02463336)."}, {"name": "add_right_cancel_monoid.to_add_monoid", "description": ""}, {"name": "right_cancel_semigroup.to_semigroup", "description": ""}, {"name": "cancel_monoid.to_left_cancel_monoid", "description": ""}, {"name": "left_cancel_monoid.to_monoid", "description": ""}, {"name": "inv_mul_cancel_right", "description": ""}, {"name": "add_ne_add_right", "description": ""}, {"name": "zpow_coe_nat", "description": ""}, {"name": "add_semigroup", "description": "An additive semigroup is a type with an associative `(+)`."}, {"name": "add_semigroup.add", "description": "An additive semigroup is a type with an associative `(+)`."}, {"name": "add_semigroup.add_assoc", "description": "An additive semigroup is a type with an associative `(+)`."}, {"name": "name_set.to_list", "description": ""}, {"name": "native.rb_map.of_list", "description": ""}, {"name": "name_set.size", "description": ""}, {"name": "native.rb_set", "description": ""}, {"name": "name_set.mfold", "description": ""}, {"name": "native.rb_set.erase", "description": ""}, {"name": "name_map", "description": ""}, {"name": "native.rb_set.size", "description": ""}, {"name": "mk_name_set", "description": ""}, {"name": "native.rb_lmap.find", "description": ""}, {"name": "name_set.of_list", "description": ""}, {"name": "name_set.has_to_format", "description": ""}, {"name": "mk_name_map", "description": ""}, {"name": "name_set.contains", "description": ""}, {"name": "name_set.union", "description": ""}, {"name": "native.rb_map.map", "description": ""}, {"name": "native.rb_map.mk", "description": ""}, {"name": "native.rb_map", "description": ""}, {"name": "native.rb_map.has_to_string", "description": ""}, {"name": "native.rb_set.fold", "description": ""}, {"name": "native.rb_set.contains", "description": ""}, {"name": "native.rb_map.insert", "description": ""}, {"name": "native.rb_lmap.contains", "description": ""}, {"name": "name_set.insert", "description": ""}, {"name": "native.rb_map.max", "description": ""}, {"name": "native.rb_lmap.mk", "description": ""}, {"name": "native.rb_set.mfold", "description": ""}, {"name": "native.rb_map.values", "description": ""}, {"name": "native.rb_map.for", "description": ""}, {"name": "native.rb_map.keys", "description": ""}, {"name": "name_set.erase", "description": ""}, {"name": "native.rb_set.has_to_format", "description": ""}, {"name": "native.nat_map.mk", "description": ""}, {"name": "name_set", "description": "An rb_map of `name`s."}, {"name": "native.rb_map.mfold", "description": ""}, {"name": "native.rb_map.empty", "description": ""}, {"name": "native.rb_map.set_of_list", "description": ""}, {"name": "native.rb_lmap.insert", "description": ""}, {"name": "native.rb_lmap.erase", "description": ""}, {"name": "native.rb_map.size", "description": ""}, {"name": "native.rb_map.find", "description": ""}, {"name": "name_set.empty", "description": ""}, {"name": "native.mk_rb_set", "description": ""}, {"name": "native.nat_map", "description": ""}, {"name": "native.rb_map.contains", "description": ""}, {"name": "native.rb_set.insert", "description": ""}, {"name": "name_set.fold", "description": ""}, {"name": "native.rb_map.mk_core", "description": ""}, {"name": "native.rb_map.min", "description": ""}, {"name": "native.rb_lmap", "description": "a variant of rb_maps that stores a list of elements for each key.\n  `find` returns the list of elements in the opposite order that they were inserted."}, {"name": "native.rb_map.filter", "description": ""}, {"name": "native.rb_map.erase", "description": ""}, {"name": "native.mk_nat_map", "description": ""}, {"name": "native.mk_rb_map", "description": ""}, {"name": "native.rb_set.to_list", "description": ""}, {"name": "native.rb_map.fold", "description": ""}, {"name": "name_map.mk", "description": ""}, {"name": "native.rb_map.to_list", "description": ""}, {"name": "native.rb_set.empty", "description": ""}, {"name": "native.rb_map.has_to_format", "description": ""}, {"name": "norm_cast.mk_cache", "description": "`mk_cache names` creates a `norm_cast_cache`. It infers the proper `norm_cast` attributes\nfor names in `names`, and collects the lemmas attributed with specific `norm_cast` attributes."}, {"name": "norm_cast.derive_push_cast", "description": "A small variant of `push_cast` suited for non-interactive use.\n\n`derive_push_cast extra_lems e` returns an expression `e'` and a proof that `e = e'`."}, {"name": "tactic.interactive.exact_mod_cast", "description": "Normalize the goal and the given expression, then close the goal with exact."}, {"name": "tactic.interactive.rw_mod_cast", "description": "Rewrite with the given rules and normalize casts between steps."}, {"name": "norm_cast.add_lemma", "description": "`add_lemma cache decl` infers the proper `norm_cast` attribute for `decl` and adds it to `cache`."}, {"name": "simp_attr.push_cast", "description": "The `push_cast` simp attribute uses `norm_cast` lemmas\nto move casts toward the leaf nodes of the expression."}, {"name": "norm_cast.label.has_to_string", "description": ""}, {"name": "tactic.mk_instance_fast", "description": "Runs `mk_instance` with a time limit.\n\nThis is a work around to the fact that in some cases\nmk_instance times out instead of failing,\nfor example: `has_lift_t \u2124 \u2115`\n\n`mk_instance_fast` is used when we assume the type class search\nshould end instantly."}, {"name": "norm_cast.label.has_reflect", "description": ""}, {"name": "tactic_doc.tactic.norm_cast", "description": "The `norm_cast` family of tactics is used to normalize casts inside expressions.\nIt is basically a simp tactic with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore it can be used more safely as a non-terminating tactic.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : \u2124\nh : \u2191a + \u2191b < (10 : \u211a)\n```\n\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nYou can also use `exact_mod_cast`, `apply_mod_cast`, `rw_mod_cast`\nor `assumption_mod_cast`.\nWriting `exact_mod_cast h` and `apply_mod_cast h` will normalize the goal and\n`h` before using `exact h` or `apply h`.\nWriting `assumption_mod_cast` will normalize the goal and for every\nexpression `h` in the context it will try to normalize `h` and use\n`exact h`.\n`rw_mod_cast` acts like the `rw` tactic but it applies `norm_cast` between steps.\n\n`push_cast` rewrites the expression to move casts toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `\u2191(a + b)` will be written to `\u2191a + \u2191b`.\nIt is equivalent to `simp only with push_cast`.\nIt can also be used at hypotheses with `push_cast at h`\nand with extra simp lemmas with `push_cast [int.add_zero]`.\n\n```lean\nexample (a b : \u2115) (h1 : ((a + b : \u2115) : \u2124) = 10) (h2 : ((a + b + 0 : \u2115) : \u2124) = 10) :\n  ((a + b : \u2115) : \u2124) = 10 :=\nbegin\n  push_cast,\n  push_cast at h1,\n  push_cast [int.add_zero] at h2,\nend\n```\n\nThe implementation and behavior of the `norm_cast` family is described in detail at\n<https://lean-forward.github.io/norm_cast/norm_cast.pdf>."}, {"name": "tactic.interactive.push_cast", "description": "`push_cast` rewrites the expression to move casts toward the leaf nodes.\nFor example, `\u2191(a + b)` will be written to `\u2191a + \u2191b`.\nEquivalent to `simp only with push_cast`.\nCan also be used at hypotheses.\n\n`push_cast` can also be used at hypotheses and with extra simp rules.\n\n```lean\nexample (a b : \u2115) (h1 : ((a + b : \u2115) : \u2124) = 10) (h2 : ((a + b + 0 : \u2115) : \u2124) = 10) :\n  ((a + b : \u2115) : \u2124) = 10 :=\nbegin\n  push_cast,\n  push_cast at h1,\n  push_cast [int.add_zero] at h2,\nend\n```"}, {"name": "norm_cast.label.decidable_eq", "description": ""}, {"name": "norm_cast.splitting_procedure", "description": "This is the main heuristic used alongside the elim and move lemmas.\nThe goal is to help casts move past operators by adding intermediate casts.\nAn expression of the shape: op (\u2191(x : \u03b1) : \u03b3) (\u2191(y : \u03b2) : \u03b3)\nis rewritten to:            op (\u2191(\u2191(x : \u03b1) : \u03b2) : \u03b3) (\u2191(y : \u03b2) : \u03b3)\nwhen (\u2191(\u2191(x : \u03b1) : \u03b2) : \u03b3) = (\u2191(x : \u03b1) : \u03b3) can be proven with a squash lemma"}, {"name": "norm_cast.norm_cast_attr_ty", "description": "The type of the `norm_cast` attribute.\nThe optional label is used to overwrite the classifier."}, {"name": "norm_cast.empty_cache", "description": "Empty `norm_cast_cache`."}, {"name": "tactic.interactive.norm_cast", "description": "Normalize casts at the given locations by moving them \"upwards\".\nAs opposed to simp, norm_cast can be used without necessarily closing the goal."}, {"name": "norm_cast.label.has_to_format", "description": ""}, {"name": "norm_cast.make_guess", "description": "Classify a declaration as a `norm_cast` rule."}, {"name": "tactic.interactive.assumption_mod_cast", "description": "Normalize the goal and every expression in the local context, then close the goal with assumption."}, {"name": "norm_cast.prove_eq_using_down", "description": "Prove `a = b` by simplifying using move and squash lemmas."}, {"name": "tactic.assumption_mod_cast", "description": " `assumption_mod_cast` runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` and tries to use that to close the goal."}, {"name": "norm_cast.count_head_coes", "description": "Count how many coercions are at the top of the expression."}, {"name": "tactic.interactive.apply_mod_cast", "description": "Normalize the goal and the given expression, then apply the expression to the goal."}, {"name": "tactic.exact_mod_cast", "description": " `exact_mod_cast e` runs `norm_cast` on the goal and `e`, and tries to use `e` to close the\ngoal."}, {"name": "norm_cast.trace_norm_cast", "description": "Output a trace message if `trace.norm_cast` is enabled."}, {"name": "norm_cast.count_coes", "description": "Count how many coercions are inside the expression, including the top ones."}, {"name": "tactic.apply_mod_cast", "description": "`apply_mod_cast e` runs `norm_cast` on the goal and `e`, and tries to apply `e`."}, {"name": "dite_cast", "description": ""}, {"name": "norm_cast.upward_and_elim", "description": "Core rewriting function used in the \"squash\" step, which moves casts upwards\nand eliminates them.\n\nIt tries to rewrite an expression using the elim and move lemmas.\nOn failure, it calls the splitting procedure heuristic."}, {"name": "norm_cast.label.of_string", "description": "Convert `string` into `label`."}, {"name": "norm_cast.classify_type", "description": "Classifies a declaration of type `ty` as a `norm_cast` rule."}, {"name": "norm_cast.get_label", "description": "Gets the `norm_cast` classification label for a declaration. Applies the\noverride specified on the attribute, if necessary."}, {"name": "tactic_doc.attribute.norm_cast attributes", "description": "The `norm_cast` attribute should be given to lemmas that describe the\nbehaviour of a coercion in regard to an operator, a relation, or a particular\nfunction.\n\nIt only concerns equality or iff lemmas involving `\u2191`, `\u21d1` and `\u21a5`, describing the behavior of\nthe coercion functions.\nIt does not apply to the explicit functions that define the coercions.\n\nExamples:\n```lean\n@[norm_cast] theorem coe_nat_inj' {m n : \u2115} : (\u2191m : \u2124) = \u2191n \u2194 m = n\n\n@[norm_cast] theorem coe_int_denom (n : \u2124) : (n : \u211a).denom = 1\n\n@[norm_cast] theorem cast_id : \u2200 n : \u211a, \u2191n = n\n\n@[norm_cast] theorem coe_nat_add (m n : \u2115) : (\u2191(m + n) : \u2124) = \u2191m + \u2191n\n\n@[norm_cast] theorem cast_sub [add_group \u03b1] [has_one \u03b1] {m n} (h : m \u2264 n) :\n  ((n - m : \u2115) : \u03b1) = n - m\n\n@[norm_cast] theorem coe_nat_bit0 (n : \u2115) : (\u2191(bit0 n) : \u2124) = bit0 \u2191n\n\n@[norm_cast] theorem cast_coe_nat (n : \u2115) : ((n : \u2124) : \u03b1) = n\n\n@[norm_cast] theorem cast_one : ((1 : \u211a) : \u03b1) = 1\n```\n\nLemmas tagged with `@[norm_cast]` are classified into three categories: `move`, `elim`, and\n`squash`. They are classified roughly as follows:\n\n* elim lemma:   LHS has 0 head coes and \u2265 1 internal coe\n* move lemma:   LHS has 1 head coe and 0 internal coes,    RHS has 0 head coes and \u2265 1 internal coes\n* squash lemma: LHS has \u2265 1 head coes and 0 internal coes, RHS has fewer head coes\n\n`norm_cast` uses `move` and `elim` lemmas to factor coercions toward the root of an expression\nand to cancel them from both sides of an equation or relation. It uses `squash` lemmas to clean\nup the result.\n\nOccasionally you may want to override the automatic classification.\nYou can do this by giving an optional `elim`, `move`, or `squash` parameter to the attribute.\n\n```lean\n@[simp, norm_cast elim] lemma nat_cast_re (n : \u2115) : (n : \u2102).re = n :=\nby rw [\u2190 of_real_nat_cast, of_real_re]\n```\n\nDon't do this unless you understand what you are doing.\n\nA full description of the tactic, and the use of each lemma category, can be found at\n<https://lean-forward.github.io/norm_cast/norm_cast.pdf>."}, {"name": "norm_cast.add_move", "description": "`add_move cache e` adds `e` as a `move` lemma to `cache`."}, {"name": "norm_cast.add_elim", "description": "`add_elim cache e` adds `e` as an `elim` lemma to `cache`."}, {"name": "norm_cast.derive", "description": "The core simplification routine of `norm_cast`."}, {"name": "norm_cast.prove_eq_using", "description": "Prove `a = b` using the given simp set."}, {"name": "norm_cast.label", "description": "`label` is a type used to classify `norm_cast` lemmas.\n* elim lemma:   LHS has 0 head coes and \u2265 1 internal coe\n* move lemma:   LHS has 1 head coe and 0 internal coes,    RHS has 0 head coes and \u2265 1 internal coes\n* squash lemma: LHS has \u2265 1 head coes and 0 internal coes, RHS has fewer head coes"}, {"name": "norm_cast.label.elim", "description": "`label` is a type used to classify `norm_cast` lemmas.\n* elim lemma:   LHS has 0 head coes and \u2265 1 internal coe\n* move lemma:   LHS has 1 head coe and 0 internal coes,    RHS has 0 head coes and \u2265 1 internal coes\n* squash lemma: LHS has \u2265 1 head coes and 0 internal coes, RHS has fewer head coes"}, {"name": "norm_cast.label.move", "description": "`label` is a type used to classify `norm_cast` lemmas.\n* elim lemma:   LHS has 0 head coes and \u2265 1 internal coe\n* move lemma:   LHS has 1 head coe and 0 internal coes,    RHS has 0 head coes and \u2265 1 internal coes\n* squash lemma: LHS has \u2265 1 head coes and 0 internal coes, RHS has fewer head coes"}, {"name": "norm_cast.label.squash", "description": "`label` is a type used to classify `norm_cast` lemmas.\n* elim lemma:   LHS has 0 head coes and \u2265 1 internal coe\n* move lemma:   LHS has 1 head coe and 0 internal coes,    RHS has 0 head coes and \u2265 1 internal coes\n* squash lemma: LHS has \u2265 1 head coes and 0 internal coes, RHS has fewer head coes"}, {"name": "conv.interactive.norm_cast", "description": "the converter version of `norm_cast'"}, {"name": "tactic.aux_mod_cast", "description": " `aux_mod_cast e` runs `norm_cast` on `e` and returns the result. If `include_goal` is true, it\nalso normalizes the goal."}, {"name": "norm_cast.norm_cast_cache", "description": "The cache for `norm_cast` attribute stores three `simp_lemma` objects."}, {"name": "norm_cast.norm_cast_cache.up", "description": "The cache for `norm_cast` attribute stores three `simp_lemma` objects."}, {"name": "norm_cast.norm_cast_cache.down", "description": "The cache for `norm_cast` attribute stores three `simp_lemma` objects."}, {"name": "norm_cast.norm_cast_cache.squash", "description": "The cache for `norm_cast` attribute stores three `simp_lemma` objects."}, {"name": "norm_cast.numeral_to_coe", "description": "If possible, rewrite `(n : \u03b1)` to `((n : \u2115) : \u03b1)` where `n` is a numeral and `\u03b1 \u2260 \u2115`.\nReturns a pair of the new expression and proof that they are equal."}, {"name": "norm_cast.norm_cast_cache.inhabited", "description": ""}, {"name": "norm_cast.get_label_param", "description": "Efficient getter for the `@[norm_cast]` attribute parameter that does not call `eval_expr`.\n\nSee Note [user attribute parameters]."}, {"name": "norm_cast.label.to_string", "description": "Convert `label` into `string`."}, {"name": "norm_cast.add_squash", "description": "`add_squash cache e` adds `e` as an `squash` lemma to `cache`."}, {"name": "norm_cast.label.has_repr", "description": ""}, {"name": "ite_cast", "description": ""}, {"name": "norm_cast.label.inhabited", "description": ""}, {"name": "norm_cast.coe_to_numeral", "description": "If possible, rewrite `((n : \u2115) : \u03b1)` to `(n : \u03b1)` where `n` is a numeral.\nReturns a pair of the new expression and proof that they are equal."}, {"name": "norm_cast.norm_cast_attr", "description": "The `norm_cast` attribute."}, {"name": "category_theory.full_subcategory.full", "description": ""}, {"name": "category_theory.full_subcategory.lift", "description": "A functor which maps objects to objects satisfying a certain property induces a lift through\n   the full subcategory of objects satisfying that property."}, {"name": "category_theory.full_subcategory.map.faithful", "description": ""}, {"name": "category_theory.full_subcategory.faithful", "description": ""}, {"name": "category_theory.induced_category.faithful", "description": ""}, {"name": "category_theory.full_subcategory.lift.faithful", "description": ""}, {"name": "category_theory.full_subcategory.lift_obj_obj", "description": ""}, {"name": "category_theory.full_subcategory.inclusion_obj_lift_obj", "description": ""}, {"name": "category_theory.full_subcategory.map", "description": "An implication of predicates `Z \u2192 Z'` induces a functor between full subcategories."}, {"name": "category_theory.induced_functor", "description": "The forgetful functor from an induced category to the original category,\nforgetting the extra data."}, {"name": "category_theory.induced_category", "description": "`induced_category D F`, where `F : C \u2192 D`, is a typeclass synonym for `C`,\nwhich provides a category structure so that the morphisms `X \u27f6 Y` are the morphisms\nin `D` from `F X` to `F Y`."}, {"name": "category_theory.full_subcategory", "description": "A subtype-like structure for full subcategories. Morphisms just ignore the property. We don't use\nactual subtypes since the simp-normal form `\u2191X` of `X.val` does not work well for full\nsubcategories.\n\nSee <https://stacks.math.columbia.edu/tag/001D>. We do not define 'strictly full' subcategories."}, {"name": "category_theory.full_subcategory.obj", "description": "A subtype-like structure for full subcategories. Morphisms just ignore the property. We don't use\nactual subtypes since the simp-normal form `\u2191X` of `X.val` does not work well for full\nsubcategories.\n\nSee <https://stacks.math.columbia.edu/tag/001D>. We do not define 'strictly full' subcategories."}, {"name": "category_theory.full_subcategory.property", "description": "A subtype-like structure for full subcategories. Morphisms just ignore the property. We don't use\nactual subtypes since the simp-normal form `\u2191X` of `X.val` does not work well for full\nsubcategories.\n\nSee <https://stacks.math.columbia.edu/tag/001D>. We do not define 'strictly full' subcategories."}, {"name": "category_theory.induced_category.has_coe_to_sort", "description": ""}, {"name": "category_theory.induced_functor_obj", "description": ""}, {"name": "category_theory.full_subcategory_inclusion.map", "description": ""}, {"name": "category_theory.full_subcategory.map_obj_obj", "description": ""}, {"name": "category_theory.induced_category.category", "description": ""}, {"name": "category_theory.full_subcategory.inclusion_map_lift_map", "description": ""}, {"name": "category_theory.full_subcategory.category", "description": ""}, {"name": "category_theory.full_subcategory_inclusion", "description": "The forgetful functor from a full subcategory into the original category\n(\"forgetting\" the condition)."}, {"name": "category_theory.full_subcategory.lift.full", "description": ""}, {"name": "category_theory.full_subcategory.lift_comp_inclusion", "description": "Composing the lift of a functor through a full subcategory with the inclusion yields the\n   original functor. Unfortunately, this is not true by definition, so we only get a natural\n   isomorphism, but it is pointwise definitionally true, see\n   `full_subcategory.inclusion_obj_lift_obj` and `full_subcategory.inclusion_map_lift_map`."}, {"name": "category_theory.full_subcategory.map.full", "description": ""}, {"name": "category_theory.full_subcategory.lift_map", "description": ""}, {"name": "category_theory.full_subcategory.map_inclusion", "description": ""}, {"name": "category_theory.full_subcategory.ext", "description": ""}, {"name": "category_theory.induced_category.full", "description": ""}, {"name": "category_theory.induced_functor_map", "description": ""}, {"name": "category_theory.full_subcategory.lift_comp_map", "description": ""}, {"name": "category_theory.full_subcategory.map_map", "description": ""}, {"name": "category_theory.full_subcategory_inclusion.obj", "description": ""}, {"name": "category_theory.full_subcategory.ext_iff", "description": ""}, {"name": "int.sign_coe_nat_of_nonzero", "description": ""}, {"name": "int.dvd_of_mod_eq_zero", "description": ""}, {"name": "int.neg_div_of_dvd", "description": ""}, {"name": "int.eq_nat_abs_iff_mul_eq_zero", "description": ""}, {"name": "int.units_inv_eq_self", "description": ""}, {"name": "int.mod_add_div'", "description": ""}, {"name": "int.mod_add_cancel_left", "description": ""}, {"name": "int.lt_to_nat", "description": ""}, {"name": "int.coe_nat_ne_zero", "description": ""}, {"name": "int.neg_nat_succ", "description": ""}, {"name": "int.mod_two_eq_zero_or_one", "description": ""}, {"name": "int.bit0_ne_bit1", "description": ""}, {"name": "int.div_eq_zero_of_lt_abs", "description": ""}, {"name": "int.lt_div_iff_mul_lt", "description": ""}, {"name": "int.mod_add_div_aux", "description": ""}, {"name": "int.add_comm_monoid", "description": ""}, {"name": "int.of_nat_div", "description": ""}, {"name": "int.nat_abs_inj_of_nonneg_of_nonpos", "description": ""}, {"name": "int.add_mul_mod_self_left", "description": ""}, {"name": "int.mul_le_of_le_div", "description": ""}, {"name": "int.lt_of_to_nat_lt", "description": ""}, {"name": "int.neg_of_nat_ne_zero", "description": ""}, {"name": "int.mod_neg", "description": ""}, {"name": "int.pow_dvd_of_le_of_pow_dvd", "description": ""}, {"name": "int.nat_abs_eq_iff", "description": ""}, {"name": "int.shiftr_neg_succ", "description": ""}, {"name": "int.test_bit_lxor", "description": ""}, {"name": "int.neg_succ_not_nonneg", "description": ""}, {"name": "int.nat_abs_sub_le", "description": ""}, {"name": "int.nat_abs_le_of_dvd_ne_zero", "description": ""}, {"name": "int.div_nonneg", "description": ""}, {"name": "int.to_nat_sub_to_nat_neg", "description": ""}, {"name": "int.neg_succ_sub_one", "description": ""}, {"name": "int.div_eq_of_eq_mul_right", "description": ""}, {"name": "int.to_nat_neg_nat", "description": ""}, {"name": "int.div_le_of_le_mul", "description": ""}, {"name": "int.to_nat_coe_nat_add_one", "description": ""}, {"name": "int.test_bit_land", "description": ""}, {"name": "int.mod_self", "description": ""}, {"name": "int.add_comm_semigroup", "description": ""}, {"name": "int.lt_add_one_iff", "description": ""}, {"name": "int.div_one", "description": ""}, {"name": "int.mul_def", "description": ""}, {"name": "int.dvd_antisymm", "description": ""}, {"name": "int.succ", "description": "Immediate successor of an integer: `succ n = n + 1`"}, {"name": "int.nat_abs_mul", "description": ""}, {"name": "int.nat_abs_sign", "description": ""}, {"name": "int.zero_mod", "description": ""}, {"name": "int.lnot_bit", "description": ""}, {"name": "int.div_self", "description": ""}, {"name": "int.coe_nat_nonpos_iff", "description": ""}, {"name": "int.neg_succ_mul_coe_nat", "description": ""}, {"name": "int.lxor_bit", "description": ""}, {"name": "int.comm_semiring", "description": ""}, {"name": "int.div_neg", "description": ""}, {"name": "int.test_bit_zero", "description": ""}, {"name": "int.bit_decomp", "description": ""}, {"name": "int.eq_zero_of_dvd_of_nonneg_of_lt", "description": ""}, {"name": "int.shiftl_neg", "description": ""}, {"name": "int.le_induction_down", "description": "See `int.induction_on'` for an induction in both directions."}, {"name": "int.to_nat_sub_of_le", "description": ""}, {"name": "int.coe_nat_dvd", "description": ""}, {"name": "int.nat_abs_lt_iff_mul_self_lt", "description": ""}, {"name": "int.neg_add_neg", "description": ""}, {"name": "int.succ_neg_succ", "description": ""}, {"name": "int.le_coe_nat_sub", "description": ""}, {"name": "int.le_to_nat", "description": ""}, {"name": "int.mul_div_cancel", "description": ""}, {"name": "int.div_zero", "description": ""}, {"name": "int.sub_one_lt_iff", "description": ""}, {"name": "int.bodd_sub_nat_nat", "description": ""}, {"name": "int.of_nat_add_neg_succ_of_nat_of_ge", "description": ""}, {"name": "int.coe_nat_dvd_right", "description": ""}, {"name": "int.bitwise_diff", "description": ""}, {"name": "int.bitwise_xor", "description": ""}, {"name": "int.nat_abs_add_le", "description": ""}, {"name": "int.pred_succ", "description": ""}, {"name": "int.bodd_coe", "description": ""}, {"name": "int.decidable_dvd", "description": ""}, {"name": "int.div_add_mod", "description": ""}, {"name": "int.to_nat_add_to_nat_neg_eq_nat_abs", "description": ""}, {"name": "int.coe_nat_ne_zero_iff_pos", "description": ""}, {"name": "int.div_eq_iff_eq_mul_left", "description": ""}, {"name": "int.mod_add_cancel_right", "description": ""}, {"name": "int.neg_succ", "description": ""}, {"name": "int.bodd_mul", "description": ""}, {"name": "int.mul_div_cancel'", "description": ""}, {"name": "int.div_lt_iff_lt_mul", "description": ""}, {"name": "int.bitwise_and", "description": ""}, {"name": "int.nat_abs_inj_of_nonneg_of_nonneg", "description": ""}, {"name": "int.nat_abs_mul_self'", "description": ""}, {"name": "int.div_nonpos", "description": ""}, {"name": "int.inhabited", "description": ""}, {"name": "int.coe_nat_pos", "description": ""}, {"name": "int.add_mod_mod", "description": ""}, {"name": "int.is_unit.nat_abs_eq", "description": "**Alias** of the forward direction of `int.is_unit_iff_nat_abs_eq`."}, {"name": "int.dvd_nat_abs_of_of_nat_dvd", "description": ""}, {"name": "int.le_sub_one_iff", "description": ""}, {"name": "int.dvd_sub_of_mod_eq", "description": "If `a % b = c` then `b` divides `a - c`."}, {"name": "int.mod_eq_of_lt", "description": ""}, {"name": "int.to_nat_eq_zero", "description": ""}, {"name": "int.units_sq", "description": ""}, {"name": "int.div_of_neg_of_pos", "description": ""}, {"name": "int.shiftr_coe_nat", "description": ""}, {"name": "int.sign_mul", "description": ""}, {"name": "int.is_unit_iff_abs_eq", "description": ""}, {"name": "int.div_neg'", "description": ""}, {"name": "int.le_div_iff_mul_le", "description": ""}, {"name": "int.eq_zero_of_abs_lt_dvd", "description": ""}, {"name": "int.add_mod_eq_add_mod_right", "description": ""}, {"name": "int.comm_ring", "description": ""}, {"name": "int.bit0_val", "description": ""}, {"name": "int.bodd_bit1", "description": ""}, {"name": "int.coe_nat_div", "description": ""}, {"name": "int.nat_abs_le_iff_mul_self_le", "description": ""}, {"name": "int.bit_zero", "description": ""}, {"name": "int.to_nat_of_nonpos", "description": ""}, {"name": "int.to_nat_eq_max", "description": ""}, {"name": "int.bodd_bit", "description": ""}, {"name": "int.mul_mod_left", "description": ""}, {"name": "int.coe_nat_eq_zero", "description": ""}, {"name": "int.bodd_neg", "description": ""}, {"name": "int.add_group", "description": ""}, {"name": "int.mod_lt", "description": ""}, {"name": "int.add_semigroup", "description": ""}, {"name": "int.eq_one_of_mul_eq_one_right", "description": ""}, {"name": "int.sub_div_of_dvd", "description": ""}, {"name": "int.bodd_add_div2", "description": ""}, {"name": "int.reflect", "description": ""}, {"name": "int.mul_mod_mul_of_pos", "description": ""}, {"name": "int.is_unit_eq_or_eq_neg", "description": ""}, {"name": "int.mul_div_mul_of_pos", "description": ""}, {"name": "int.strict_anti_on_nat_abs", "description": ""}, {"name": "int.test_bit_succ", "description": ""}, {"name": "int.to_nat'", "description": "If `n : \u2115`, then `int.to_nat' n = some n`, if `n : \u2124` is negative, then `int.to_nat' n = none`."}, {"name": "int.div_le_self", "description": ""}, {"name": "int.mul_div_assoc", "description": ""}, {"name": "int.shiftl_sub", "description": ""}, {"name": "int.div_sign", "description": ""}, {"name": "int.nat_abs_inj_of_nonpos_of_nonneg", "description": ""}, {"name": "int.bodd_two", "description": ""}, {"name": "int.test_bit_ldiff", "description": ""}, {"name": "int.shiftr_neg", "description": ""}, {"name": "int.to_nat_lt_to_nat", "description": ""}, {"name": "int.div_mod_unique", "description": ""}, {"name": "int.mod_add_mod", "description": ""}, {"name": "int.div_le_div", "description": ""}, {"name": "int.to_nat_of_nonneg", "description": ""}, {"name": "int.coe_nat_inj'", "description": ""}, {"name": "int.one_shiftl", "description": ""}, {"name": "int.eq_one_or_neg_one_of_mul_eq_one", "description": ""}, {"name": "int.mul_div_cancel_left", "description": ""}, {"name": "int.add_one_le_iff", "description": ""}, {"name": "int.pred_neg_pred", "description": ""}, {"name": "int.bit1_ne_zero", "description": ""}, {"name": "int.nat_abs_ne_zero_of_ne_zero", "description": ""}, {"name": "int.bit_coe_nat", "description": ""}, {"name": "int.induction_on'", "description": " Inductively define a function on `\u2124` by defining it at `b`, for the `succ` of a number greater\nthan `b`, and the `pred` of a number less than `b`."}, {"name": "int.bit_val", "description": ""}, {"name": "int.mod_mod", "description": ""}, {"name": "int.sq_eq_one_of_sq_lt_four", "description": ""}, {"name": "int.add_div_of_dvd_left", "description": ""}, {"name": "int.default_eq_zero", "description": ""}, {"name": "int.land_bit", "description": ""}, {"name": "int.div2_bit", "description": ""}, {"name": "int.sign_eq_div_abs", "description": ""}, {"name": "int.coe_nat_mod", "description": ""}, {"name": "int.abs_eq_nat_abs", "description": ""}, {"name": "int.pred_to_nat", "description": ""}, {"name": "int.units_nat_abs", "description": ""}, {"name": "int.nat_abs_eq_zero", "description": ""}, {"name": "int.lt_succ_self", "description": ""}, {"name": "int.mul_div_cancel_of_mod_eq_zero", "description": ""}, {"name": "int.div_add_mod'", "description": ""}, {"name": "int.mod_mod_of_dvd", "description": ""}, {"name": "int.bit1_val", "description": ""}, {"name": "int.bodd_add", "description": ""}, {"name": "int.coe_nat_nonneg", "description": ""}, {"name": "int.sign_mul_abs", "description": ""}, {"name": "int.mul_mod", "description": ""}, {"name": "int.lt_mul_of_div_lt", "description": ""}, {"name": "int.add_mul_div_left", "description": ""}, {"name": "int.mem_to_nat'", "description": ""}, {"name": "int.shiftl_coe_nat", "description": ""}, {"name": "int.neg_succ_not_pos", "description": ""}, {"name": "int.nat_abs_eq_of_dvd_dvd", "description": ""}, {"name": "int.nat_abs_lt_nat_abs_of_nonneg_of_lt", "description": ""}, {"name": "int.add_monoid", "description": ""}, {"name": "int.pred", "description": "Immediate predecessor of an integer: `pred n = n - 1`"}, {"name": "int.semigroup", "description": ""}, {"name": "int.shiftl_add", "description": ""}, {"name": "int.to_nat_coe_nat", "description": ""}, {"name": "int.coe_nat_le", "description": ""}, {"name": "int.nat_abs_ne_zero", "description": ""}, {"name": "int.nat_abs_mul_nat_abs_eq", "description": ""}, {"name": "int.neg_succ_of_nat_eq'", "description": ""}, {"name": "int.sign_pow_bit1", "description": ""}, {"name": "int.mul_lt_of_lt_div", "description": ""}, {"name": "int.mod_eq_zero_of_dvd", "description": ""}, {"name": "int.is_unit_iff", "description": ""}, {"name": "int.add_comm_group", "description": ""}, {"name": "int.shiftr_eq_div_pow", "description": ""}, {"name": "int.add_mod", "description": ""}, {"name": "int.nat_abs_inj_of_nonpos_of_nonpos", "description": ""}, {"name": "int.bodd_zero", "description": ""}, {"name": "int.units_coe_mul_self", "description": ""}, {"name": "int.neg_succ_of_nat_div", "description": ""}, {"name": "int.test_bit_lnot", "description": ""}, {"name": "int.nat_abs_dvd_iff_dvd", "description": ""}, {"name": "int.has_to_format", "description": ""}, {"name": "int.div_mul_le", "description": ""}, {"name": "int.div_eq_div_of_mul_eq_mul", "description": ""}, {"name": "int.test_bit_bitwise", "description": ""}, {"name": "int.le_induction", "description": "See `int.induction_on'` for an induction in both directions."}, {"name": "int.is_unit_mul_self", "description": ""}, {"name": "int.le_to_nat_iff", "description": ""}, {"name": "int.succ_neg_nat_succ", "description": ""}, {"name": "int.mul_div_assoc'", "description": ""}, {"name": "int.bit_cases_on", "description": "Defines a function from `\u2124` conditionally, if it is defined for odd and even integers separately\n using `bit`."}, {"name": "int.mod_eq_mod_iff_mod_sub_eq_zero", "description": ""}, {"name": "int.mod_sub_cancel_right", "description": ""}, {"name": "int.neg_succ_of_nat_mod", "description": ""}, {"name": "int.add_def", "description": ""}, {"name": "int.nontrivial", "description": ""}, {"name": "int.to_nat_le", "description": ""}, {"name": "int.eq_zero_of_div_eq_zero", "description": ""}, {"name": "int.sign_neg", "description": ""}, {"name": "int.coe_nat_lt", "description": ""}, {"name": "int.inj_on_nat_abs_Ici", "description": ""}, {"name": "int.succ_pred", "description": ""}, {"name": "int.mod_lt_of_pos", "description": ""}, {"name": "int.nat_abs_sign_of_nonzero", "description": ""}, {"name": "int.coe_nat_strict_mono", "description": ""}, {"name": "int.div_mul_cancel_of_mod_eq_zero", "description": ""}, {"name": "int.one_le_abs", "description": ""}, {"name": "int.div2_val", "description": ""}, {"name": "int.zero_shiftr", "description": ""}, {"name": "int.sub_mod", "description": ""}, {"name": "int.nat_abs_eq_nat_abs_iff", "description": ""}, {"name": "int.units_mul_self", "description": ""}, {"name": "int.of_nat_add_neg_succ_of_nat_of_lt", "description": ""}, {"name": "int.sub_div_of_dvd_sub", "description": ""}, {"name": "int.eq_mul_div_of_mul_eq_mul_of_dvd_left", "description": ""}, {"name": "int.mod_nonneg", "description": ""}, {"name": "int.nat_abs_eq_iff_mul_self_eq", "description": ""}, {"name": "int.div_mul_cancel", "description": ""}, {"name": "int.le_add_one", "description": ""}, {"name": "int.nat_abs_lt_iff_sq_lt", "description": ""}, {"name": "int.neg_pred", "description": ""}, {"name": "int.mod_add_div", "description": ""}, {"name": "int.shiftr_add", "description": ""}, {"name": "int.eq_one_or_neg_one_of_mul_eq_one'", "description": ""}, {"name": "int.add_mod_self_left", "description": ""}, {"name": "int.bitwise_bit", "description": ""}, {"name": "int.nat_abs_dvd", "description": ""}, {"name": "int.zero_ne_neg_of_nat", "description": ""}, {"name": "int.mod_zero", "description": ""}, {"name": "int.mul_mod_right", "description": ""}, {"name": "int.bit_neg_succ", "description": ""}, {"name": "int.is_unit_sq", "description": ""}, {"name": "int.shiftl_neg_succ", "description": ""}, {"name": "int.pred_nat_succ", "description": ""}, {"name": "int.ring", "description": ""}, {"name": "int.zero_shiftl", "description": ""}, {"name": "int.strict_mono_on_nat_abs", "description": ""}, {"name": "int.pred_self_lt", "description": ""}, {"name": "int.distrib", "description": ""}, {"name": "int.of_nat_mod", "description": ""}, {"name": "int.abs_lt_one_iff", "description": ""}, {"name": "int.dvd_div_of_mul_dvd", "description": ""}, {"name": "int.div_lt_of_lt_mul", "description": ""}, {"name": "int.units_eq_one_or", "description": ""}, {"name": "int.nat_abs_le_iff_sq_le", "description": ""}, {"name": "int.exists_lt_and_lt_iff_not_dvd", "description": "If `n > 0` then `m` is not divisible by `n` iff it is between `n * k` and `n * (k + 1)`\n for some `k`."}, {"name": "int.semiring", "description": ""}, {"name": "int.abs_div_le_abs", "description": ""}, {"name": "int.coe_nat_abs", "description": ""}, {"name": "int.eq_zero_of_dvd_of_nat_abs_lt_nat_abs", "description": " If an integer with larger absolute value divides an integer, it is\nzero."}, {"name": "int.is_unit_iff_nat_abs_eq", "description": ""}, {"name": "int.add_div_of_dvd_right", "description": ""}, {"name": "int.comm_monoid", "description": ""}, {"name": "int.is_unit_add_is_unit_eq_is_unit_add_is_unit", "description": ""}, {"name": "int.add_mod_eq_add_mod_left", "description": ""}, {"name": "int.mod_abs", "description": ""}, {"name": "int.neg_one_pow_ne_zero", "description": ""}, {"name": "int.div_pos_of_pos_of_dvd", "description": ""}, {"name": "int.le_div_of_mul_le", "description": ""}, {"name": "int.monoid", "description": ""}, {"name": "int.coe_nat_dvd_left", "description": ""}, {"name": "int.eq_mul_of_div_eq_right", "description": ""}, {"name": "int.zero_div", "description": ""}, {"name": "int.test_bit_lor", "description": ""}, {"name": "int.add_neg_one", "description": ""}, {"name": "int.div_eq_iff_eq_mul_right", "description": ""}, {"name": "int.bit1_ne_bit0", "description": ""}, {"name": "int.abs_le_one_iff", "description": ""}, {"name": "int.div_dvd_div", "description": ""}, {"name": "int.nat_succ_eq_int_succ", "description": ""}, {"name": "int.add_mul_div_right", "description": ""}, {"name": "int.to_nat_zero", "description": ""}, {"name": "int.coe_nat_succ_pos", "description": ""}, {"name": "int.coe_nat_mul_neg_succ", "description": ""}, {"name": "int.to_nat_add_nat", "description": ""}, {"name": "int.eq_one_of_mul_eq_one_left", "description": ""}, {"name": "int.bodd_bit0", "description": ""}, {"name": "int.dvd_of_pow_dvd", "description": ""}, {"name": "int.eq_of_mod_eq_of_nat_abs_sub_lt_nat_abs", "description": " If two integers are congruent to a sufficiently large modulus,\nthey are equal."}, {"name": "int.nat_abs_neg_of_nat", "description": ""}, {"name": "int.lt_div_add_one_mul_self", "description": ""}, {"name": "int.div_left_inj", "description": ""}, {"name": "int.eq_mul_of_div_eq_left", "description": ""}, {"name": "int.to_nat_le_to_nat", "description": ""}, {"name": "int.mul_div_mul_of_pos_left", "description": ""}, {"name": "int.dvd_iff_mod_eq_zero", "description": ""}, {"name": "int.dvd_nat_abs", "description": ""}, {"name": "int.to_nat_one", "description": ""}, {"name": "int.lor_bit", "description": ""}, {"name": "int.bodd_one", "description": ""}, {"name": "int.div_eq_zero_of_lt", "description": ""}, {"name": "int.neg_succ_mul_neg_succ", "description": ""}, {"name": "int.coe_pred_of_pos", "description": ""}, {"name": "int.add_mod_self", "description": ""}, {"name": "int.nat_abs_eq_iff_sq_eq", "description": ""}, {"name": "int.sq_eq_one_of_sq_le_three", "description": ""}, {"name": "int.shiftl_eq_mul_pow", "description": ""}, {"name": "int.eq_one_of_dvd_one", "description": ""}, {"name": "int.lt_div_of_mul_lt", "description": ""}, {"name": "int.comm_semigroup", "description": ""}, {"name": "int.bodd_neg_of_nat", "description": ""}, {"name": "int.le_of_dvd", "description": ""}, {"name": "int.add_mul_mod_self", "description": ""}, {"name": "int.div_eq_of_eq_mul_left", "description": ""}, {"name": "int.nat_abs_abs", "description": ""}, {"name": "int.div_dvd_of_dvd", "description": ""}, {"name": "int.linear_ordered_comm_ring", "description": ""}, {"name": "int.mod_one", "description": ""}, {"name": "int.le_mul_of_div_le", "description": ""}, {"name": "int.of_nat_is_unit", "description": ""}, {"name": "int.eq_div_of_mul_eq_right", "description": ""}, {"name": "int.to_nat_add", "description": ""}, {"name": "int.mod_def", "description": ""}, {"name": "int.of_nat_dvd_of_dvd_nat_abs", "description": ""}, {"name": "int.neg_mod_two", "description": ""}, {"name": "int.is_unit_eq_one_or", "description": ""}, {"name": "int.linear_ordered_add_comm_group", "description": ""}, {"name": "int.to_nat_pred_coe_of_pos", "description": ""}, {"name": "int.induction_on", "description": ""}, {"name": "int.succ_coe_nat_pos", "description": ""}, {"name": "int.mul_sign", "description": ""}, {"name": "int.inj_on_nat_abs_Iic", "description": ""}, {"name": "int.ldiff_bit", "description": ""}, {"name": "int.abs_sign_of_nonzero", "description": ""}, {"name": "int.bitwise_or", "description": ""}, {"name": "nat.pow_sub_lt_desc_factorial", "description": ""}, {"name": "nat.mul_factorial_pred", "description": ""}, {"name": "nat.factorial_mul_asc_factorial", "description": " `n.asc_factorial k = (n + k)! / n!` but without \u2115-division. See `nat.asc_factorial_eq_div` for\nthe version with \u2115-division."}, {"name": "nat.desc_factorial_zero", "description": ""}, {"name": "nat.desc_factorial_one", "description": ""}, {"name": "nat.factorial_mul_pow_sub_le_factorial", "description": ""}, {"name": "nat.desc_factorial_self", "description": ""}, {"name": "nat.pow_sub_lt_desc_factorial'", "description": ""}, {"name": "nat.factorial_mul_desc_factorial", "description": " `n.desc_factorial k = n! / (n - k)!` but without \u2115-division. See `nat.desc_factorial_eq_div`\nfor the version using \u2115-division."}, {"name": "nat.asc_factorial", "description": " `n.asc_factorial k = (n + k)! / n!` (as seen in `nat.asc_factorial_eq_div`), but implemented\nrecursively to allow for \"quick\" computation when using `norm_num`. This is closely related to\n`pochhammer`, but much less general."}, {"name": "nat.factorial", "description": "`nat.factorial n` is the factorial of `n`."}, {"name": "nat.succ_desc_factorial", "description": ""}, {"name": "nat.succ_desc_factorial_succ", "description": ""}, {"name": "nat.dvd_factorial", "description": ""}, {"name": "nat.factorial_zero", "description": ""}, {"name": "nat.monotone_factorial", "description": ""}, {"name": "nat.desc_factorial_of_lt", "description": "**Alias** of the reverse direction of `nat.desc_factorial_eq_zero_iff_lt`."}, {"name": "nat.desc_factorial_succ", "description": ""}, {"name": "nat.asc_factorial_le_pow_add", "description": ""}, {"name": "nat.pow_lt_asc_factorial", "description": ""}, {"name": "nat.add_factorial_le_factorial_add", "description": ""}, {"name": "nat.pow_succ_le_asc_factorial", "description": ""}, {"name": "nat.desc_factorial_le_pow", "description": ""}, {"name": "nat.factorial_two", "description": ""}, {"name": "nat.self_le_factorial", "description": ""}, {"name": "nat.add_desc_factorial_eq_asc_factorial", "description": ""}, {"name": "nat.asc_factorial_zero", "description": ""}, {"name": "nat.factorial_one", "description": ""}, {"name": "nat.asc_factorial_pos", "description": ""}, {"name": "nat.pow_sub_le_desc_factorial", "description": ""}, {"name": "nat.asc_factorial_of_sub", "description": ""}, {"name": "nat.desc_factorial_lt_pow", "description": ""}, {"name": "nat.add_factorial_succ_le_factorial_add_succ", "description": ""}, {"name": "nat.pow_lt_asc_factorial'", "description": ""}, {"name": "nat.add_factorial_lt_factorial_add", "description": ""}, {"name": "nat.lt_factorial_self", "description": ""}, {"name": "nat.factorial_pos", "description": ""}, {"name": "nat.factorial_succ", "description": ""}, {"name": "nat.factorial_le", "description": ""}, {"name": "nat.succ_asc_factorial", "description": ""}, {"name": "nat.factorial_dvd_factorial", "description": ""}, {"name": "nat.zero_asc_factorial", "description": ""}, {"name": "nat.factorial_eq_one", "description": ""}, {"name": "nat.desc_factorial_eq_div", "description": "Avoid in favor of `nat.factorial_mul_desc_factorial` if you can. \u2115-division isn't worth it."}, {"name": "nat.asc_factorial_succ", "description": ""}, {"name": "nat.factorial_ne_zero", "description": ""}, {"name": "nat.one_lt_factorial", "description": ""}, {"name": "nat.desc_factorial", "description": " `n.desc_factorial k = n! / (n - k)!` (as seen in `nat.desc_factorial_eq_div`), but\nimplemented recursively to allow for \"quick\" computation when using `norm_num`. This is closely\nrelated to `pochhammer`, but much less general."}, {"name": "nat.asc_factorial_lt_pow_add", "description": ""}, {"name": "nat.factorial_lt", "description": ""}, {"name": "nat.factorial_inj", "description": ""}, {"name": "nat.add_factorial_succ_lt_factorial_add_succ", "description": ""}, {"name": "nat.zero_desc_factorial_succ", "description": ""}, {"name": "nat.desc_factorial_eq_zero_iff_lt", "description": ""}, {"name": "nat.asc_factorial_eq_div", "description": "Avoid in favor of `nat.factorial_mul_asc_factorial` if you can. \u2115-division isn't worth it."}, {"name": "nat.factorial_mul_pow_le_factorial", "description": ""}, {"name": "tactic.interactive.constructor", "description": "This tactic applies to a goal such that its conclusion is an inductive type (say `I`). It tries to apply each constructor of `I` until it succeeds."}, {"name": "tactic.interactive.cases", "description": "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.\n\nFor example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.\n\n`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n\n`cases e with y\u2081 ... y\u2099`, where `e` is a variable or an expression, specifies that the sequence of names `y\u2081 ... y\u2099` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.\n\n`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case."}, {"name": "tactic.interactive.skip", "description": "A do-nothing tactic that always succeeds."}, {"name": "tactic.i_to_expr_strict", "description": ""}, {"name": "tactic.interactive.with_cases", "description": "Apply `t` to the main goal and revert any new hypothesis in the generated goals.\nIf `t` is a supported tactic or chain of supported tactics (e.g. `induction`,\n`cases`, `apply`, `constructor`), the generated goals are also tagged with case\ntags. You can then use `case` to focus such tagged goals.\n\nTwo typical uses of `with_cases`:\n\n1. Applying a custom eliminator:\n\n   ```lean\n   lemma my_nat_rec :\n     \u2200 n {P : \u2115 \u2192 Prop} (zero : P 0) (succ : \u2200 n, P n \u2192 P (n + 1)), P n := ...\n\n   example (n : \u2115) : n = n :=\n   begin\n     with_cases { apply my_nat_rec n },\n     case zero { refl },\n     case succ : m ih { refl }\n   end\n   ```\n\n2. Enabling the use of `case` after a chain of case-splitting tactics:\n\n   ```lean\n   example (n m : \u2115) : unit :=\n   begin\n     with_cases { cases n; induction m },\n     case nat.zero nat.zero { exact () },\n     case nat.zero nat.succ : k { exact () },\n     case nat.succ nat.zero : i { exact () },\n     case nat.succ nat.succ : k i ih_i { exact () }\n   end\n   ```"}, {"name": "tactic.interactive.rw_rule.has_reflect", "description": ""}, {"name": "tactic.interactive.any_goals", "description": "`any_goals { t }` applies the tactic `t` to every goal, and succeeds if at least one application succeeds."}, {"name": "tactic.interactive.contradiction", "description": "The contradiction tactic attempts to find in the current local context a hypothesis that is equivalent to an empty inductive type (e.g. `false`), a hypothesis of the form `c_1 ... = c_2 ...` where `c_1` and `c_2` are distinct constructors, or two contradictory hypotheses."}, {"name": "tactic.interactive.refl", "description": "Shorter name for the tactic `reflexivity`."}, {"name": "tactic.interactive.trivial", "description": "Tries to solve the current goal using a canonical proof of `true`, or the `reflexivity` tactic, or the `contradiction` tactic."}, {"name": "tactic.apply_inj_lemma", "description": ""}, {"name": "tactic.interactive.from", "description": "A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode."}, {"name": "tactic.interactive.propagate_tags", "description": ""}, {"name": "tactic.interactive.focus", "description": "`focus { t }` temporarily hides all goals other than the first, applies `t`, and then restores the other goals. It fails if there are no goals."}, {"name": "tactic.interactive.symmetry", "description": "This tactic applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation, that is, a relation which has a symmetry lemma tagged with the attribute `[symm]`. It replaces the target with `u ~ t`."}, {"name": "tactic.interactive.by_contra", "description": "If the target of the main goal is a proposition `p`, `by_contra` reduces the goal to proving `false` using the additional hypothesis `h : \u00ac p`. `by_contra h` can be used to name the hypothesis `h : \u00ac p`.\n\nThis tactic will attempt to use decidability of `p` if available, and will otherwise fall back on classical reasoning."}, {"name": "tactic.interactive.get_rule_eqn_lemmas", "description": ""}, {"name": "tactic.interactive.by_cases", "description": "`by_cases p` splits the main goal into two cases, assuming `h : p` in the first branch, and\n`h : \u00ac p` in the second branch. You can specify the name of the new hypothesis using the syntax\n`by_cases h : p`."}, {"name": "tactic.interactive.cc", "description": "Tries to prove the main goal using congruence closure."}, {"name": "tactic.interactive.revert", "description": "`revert h\u2081 ... h\u2099` applies to any goal with hypotheses `h\u2081` ... `h\u2099`. It moves the hypotheses and their dependencies to the target of the goal. This tactic is the inverse of `intro`."}, {"name": "tactic.interactive.unfold", "description": "Given defined constants `e\u2081 ... e\u2099`, `unfold e\u2081 ... e\u2099` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.\n\nAs with `simp`, the `at` modifier can be used to specify locations for the unfolding."}, {"name": "tactic.interactive.induction", "description": "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih\u2081 : P a \u2192 Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih\u2081` ire chosen automatically.\n\n`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n\n`induction e with y\u2081 ... y\u2099`, where `e` is a variable or an expression, specifies that the sequence of names `y\u2081 ... y\u2099` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.\n\n`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n\n`induction e generalizing z\u2081 ... z\u2099`, where `z\u2081 ... z\u2099` are variables in the local context, generalizes over `z\u2081 ... z\u2099` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n\n`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context."}, {"name": "tactic.interactive.dsimp", "description": "`dsimp` is similar to `simp`, except that it only uses definitional equalities."}, {"name": "tactic.interactive.cases_matching", "description": "`cases_matching p` applies the `cases` tactic to a hypothesis `h : type` if `type` matches the pattern `p`.\n`cases_matching [p_1, ..., p_n]` applies the `cases` tactic to a hypothesis `h : type` if `type` matches one of the given patterns.\n`cases_matching* p` more efficient and compact version of `focus1 { repeat { cases_matching p } }`. It is more efficient because the pattern is compiled once.\n\nExample: The following tactic destructs all conjunctions and disjunctions in the current goal.\n```lean\ncases_matching* [_ \u2228 _, _ \u2227 _]\n```"}, {"name": "has_dup", "description": ""}, {"name": "tactic.interactive.apply_opt_param", "description": "If the target of the main goal is an `opt_param`, assigns the default value."}, {"name": "tactic.interactive.subst_vars", "description": "Apply `subst` to all hypotheses of the form `h : x = t` or `h : t = x`."}, {"name": "tactic.interactive.refine", "description": "This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.\n\nNote that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat \u2192 Prop)`."}, {"name": "tactic.interactive.right", "description": "Applies the second constructor when the type of the target is an inductive data type with two constructors."}, {"name": "tactic.interactive.unfold1", "description": "Similar to `unfold`, but does not iterate the unfolding."}, {"name": "tactic.interactive.unfold_projs", "description": "This tactic unfolds all structure projections."}, {"name": "add_interactive", "description": "Copy a list of meta definitions in the current namespace to tactic.interactive.\n\nThis command is useful when we want to update tactic.interactive without closing the current namespace."}, {"name": "tactic.interactive.abstract", "description": "`abstract id { t }` tries to use tactic `t` to solve the main goal. If it succeeds, it abstracts the goal as an independent definition or theorem with name `id`. If `id` is omitted, a name is generated automatically."}, {"name": "tactic.interactive.let", "description": "`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.\n\n`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.\n\nIf `h` is omitted, the name `this` is used."}, {"name": "tactic.i_to_expr_for_apply", "description": ""}, {"name": "tactic.interactive.econstructor", "description": "Similar to `constructor`, but only non-dependent premises are added as new goals."}, {"name": "tactic.interactive.split", "description": "Applies the constructor when the type of the target is an inductive data type with one constructor."}, {"name": "tactic.interactive.cases_core", "description": ""}, {"name": "tactic.interactive.simp", "description": "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n\n`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n\n`simp [h\u2081 h\u2082 ... h\u2099]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `h\u1d62`'s, where the `h\u1d62`'s are expressions. If `h\u1d62` is preceded by left arrow (`\u2190` or `<-`), the simplification is performed in the reverse direction. If an `h\u1d62` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n\n`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n\n`simp *` is a shorthand for `simp [*]`.\n\n`simp only [h\u2081 h\u2082 ... h\u2099]` is like `simp [h\u2081 h\u2082 ... h\u2099]` but does not use `[simp]` lemmas\n\n`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `id\u1d62`.\n\n`simp at h\u2081 h\u2082 ... h\u2099` simplifies the non-dependent hypotheses `h\u2081 : T\u2081` ... `h\u2099 : T\u2099`. The tactic fails if the target or another hypothesis depends on one of them. The token `\u22a2` or `|-` can be added to the list to include the target.\n\n`simp at *` simplifies all the hypotheses and the target.\n\n`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.\n\n`simp with attr\u2081 ... attr\u2099` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr\u2081]`, ..., `[attr\u2099]` or `[simp]`."}, {"name": "tactic.interactive.type_check", "description": "Type check the given expression, and trace its type."}, {"name": "tactic.interactive.success_if_fail", "description": "Succeeds if the given tactic fails."}, {"name": "tactic.interactive.rw_rule_p", "description": ""}, {"name": "tactic.simp_arg_type.has_reflect", "description": ""}, {"name": "tactic.interactive.repeat", "description": "`repeat { t }` applies `t` to each goal. If the application succeeds,\nthe tactic is applied recursively to all the generated subgoals until it eventually fails.\nThe recursion stops in a subgoal when the tactic has failed to make progress.\nThe tactic `repeat { t }` never fails."}, {"name": "tactic.interactive.iterate", "description": "`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.\n\n`iterate n { t }` applies `t` `n` times."}, {"name": "tactic.interactive.simp_core_aux", "description": ""}, {"name": "tactic.interactive.clear", "description": "`clear h\u2081 ... h\u2099` tries to clear each hypothesis `h\u1d62` from the local context."}, {"name": "tactic.interactive.injection", "description": "The `injection` tactic is based on the fact that constructors of inductive data types are injections. That means that if `c` is a constructor of an inductive datatype, and if `(c t\u2081)` and `(c t\u2082)` are two terms that are equal then  `t\u2081` and `t\u2082` are equal too.\n\nIf `q` is a proof of a statement of conclusion `t\u2081 = t\u2082`, then injection applies injectivity to derive the equality of all arguments of `t\u2081` and `t\u2082` placed in the same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`. To use this tactic `t\u2081` and `t\u2082` should be constructor applications of the same constructor.\n\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types `a = c` and `b = d` to the main goal. The tactic `injection h with h\u2081 h\u2082` uses the names `h\u2081` and `h\u2082` to name the new hypotheses."}, {"name": "tactic.interactive.exact", "description": "This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified."}, {"name": "tactic.interactive.existsi", "description": "`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.\n\n`existsi [e\u2081, ..., e\u2099]` iteratively does the same for each expression in the list."}, {"name": "tactic.interactive.suffices", "description": "`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`."}, {"name": "tactic.interactive.by_contradiction", "description": "If the target of the main goal is a proposition `p`, `by_contradiction` reduces the goal to proving `false` using the additional hypothesis `h : \u00ac p`. `by_contradiction h` can be used to name the hypothesis `h : \u00ac p`.\n\nThis tactic will attempt to use decidability of `p` if available, and will otherwise fall back on classical reasoning."}, {"name": "tactic.interactive.cases_arg_p", "description": ""}, {"name": "tactic.interactive.rename", "description": "Rename one or more local hypotheses. The renamings are given as follows:\n\n```lean\nrename x y             -- rename x to y\nrename x \u2192 y           -- ditto\nrename [x y, a b]      -- rename x to y and a to b\nrename [x \u2192 y, a \u2192 b]  -- ditto\n```\n\nNote that if there are multiple hypotheses called `x` in the context, then\n`rename x y` will rename *all* of them. If you want to rename only one, use\n`dedup` first."}, {"name": "tactic.interactive.all_goals", "description": "`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds."}, {"name": "tactic.interactive.assume", "description": "Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.\n\n`assume (h\u2081 : t\u2081) ... (h\u2099 : t\u2099)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present."}, {"name": "tactic.interactive.assumption'", "description": "Try to apply `assumption` to all goals."}, {"name": "tactic.interactive.rw_rule", "description": ""}, {"name": "tactic.interactive.rw_rule.pos", "description": ""}, {"name": "tactic.interactive.rw_rule.symm", "description": ""}, {"name": "tactic.interactive.rw_rule.rule", "description": ""}, {"name": "tactic.decode_simp_arg_list_with_symm", "description": "Decode a list of `simp_arg_type` into lists for each type.\n\n This is the newer version of `decode_simp_arg_list`,\n and has a new name for backwards compatibility.\n This version indicates the direction of a `simp` lemma by including a `bool` with the `pexpr`."}, {"name": "tactic.simp_arg_type", "description": ""}, {"name": "tactic.simp_arg_type.all_hyps", "description": ""}, {"name": "tactic.simp_arg_type.except", "description": ""}, {"name": "tactic.simp_arg_type.expr", "description": ""}, {"name": "tactic.simp_arg_type.symm_expr", "description": ""}, {"name": "tactic.interactive.rw_rules_t.has_reflect", "description": ""}, {"name": "tactic.interactive.itactic", "description": "itactic: parse a nested \"interactive\" tactic. That is, parse\n  `{` tactic `}`"}, {"name": "tactic.interactive.guard_hyp", "description": "`guard_hyp h : t` fails if the hypothesis `h` does not have type `t`.\nWe use this tactic for writing tests."}, {"name": "tactic.interactive.reflexivity", "description": "This tactic applies to a goal whose target has the form `t ~ u` where `~` is a reflexive relation, that is, a relation which has a reflexivity lemma tagged with the attribute `[refl]`. The tactic checks whether `t` and `u` are definitionally equal and then solves the goal."}, {"name": "tactic.interactive.erw", "description": "An abbreviation for `erewrite`."}, {"name": "tactic.interactive.generalize", "description": "`generalize : e = x` replaces all occurrences of `e` in the target with a new hypothesis `x` of the same type.\n\n`generalize h : e = x` in addition registers the hypothesis `h : e = x`."}, {"name": "tactic.simp_arg_type_to_tactic_format", "description": ""}, {"name": "tactic.interactive.transitivity", "description": "This tactic applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation, that is, a relation which has a transitivity lemma tagged with the attribute `[trans]`.\n\n`transitivity s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`. If `s` is omitted, then a metavariable is used instead."}, {"name": "tactic.interactive.case_arg_parser", "description": ""}, {"name": "tactic.interactive.cases_type", "description": "`cases_type I` applies the `cases` tactic to a hypothesis `h : (I ...)`\n`cases_type I_1 ... I_n` applies the `cases` tactic to a hypothesis `h : (I_1 ...)` or ... or `h : (I_n ...)`\n`cases_type* I` is shorthand for `focus1 { repeat { cases_type I } }`\n`cases_type! I` only applies `cases` if the number of resulting subgoals is <= 1.\n\nExample: The following tactic destructs all conjunctions and disjunctions in the current goal.\n```lean\ncases_type* or and\n```"}, {"name": "tactic.interactive.eapply", "description": "Similar to the `apply` tactic, but only creates subgoals for non-dependent premises that have not been fixed by type inference or type class resolution."}, {"name": "tactic.interactive.to_expr'", "description": ""}, {"name": "tactic.interactive.show", "description": "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`."}, {"name": "tactic.interactive.admit", "description": "Closes the main goal using `sorry`. Takes an optional ignored tactic block.\n\nThe ignored tactic block is useful for \"commenting out\" part of a proof during development:\n```lean\nbegin\n  split,\n  admit { expensive_tactic },\n\nend\n```"}, {"name": "tactic.interactive.simp_intros", "description": "`simp_intros h\u2081 h\u2082 ... h\u2099` is similar to `intros h\u2081 h\u2082 ... h\u2099` except that each hypothesis is simplified as it is introduced, and each introduced hypothesis is used to simplify later ones and the final target.\n\nAs with `simp`, a list of simplification lemmas can be provided. The modifiers `only` and `with` behave as with `simp`."}, {"name": "tactic.interactive.erewrite", "description": "A variant of `rewrite` that uses the unifier more aggressively, unfolding semireducible definitions."}, {"name": "tactic.interactive.concat_tags", "description": ""}, {"name": "tactic.interactive.subst", "description": "Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`."}, {"name": "tactic.interactive.constructor_matching", "description": ""}, {"name": "tactic.interactive.trace_state", "description": "This tactic displays the current state in the tracing buffer."}, {"name": "tactic.interactive.intro", "description": "If the current goal is a Pi/forall `\u2200 x : t, u` (resp. `let x := t in u`) then `intro` puts `x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.\n\nIf the goal is an arrow `t \u2192 u`, then it puts `h : t` in the local context and the new goal target is `u`.\n\nIf the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the tactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter case, the tactic fails."}, {"name": "tactic.interactive.funext", "description": "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to\n```lean\n  |-  ((fun x, ...) = (fun x, ...))\n```\nThe variant `funext h\u2081 ... h\u2099` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses."}, {"name": "tactic.interactive.exacts", "description": "Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic."}, {"name": "tactic.interactive.change", "description": "`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.\n\n`change u at h` will change a local hypothesis to `u`.\n\n`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal."}, {"name": "tactic.unfold_config", "description": ""}, {"name": "tactic.unfold_config.to_simp_config", "description": ""}, {"name": "tactic.interactive.trace", "description": "`trace a` displays `a` in the tracing buffer."}, {"name": "tactic.i_to_expr_no_subgoals", "description": ""}, {"name": "tactic.interactive.simp_core", "description": ""}, {"name": "tactic.interactive.done", "description": "Fail if there are unsolved goals."}, {"name": "tactic.interactive.match_target", "description": "`match_target t` fails if target does not match pattern `t`."}, {"name": "tactic.mk_simp_set_core", "description": ""}, {"name": "tactic.interactive.mapply", "description": "Similar to the `apply` tactic, but uses matching instead of unification.\n`apply_match t` is equivalent to `apply_with t {unify := ff}`"}, {"name": "tactic.interactive.specialize", "description": "The tactic `specialize h a\u2081 ... a\u2099` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a\u2081` ... `a\u2099`. The tactic adds a new hypothesis with the same name `h := h a\u2081 ... a\u2099` and tries to clear the previous one."}, {"name": "tactic.interactive.apply_with", "description": "Similar to the `apply` tactic, but allows the user to provide a `apply_cfg` configuration object."}, {"name": "tactic.interactive.left", "description": "Applies the first constructor when the type of the target is an inductive data type with two constructors."}, {"name": "tactic.interactive.exfalso", "description": "Replaces the target of the main goal by `false`."}, {"name": "tactic.interactive.fapply", "description": "Similar to the `apply` tactic, but does not reorder goals."}, {"name": "tactic.interactive.apply_auto_param", "description": "If the target of the main goal is an `auto_param`, executes the associated tactic."}, {"name": "tactic.interactive.try", "description": "`try { t }` tries to apply tactic `t`, but succeeds whether or not `t` succeeds."}, {"name": "tactic.interactive.guard_expr_eq", "description": ""}, {"name": "tactic.interactive.casesm", "description": "Shorthand for `cases_matching`"}, {"name": "tactic.decode_simp_arg_list", "description": "Decode a list of `simp_arg_type` into lists for each type.\n\n This is a backwards-compatibility version of `decode_simp_arg_list_with_symm`.\n This version fails when an argument of the form `simp_arg_type.symm_expr`\n is included, so that `simp`-like tactics that do not (yet) support backwards rewriting\n should properly report an error but function normally on other inputs."}, {"name": "tactic.interactive.rwa", "description": "`rewrite` followed by `assumption`."}, {"name": "tactic.interactive.apply_instance", "description": "This tactic tries to close the main goal `... \u22a2 t` by generating a term of type `t` using type class resolution."}, {"name": "tactic.interactive.rw_rules", "description": ""}, {"name": "tactic.interactive.guard_target", "description": "`guard_target t` fails if the target of the main goal is not `t`.\nWe use this tactic for writing tests."}, {"name": "tactic.interactive.dunfold", "description": "Similar to `unfold`, but only uses definitional equalities."}, {"name": "tactic.interactive.rw", "description": "An abbreviation for `rewrite`."}, {"name": "tactic.simp_arg_list", "description": ""}, {"name": "tactic.simp_arg", "description": ""}, {"name": "tactic.interactive.have", "description": "`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.\n\n`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.\n\nIf `h` is omitted, the name `this` is used."}, {"name": "tactic.interactive.injections", "description": "`injections with h\u2081 ... h\u2099` iteratively applies `injection` to hypotheses using the names `h\u2081 ... h\u2099`."}, {"name": "tactic.interactive.fail_if_success", "description": "Fails if the given tactic succeeds."}, {"name": "tactic.mk_inj_eq", "description": ""}, {"name": "tactic.interactive.destruct", "description": "Assuming `x` is a variable in the local context with an inductive type, `destruct x` splits the main goal, producing one goal for each constructor of the inductive type, in which `x` is assumed to be a general instance of that constructor. In contrast to `cases`, the local context is unchanged, i.e. no elements are reverted or introduced.\n\nFor example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `destruct n` produces one goal with target `n = 0 \u2192 Q n`, and one goal with target `\u2200 (a : \u2115), (\u03bb (w : \u2115), n = w \u2192 Q n) (nat.succ a)`. Here the name `a` is chosen automatically."}, {"name": "tactic.simp_config_ext", "description": ""}, {"name": "tactic.simp_config_ext.to_simp_config", "description": ""}, {"name": "tactic.simp_config_ext.discharger", "description": ""}, {"name": "tactic.interactive.intros", "description": "Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.\n\nThe variant `intros h\u2081 ... h\u2099` introduces `n` new hypotheses using the given identifiers to name them."}, {"name": "tactic.interactive.case", "description": "Focuses on a goal ('case') generated by `induction`, `cases` or `with_cases`.\n\nThe goal is selected by giving one or more names which must match exactly one\ngoal. A goal is matched if the given names are a suffix of its goal tag.\nAdditionally, each name in the sequence can be abbreviated to a suffix of the\ncorresponding name in the goal tag. Thus, a goal with tag\n```lean\nnat.zero, list.nil\n```\ncan be selected with any of these invocations (among others):\n```lean\ncase nat.zero list.nil {...}\ncase nat.zero nil      {...}\ncase zero     nil      {...}\ncase          nil      {...}\n```\n\nAdditionally, the form\n```lean\ncase C : N\u2080 ... N\u2099 {...}\n```\ncan be used to rename hypotheses introduced by the preceding\n`cases`/`induction`/`with_cases`, using the names `N\u1d62`. For example:\n```lean\nexample (xs : list \u2115) : xs = xs :=\nbegin\n  induction xs,\n  case nil { reflexivity },\n  case cons : x xs ih {\n    -- x : \u2115, xs : list \u2115, ih : xs = xs\n    reflexivity }\nend\n```\n\nNote that this renaming functionality only work reliably *directly after* an\n`induction`/`cases`/`with_cases`. If you need to perform additional work after\nan `induction` or `cases` (e.g. introduce hypotheses in all goals), use\n`with_cases`.\n\nMultiple cases can be handled by the same tactic block with\n```lean\ncase [A : N\u2080 ... N\u2099, B : M\u2080 ... M\u2099] {...}\n```"}, {"name": "tactic.interactive.introv", "description": "The tactic `introv` allows the user to automatically introduce the variables of a theorem and explicitly name the hypotheses involved. The given names are used to name non-dependent hypotheses.\n\nExamples:\n```lean\nexample : \u2200 a b : nat, a = b \u2192 b = a :=\nbegin\n  introv h,\n  exact h.symm\nend\n```\nThe state after `introv h` is\n```lean\na b : \u2115,\nh : a = b\n\u22a2 b = a\n```\n\n```lean\nexample : \u2200 a b : nat, a = b \u2192 \u2200 c, b = c \u2192 a = c :=\nbegin\n  introv h\u2081 h\u2082,\n  exact h\u2081.trans h\u2082\nend\n```\nThe state after `introv h\u2081 h\u2082` is\n```lean\na b : \u2115,\nh\u2081 : a = b,\nc : \u2115,\nh\u2082 : b = c\n\u22a2 a = c\n```"}, {"name": "tactic.interactive.solve1", "description": "`solve1 { t }` applies the tactic `t` to the main goal and fails if it is not solved."}, {"name": "tactic.interactive.trace_simp_set", "description": "Just construct the simp set and trace it. Used for debugging."}, {"name": "tactic.interactive.rw_rules_t", "description": ""}, {"name": "tactic.interactive.rw_rules_t.rules", "description": ""}, {"name": "tactic.interactive.rw_rules_t.end_pos", "description": ""}, {"name": "tactic.interactive.ac_reflexivity", "description": "Proves a goal with target `s = t` when `s` and `t` are equal up to the associativity and commutativity of their binary operations."}, {"name": "tactic.interactive.rewrite", "description": "`rewrite e` applies identity `e` as a rewrite rule to the target of the main goal. If `e` is preceded by left arrow (`\u2190` or `<-`), the rewrite is applied in the reverse direction. If `e` is a defined constant, then the equational lemmas associated with `e` are used. This provides a convenient way to unfold `e`.\n\n`rewrite [e\u2081, ..., e\u2099]` applies the given rules sequentially.\n\n`rewrite e at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a list of hypotheses in the local context. In the latter case, a turnstile `\u22a2` or `|-` can also be used, to signify the target of the goal."}, {"name": "tactic.ids_to_simp_arg_list", "description": ""}, {"name": "tactic.interactive.sorry", "description": "Closes the main goal using `sorry`. Takes an optional ignored tactic block.\n\nThe ignored tactic block is useful for \"commenting out\" part of a proof during development:\n```lean\nbegin\n  split,\n  sorry { expensive_tactic },\n\nend\n```"}, {"name": "tactic.interactive.apply", "description": "The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types."}, {"name": "dedup", "description": "Renames hypotheses with the same name."}, {"name": "tactic.interactive.delta", "description": "Similar to `dunfold`, but performs a raw delta reduction, rather than using an equation associated with the defined constants."}, {"name": "tactic.i_to_expr", "description": ""}, {"name": "tactic.interactive.case_parser", "description": ""}, {"name": "tactic.interactive.congr", "description": ""}, {"name": "tactic.interactive.ac_refl", "description": "An abbreviation for `ac_reflexivity`."}, {"name": "tactic.mk_simp_set", "description": ""}, {"name": "tactic.interactive.assumption", "description": "This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails."}, {"name": "neg_eq_iff_neg_eq", "description": ""}, {"name": "add_left_eq_self", "description": ""}, {"name": "sub_eq_sub_iff_sub_eq_sub", "description": ""}, {"name": "eq_add_neg_iff_add_eq", "description": ""}, {"name": "one_div", "description": ""}, {"name": "bit1_sub", "description": ""}, {"name": "neg_sub_left", "description": ""}, {"name": "add_right_eq_self", "description": ""}, {"name": "add_eq_of_eq_sub'", "description": ""}, {"name": "div_ne_one_of_ne", "description": ""}, {"name": "zero_sub_add_zero_sub_rev", "description": ""}, {"name": "add_zero_eq_id", "description": ""}, {"name": "eq_inv_iff_mul_eq_one", "description": ""}, {"name": "bit0_zero", "description": ""}, {"name": "sub_eq_self", "description": ""}, {"name": "inv_eq_of_mul_eq_one_left", "description": ""}, {"name": "commutator_element_def", "description": ""}, {"name": "div_left_inj", "description": ""}, {"name": "div_eq_div_iff_div_eq_div", "description": ""}, {"name": "mul_div_mul_right_eq_div", "description": ""}, {"name": "add_sub_left_comm", "description": ""}, {"name": "add_sub_add_left_eq_sub", "description": ""}, {"name": "mul_right_eq_self", "description": ""}, {"name": "eq_mul_inv_iff_mul_eq", "description": ""}, {"name": "sub_right_comm", "description": ""}, {"name": "div_right_comm", "description": ""}, {"name": "neg_surjective", "description": ""}, {"name": "add_add_sub_cancel", "description": ""}, {"name": "div_eq_one", "description": ""}, {"name": "neg_add_eq_sub", "description": ""}, {"name": "right_inverse_neg", "description": ""}, {"name": "eq_of_sub_eq_zero", "description": ""}, {"name": "sub_add_add_cancel", "description": ""}, {"name": "comp_assoc_right", "description": "Composing two associative operations of `f : \u03b1 \u2192 \u03b1 \u2192 \u03b1` on the right\nis equal to an associative operation on the right."}, {"name": "add_zero_sub", "description": ""}, {"name": "add_sub_cancel'", "description": ""}, {"name": "div_mul_div_comm", "description": ""}, {"name": "mul_eq_one_iff_inv_eq", "description": ""}, {"name": "mul_eq_of_eq_div", "description": ""}, {"name": "sub_eq_neg_self", "description": ""}, {"name": "comp_add_right", "description": "Composing two additions on the right by `y` and `x`\nis equal to a addition on the right by `y + x`."}, {"name": "add_right_surjective", "description": ""}, {"name": "add_rotate'", "description": ""}, {"name": "div_eq_of_eq_mul'", "description": ""}, {"name": "add_sub_sub_cancel", "description": ""}, {"name": "div_mul", "description": ""}, {"name": "sub_eq_zero_of_eq", "description": "**Alias** of the reverse direction of `sub_eq_zero`."}, {"name": "sub_add_sub_comm", "description": ""}, {"name": "self_eq_add_left", "description": ""}, {"name": "ite_zero_add", "description": ""}, {"name": "div_mul_eq_mul_div", "description": ""}, {"name": "mul_div_left_comm", "description": ""}, {"name": "inv_div_inv", "description": ""}, {"name": "add_neg_eq_of_eq_add", "description": ""}, {"name": "bit0_add", "description": ""}, {"name": "eq_zero_sub_of_add_eq_zero_left", "description": ""}, {"name": "one_div_mul_one_div", "description": ""}, {"name": "eq_div_of_mul_eq''", "description": ""}, {"name": "one_eq_inv", "description": ""}, {"name": "add_rotate", "description": ""}, {"name": "sub_add_comm", "description": ""}, {"name": "mul_div_cancel''", "description": ""}, {"name": "div_eq_of_eq_mul''", "description": ""}, {"name": "comp_add_left", "description": "Composing two additions on the left by `y` then `x`\nis equal to a addition on the left by `x + y`."}, {"name": "add_neg_eq_iff_eq_add", "description": ""}, {"name": "sub_ne_zero_of_ne", "description": ""}, {"name": "div_mul_div_cancel'", "description": ""}, {"name": "self_eq_mul_left", "description": ""}, {"name": "inv_mul_eq_one", "description": ""}, {"name": "mul_inv", "description": ""}, {"name": "eq_add_neg_of_add_eq", "description": ""}, {"name": "sub_eq_iff_eq_add", "description": ""}, {"name": "mul_one_eq_id", "description": ""}, {"name": "neg_sub_neg", "description": ""}, {"name": "comp_mul_right", "description": "Composing two multiplications on the right by `y` and `x`\nis equal to a multiplication on the right by `y * x`."}, {"name": "sub_sub_cancel", "description": ""}, {"name": "add_sub_cancel'_right", "description": ""}, {"name": "inv_surjective", "description": ""}, {"name": "mul_left_comm", "description": ""}, {"name": "comp_mul_left", "description": "Composing two multiplications on the left by `y` then `x`\nis equal to a multiplication on the left by `x * y`."}, {"name": "left_inverse_neg_add_add_right", "description": ""}, {"name": "inv_div'", "description": ""}, {"name": "left_inverse_add_left_sub", "description": ""}, {"name": "sub_add_eq_sub_add_zero_sub", "description": ""}, {"name": "eq_inv_iff_eq_inv", "description": ""}, {"name": "neg_injective", "description": ""}, {"name": "sub_eq_sub_iff_add_eq_add", "description": ""}, {"name": "inv_eq_iff_inv_eq", "description": ""}, {"name": "left_inverse_add_right_neg_add", "description": ""}, {"name": "right_inverse_inv", "description": ""}, {"name": "eq_neg_iff_eq_neg", "description": ""}, {"name": "add_add_add_comm", "description": ""}, {"name": "neg_add", "description": ""}, {"name": "eq_zero_sub_of_add_eq_zero_right", "description": ""}, {"name": "zero_sub_add_zero_sub", "description": ""}, {"name": "neg_neg_sub_neg", "description": ""}, {"name": "sub_eq_add_zero_sub", "description": ""}, {"name": "eq_mul_of_div_eq", "description": ""}, {"name": "zero_sub", "description": ""}, {"name": "mul_div_mul_comm", "description": ""}, {"name": "div_div_div_cancel_right'", "description": ""}, {"name": "mul_right_surjective", "description": ""}, {"name": "add_eq_zero_iff_neg_eq", "description": ""}, {"name": "inv_injective", "description": ""}, {"name": "exists_npow_eq_one_of_zpow_eq_one", "description": ""}, {"name": "eq_inv_mul_iff_mul_eq", "description": ""}, {"name": "div_eq_div_mul_div", "description": ""}, {"name": "exists_nsmul_eq_zero_of_zsmul_eq_zero", "description": ""}, {"name": "one_div_one", "description": ""}, {"name": "one_div_mul_one_div_rev", "description": ""}, {"name": "div_div_cancel_left", "description": ""}, {"name": "mul_eq_one_iff_eq_inv", "description": ""}, {"name": "neg_add_eq_iff_eq_add", "description": ""}, {"name": "add_sub_assoc'", "description": ""}, {"name": "div_mul_eq_div_div", "description": ""}, {"name": "add_sub_add_right_eq_sub", "description": ""}, {"name": "mul_eq_of_eq_inv_mul", "description": ""}, {"name": "inv_ne_one", "description": ""}, {"name": "eq_of_zero_sub_eq_zero_sub", "description": ""}, {"name": "mul_left_eq_self", "description": ""}, {"name": "mul_right_comm", "description": ""}, {"name": "bit0_neg", "description": ""}, {"name": "eq_add_of_add_neg_eq", "description": ""}, {"name": "div_div_cancel", "description": ""}, {"name": "mul_div_cancel'_right", "description": ""}, {"name": "inv_unique", "description": ""}, {"name": "left_inverse_neg", "description": ""}, {"name": "mul_comm_div", "description": ""}, {"name": "sub_add_cancel", "description": ""}, {"name": "mul_inv_eq_iff_eq_mul", "description": ""}, {"name": "sub_sub", "description": ""}, {"name": "sub_add_cancel'", "description": ""}, {"name": "add_eq_zero_iff_eq_neg", "description": ""}, {"name": "mul_div", "description": ""}, {"name": "sub_eq_zero", "description": ""}, {"name": "inv_inv_div_inv", "description": ""}, {"name": "comp_assoc_left", "description": "Composing two associative operations of `f : \u03b1 \u2192 \u03b1 \u2192 \u03b1` on the left\nis equal to an associative operation on the left."}, {"name": "sub_ne_zero", "description": ""}, {"name": "zero_sub_zero", "description": ""}, {"name": "eq_iff_eq_of_sub_eq_sub", "description": ""}, {"name": "ite_mul_one", "description": ""}, {"name": "mul_div_cancel'''", "description": ""}, {"name": "eq_zero_iff_eq_zero_of_add_eq_zero", "description": ""}, {"name": "sub_eq_of_eq_add", "description": ""}, {"name": "neg_unique", "description": ""}, {"name": "sub_sub_sub_cancel_left", "description": ""}, {"name": "sub_sub_self", "description": ""}, {"name": "sub_eq_of_eq_add'", "description": ""}, {"name": "div_mul_mul_cancel", "description": ""}, {"name": "div_eq_iff_eq_mul", "description": ""}, {"name": "eq_neg_of_add_eq_zero_left", "description": ""}, {"name": "mul_mul_div_cancel", "description": ""}, {"name": "div_mul_div_cancel''", "description": ""}, {"name": "div_eq_inv_self", "description": ""}, {"name": "mul_div_assoc'", "description": ""}, {"name": "bit1_add", "description": ""}, {"name": "div_div_div_cancel_left", "description": ""}, {"name": "eq_inv_of_eq_inv", "description": ""}, {"name": "div_div_div_comm", "description": ""}, {"name": "mul_eq_of_eq_mul_inv", "description": ""}, {"name": "mul_mul_inv_cancel'_right", "description": ""}, {"name": "eq_sub_of_add_eq", "description": ""}, {"name": "sub_sub_sub_eq", "description": ""}, {"name": "div_mul_eq_div_div_swap", "description": ""}, {"name": "sub_zero", "description": ""}, {"name": "inv_eq_one", "description": ""}, {"name": "add_comm_sub", "description": ""}, {"name": "div_eq_mul_one_div", "description": ""}, {"name": "div_mul_comm", "description": ""}, {"name": "one_mul_eq_id", "description": ""}, {"name": "div_eq_iff_eq_mul'", "description": ""}, {"name": "eq_neg_iff_add_eq_zero", "description": ""}, {"name": "eq_neg_of_add_eq_zero_right", "description": ""}, {"name": "sub_add_sub_cancel", "description": ""}, {"name": "add_eq_of_eq_add_neg", "description": ""}, {"name": "inv_comp_inv", "description": ""}, {"name": "neg_sub", "description": ""}, {"name": "div_mul_eq_div_mul_one_div", "description": ""}, {"name": "eq_div_iff_mul_eq'", "description": ""}, {"name": "add_sub_cancel", "description": ""}, {"name": "eq_mul_of_div_eq'", "description": ""}, {"name": "mul_rotate'", "description": ""}, {"name": "inv_involutive", "description": ""}, {"name": "eq_neg_add_of_add_eq", "description": ""}, {"name": "add_right_comm", "description": ""}, {"name": "bit1_zero", "description": ""}, {"name": "mul_div_div_cancel", "description": ""}, {"name": "mul_div_assoc", "description": ""}, {"name": "inv_inj", "description": ""}, {"name": "div_div_eq_mul_div", "description": ""}, {"name": "inv_div", "description": ""}, {"name": "neg_sub'", "description": ""}, {"name": "div_self'", "description": ""}, {"name": "eq_div_iff_mul_eq''", "description": ""}, {"name": "self_eq_mul_right", "description": ""}, {"name": "neg_involutive", "description": ""}, {"name": "mul_inv_eq_one", "description": ""}, {"name": "div_ne_one", "description": ""}, {"name": "add_sub", "description": ""}, {"name": "mul_div_mul_left_eq_div", "description": ""}, {"name": "left_inverse_mul_right_inv_mul", "description": ""}, {"name": "mul_eq_of_eq_div'", "description": ""}, {"name": "self_eq_add_right", "description": ""}, {"name": "div_mul_cancel''", "description": ""}, {"name": "inv_mul'", "description": ""}, {"name": "eq_mul_inv_of_mul_eq", "description": ""}, {"name": "neg_inj", "description": ""}, {"name": "div_eq_self", "description": ""}, {"name": "one_div_div", "description": ""}, {"name": "eq_div_of_mul_eq'", "description": ""}, {"name": "add_add_neg_cancel'_right", "description": ""}, {"name": "bit0_sub", "description": ""}, {"name": "mul_left_surjective", "description": ""}, {"name": "inv_one", "description": ""}, {"name": "eq_mul_of_inv_mul_eq", "description": ""}, {"name": "left_inverse_sub_add_left", "description": ""}, {"name": "neg_eq_iff_add_eq_zero", "description": ""}, {"name": "add_left_surjective", "description": ""}, {"name": "neg_eq_zero", "description": ""}, {"name": "sub_add_eq_add_sub", "description": ""}, {"name": "neg_ne_zero", "description": ""}, {"name": "one_div_one_div", "description": ""}, {"name": "sub_sub_cancel_left", "description": ""}, {"name": "inv_div_left", "description": ""}, {"name": "sub_sub_eq_add_sub", "description": ""}, {"name": "eq_sub_iff_add_eq", "description": ""}, {"name": "zero_add_eq_id", "description": ""}, {"name": "mul_inv_eq_of_eq_mul", "description": ""}, {"name": "div_div", "description": ""}, {"name": "div_right_inj", "description": ""}, {"name": "eq_inv_of_mul_eq_one_right", "description": ""}, {"name": "div_one", "description": ""}, {"name": "eq_sub_of_add_eq'", "description": ""}, {"name": "neg_add_eq_zero", "description": ""}, {"name": "mul_rotate", "description": ""}, {"name": "eq_one_div_of_mul_eq_one_right", "description": ""}, {"name": "left_inverse_inv", "description": ""}, {"name": "eq_of_div_eq_one", "description": ""}, {"name": "mul_one_div", "description": ""}, {"name": "eq_inv_mul_of_mul_eq", "description": ""}, {"name": "eq_add_of_neg_add_eq", "description": ""}, {"name": "sub_sub_sub_cancel_right", "description": ""}, {"name": "eq_iff_eq_of_div_eq_div", "description": ""}, {"name": "eq_of_one_div_eq_one_div", "description": ""}, {"name": "eq_add_of_sub_eq", "description": ""}, {"name": "eq_add_of_sub_eq'", "description": ""}, {"name": "sub_left_injective", "description": ""}, {"name": "sub_sub_sub_comm", "description": ""}, {"name": "eq_one_div_of_mul_eq_one_left", "description": ""}, {"name": "neg_eq_of_add_eq_zero_left", "description": ""}, {"name": "zero_sub_sub", "description": ""}, {"name": "sub_left_inj", "description": ""}, {"name": "neg_add'", "description": ""}, {"name": "sub_add_eq_sub_sub", "description": ""}, {"name": "ite_one_mul", "description": ""}, {"name": "left_inverse_div_mul_left", "description": ""}, {"name": "zero_eq_neg", "description": ""}, {"name": "eq_neg_add_iff_add_eq", "description": ""}, {"name": "div_eq_one_of_eq", "description": "**Alias** of the reverse direction of `div_eq_one`."}, {"name": "zero_sub_zero_sub", "description": ""}, {"name": "sub_eq_neg_add", "description": ""}, {"name": "sub_eq_sub_add_sub", "description": ""}, {"name": "commutator_element", "description": "The commutator of two elements `g\u2081` and `g\u2082`."}, {"name": "mul_div_right_comm", "description": ""}, {"name": "sub_right_inj", "description": ""}, {"name": "eq_inv_of_mul_eq_one_left", "description": ""}, {"name": "div_left_injective", "description": ""}, {"name": "add_left_comm", "description": ""}, {"name": "inv_eq_iff_mul_eq_one", "description": ""}, {"name": "eq_one_iff_eq_one_of_mul_eq_one", "description": ""}, {"name": "inv_mul_eq_of_eq_mul", "description": ""}, {"name": "sub_add_sub_cancel'", "description": ""}, {"name": "div_eq_inv_mul", "description": ""}, {"name": "left_inverse_mul_left_div", "description": ""}, {"name": "sub_add", "description": ""}, {"name": "sub_eq_iff_eq_add'", "description": ""}, {"name": "eq_sub_iff_add_eq'", "description": ""}, {"name": "mul_mul_mul_comm", "description": ""}, {"name": "bit1_add'", "description": ""}, {"name": "eq_mul_of_mul_inv_eq", "description": ""}, {"name": "sub_self", "description": ""}, {"name": "neg_eq_zero_sub", "description": ""}, {"name": "add_sub_add_comm", "description": ""}, {"name": "neg_comp_neg", "description": ""}, {"name": "add_sub_right_comm", "description": ""}, {"name": "ite_add_zero", "description": ""}, {"name": "div_div_self'", "description": ""}, {"name": "inv_eq_one_div", "description": ""}, {"name": "add_eq_of_eq_neg_add", "description": ""}, {"name": "inv_mul_eq_iff_eq_mul", "description": ""}, {"name": "div_eq_div_iff_mul_eq_mul", "description": ""}, {"name": "neg_zero", "description": ""}, {"name": "add_eq_of_eq_sub", "description": ""}, {"name": "sub_neg_eq_add", "description": ""}, {"name": "neg_add_eq_of_eq_add", "description": ""}, {"name": "eq_neg_of_eq_neg", "description": ""}, {"name": "div_mul_cancel'", "description": ""}, {"name": "sub_add_eq_sub_sub_swap", "description": ""}, {"name": "div_div_div_eq", "description": ""}, {"name": "inv_mul_eq_div", "description": ""}, {"name": "div_right_injective", "description": ""}, {"name": "add_sub_assoc", "description": ""}, {"name": "div_inv_eq_mul", "description": ""}, {"name": "add_neg_eq_zero", "description": ""}, {"name": "left_inverse_inv_mul_mul_right", "description": ""}, {"name": "sub_right_injective", "description": ""}, {"name": "tactic.get_subsingleton_info", "description": ""}, {"name": "param_info.to_format", "description": ""}, {"name": "subsingleton_info.has_to_format", "description": ""}, {"name": "fun_info.has_to_format", "description": ""}, {"name": "param_info", "description": ""}, {"name": "param_info.is_implicit", "description": ""}, {"name": "param_info.is_inst_implicit", "description": ""}, {"name": "param_info.is_prop", "description": ""}, {"name": "param_info.has_fwd_deps", "description": ""}, {"name": "param_info.is_dec_inst", "description": ""}, {"name": "param_info.back_deps", "description": ""}, {"name": "subsingleton_info_to_format", "description": ""}, {"name": "tactic.fold_explicit_args", "description": ""}, {"name": "tactic.get_spec_subsingleton_info", "description": "`get_spec_subsingleton_info t` return subsingleton parameter\n  information for the function application t of the form\n     `f a_1 ... a_n`.\n\n   This tactic is more precise than `get_subsingleton_info f` and `get_subsingleton_info_n f n`\n\n   Example: given `f : Pi (\u03b1 : Type), \u03b1 -> \u03b1`, `get_spec_subsingleton_info` for\n\n   `f unit b`\n\n   returns a fun_info with two param_info\n   1) specialized = tt\n   2) is_subsingleton = tt\n\n   The second argument is marked as subsingleton only because the resulting information\n   is taking into account the first argument."}, {"name": "subsingleton_info", "description": "specialized is true if the result of fun_info has been specifialized\nusing this argument.\nFor example, consider the function\n\n           f : Pi (\u03b1 : Type), \u03b1 -> \u03b1\n\nNow, suppse we request get_specialize fun_info for the application\n\n       f unit a\n\nfun_info_manager returns two param_info objects:\n1) specialized = true\n2) is_subsingleton = true\n\nNote that, in general, the second argument of f is not a subsingleton,\nbut it is in this particular case/specialization.\n\n\\remark This bit is only set if it is a dependent parameter.\n\n Moreover, we only set is_specialized IF another parameter\n becomes a subsingleton"}, {"name": "subsingleton_info.specialized", "description": "specialized is true if the result of fun_info has been specifialized\nusing this argument.\nFor example, consider the function\n\n           f : Pi (\u03b1 : Type), \u03b1 -> \u03b1\n\nNow, suppse we request get_specialize fun_info for the application\n\n       f unit a\n\nfun_info_manager returns two param_info objects:\n1) specialized = true\n2) is_subsingleton = true\n\nNote that, in general, the second argument of f is not a subsingleton,\nbut it is in this particular case/specialization.\n\n\\remark This bit is only set if it is a dependent parameter.\n\n Moreover, we only set is_specialized IF another parameter\n becomes a subsingleton"}, {"name": "subsingleton_info.is_subsingleton", "description": "specialized is true if the result of fun_info has been specifialized\nusing this argument.\nFor example, consider the function\n\n           f : Pi (\u03b1 : Type), \u03b1 -> \u03b1\n\nNow, suppse we request get_specialize fun_info for the application\n\n       f unit a\n\nfun_info_manager returns two param_info objects:\n1) specialized = true\n2) is_subsingleton = true\n\nNote that, in general, the second argument of f is not a subsingleton,\nbut it is in this particular case/specialization.\n\n\\remark This bit is only set if it is a dependent parameter.\n\n Moreover, we only set is_specialized IF another parameter\n becomes a subsingleton"}, {"name": "fun_info_to_format", "description": ""}, {"name": "tactic.fold_explicit_args_aux", "description": ""}, {"name": "fun_info", "description": ""}, {"name": "fun_info.params", "description": ""}, {"name": "fun_info.result_deps", "description": ""}, {"name": "tactic.get_fun_info", "description": "If nargs is not none, then return information assuming the function has only nargs arguments."}, {"name": "param_info.has_to_format", "description": ""}, {"name": "tactic.get_spec_prefix_size", "description": ""}, {"name": "invertible.copy", "description": "If `r` is invertible and `s = r`, then `s` is invertible."}, {"name": "inv_of_div", "description": ""}, {"name": "invertible_div", "description": "`b / a` is the inverse of `a / b`"}, {"name": "coe_unit_of_invertible", "description": ""}, {"name": "inv_of_eq_inv", "description": ""}, {"name": "inv_mul_cancel_of_invertible", "description": ""}, {"name": "invertible.map", "description": "Monoid homs preserve invertibility."}, {"name": "inv_of_one", "description": ""}, {"name": "is_unit_of_invertible", "description": ""}, {"name": "is_unit.invertible", "description": " Convert `is_unit` to `invertible` using `classical.choice`.\n\nPrefer `casesI h.nonempty_invertible` over `letI := h.invertible` if you want to avoid choice."}, {"name": "invertible_inv", "description": "`a` is the inverse of `a\u207b\u00b9`"}, {"name": "commute.inv_of_right", "description": ""}, {"name": "invertible_of_group", "description": "Each element of a group is invertible."}, {"name": "mul_inv_of_self", "description": ""}, {"name": "inv_of_eq_group_inv", "description": ""}, {"name": "invertible.subsingleton", "description": ""}, {"name": "mul_div_cancel_of_invertible", "description": ""}, {"name": "units.invertible", "description": "Units are invertible in their associated monoid."}, {"name": "unit_of_invertible", "description": "An `invertible` element is a unit."}, {"name": "mul_inv_cancel_of_invertible", "description": ""}, {"name": "inv_of_mul", "description": ""}, {"name": "inv_of_mul_self_assoc", "description": ""}, {"name": "nonzero_of_invertible", "description": ""}, {"name": "mul_mul_inv_of_self_cancel", "description": ""}, {"name": "commute_inv_of", "description": ""}, {"name": "inv_of_mul_self", "description": ""}, {"name": "div_self_of_invertible", "description": ""}, {"name": "one_sub_inv_of_two", "description": ""}, {"name": "inv_of_two_add_inv_of_two", "description": ""}, {"name": "coe_inv_unit_of_invertible", "description": ""}, {"name": "inv_of_eq_right_inv", "description": ""}, {"name": "invertible_mul", "description": "`\u215fb * \u215fa` is the inverse of `a * b`"}, {"name": "ring.inverse_invertible", "description": "A variant of `ring.inverse_unit`."}, {"name": "nonempty_invertible_iff_is_unit", "description": ""}, {"name": "commute.inv_of_left", "description": ""}, {"name": "invertible_unique", "description": ""}, {"name": "div_mul_cancel_of_invertible", "description": ""}, {"name": "mul_inv_of_self_assoc", "description": ""}, {"name": "inv_of_inv_of", "description": ""}, {"name": "invertible_of_nonzero", "description": "`a\u207b\u00b9` is an inverse of `a` if `a \u2260 0`"}, {"name": "inv_of_inj", "description": ""}, {"name": "inv_of_neg", "description": ""}, {"name": "invertible_one", "description": "`1` is the inverse of itself"}, {"name": "mul_inv_of_mul_self_cancel", "description": ""}, {"name": "inv_of_units", "description": ""}, {"name": "inv_of_eq_left_inv", "description": ""}, {"name": "invertible_inv_of", "description": "`a` is the inverse of `\u215fa`."}, {"name": "is_unit.nonempty_invertible", "description": ""}, {"name": "invertible_neg", "description": "`-\u215fa` is the inverse of `-a`"}, {"name": "invertible", "description": "`invertible a` gives a two-sided multiplicative inverse of `a`."}, {"name": "invertible.inv_of", "description": "`invertible a` gives a two-sided multiplicative inverse of `a`."}, {"name": "invertible.inv_of_mul_self", "description": "`invertible a` gives a two-sided multiplicative inverse of `a`."}, {"name": "invertible.mul_inv_of_self", "description": "`invertible a` gives a two-sided multiplicative inverse of `a`."}, {"name": "nat.choose_le_succ", "description": ""}, {"name": "nat.choose_mono", "description": ""}, {"name": "nat.choose_self", "description": ""}, {"name": "nat.choose_zero_succ", "description": ""}, {"name": "nat.multichoose_one", "description": ""}, {"name": "nat.choose_eq_zero_of_lt", "description": ""}, {"name": "nat.choose_eq_desc_factorial_div_factorial", "description": ""}, {"name": "nat.choose_symm_add", "description": ""}, {"name": "nat.add_choose", "description": ""}, {"name": "nat.choose", "description": " `choose n k` is the number of `k`-element subsets in an `n`-element set. Also known as binomial\ncoefficients."}, {"name": "nat.choose_symm_half", "description": ""}, {"name": "nat.choose_symm_of_eq_add", "description": ""}, {"name": "nat.choose_zero_right", "description": ""}, {"name": "nat.factorial_mul_factorial_dvd_factorial_add", "description": ""}, {"name": "nat.choose_mul_factorial_mul_factorial", "description": ""}, {"name": "nat.factorial_dvd_asc_factorial", "description": ""}, {"name": "nat.asc_factorial_eq_factorial_mul_choose", "description": ""}, {"name": "nat.desc_factorial_eq_factorial_mul_choose", "description": ""}, {"name": "nat.triangle_succ", "description": ""}, {"name": "nat.multichoose", "description": "`multichoose n k` is the number of multisets of cardinality `k` from a type of cardinality `n`."}, {"name": "nat.choose_mul", "description": ""}, {"name": "nat.choose_succ_self", "description": ""}, {"name": "nat.factorial_dvd_desc_factorial", "description": ""}, {"name": "nat.multichoose_one_right", "description": ""}, {"name": "nat.choose_eq_zero_iff", "description": ""}, {"name": "nat.choose_one_right", "description": ""}, {"name": "nat.choose_pos", "description": ""}, {"name": "nat.multichoose_eq", "description": ""}, {"name": "nat.add_choose_mul_factorial_mul_factorial", "description": ""}, {"name": "nat.choose_succ_self_right", "description": ""}, {"name": "nat.choose_le_succ_of_lt_half_left", "description": "Show that `nat.choose` is increasing for small values of the right argument."}, {"name": "nat.choose_succ_right_eq", "description": ""}, {"name": "nat.succ_mul_choose_eq", "description": ""}, {"name": "nat.multichoose_zero_right", "description": ""}, {"name": "nat.multichoose_two", "description": ""}, {"name": "nat.choose_succ_succ", "description": ""}, {"name": "nat.choose_symm", "description": ""}, {"name": "nat.choose_le_middle", "description": "`choose n r` is maximised when `r` is `n/2`."}, {"name": "nat.choose_mul_succ_eq", "description": ""}, {"name": "nat.choose_eq_asc_factorial_div_factorial", "description": ""}, {"name": "nat.multichoose_succ_succ", "description": ""}, {"name": "nat.choose_eq_factorial_div_factorial", "description": ""}, {"name": "nat.factorial_mul_factorial_dvd_factorial", "description": ""}, {"name": "nat.choose_two_right", "description": "`choose n 2` is the `n`-th triangle number."}, {"name": "nat.choose_le_choose", "description": ""}, {"name": "nat.multichoose_zero_succ", "description": ""}, {"name": "nat.choose_le_add", "description": ""}, {"name": "finset.lt_fold_min", "description": ""}, {"name": "finset.fold_op_rel_iff_or", "description": ""}, {"name": "finset.fold_disj_union", "description": ""}, {"name": "finset.fold_min_lt", "description": ""}, {"name": "finset.fold_cons", "description": ""}, {"name": "finset.le_fold_min", "description": ""}, {"name": "finset.fold_union_inter", "description": ""}, {"name": "finset.fold_congr", "description": ""}, {"name": "finset.fold_max_le", "description": ""}, {"name": "finset.fold_image_idem", "description": ""}, {"name": "finset.fold", "description": "`fold op b f s` folds the commutative associative operation `op` over the\n `f`-image of `s`, i.e. `fold (+) b f {1,2,3} = f 1 + f 2 + f 3 + b`."}, {"name": "finset.fold_op_distrib", "description": ""}, {"name": "finset.fold_min_le", "description": ""}, {"name": "finset.fold_map", "description": ""}, {"name": "finset.fold_op_rel_iff_and", "description": ""}, {"name": "finset.fold_singleton", "description": ""}, {"name": "finset.fold_insert_idem", "description": ""}, {"name": "finset.fold_union_empty_singleton", "description": ""}, {"name": "finset.fold_const", "description": ""}, {"name": "finset.fold_empty", "description": ""}, {"name": "finset.fold_max_add", "description": ""}, {"name": "finset.lt_fold_max", "description": ""}, {"name": "finset.fold_image", "description": ""}, {"name": "finset.fold_max_lt", "description": ""}, {"name": "finset.le_fold_max", "description": ""}, {"name": "finset.fold_hom", "description": ""}, {"name": "finset.fold_insert", "description": ""}, {"name": "finset.fold_ite'", "description": " A stronger version of `finset.fold_ite`, but relies on\nan explicit proof of idempotency on the seed element, rather\nthan relying on typeclass idempotency over the whole type."}, {"name": "finset.fold_sup_bot_singleton", "description": ""}, {"name": "finset.fold_ite", "description": " A weaker version of `finset.fold_ite'`,\nrelying on typeclass idempotency over the whole type,\ninstead of solely on the seed element.\nHowever, this is easier to use because it does not generate side goals."}, {"name": "comm_semiring", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.add", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.add_assoc", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.zero", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.zero_add", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.add_zero", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.nsmul", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.nsmul_zero'", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.nsmul_succ'", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.add_comm", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.mul", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.left_distrib", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.right_distrib", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.zero_mul", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.mul_zero", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.mul_assoc", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.one", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.one_mul", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.mul_one", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.nat_cast", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.nat_cast_zero", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.nat_cast_succ", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.npow", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.npow_zero'", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.npow_succ'", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "comm_semiring.mul_comm", "description": " A commutative semiring is a `semiring` with commutative multiplication. In other words, it is a\ntype with the following structures: additive commutative monoid (`add_comm_monoid`), multiplicative\ncommutative monoid (`comm_monoid`), distributive laws (`distrib`), and multiplication by zero law\n(`mul_zero_class`)."}, {"name": "add_monoid_hom.coe_mul_right", "description": ""}, {"name": "one_add_one_eq_two", "description": ""}, {"name": "function.injective.non_unital_non_assoc_semiring", "description": " Pullback a `non_unital_non_assoc_semiring` instance along an injective function.\nSee note [reducible non-instances]."}, {"name": "function.injective.comm_semiring", "description": " Pullback a `semiring` instance along an injective function.\nSee note [reducible non-instances]."}, {"name": "commute.sub_right", "description": ""}, {"name": "dvd_add_self_left", "description": "An element a divides the sum a + b if and only if a divides b."}, {"name": "semiconj_by.sub_right", "description": ""}, {"name": "units.has_neg", "description": "Each element of the group of units of a ring has an additive inverse."}, {"name": "mul_one_add", "description": ""}, {"name": "non_unital_comm_ring.to_non_unital_comm_semiring", "description": ""}, {"name": "mul_boole", "description": ""}, {"name": "two_mul", "description": ""}, {"name": "semiconj_by.neg_one_left", "description": ""}, {"name": "dvd_add_right", "description": "If an element a divides another element b in a commutative ring, a divides the sum of b and\n another element c iff a divides c."}, {"name": "ring.to_monoid", "description": ""}, {"name": "right_distrib", "description": ""}, {"name": "non_unital_comm_ring", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.add", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.add_assoc", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.zero", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.zero_add", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.add_zero", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.nsmul", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.nsmul_zero'", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.nsmul_succ'", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.neg", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.sub", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.sub_eq_add_neg", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.zsmul", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.zsmul_zero'", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.zsmul_succ'", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.zsmul_neg'", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.add_left_neg", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.add_comm", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.mul", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.left_distrib", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.right_distrib", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.zero_mul", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.mul_zero", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.mul_assoc", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "non_unital_comm_ring.mul_comm", "description": "A non-unital commutative ring is a `non_unital_ring` with commutative multiplication."}, {"name": "mul_add_one", "description": ""}, {"name": "no_zero_divisors.to_cancel_monoid_with_zero", "description": " A ring with no zero divisors is a `cancel_monoid_with_zero`.\n\nNote this is not an instance as it forms a typeclass loop."}, {"name": "succ_ne_self", "description": ""}, {"name": "function.surjective.comm_ring", "description": " Pushforward a `comm_ring` instance along a surjective function.\nSee note [reducible non-instances]."}, {"name": "non_assoc_ring", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.add", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.add_assoc", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.zero", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.zero_add", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.add_zero", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.nsmul", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.nsmul_zero'", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.nsmul_succ'", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.neg", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.sub", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.sub_eq_add_neg", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.zsmul", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.zsmul_zero'", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.zsmul_succ'", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.zsmul_neg'", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.add_left_neg", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.add_comm", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.mul", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.left_distrib", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.right_distrib", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.zero_mul", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.mul_zero", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.one", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.one_mul", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.mul_one", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.nat_cast", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.nat_cast_zero", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.nat_cast_succ", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.int_cast", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.int_cast_of_nat", "description": "A unital but not-necessarily-associative ring."}, {"name": "non_assoc_ring.int_cast_neg_succ_of_nat", "description": "A unital but not-necessarily-associative ring."}, {"name": "units.divp_add_divp", "description": ""}, {"name": "dvd_iff_dvd_of_dvd_sub", "description": ""}, {"name": "non_unital_non_assoc_semiring.to_distrib", "description": ""}, {"name": "non_unital_non_assoc_semiring.to_mul_zero_class", "description": ""}, {"name": "commute.neg_one_right", "description": ""}, {"name": "sub_one_mul", "description": ""}, {"name": "dvd_add_iff_right", "description": ""}, {"name": "add_hom.mul_left", "description": "Left multiplication by an element of a type with distributive multiplication is an `add_hom`."}, {"name": "add_hom.mul_right_apply", "description": ""}, {"name": "non_unital_comm_semiring", "description": " A non-unital commutative semiring is a `non_unital_semiring` with commutative multiplication.\nIn other words, it is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), commutative semigroup (`comm_semigroup`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`)."}, {"name": "non_unital_comm_semiring.add", "description": " A non-unital commutative semiring is a `non_unital_semiring` with commutative multiplication.\nIn other words, it is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), commutative semigroup (`comm_semigroup`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`)."}, {"name": "non_unital_comm_semiring.add_assoc", "description": " A non-unital commutative semiring is a `non_unital_semiring` with commutative multiplication.\nIn other words, it is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), commutative semigroup (`comm_semigroup`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`)."}, {"name": "non_unital_comm_semiring.zero", "description": " A non-unital commutative semiring is a `non_unital_semiring` with commutative multiplication.\nIn other words, it is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), commutative semigroup (`comm_semigroup`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`)."}, {"name": "non_unital_comm_semiring.zero_add", "description": " A non-unital commutative semiring is a `non_unital_semiring` with commutative multiplication.\nIn other words, it is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), commutative semigroup (`comm_semigroup`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`)."}, {"name": "non_unital_comm_semiring.add_zero", "description": " A non-unital commutative semiring is a `non_unital_semiring` with commutative multiplication.\nIn other words, it is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), commutative semigroup (`comm_semigroup`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`)."}, {"name": "non_unital_comm_semiring.nsmul", "description": " A non-unital commutative semiring is a `non_unital_semiring` with commutative multiplication.\nIn other words, it is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), commutative semigroup (`comm_semigroup`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`)."}, {"name": "non_unital_comm_semiring.nsmul_zero'", "description": " A non-unital commutative semiring is a `non_unital_semiring` with commutative multiplication.\nIn other words, it is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), commutative semigroup (`comm_semigroup`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`)."}, {"name": "non_unital_comm_semiring.nsmul_succ'", "description": " A non-unital commutative semiring is a `non_unital_semiring` with commutative multiplication.\nIn other words, it is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), commutative semigroup (`comm_semigroup`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`)."}, {"name": "non_unital_comm_semiring.add_comm", "description": " A non-unital commutative semiring is a `non_unital_semiring` with commutative multiplication.\nIn other words, it is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), commutative semigroup (`comm_semigroup`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`)."}, {"name": "non_unital_comm_semiring.mul", "description": " A non-unital commutative semiring is a `non_unital_semiring` with commutative multiplication.\nIn other words, it is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), commutative semigroup (`comm_semigroup`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`)."}, {"name": "non_unital_comm_semiring.left_distrib", "description": " A non-unital commutative semiring is a `non_unital_semiring` with commutative multiplication.\nIn other words, it is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), commutative semigroup (`comm_semigroup`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`)."}, {"name": "non_unital_comm_semiring.right_distrib", "description": " A non-unital commutative semiring is a `non_unital_semiring` with commutative multiplication.\nIn other words, it is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), commutative semigroup (`comm_semigroup`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`)."}, {"name": "non_unital_comm_semiring.zero_mul", "description": " A non-unital commutative semiring is a `non_unital_semiring` with commutative multiplication.\nIn other words, it is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), commutative semigroup (`comm_semigroup`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`)."}, {"name": "non_unital_comm_semiring.mul_zero", "description": " A non-unital commutative semiring is a `non_unital_semiring` with commutative multiplication.\nIn other words, it is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), commutative semigroup (`comm_semigroup`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`)."}, {"name": "non_unital_comm_semiring.mul_assoc", "description": " A non-unital commutative semiring is a `non_unital_semiring` with commutative multiplication.\nIn other words, it is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), commutative semigroup (`comm_semigroup`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`)."}, {"name": "non_unital_comm_semiring.mul_comm", "description": " A non-unital commutative semiring is a `non_unital_semiring` with commutative multiplication.\nIn other words, it is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), commutative semigroup (`comm_semigroup`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`)."}, {"name": "mul_add_eq_mul_add_iff_sub_mul_add_eq", "description": "An iff statement following from right distributivity in rings and the definition\n of subtraction."}, {"name": "function.injective.non_unital_non_assoc_ring", "description": " Pullback a `non_unital_non_assoc_ring` instance along an injective function.\nSee note [reducible non-instances]."}, {"name": "units.divp_add", "description": ""}, {"name": "semiconj_by.neg_right_iff", "description": ""}, {"name": "neg_mul", "description": ""}, {"name": "semiring.to_non_assoc_semiring", "description": ""}, {"name": "function.surjective.non_unital_comm_ring", "description": " Pushforward a `non_unital_comm_ring` instance along a surjective function.\nSee note [reducible non-instances]."}, {"name": "ite_and_mul_zero", "description": ""}, {"name": "neg_mul_eq_neg_mul", "description": ""}, {"name": "neg_zero'", "description": "Prefer `neg_zero` if `subtraction_monoid` is available."}, {"name": "function.surjective.non_unital_non_assoc_semiring", "description": " Pushforward a `non_unital_non_assoc_semiring` instance along a surjective function.\nSee note [reducible non-instances]."}, {"name": "semiring", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.add", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.add_assoc", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.zero", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.zero_add", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.add_zero", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.nsmul", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.nsmul_zero'", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.nsmul_succ'", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.add_comm", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.mul", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.left_distrib", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.right_distrib", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.zero_mul", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.mul_zero", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.mul_assoc", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.one", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.one_mul", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.mul_one", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.nat_cast", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.nat_cast_zero", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.nat_cast_succ", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.npow", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.npow_zero'", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "semiring.npow_succ'", "description": " A semiring is a type with the following structures: additive commutative monoid\n(`add_comm_monoid`), multiplicative monoid (`monoid`), distributive laws (`distrib`), and\nmultiplication by zero law (`mul_zero_class`). The actual definition extends `monoid_with_zero`\ninstead of `monoid` and `mul_zero_class`."}, {"name": "dvd_add_left", "description": "If an element a divides another element c in a commutative ring, a divides the sum of another\n element b with c iff a divides b."}, {"name": "function.injective.non_assoc_ring", "description": " Pullback a `non_assoc_ring` instance along an injective function.\nSee note [reducible non-instances]."}, {"name": "non_unital_ring.to_non_unital_semiring", "description": ""}, {"name": "commute.bit1_right", "description": ""}, {"name": "one_add_mul", "description": ""}, {"name": "is_unit.neg", "description": ""}, {"name": "units.has_distrib_neg", "description": ""}, {"name": "commute.neg_right_iff", "description": ""}, {"name": "function.injective.non_unital_comm_ring", "description": " Pullback a `comm_ring` instance along an injective function.\nSee note [reducible non-instances]."}, {"name": "comm_ring.to_ring", "description": ""}, {"name": "neg_one_mul", "description": "The additive inverse of one multiplied by an element of a ring is the element's additive\n inverse."}, {"name": "distrib.to_has_mul", "description": ""}, {"name": "ring.to_add_comm_group_with_one", "description": ""}, {"name": "add_monoid_hom.mul_right_apply", "description": ""}, {"name": "units.inv_eq_self_iff", "description": "In the unit group of an integral domain, a unit is its own inverse iff the unit is one or\n one's additive inverse."}, {"name": "ring.to_semiring", "description": ""}, {"name": "is_domain.to_no_zero_divisors", "description": ""}, {"name": "ite_add", "description": ""}, {"name": "ring.to_non_unital_ring", "description": ""}, {"name": "add_monoid_hom.coe_mul_left", "description": ""}, {"name": "non_unital_ring", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.add", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.add_assoc", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.zero", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.zero_add", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.add_zero", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.nsmul", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.nsmul_zero'", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.nsmul_succ'", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.neg", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.sub", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.sub_eq_add_neg", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.zsmul", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.zsmul_zero'", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.zsmul_succ'", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.zsmul_neg'", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.add_left_neg", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.add_comm", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.mul", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.left_distrib", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.right_distrib", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.zero_mul", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.mul_zero", "description": "An associative but not-necessarily unital ring."}, {"name": "non_unital_ring.mul_assoc", "description": "An associative but not-necessarily unital ring."}, {"name": "commute.mul_self_sub_mul_self_eq'", "description": ""}, {"name": "add_mul_self_eq", "description": ""}, {"name": "ring", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.add", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.add_assoc", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.zero", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.zero_add", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.add_zero", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.nsmul", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.nsmul_zero'", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.nsmul_succ'", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.neg", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.sub", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.sub_eq_add_neg", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.zsmul", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.zsmul_zero'", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.zsmul_succ'", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.zsmul_neg'", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.add_left_neg", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.add_comm", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.int_cast", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.nat_cast", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.one", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.nat_cast_zero", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.nat_cast_succ", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.int_cast_of_nat", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.int_cast_neg_succ_of_nat", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.mul", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.mul_assoc", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.one_mul", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.mul_one", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.npow", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.npow_zero'", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.npow_succ'", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.left_distrib", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "ring.right_distrib", "description": " A ring is a type with the following structures: additive commutative group (`add_comm_group`),\nmultiplicative monoid (`monoid`), and distributive laws (`distrib`).  Equivalently, a ring is a\n`semiring` with a negation operation making it an additive group."}, {"name": "add_hom.mul_left_apply", "description": ""}, {"name": "units.divp_sub_divp_same", "description": ""}, {"name": "one_sub_mul", "description": ""}, {"name": "non_assoc_ring.to_add_group_with_one", "description": ""}, {"name": "function.injective.non_unital_comm_semiring", "description": " Pullback a `non_unital_semiring` instance along an injective function.\nSee note [reducible non-instances]."}, {"name": "function.surjective.non_unital_semiring", "description": " Pushforward a `non_unital_semiring` instance along a surjective function.\nSee note [reducible non-instances]."}, {"name": "inv_neg'", "description": ""}, {"name": "neg_mul_comm", "description": ""}, {"name": "comm_semiring.to_non_unital_comm_semiring", "description": ""}, {"name": "distrib.right_distrib_class", "description": ""}, {"name": "semiconj_by.add_right", "description": ""}, {"name": "units.add_divp", "description": ""}, {"name": "left_distrib", "description": ""}, {"name": "add_hom.mul_right", "description": "Left multiplication by an element of a type with distributive multiplication is an `add_hom`."}, {"name": "dvd_neg", "description": " An element a of a semigroup with a distributive negation divides the negation of an element b\niff a divides b."}, {"name": "boole_mul", "description": ""}, {"name": "function.injective.semiring", "description": " Pullback a `semiring` instance along an injective function.\nSee note [reducible non-instances]."}, {"name": "mul_sub", "description": "**Alias** of `mul_sub_left_distrib`."}, {"name": "function.surjective.distrib", "description": " Pushforward a `distrib` instance along a surjective function.\nSee note [reducible non-instances]."}, {"name": "commute.add_left", "description": ""}, {"name": "mul_neg", "description": ""}, {"name": "comm_ring", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.add", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.add_assoc", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.zero", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.zero_add", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.add_zero", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.nsmul", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.nsmul_zero'", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.nsmul_succ'", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.neg", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.sub", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.sub_eq_add_neg", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.zsmul", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.zsmul_zero'", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.zsmul_succ'", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.zsmul_neg'", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.add_left_neg", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.add_comm", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.int_cast", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.nat_cast", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.one", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.nat_cast_zero", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.nat_cast_succ", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.int_cast_of_nat", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.int_cast_neg_succ_of_nat", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.mul", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.mul_assoc", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.one_mul", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.mul_one", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.npow", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.npow_zero'", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.npow_succ'", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.left_distrib", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.right_distrib", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "comm_ring.mul_comm", "description": "A commutative ring is a `ring` with commutative multiplication."}, {"name": "add_monoid_hom.mul_left", "description": "Left multiplication by an element of a (semi)ring is an `add_monoid_hom`"}, {"name": "ring.to_non_assoc_ring", "description": ""}, {"name": "non_assoc_ring.to_non_assoc_semiring", "description": ""}, {"name": "add_opposite.has_distrib_neg", "description": ""}, {"name": "mul_sub_one", "description": ""}, {"name": "commute.bit0_right", "description": ""}, {"name": "is_right_regular_of_non_zero_divisor", "description": " Right `mul` by a `k : \u03b1` over `[ring \u03b1]` is injective, if `k` is not a zero divisor.\nThe typeclass that restricts all terms of `\u03b1` to have this property is `no_zero_divisors`."}, {"name": "distrib", "description": " A typeclass stating that multiplication is left and right distributive\nover addition."}, {"name": "distrib.mul", "description": " A typeclass stating that multiplication is left and right distributive\nover addition."}, {"name": "distrib.add", "description": " A typeclass stating that multiplication is left and right distributive\nover addition."}, {"name": "distrib.left_distrib", "description": " A typeclass stating that multiplication is left and right distributive\nover addition."}, {"name": "distrib.right_distrib", "description": " A typeclass stating that multiplication is left and right distributive\nover addition."}, {"name": "mul_opposite.has_distrib_neg", "description": ""}, {"name": "right_distrib_class", "description": "A typeclass stating that multiplication is right distributive over addition."}, {"name": "right_distrib_class.right_distrib", "description": "A typeclass stating that multiplication is right distributive over addition."}, {"name": "neg_dvd_of_dvd", "description": ""}, {"name": "add_one_mul", "description": ""}, {"name": "commute.bit0_left", "description": ""}, {"name": "semiring.to_non_unital_semiring", "description": ""}, {"name": "non_unital_ring.to_non_unital_non_assoc_ring", "description": ""}, {"name": "has_distrib_neg.to_has_involutive_neg", "description": ""}, {"name": "units.coe_neg_one", "description": ""}, {"name": "non_assoc_semiring.to_non_unital_non_assoc_semiring", "description": ""}, {"name": "non_unital_comm_ring.to_comm_semigroup", "description": ""}, {"name": "has_dvd.dvd.linear_comb", "description": ""}, {"name": "add_mul", "description": "**Alias** of `right_distrib`."}, {"name": "semiconj_by.add_left", "description": ""}, {"name": "function.injective.non_unital_ring", "description": " Pullback a `non_unital_ring` instance along an injective function.\nSee note [reducible non-instances]."}, {"name": "commute.add_right", "description": ""}, {"name": "sub_mul", "description": "**Alias** of `mul_sub_right_distrib`."}, {"name": "neg_eq_neg_one_mul", "description": ""}, {"name": "map_bit0", "description": "Additive homomorphisms preserve `bit0`."}, {"name": "non_unital_non_assoc_ring.to_non_unital_non_assoc_semiring", "description": ""}, {"name": "function.surjective.non_assoc_semiring", "description": " Pushforward a `non_assoc_semiring` instance along a surjective function.\nSee note [reducible non-instances]."}, {"name": "comm_ring.to_comm_monoid", "description": ""}, {"name": "comm_semiring.to_comm_monoid_with_zero", "description": ""}, {"name": "non_unital_non_assoc_ring", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.add", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.add_assoc", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.zero", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.zero_add", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.add_zero", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.nsmul", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.nsmul_zero'", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.nsmul_succ'", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.neg", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.sub", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.sub_eq_add_neg", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.zsmul", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.zsmul_zero'", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.zsmul_succ'", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.zsmul_neg'", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.add_left_neg", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.add_comm", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.mul", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.left_distrib", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.right_distrib", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.zero_mul", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "non_unital_non_assoc_ring.mul_zero", "description": "A not-necessarily-unital, not-necessarily-associative ring."}, {"name": "units.divp_sub_divp", "description": ""}, {"name": "mul_self_sub_one", "description": ""}, {"name": "is_unit.neg_iff", "description": ""}, {"name": "two_dvd_bit1", "description": ""}, {"name": "commute.mul_self_eq_mul_self_iff", "description": ""}, {"name": "commute.neg_one_left", "description": ""}, {"name": "non_unital_comm_semiring.to_comm_semigroup", "description": ""}, {"name": "dvd_of_neg_dvd", "description": ""}, {"name": "add_ite", "description": ""}, {"name": "ite_mul_zero_left", "description": ""}, {"name": "distrib.left_distrib_class", "description": ""}, {"name": "function.injective.has_distrib_neg", "description": " A type endowed with `-` and `*` has distributive negation, if it admits an injective map that\npreserves `-` and `*` to a type which has distributive negation."}, {"name": "non_assoc_semiring.to_mul_zero_one_class", "description": ""}, {"name": "mul_one_sub", "description": ""}, {"name": "comm_ring.to_comm_semiring", "description": ""}, {"name": "ite_mul_zero_right", "description": ""}, {"name": "commute.mul_self_sub_mul_self_eq", "description": "Representation of a difference of two squares of commuting elements as a product."}, {"name": "semiconj_by.neg_one_right", "description": ""}, {"name": "ite_mul", "description": ""}, {"name": "mul_sub_right_distrib", "description": ""}, {"name": "commute.sub_left", "description": ""}, {"name": "function.injective.comm_ring", "description": " Pullback a `comm_ring` instance along an injective function.\nSee note [reducible non-instances]."}, {"name": "has_distrib_neg", "description": " Typeclass for a negation operator that distributes across multiplication.\n\nThis is useful for dealing with submonoids of a ring that contain `-1` without having to duplicate\nlemmas."}, {"name": "has_distrib_neg.neg", "description": " Typeclass for a negation operator that distributes across multiplication.\n\nThis is useful for dealing with submonoids of a ring that contain `-1` without having to duplicate\nlemmas."}, {"name": "has_distrib_neg.neg_neg", "description": " Typeclass for a negation operator that distributes across multiplication.\n\nThis is useful for dealing with submonoids of a ring that contain `-1` without having to duplicate\nlemmas."}, {"name": "has_distrib_neg.neg_mul", "description": " Typeclass for a negation operator that distributes across multiplication.\n\nThis is useful for dealing with submonoids of a ring that contain `-1` without having to duplicate\nlemmas."}, {"name": "has_distrib_neg.mul_neg", "description": " Typeclass for a negation operator that distributes across multiplication.\n\nThis is useful for dealing with submonoids of a ring that contain `-1` without having to duplicate\nlemmas."}, {"name": "function.injective.non_unital_semiring", "description": " Pullback a `non_unital_semiring` instance along an injective function.\nSee note [reducible non-instances]."}, {"name": "function.injective.ring", "description": " Pullback a `ring` instance along an injective function.\nSee note [reducible non-instances]."}, {"name": "function.surjective.comm_semiring", "description": " Pushforward a `semiring` instance along a surjective function.\nSee note [reducible non-instances]."}, {"name": "non_unital_semiring.to_semigroup_with_zero", "description": ""}, {"name": "dvd_add", "description": ""}, {"name": "comm_semiring.to_comm_monoid", "description": ""}, {"name": "units.neg_divp", "description": ""}, {"name": "function.injective.distrib", "description": " Pullback a `distrib` instance along an injective function.\nSee note [reducible non-instances]."}, {"name": "non_unital_semiring.to_non_unital_non_assoc_semiring", "description": ""}, {"name": "is_left_regular_of_non_zero_divisor", "description": " Left `mul` by a `k : \u03b1` over `[ring \u03b1]` is injective, if `k` is not a zero divisor.\nThe typeclass that restricts all terms of `\u03b1` to have this property is `no_zero_divisors`."}, {"name": "non_unital_non_assoc_ring.to_has_distrib_neg", "description": ""}, {"name": "dvd_sub", "description": ""}, {"name": "neg_dvd", "description": " The negation of an element a of a semigroup with a distributive negation divides\nanother element b iff a divides b."}, {"name": "dvd_add_self_right", "description": "An element a divides the sum b + a if and only if a divides b."}, {"name": "non_unital_comm_ring.to_non_unital_ring", "description": ""}, {"name": "mul_two", "description": ""}, {"name": "function.surjective.ring", "description": " Pushforward a `ring` instance along a surjective function.\nSee note [reducible non-instances]."}, {"name": "is_domain", "description": "A domain is a nontrivial ring with no zero divisors, i.e. satisfying\n the condition `a * b = 0 \u2194 a = 0 \u2228 b = 0`.\n\n This is implemented as a mixin for `ring \u03b1`.\n To obtain an integral domain use `[comm_ring \u03b1] [is_domain \u03b1]`."}, {"name": "is_domain.eq_zero_or_eq_zero_of_mul_eq_zero", "description": "A domain is a nontrivial ring with no zero divisors, i.e. satisfying\n the condition `a * b = 0 \u2194 a = 0 \u2228 b = 0`.\n\n This is implemented as a mixin for `ring \u03b1`.\n To obtain an integral domain use `[comm_ring \u03b1] [is_domain \u03b1]`."}, {"name": "is_domain.exists_pair_ne", "description": "A domain is a nontrivial ring with no zero divisors, i.e. satisfying\n the condition `a * b = 0 \u2194 a = 0 \u2228 b = 0`.\n\n This is implemented as a mixin for `ring \u03b1`.\n To obtain an integral domain use `[comm_ring \u03b1] [is_domain \u03b1]`."}, {"name": "distrib.to_has_add", "description": ""}, {"name": "dvd_mul_sub_mul", "description": ""}, {"name": "dvd_neg_of_dvd", "description": ""}, {"name": "semiconj_by.neg_left", "description": ""}, {"name": "function.injective.non_assoc_semiring", "description": " Pullback a `non_assoc_semiring` instance along an injective function.\nSee note [reducible non-instances]."}, {"name": "non_assoc_ring.to_non_unital_non_assoc_ring", "description": ""}, {"name": "semiconj_by.neg_right", "description": ""}, {"name": "mul_self_eq_mul_self_iff", "description": ""}, {"name": "mul_ite", "description": ""}, {"name": "units.divp_sub", "description": ""}, {"name": "distrib_three_right", "description": ""}, {"name": "is_domain.to_cancel_monoid_with_zero", "description": ""}, {"name": "left_distrib_class", "description": "A typeclass stating that multiplication is left distributive over addition."}, {"name": "left_distrib_class.left_distrib", "description": "A typeclass stating that multiplication is left distributive over addition."}, {"name": "commute.neg_left", "description": ""}, {"name": "commute.bit1_left", "description": ""}, {"name": "comm_ring.to_non_unital_comm_ring", "description": ""}, {"name": "bit0_eq_two_mul", "description": ""}, {"name": "pred_ne_self", "description": ""}, {"name": "semiconj_by.sub_left", "description": ""}, {"name": "is_regular_of_ne_zero'", "description": ""}, {"name": "function.surjective.non_unital_ring", "description": " Pushforward a `non_unital_ring` instance along a surjective function.\nSee note [reducible non-instances]."}, {"name": "semiconj_by.neg_left_iff", "description": ""}, {"name": "Vieta_formula_quadratic", "description": "Vieta's formula for a quadratic equation, relating the coefficients of the polynomial with\n its roots. This particular version states that if we have a root `x` of a monic quadratic\n polynomial, then there is another root `y` such that `x + y` is negative the `a_1` coefficient\n and `x * y` is the `a_0` coefficient."}, {"name": "function.surjective.non_unital_non_assoc_ring", "description": " Pushforward a `non_unital_non_assoc_ring` instance along a surjective function.\nSee note [reducible non-instances]."}, {"name": "non_assoc_semiring.to_add_comm_monoid_with_one", "description": ""}, {"name": "mul_sub_left_distrib", "description": ""}, {"name": "commute.neg_right", "description": ""}, {"name": "non_unital_semiring", "description": "An associative but not-necessarily unital semiring."}, {"name": "non_unital_semiring.add", "description": "An associative but not-necessarily unital semiring."}, {"name": "non_unital_semiring.add_assoc", "description": "An associative but not-necessarily unital semiring."}, {"name": "non_unital_semiring.zero", "description": "An associative but not-necessarily unital semiring."}, {"name": "non_unital_semiring.zero_add", "description": "An associative but not-necessarily unital semiring."}, {"name": "non_unital_semiring.add_zero", "description": "An associative but not-necessarily unital semiring."}, {"name": "non_unital_semiring.nsmul", "description": "An associative but not-necessarily unital semiring."}, {"name": "non_unital_semiring.nsmul_zero'", "description": "An associative but not-necessarily unital semiring."}, {"name": "non_unital_semiring.nsmul_succ'", "description": "An associative but not-necessarily unital semiring."}, {"name": "non_unital_semiring.add_comm", "description": "An associative but not-necessarily unital semiring."}, {"name": "non_unital_semiring.mul", "description": "An associative but not-necessarily unital semiring."}, {"name": "non_unital_semiring.left_distrib", "description": "An associative but not-necessarily unital semiring."}, {"name": "non_unital_semiring.right_distrib", "description": "An associative but not-necessarily unital semiring."}, {"name": "non_unital_semiring.zero_mul", "description": "An associative but not-necessarily unital semiring."}, {"name": "non_unital_semiring.mul_zero", "description": "An associative but not-necessarily unital semiring."}, {"name": "non_unital_semiring.mul_assoc", "description": "An associative but not-necessarily unital semiring."}, {"name": "function.surjective.has_distrib_neg", "description": " A type endowed with `-` and `*` has distributive negation, if it admits a surjective map that\npreserves `-` and `*` from a type which has distributive negation."}, {"name": "no_zero_divisors.to_cancel_comm_monoid_with_zero", "description": " A commutative ring with no zero divisors is a `cancel_comm_monoid_with_zero`.\n\nNote this is not an instance as it forms a typeclass loop."}, {"name": "neg_mul_eq_mul_neg", "description": ""}, {"name": "is_regular_iff_ne_zero'", "description": ""}, {"name": "neg_mul_neg", "description": ""}, {"name": "commute.neg_left_iff", "description": ""}, {"name": "comm_semiring.to_semiring", "description": ""}, {"name": "dvd_add_iff_left", "description": ""}, {"name": "semiring.to_monoid_with_zero", "description": ""}, {"name": "two_dvd_bit0", "description": ""}, {"name": "is_domain.to_cancel_comm_monoid_with_zero", "description": ""}, {"name": "sub_mul_add_eq_of_mul_add_eq_mul_add", "description": "A simplification of one side of an equation exploiting right distributivity in rings\n and the definition of subtraction."}, {"name": "non_unital_comm_semiring.to_non_unital_semiring", "description": ""}, {"name": "units.sub_divp", "description": ""}, {"name": "function.surjective.semiring", "description": " Pushforward a `semiring` instance along a surjective function.\nSee note [reducible non-instances]."}, {"name": "is_unit.sub_iff", "description": ""}, {"name": "mul_neg_one", "description": "An element of a ring multiplied by the additive inverse of one is the element's additive\n inverse."}, {"name": "non_assoc_semiring", "description": "A unital but not-necessarily-associative semiring."}, {"name": "non_assoc_semiring.add", "description": "A unital but not-necessarily-associative semiring."}, {"name": "non_assoc_semiring.add_assoc", "description": "A unital but not-necessarily-associative semiring."}, {"name": "non_assoc_semiring.zero", "description": "A unital but not-necessarily-associative semiring."}, {"name": "non_assoc_semiring.zero_add", "description": "A unital but not-necessarily-associative semiring."}, {"name": "non_assoc_semiring.add_zero", "description": "A unital but not-necessarily-associative semiring."}, {"name": "non_assoc_semiring.nsmul", "description": "A unital but not-necessarily-associative semiring."}, {"name": "non_assoc_semiring.nsmul_zero'", "description": "A unital but not-necessarily-associative semiring."}, {"name": "non_assoc_semiring.nsmul_succ'", "description": "A unital but not-necessarily-associative semiring."}, {"name": "non_assoc_semiring.add_comm", "description": "A unital but not-necessarily-associative semiring."}, {"name": "non_assoc_semiring.mul", "description": "A unital but not-necessarily-associative semiring."}, {"name": "non_assoc_semiring.left_distrib", "description": "A unital but not-necessarily-associative semiring."}, {"name": "non_assoc_semiring.right_distrib", "description": "A unital but not-necessarily-associative semiring."}, {"name": "non_assoc_semiring.zero_mul", "description": "A unital but not-necessarily-associative semiring."}, {"name": "non_assoc_semiring.mul_zero", "description": "A unital but not-necessarily-associative semiring."}, {"name": "non_assoc_semiring.one", "description": "A unital but not-necessarily-associative semiring."}, {"name": "non_assoc_semiring.one_mul", "description": "A unital but not-necessarily-associative semiring."}, {"name": "non_assoc_semiring.mul_one", "description": "A unital but not-necessarily-associative semiring."}, {"name": "non_assoc_semiring.nat_cast", "description": "A unital but not-necessarily-associative semiring."}, {"name": "non_assoc_semiring.nat_cast_zero", "description": "A unital but not-necessarily-associative semiring."}, {"name": "non_assoc_semiring.nat_cast_succ", "description": "A unital but not-necessarily-associative semiring."}, {"name": "mul_self_sub_mul_self", "description": "Representation of a difference of two squares in a commutative ring as a product."}, {"name": "ring.to_distrib", "description": ""}, {"name": "dvd_of_dvd_neg", "description": ""}, {"name": "add_monoid_hom.mul_right", "description": "Right multiplication by an element of a (semi)ring is an `add_monoid_hom`"}, {"name": "mul_self_eq_one_iff", "description": ""}, {"name": "function.surjective.non_assoc_ring", "description": " Pushforward a `non_unital_ring` instance along a surjective function.\nSee note [reducible non-instances]."}, {"name": "units.divp_add_divp_same", "description": ""}, {"name": "is_domain.to_nontrivial", "description": ""}, {"name": "non_unital_non_assoc_ring.to_add_comm_group", "description": ""}, {"name": "non_unital_non_assoc_semiring.to_add_comm_monoid", "description": ""}, {"name": "units.coe_neg", "description": "Representing an element of a ring's unit group as an element of the ring commutes with\n   mapping this element to its additive inverse."}, {"name": "function.surjective.non_unital_comm_semiring", "description": " Pushforward a `non_unital_semiring` instance along a surjective function.\nSee note [reducible non-instances]."}, {"name": "non_unital_non_assoc_semiring", "description": "A not-necessarily-unital, not-necessarily-associative semiring."}, {"name": "non_unital_non_assoc_semiring.add", "description": "A not-necessarily-unital, not-necessarily-associative semiring."}, {"name": "non_unital_non_assoc_semiring.add_assoc", "description": "A not-necessarily-unital, not-necessarily-associative semiring."}, {"name": "non_unital_non_assoc_semiring.zero", "description": "A not-necessarily-unital, not-necessarily-associative semiring."}, {"name": "non_unital_non_assoc_semiring.zero_add", "description": "A not-necessarily-unital, not-necessarily-associative semiring."}, {"name": "non_unital_non_assoc_semiring.add_zero", "description": "A not-necessarily-unital, not-necessarily-associative semiring."}, {"name": "non_unital_non_assoc_semiring.nsmul", "description": "A not-necessarily-unital, not-necessarily-associative semiring."}, {"name": "non_unital_non_assoc_semiring.nsmul_zero'", "description": "A not-necessarily-unital, not-necessarily-associative semiring."}, {"name": "non_unital_non_assoc_semiring.nsmul_succ'", "description": "A not-necessarily-unital, not-necessarily-associative semiring."}, {"name": "non_unital_non_assoc_semiring.add_comm", "description": "A not-necessarily-unital, not-necessarily-associative semiring."}, {"name": "non_unital_non_assoc_semiring.mul", "description": "A not-necessarily-unital, not-necessarily-associative semiring."}, {"name": "non_unital_non_assoc_semiring.left_distrib", "description": "A not-necessarily-unital, not-necessarily-associative semiring."}, {"name": "non_unital_non_assoc_semiring.right_distrib", "description": "A not-necessarily-unital, not-necessarily-associative semiring."}, {"name": "non_unital_non_assoc_semiring.zero_mul", "description": "A not-necessarily-unital, not-necessarily-associative semiring."}, {"name": "non_unital_non_assoc_semiring.mul_zero", "description": "A not-necessarily-unital, not-necessarily-associative semiring."}, {"name": "mul_add", "description": "**Alias** of `left_distrib`."}, {"name": "char.val_of_nat_eq_of_is_valid", "description": ""}, {"name": "char.of_nat_eq_of_not_is_valid", "description": ""}, {"name": "char.val_of_nat_eq_of_not_is_valid", "description": ""}, {"name": "char.of_nat_ne_of_ne", "description": ""}, {"name": "nat.sub_mono_right_strict", "description": ""}, {"name": "mul_mono_nonpos", "description": ""}, {"name": "mul_mono_nonneg", "description": ""}, {"name": "nat.sub_mono_left_strict", "description": ""}, {"name": "lt_of_mul_lt_mul_neg_right", "description": ""}, {"name": "tactic.interactive.traversable_derive_handler'", "description": ""}, {"name": "tactic.interactive.functor_derive_handler'", "description": ""}, {"name": "tactic.interactive.traversable_derive_handler", "description": ""}, {"name": "tactic.interactive.lawful_functor_derive_handler'", "description": ""}, {"name": "tactic.interactive.nested_map", "description": "similar to `nested_traverse` but for `functor`"}, {"name": "tactic.interactive.higher_order_derive_handler", "description": ""}, {"name": "tactic.interactive.guard_class", "description": ""}, {"name": "tactic.interactive.lawful_traversable_derive_handler", "description": ""}, {"name": "tactic.interactive.mk_mapp_aux'", "description": ""}, {"name": "tactic.interactive.mk_traverse", "description": "derive the `traverse` definition of a `traversable` instance"}, {"name": "tactic.interactive.derive_lawful_functor", "description": ""}, {"name": "tactic.interactive.map_field", "description": "similar to `traverse_field` but for `functor`"}, {"name": "tactic.interactive.derive_traverse", "description": ""}, {"name": "tactic.interactive.derive_functor", "description": ""}, {"name": "tactic.interactive.lawful_functor_derive_handler", "description": ""}, {"name": "tactic.interactive.mk_map", "description": "derive the `map` definition of a `functor`"}, {"name": "tactic.interactive.with_prefix", "description": ""}, {"name": "tactic.interactive.lawful_traversable_derive_handler'", "description": ""}, {"name": "tactic.interactive.functor_derive_handler", "description": ""}, {"name": "tactic.interactive.derive_traverse_equations", "description": "derive the equations for a specific `traverse` definition"}, {"name": "tactic.interactive.mk_one_instance", "description": ""}, {"name": "tactic.interactive.simp_functor", "description": ""}, {"name": "tactic.interactive.get_equations_of", "description": ""}, {"name": "tactic.interactive.derive_lawful_traversable", "description": ""}, {"name": "tactic.interactive.nested_traverse", "description": " ``nested_traverse f \u03b1 (list (array n (list \u03b1)))`` synthesizes the expression\n`traverse (traverse (traverse f))`. `nested_traverse` assumes that `\u03b1` appears in\n`(list (array n (list \u03b1)))`"}, {"name": "tactic.interactive.traverse_field", "description": "For a sum type `inductive foo (\u03b1 : Type) | foo1 : list \u03b1 \u2192 \u2115 \u2192 foo | ...`\n``traverse_field `foo appl_inst f `\u03b1 `(x : list \u03b1)`` synthesizes\n`traverse f x` as part of traversing `foo1`."}, {"name": "tactic.interactive.traverse_constructor", "description": "For a sum type `inductive foo (\u03b1 : Type) | foo1 : list \u03b1 \u2192 \u2115 \u2192 foo | ...`\n``traverse_constructor `foo1 `foo appl_inst f `\u03b1 `\u03b2 [`(x : list \u03b1), `(y : \u2115)]``\nsynthesizes `foo1 <$> traverse f x <*> pure y.`"}, {"name": "tactic.interactive.traversable_law_starter", "description": ""}, {"name": "tactic.interactive.derive_map_equations", "description": "derive the equations for a specific `map` definition"}, {"name": "tactic.interactive.mk_mapp'", "description": ""}, {"name": "tactic.interactive.map_constructor", "description": "similar to `traverse_constructor` but for `functor`"}, {"name": "tactic.interactive.squeeze_simp", "description": "`squeeze_simp`, `squeeze_simpa` and `squeeze_dsimp` perform the same\ntask with the difference that `squeeze_simp` relates to `simp` while\n`squeeze_simpa` relates to `simpa` and `squeeze_dsimp` relates to\n`dsimp`. The following applies to `squeeze_simp`, `squeeze_simpa` and\n`squeeze_dsimp`.\n\n`squeeze_simp` behaves like `simp` (including all its arguments)\nand prints a `simp only` invocation to skip the search through the\n`simp` lemma list.\n\nFor instance, the following is easily solved with `simp`:\n\n```lean\nexample : 0 + 1 = 1 + 0 := by simp\n```\n\nTo guide the proof search and speed it up, we may replace `simp`\nwith `squeeze_simp`:\n\n```lean\nexample : 0 + 1 = 1 + 0 := by squeeze_simp\n-- prints:\n-- Try this: simp only [add_zero, eq_self_iff_true, zero_add]\n```\n\n`squeeze_simp` suggests a replacement which we can use instead of\n`squeeze_simp`.\n\n```lean\nexample : 0 + 1 = 1 + 0 := by simp only [add_zero, eq_self_iff_true, zero_add]\n```\n\n`squeeze_simp only` prints nothing as it already skips the `simp` list.\n\nThis tactic is useful for speeding up the compilation of a complete file.\nSteps:\n\n   1. search and replace ` simp` with ` squeeze_simp` (the space helps avoid the\n      replacement of `simp` in `@[simp]`) throughout the file.\n   2. Starting at the beginning of the file, go to each printout in turn, copy\n      the suggestion in place of `squeeze_simp`.\n   3. after all the suggestions were applied, search and replace `squeeze_simp` with\n      `simp` to remove the occurrences of `squeeze_simp` that did not produce a suggestion.\n\nKnown limitation(s):\n  * in cases where `squeeze_simp` is used after a `;` (e.g. `cases x; squeeze_simp`),\n    `squeeze_simp` will produce as many suggestions as the number of goals it is applied to.\n    It is likely that none of the suggestion is a good replacement but they can all be\n    combined by concatenating their list of lemmas. `squeeze_scope` can be used to\n    combine the suggestions: `by squeeze_scope { cases x; squeeze_simp }`\n  * sometimes, `simp` lemmas are also `_refl_lemma` and they can be used without appearing in the\n    resulting proof. `squeeze_simp` won't know to try that lemma unless it is called as\n    `squeeze_simp?`"}, {"name": "tactic.squeeze_loc_attr_carrier", "description": "dummy declaration used as target of `squeeze_loc` attribute"}, {"name": "tactic.interactive.squeeze_dsimp", "description": " `squeeze_dsimp` behaves like `dsimp` (including all its arguments)\nand prints a `dsimp only` invocation to skip the search through the\n`simp` lemma list. See the doc string of `squeeze_simp` for examples."}, {"name": "tactic.parse_config", "description": "translate a `pexpr` into a `simp` configuration"}, {"name": "tactic.prepend_root_if_needed", "description": " If the `name` is (likely) to be overloaded, then prepend a `_root_` on it. The `expr` of an\noverloaded name is constructed using `expr.macro`; this is how we guess whether it's overloaded."}, {"name": "tactic.filter_simp_set", "description": "`filter_simp_set g call_simp user_args simp_args` returns `args'` such that, when calling\n`call_simp tt /- only -/ args'` on the goal `g` (`g` is a meta var) we end up in the same\nstate as if we had called `call_simp ff (user_args ++ simp_args)` and removing any one\nelement of `args'` changes the resulting proof."}, {"name": "tactic.same_result", "description": " `same_result proof tac` runs tactic `tac` and checks if the proof\nproduced by `tac` is equivalent to `proof`."}, {"name": "tactic.simp_arg_type.has_to_string", "description": "Turn a `simp_arg_type` into a string."}, {"name": "tactic.simp_arg_type.decidable_eq", "description": ""}, {"name": "tactic.interactive.squeeze_simpa", "description": "see `squeeze_simp`"}, {"name": "tactic.interactive.squeeze_scope", "description": " combinator meant to aggregate the suggestions issued by multiple calls\nof `squeeze_simp` (due, for instance, to `;`).\n\nCan be used as:\n\n```lean\nexample {\u03b1 \u03b2} (xs ys : list \u03b1) (f : \u03b1 \u2192 \u03b2) :\n  (xs ++ ys.tail).map f = xs.map f \u2227 (xs.tail.map f).length = xs.length :=\nbegin\n  have : xs = ys, admit,\n  squeeze_scope\n  { split; squeeze_simp,\n    -- `squeeze_simp` is run twice, the first one requires\n    -- `list.map_append` and the second one\n    -- `[list.length_map, list.length_tail]`\n    -- prints only one message and combine the suggestions:\n    -- > Try this: simp only [list.length_map, list.length_tail, list.map_append]\n    squeeze_simp [this]\n    -- `squeeze_simp` is run only once\n    -- prints:\n    -- > Try this: simp only [this] },\nend\n```"}, {"name": "tactic.mk_suggestion", "description": " Emit a suggestion to the user. If inside a `squeeze_scope` block,\nthe suggestions emitted through `mk_suggestion` will be aggregated so that\nevery tactic that makes a suggestion can consider multiple execution of the\nsame invocation.\nIf `at_pos` is true, make the suggestion at `p` instead of the current position."}, {"name": "tactic.render_simp_arg_list", "description": " Format a list of arguments for use with `simp` and friends. This omits the\nlist entirely if it is empty.\n\nPatch: `pp` was changed to `to_string` because it was getting rid of prefixes\nthat would be necessary for some disambiguations."}, {"name": "tactic.name.to_simp_args", "description": "make a `simp_arg_type` that references the name given as an argument"}, {"name": "pos.move_left", "description": "shift `pos` `n` columns to the left"}, {"name": "tactic_doc.tactic.squeeze_simp / squeeze_simpa / squeeze_dsimp / squeeze_scope", "description": "`squeeze_simp`, `squeeze_simpa` and `squeeze_dsimp` perform the same\ntask with the difference that `squeeze_simp` relates to `simp` while\n`squeeze_simpa` relates to `simpa` and `squeeze_dsimp` relates to\n`dsimp`. The following applies to `squeeze_simp`, `squeeze_simpa` and\n`squeeze_dsimp`.\n\n`squeeze_simp` behaves like `simp` (including all its arguments)\nand prints a `simp only` invocation to skip the search through the\n`simp` lemma list.\n\nFor instance, the following is easily solved with `simp`:\n\n```lean\nexample : 0 + 1 = 1 + 0 := by simp\n```\n\nTo guide the proof search and speed it up, we may replace `simp`\nwith `squeeze_simp`:\n\n```lean\nexample : 0 + 1 = 1 + 0 := by squeeze_simp\n-- prints:\n-- Try this: simp only [add_zero, eq_self_iff_true, zero_add]\n```\n\n`squeeze_simp` suggests a replacement which we can use instead of\n`squeeze_simp`.\n\n```lean\nexample : 0 + 1 = 1 + 0 := by simp only [add_zero, eq_self_iff_true, zero_add]\n```\n\n`squeeze_simp only` prints nothing as it already skips the `simp` list.\n\nThis tactic is useful for speeding up the compilation of a complete file.\nSteps:\n\n   1. search and replace ` simp` with ` squeeze_simp` (the space helps avoid the\n      replacement of `simp` in `@[simp]`) throughout the file.\n   2. Starting at the beginning of the file, go to each printout in turn, copy\n      the suggestion in place of `squeeze_simp`.\n   3. after all the suggestions were applied, search and replace `squeeze_simp` with\n      `simp` to remove the occurrences of `squeeze_simp` that did not produce a suggestion.\n\nKnown limitation(s):\n  * in cases where `squeeze_simp` is used after a `;` (e.g. `cases x; squeeze_simp`),\n    `squeeze_simp` will produce as many suggestions as the number of goals it is applied to.\n    It is likely that none of the suggestion is a good replacement but they can all be\n    combined by concatenating their list of lemmas. `squeeze_scope` can be used to\n    combine the suggestions: `by squeeze_scope { cases x; squeeze_simp }`\n  * sometimes, `simp` lemmas are also `_refl_lemma` and they can be used without appearing in the\n    resulting proof. `squeeze_simp` won't know to try that lemma unless it is called as\n    `squeeze_simp?`"}, {"name": "loc.to_string", "description": "pretty print a `loc`"}, {"name": "tactic.squeeze_simp_core", "description": " tactic combinator to create a `simp`-like tactic that minimizes its\nargument list.\n\n * `slow`: adds all rfl-lemmas from the environment to the initial list (this is a slower but more\n           accurate strategy)\n * `no_dflt`: did the user use the `only` keyword?\n * `args`:    list of `simp` arguments\n * `tac`:     how to invoke the underlying `simp` tactic"}, {"name": "tactic.struct.to_tactic_format", "description": "pretty print structure instance"}, {"name": "tactic.parse_dsimp_config", "description": "translate a `pexpr` into a `dsimp` configuration"}, {"name": "tactic.struct_inst", "description": "parse structure instance of the shape `{ field1 := value1, .. , field2 := value2 }`"}, {"name": "semifield.to_comm_semiring", "description": ""}, {"name": "div_neg", "description": ""}, {"name": "div_add_one", "description": ""}, {"name": "div_sub_div", "description": ""}, {"name": "division_semiring", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.add", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.add_assoc", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.zero", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.zero_add", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.add_zero", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.nsmul", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.nsmul_zero'", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.nsmul_succ'", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.add_comm", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.mul", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.left_distrib", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.right_distrib", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.zero_mul", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.mul_zero", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.mul_assoc", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.one", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.one_mul", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.mul_one", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.nat_cast", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.nat_cast_zero", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.nat_cast_succ", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.npow", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.npow_zero'", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.npow_succ'", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.inv", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.div", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.div_eq_mul_inv", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.zpow", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.zpow_zero'", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.zpow_succ'", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.zpow_neg'", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.exists_pair_ne", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.inv_zero", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "division_semiring.mul_inv_cancel", "description": "A `division_semiring` is a `semiring` with multiplicative inverses for nonzero elements."}, {"name": "function.injective.division_semiring", "description": "Pullback a `division_semiring` along an injective function."}, {"name": "division_ring_of_is_unit_or_eq_zero", "description": "Constructs a `division_ring` structure on a `ring` consisting only of units and 0."}, {"name": "field_of_is_unit_or_eq_zero", "description": " Constructs a `field` structure on a `comm_ring` consisting only of units and 0.\nSee note [reducible non-instances]."}, {"name": "division_ring.to_nontrivial", "description": ""}, {"name": "is_field", "description": " A predicate to express that a (semi)ring is a (semi)field.\n\nThis is mainly useful because such a predicate does not contain data,\nand can therefore be easily transported along ring isomorphisms.\nAdditionaly, this is useful when trying to prove that\na particular ring structure extends to a (semi)field."}, {"name": "is_field.exists_pair_ne", "description": " A predicate to express that a (semi)ring is a (semi)field.\n\nThis is mainly useful because such a predicate does not contain data,\nand can therefore be easily transported along ring isomorphisms.\nAdditionaly, this is useful when trying to prove that\na particular ring structure extends to a (semi)field."}, {"name": "is_field.mul_comm", "description": " A predicate to express that a (semi)ring is a (semi)field.\n\nThis is mainly useful because such a predicate does not contain data,\nand can therefore be easily transported along ring isomorphisms.\nAdditionaly, this is useful when trying to prove that\na particular ring structure extends to a (semi)field."}, {"name": "is_field.mul_inv_cancel", "description": " A predicate to express that a (semi)ring is a (semi)field.\n\nThis is mainly useful because such a predicate does not contain data,\nand can therefore be easily transported along ring isomorphisms.\nAdditionaly, this is useful when trying to prove that\na particular ring structure extends to a (semi)field."}, {"name": "ring_hom.map_div", "description": ""}, {"name": "one_add_div", "description": ""}, {"name": "add_div", "description": ""}, {"name": "inv_neg", "description": ""}, {"name": "function.injective.semifield", "description": "Pullback a `field` along an injective function."}, {"name": "field.to_is_field", "description": "Transferring from `field` to `is_field`."}, {"name": "semifield.to_is_field", "description": "Transferring from `semifield` to `is_field`."}, {"name": "rat.smul_division_ring", "description": ""}, {"name": "division_ring.to_div_inv_monoid", "description": ""}, {"name": "sub_div", "description": ""}, {"name": "has_rat_cast", "description": "Type class for the canonical homomorphism `\u211a \u2192 K`."}, {"name": "has_rat_cast.rat_cast", "description": "Type class for the canonical homomorphism `\u211a \u2192 K`."}, {"name": "is_field.to_field", "description": "Transferring from `is_field` to `field`."}, {"name": "rat.cast_mk'", "description": ""}, {"name": "division_ring", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.add", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.add_assoc", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.zero", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.zero_add", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.add_zero", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.nsmul", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.nsmul_zero'", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.nsmul_succ'", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.neg", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.sub", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.sub_eq_add_neg", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.zsmul", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.zsmul_zero'", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.zsmul_succ'", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.zsmul_neg'", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.add_left_neg", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.add_comm", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.int_cast", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.nat_cast", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.one", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.nat_cast_zero", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.nat_cast_succ", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.int_cast_of_nat", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.int_cast_neg_succ_of_nat", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.mul", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.mul_assoc", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.one_mul", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.mul_one", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.npow", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.npow_zero'", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.npow_succ'", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.left_distrib", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.right_distrib", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.inv", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.div", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.div_eq_mul_inv", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.zpow", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.zpow_zero'", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.zpow_succ'", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.zpow_neg'", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.exists_pair_ne", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.rat_cast", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.mul_inv_cancel", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.inv_zero", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.rat_cast_mk", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.qsmul", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "division_ring.qsmul_eq_mul'", "description": " A `division_ring` is a `ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `division_ring K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the division ring has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "uniq_inv_of_is_field", "description": " For each field, and for each nonzero element of said field, there is a unique inverse.\nSince `is_field` doesn't remember the data of an `inv` function and as such,\na lemma that there is a unique inverse could be useful."}, {"name": "add_div_eq_mul_add_div", "description": ""}, {"name": "division_ring.is_domain", "description": ""}, {"name": "ring_hom.map_ne_zero", "description": ""}, {"name": "div_sub_same", "description": ""}, {"name": "ring_hom.map_inv", "description": ""}, {"name": "is_field.to_semifield", "description": "Transferring from `is_field` to `semifield`."}, {"name": "div_add_same", "description": ""}, {"name": "same_add_div", "description": ""}, {"name": "div_add'", "description": ""}, {"name": "field.to_comm_ring", "description": ""}, {"name": "div_sub'", "description": ""}, {"name": "div_neg_self", "description": ""}, {"name": "rat.smul_def", "description": ""}, {"name": "inv_sub_inv", "description": ""}, {"name": "function.injective.field", "description": " Pullback a `field` along an injective function.\nSee note [reducible non-instances]."}, {"name": "rat.cast_def", "description": ""}, {"name": "semifield.to_comm_group_with_zero", "description": ""}, {"name": "field.is_domain", "description": ""}, {"name": "field.to_division_ring", "description": ""}, {"name": "one_div_neg_one_eq_neg_one", "description": ""}, {"name": "one_div_neg_eq_neg_one_div", "description": ""}, {"name": "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "description": ""}, {"name": "ring_hom.map_eq_zero", "description": ""}, {"name": "neg_div_self", "description": ""}, {"name": "sub_div'", "description": ""}, {"name": "function.injective.division_ring", "description": " Pullback a `division_ring` along an injective function.\nSee note [reducible non-instances]."}, {"name": "division_ring.to_ring", "description": ""}, {"name": "not_is_field_of_subsingleton", "description": ""}, {"name": "semifield.to_division_semiring", "description": ""}, {"name": "neg_inv", "description": ""}, {"name": "rat.cast_coe", "description": "Construct the canonical injection from `\u211a` into an arbitrary\n division ring. If the field has positive characteristic `p`,\n we define `1 / p = 1 / 0 = 0` for consistency with our\n division by zero convention."}, {"name": "field", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.add", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.add_assoc", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.zero", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.zero_add", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.add_zero", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.nsmul", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.nsmul_zero'", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.nsmul_succ'", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.neg", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.sub", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.sub_eq_add_neg", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.zsmul", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.zsmul_zero'", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.zsmul_succ'", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.zsmul_neg'", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.add_left_neg", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.add_comm", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.int_cast", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.nat_cast", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.one", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.nat_cast_zero", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.nat_cast_succ", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.int_cast_of_nat", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.int_cast_neg_succ_of_nat", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.mul", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.mul_assoc", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.one_mul", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.mul_one", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.npow", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.npow_zero'", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.npow_succ'", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.left_distrib", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.right_distrib", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.mul_comm", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.inv", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.div", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.div_eq_mul_inv", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.zpow", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.zpow_zero'", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.zpow_succ'", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.zpow_neg'", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.exists_pair_ne", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.rat_cast", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.mul_inv_cancel", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.inv_zero", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.rat_cast_mk", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.qsmul", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "field.qsmul_eq_mul'", "description": " A `field` is a `comm_ring` with multiplicative inverses for nonzero elements.\n\nAn instance of `field K` includes maps `of_rat : \u211a \u2192 K` and `qsmul : \u211a \u2192 K \u2192 K`.\nIf the field has positive characteristic p, we define `of_rat (1 / p) = 1 / 0 = 0`\nfor consistency with our division by zero convention.\nThe fields `of_rat` and `qsmul are needed to implement the\n`algebra_rat [division_ring K] : algebra \u211a K` instance, since we need to control the specific\ndefinitions for some special cases of `K` (in particular `K = \u211a` itself).\nSee also Note [forgetful inheritance]."}, {"name": "rat.cast_rec", "description": " The default definition of the coercion `(\u2191(a : \u211a) : K)` for a division ring `K`\nis defined as `(a / b : K) = (a : K) * (b : K)\u207b\u00b9`.\nUse `coe` instead of `rat.cast_rec` for better definitional behaviour."}, {"name": "div_add_div_same", "description": ""}, {"name": "division_ring.to_division_semiring", "description": ""}, {"name": "ring_hom.map_units_inv", "description": ""}, {"name": "neg_div_neg_eq", "description": ""}, {"name": "field.to_semifield", "description": ""}, {"name": "neg_div", "description": ""}, {"name": "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "description": ""}, {"name": "div_neg_eq_neg_div", "description": ""}, {"name": "div_sub_div_same", "description": ""}, {"name": "one_div_add_one_div", "description": ""}, {"name": "is_field.nontrivial", "description": ""}, {"name": "ring_hom.injective", "description": ""}, {"name": "one_sub_div", "description": ""}, {"name": "neg_div'", "description": ""}, {"name": "division_semiring.to_group_with_zero", "description": ""}, {"name": "div_add_div", "description": ""}, {"name": "qsmul_rec", "description": " The default definition of the scalar multiplication `(a : \u211a) \u2022 (x : K)` for a division ring `K`\nis given by `a \u2022 x = (\u2191 a) * x`.\nUse `(a : \u211a) \u2022 (x : K)` instead of `qsmul_rec` for better definitional behaviour."}, {"name": "inv_add_inv", "description": ""}, {"name": "division_ring.to_has_rat_cast", "description": ""}, {"name": "same_sub_div", "description": ""}, {"name": "semifield", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.add", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.add_assoc", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.zero", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.zero_add", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.add_zero", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.nsmul", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.nsmul_zero'", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.nsmul_succ'", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.add_comm", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.mul", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.left_distrib", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.right_distrib", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.zero_mul", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.mul_zero", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.mul_assoc", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.one", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.one_mul", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.mul_one", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.nat_cast", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.nat_cast_zero", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.nat_cast_succ", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.npow", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.npow_zero'", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.npow_succ'", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.mul_comm", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.inv", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.div", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.div_eq_mul_inv", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.zpow", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.zpow_zero'", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.zpow_succ'", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.zpow_neg'", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.exists_pair_ne", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.inv_zero", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "semifield.mul_inv_cancel", "description": "A `semifield` is a `comm_semiring` with multiplicative inverses for nonzero elements."}, {"name": "div_sub_one", "description": ""}, {"name": "add_div'", "description": ""}, {"name": "division_semiring.to_semiring", "description": ""}, {"name": "list.reverse_prefix", "description": ""}, {"name": "list.prefix_cons_inj", "description": ""}, {"name": "list.is_prefix.filter_map", "description": ""}, {"name": "list.is_prefix.reverse", "description": "**Alias** of the reverse direction of `list.reverse_suffix`."}, {"name": "list.mem_inits", "description": ""}, {"name": "list.take_sublist", "description": ""}, {"name": "list.decidable_prefix", "description": ""}, {"name": "list.eq_of_prefix_of_length_eq", "description": ""}, {"name": "list.drop_sublist", "description": ""}, {"name": "list.insert_of_mem", "description": ""}, {"name": "list.is_infix.reverse", "description": "**Alias** of the reverse direction of `list.reverse_infix`."}, {"name": "list.take_subset", "description": ""}, {"name": "list.is_suffix.is_partial_order", "description": ""}, {"name": "list.mem_tails", "description": ""}, {"name": "list.suffix_rfl", "description": ""}, {"name": "list.infix_of_mem_join", "description": ""}, {"name": "list.suffix_cons", "description": ""}, {"name": "list.is_infix.length_le", "description": ""}, {"name": "list.tail_suffix", "description": ""}, {"name": "list.nil_infix", "description": ""}, {"name": "list.infix_insert", "description": ""}, {"name": "list.length_tails", "description": ""}, {"name": "list.suffix_cons_iff", "description": ""}, {"name": "list.is_infix.sublist", "description": ""}, {"name": "list.suffix_iff_eq_append", "description": ""}, {"name": "list.tails_cons", "description": ""}, {"name": "list.inits_cons", "description": ""}, {"name": "list.length_insert_of_mem", "description": ""}, {"name": "list.mem_of_mem_take", "description": ""}, {"name": "list.take_prefix", "description": ""}, {"name": "list.is_prefix.is_partial_order", "description": ""}, {"name": "list.prefix_append_right_inj", "description": ""}, {"name": "list.insert.def", "description": ""}, {"name": "list.suffix_refl", "description": ""}, {"name": "list.eq_of_suffix_of_length_eq", "description": ""}, {"name": "list.is_infix.trans", "description": ""}, {"name": "list.infix_nil_iff", "description": ""}, {"name": "list.infix_cons", "description": ""}, {"name": "list.inits_append", "description": ""}, {"name": "list.eq_or_mem_of_mem_insert", "description": ""}, {"name": "list.is_suffix.is_infix", "description": ""}, {"name": "list.insert_of_not_mem", "description": ""}, {"name": "list.is_infix.filter", "description": ""}, {"name": "list.nth_le_inits", "description": ""}, {"name": "list.is_suffix.reverse", "description": "**Alias** of the reverse direction of `list.reverse_prefix`."}, {"name": "list.prefix_iff_eq_take", "description": ""}, {"name": "list.init_subset", "description": ""}, {"name": "list.inits_eq_tails", "description": ""}, {"name": "list.tail_subset", "description": ""}, {"name": "list.suffix_nil_iff", "description": ""}, {"name": "list.is_prefix.map", "description": ""}, {"name": "list.take_while_prefix", "description": ""}, {"name": "list.cons_prefix_iff", "description": ""}, {"name": "list.tail_sublist", "description": ""}, {"name": "list.length_insert_of_not_mem", "description": ""}, {"name": "list.eq_nil_of_prefix_nil", "description": "**Alias** of the forward direction of `list.prefix_nil_iff`."}, {"name": "list.is_prefix.is_infix", "description": ""}, {"name": "list.infix_cons_iff", "description": ""}, {"name": "list.eq_of_infix_of_length_eq", "description": ""}, {"name": "list.prefix_of_prefix_length_le", "description": ""}, {"name": "list.nil_prefix", "description": ""}, {"name": "list.is_suffix.subset", "description": ""}, {"name": "list.prefix_or_prefix_of_prefix", "description": ""}, {"name": "list.infix_refl", "description": ""}, {"name": "list.eq_nil_of_suffix_nil", "description": "**Alias** of the forward direction of `list.suffix_nil_iff`."}, {"name": "list.mem_of_mem_init", "description": ""}, {"name": "list.is_suffix.trans", "description": ""}, {"name": "list.prefix_rfl", "description": ""}, {"name": "list.drop_suffix", "description": ""}, {"name": "list.init_prefix", "description": ""}, {"name": "list.tails_append", "description": ""}, {"name": "list.map_reverse_tails", "description": ""}, {"name": "list.is_prefix.reduce_option", "description": ""}, {"name": "list.nth_le_tails", "description": ""}, {"name": "list.decidable_infix", "description": ""}, {"name": "list.insert_nil", "description": ""}, {"name": "list.prefix_take_le_iff", "description": ""}, {"name": "list.prefix_nil_iff", "description": ""}, {"name": "list.is_infix.subset", "description": ""}, {"name": "list.is_prefix.sublist", "description": ""}, {"name": "list.inits_reverse", "description": ""}, {"name": "list.length_inits", "description": ""}, {"name": "list.prefix_iff_eq_append", "description": ""}, {"name": "list.suffix_or_suffix_of_suffix", "description": ""}, {"name": "list.prefix_append", "description": ""}, {"name": "list.is_suffix.sublist", "description": ""}, {"name": "list.sublist_insert", "description": ""}, {"name": "list.suffix_insert", "description": ""}, {"name": "list.mem_insert_of_mem", "description": ""}, {"name": "list.reverse_infix", "description": ""}, {"name": "list.tails_eq_inits", "description": ""}, {"name": "list.nil_suffix", "description": ""}, {"name": "list.is_suffix.filter", "description": ""}, {"name": "list.mem_insert_self", "description": ""}, {"name": "list.drop_while_suffix", "description": ""}, {"name": "list.is_prefix.trans", "description": ""}, {"name": "list.map_reverse_inits", "description": ""}, {"name": "list.suffix_of_suffix_length_le", "description": ""}, {"name": "list.infix_iff_prefix_suffix", "description": ""}, {"name": "list.infix_append'", "description": ""}, {"name": "list.is_infix.is_partial_order", "description": ""}, {"name": "list.is_prefix.filter", "description": ""}, {"name": "list.mem_of_mem_drop", "description": ""}, {"name": "list.suffix_append", "description": ""}, {"name": "list.decidable_suffix", "description": ""}, {"name": "list.eq_nil_of_infix_nil", "description": ""}, {"name": "list.reverse_suffix", "description": ""}, {"name": "list.infix_concat", "description": ""}, {"name": "list.is_prefix.length_le", "description": ""}, {"name": "list.infix_append", "description": ""}, {"name": "list.init_sublist", "description": ""}, {"name": "list.is_suffix.length_le", "description": ""}, {"name": "list.mem_insert_iff", "description": ""}, {"name": "list.prefix_refl", "description": ""}, {"name": "list.subset_insert", "description": ""}, {"name": "list.mem_of_mem_suffix", "description": ""}, {"name": "list.drop_subset", "description": ""}, {"name": "list.mem_of_mem_tail", "description": ""}, {"name": "list.is_prefix.subset", "description": ""}, {"name": "list.tails_reverse", "description": ""}, {"name": "list.suffix_iff_eq_drop", "description": ""}, {"name": "list.prefix_concat", "description": ""}, {"name": "list.infix_rfl", "description": ""}, {"name": "add_opposite.unop_one", "description": ""}, {"name": "mul_opposite.is_empty", "description": ""}, {"name": "add_opposite.has_add", "description": ""}, {"name": "mul_opposite.op_equiv_apply", "description": ""}, {"name": "add_opposite.op_vadd", "description": ""}, {"name": "mul_opposite.unop_sub", "description": ""}, {"name": "add_opposite.has_div", "description": ""}, {"name": "add_opposite.is_empty", "description": ""}, {"name": "mul_opposite.unop_injective", "description": ""}, {"name": "add_opposite.unop_eq_one_iff", "description": ""}, {"name": "mul_opposite.has_involutive_neg", "description": ""}, {"name": "mul_opposite.unop_mul", "description": ""}, {"name": "mul_opposite.op_add", "description": ""}, {"name": "add_opposite.op_comp_unop", "description": ""}, {"name": "mul_opposite.op_equiv", "description": "The canonical bijection between `\u03b1` and `\u03b1\u1d50\u1d52\u1d56`."}, {"name": "add_opposite.unop_injective", "description": ""}, {"name": "mul_opposite.op_bijective", "description": ""}, {"name": "add_opposite.op_add", "description": ""}, {"name": "add_opposite.op_surjective", "description": ""}, {"name": "add_opposite.op_equiv_apply", "description": ""}, {"name": "mul_opposite.has_inv", "description": ""}, {"name": "mul_opposite.unop_surjective", "description": ""}, {"name": "add_opposite.op_equiv_symm_apply", "description": ""}, {"name": "add_opposite.op_eq_zero_iff", "description": ""}, {"name": "add_opposite.unop_inj", "description": ""}, {"name": "mul_opposite.unop_one", "description": ""}, {"name": "mul_opposite.unop_op", "description": ""}, {"name": "mul_opposite.has_involutive_inv", "description": ""}, {"name": "add_opposite.unique", "description": ""}, {"name": "add_opposite.has_vadd", "description": ""}, {"name": "mul_opposite.unop_eq_one_iff", "description": ""}, {"name": "mul_opposite.subsingleton", "description": ""}, {"name": "add_opposite.op_zero", "description": ""}, {"name": "mul_opposite.op_injective", "description": ""}, {"name": "add_opposite.unop_op", "description": ""}, {"name": "add_opposite.op_inv", "description": ""}, {"name": "mul_opposite.op_comp_unop", "description": ""}, {"name": "mul_opposite.unop_eq_zero_iff", "description": ""}, {"name": "add_opposite.unop_eq_zero_iff", "description": ""}, {"name": "mul_opposite.has_add", "description": ""}, {"name": "add_opposite.unop_inv", "description": ""}, {"name": "mul_opposite.unop_bijective", "description": ""}, {"name": "add_opposite.has_involutive_neg", "description": ""}, {"name": "mul_opposite", "description": " Multiplicative opposite of a type. This type inherits all additive structures on `\u03b1` and\nreverses left and right in multiplication."}, {"name": "mul_opposite.unop_comp_op", "description": ""}, {"name": "mul_opposite.unop_inv", "description": ""}, {"name": "mul_opposite.rec", "description": "A recursor for `mul_opposite`. Use as `induction x using mul_opposite.rec`."}, {"name": "add_opposite.inhabited", "description": ""}, {"name": "add_opposite.rec", "description": "A recursor for `add_opposite`. Use as `induction x using add_opposite.rec`."}, {"name": "mul_opposite.op", "description": "The element of `mul_opposite \u03b1` that represents `x : \u03b1`."}, {"name": "mul_opposite.op_equiv_symm_apply", "description": ""}, {"name": "add_opposite.unop_comp_op", "description": ""}, {"name": "add_opposite.op_inj", "description": ""}, {"name": "mul_opposite.inhabited", "description": ""}, {"name": "add_opposite.unop_zero", "description": ""}, {"name": "add_opposite.op_div", "description": ""}, {"name": "mul_opposite.unop_add", "description": ""}, {"name": "mul_opposite.op_eq_zero_iff", "description": ""}, {"name": "mul_opposite.op_sub", "description": ""}, {"name": "mul_opposite.op_unop", "description": ""}, {"name": "mul_opposite.op_neg", "description": ""}, {"name": "mul_opposite.has_smul", "description": ""}, {"name": "mul_opposite.unop_neg", "description": ""}, {"name": "add_opposite.has_one", "description": ""}, {"name": "mul_opposite.nontrivial", "description": ""}, {"name": "add_opposite.unop_mul", "description": ""}, {"name": "add_opposite.has_neg", "description": ""}, {"name": "mul_opposite.has_zero", "description": ""}, {"name": "mul_opposite.op_mul", "description": ""}, {"name": "add_opposite.op_mul", "description": ""}, {"name": "add_opposite.unop_div", "description": ""}, {"name": "add_opposite.nontrivial", "description": ""}, {"name": "mul_opposite.unop", "description": "The element of `\u03b1` represented by `x : \u03b1\u1d50\u1d52\u1d56`."}, {"name": "add_opposite.has_inv", "description": ""}, {"name": "mul_opposite.op_smul", "description": ""}, {"name": "mul_opposite.op_eq_one_iff", "description": ""}, {"name": "mul_opposite.op_inj", "description": ""}, {"name": "mul_opposite.unop_ne_zero_iff", "description": ""}, {"name": "mul_opposite.unop_smul", "description": ""}, {"name": "add_opposite.unop_vadd", "description": ""}, {"name": "add_opposite.op_neg", "description": ""}, {"name": "add_opposite.has_mul", "description": ""}, {"name": "mul_opposite.op_zero", "description": ""}, {"name": "add_opposite.op_one", "description": ""}, {"name": "add_opposite.unop_add", "description": ""}, {"name": "mul_opposite.unop_zero", "description": ""}, {"name": "mul_opposite.has_one", "description": ""}, {"name": "add_opposite", "description": "Additive opposite of a type. This type inherits all multiplicative structures on\n`\u03b1` and reverses left and right in addition."}, {"name": "add_opposite.unop_bijective", "description": ""}, {"name": "add_opposite.unop", "description": "The element of `\u03b1` represented by `x : \u03b1\u1d43\u1d52\u1d56`."}, {"name": "add_opposite.has_involutive_inv", "description": ""}, {"name": "add_opposite.op_unop", "description": ""}, {"name": "mul_opposite.has_neg", "description": ""}, {"name": "add_opposite.op_equiv", "description": "The canonical bijection between `\u03b1` and `\u03b1\u1d43\u1d52\u1d56`."}, {"name": "add_opposite.unop_surjective", "description": ""}, {"name": "mul_opposite.op_ne_zero_iff", "description": ""}, {"name": "add_opposite.op_eq_one_iff", "description": ""}, {"name": "add_opposite.has_zero", "description": ""}, {"name": "add_opposite.op_injective", "description": ""}, {"name": "mul_opposite.unique", "description": ""}, {"name": "mul_opposite.unop_inj", "description": ""}, {"name": "add_opposite.op", "description": "The element of `\u03b1\u1d43\u1d52\u1d56` that represents `x : \u03b1`."}, {"name": "mul_opposite.op_inv", "description": ""}, {"name": "mul_opposite.op_surjective", "description": ""}, {"name": "mul_opposite.has_sub", "description": ""}, {"name": "add_opposite.subsingleton", "description": ""}, {"name": "add_opposite.op_bijective", "description": ""}, {"name": "mul_opposite.has_mul", "description": ""}, {"name": "mul_opposite.op_one", "description": ""}, {"name": "add_opposite.unop_neg", "description": ""}, {"name": "fish", "description": "This is the Kleisli composition"}, {"name": "sum.bind", "description": ""}, {"name": "mjoin_map_map", "description": ""}, {"name": "succeeds", "description": ""}, {"name": "sum.is_lawful_monad", "description": ""}, {"name": "list.mpartition", "description": ""}, {"name": "is_comm_applicative", "description": ""}, {"name": "is_comm_applicative.to_is_lawful_applicative", "description": ""}, {"name": "is_comm_applicative.commutative_prod", "description": ""}, {"name": "mjoin_pure", "description": ""}, {"name": "sum.monad", "description": ""}, {"name": "is_comm_applicative.commutative_map", "description": ""}, {"name": "fish_pipe", "description": ""}, {"name": "list.mmap_accuml", "description": ""}, {"name": "mzip_with'", "description": ""}, {"name": "mjoin_map_pure", "description": ""}, {"name": "mtry", "description": ""}, {"name": "simp_attr.functor_norm", "description": "Simp set for functor_norm"}, {"name": "list.mmap_accumr", "description": ""}, {"name": "map_seq", "description": ""}, {"name": "id_map'", "description": ""}, {"name": "seq_bind_eq", "description": ""}, {"name": "guard_true", "description": ""}, {"name": "sum.is_lawful_functor", "description": ""}, {"name": "mjoin_map_mjoin", "description": ""}, {"name": "seq_map_assoc", "description": ""}, {"name": "pure_id'_seq", "description": ""}, {"name": "fish_assoc", "description": ""}, {"name": "fish_pure", "description": ""}, {"name": "mzip_with", "description": ""}, {"name": "guard_false", "description": ""}, {"name": "map_bind", "description": ""}, {"name": "functor.map_map", "description": ""}, {"name": "seq_eq_bind_map", "description": ""}, {"name": "category_theory.functor.eq_to_hom_proj", "description": ""}, {"name": "category_theory.pi.eval_obj", "description": ""}, {"name": "category_theory.pi.comap_comp", "description": "The natural isomorphism comparing between\npulling back along two successive functions, and\npulling back along their composition"}, {"name": "category_theory.pi.iso_app_symm", "description": ""}, {"name": "category_theory.pi.comap_comp_hom_app", "description": ""}, {"name": "category_theory.pi.comap_eval_iso_eval_inv_app", "description": ""}, {"name": "category_theory.functor.pi'_obj", "description": ""}, {"name": "category_theory.pi.comap_eval_iso_eval", "description": "The natural isomorphism between pulling back then evaluating, and just evaluating."}, {"name": "category_theory.functor.pi'_eval", "description": ""}, {"name": "category_theory.functor.pi", "description": "Assemble an `I`-indexed family of functors into a functor between the pi types."}, {"name": "category_theory.nat_trans.pi_app", "description": ""}, {"name": "category_theory.pi.sum_elim_category", "description": ""}, {"name": "category_theory.pi.iso_app_hom", "description": ""}, {"name": "category_theory.pi.id_apply", "description": ""}, {"name": "category_theory.pi.comap_eval_iso_eval_hom_app", "description": ""}, {"name": "category_theory.functor.pi'_map", "description": ""}, {"name": "category_theory.pi.comap", "description": "Pull back an `I`-indexed family of objects to an `J`-indexed family, along a function `J \u2192 I`."}, {"name": "category_theory.pi.sum_map_app", "description": ""}, {"name": "category_theory.pi.comap_obj", "description": ""}, {"name": "category_theory.pi.comap_id_inv_app", "description": ""}, {"name": "category_theory.pi'", "description": "This provides some assistance to typeclass search in a common situation,\nwhich otherwise fails. (Without this `category_theory.pi.has_limit_of_has_limit_comp_eval` fails.)"}, {"name": "category_theory.nat_trans.pi", "description": "Assemble an `I`-indexed family of natural transformations into a single natural transformation."}, {"name": "category_theory.pi.iso_app_inv", "description": ""}, {"name": "category_theory.pi.comap_id", "description": "The natural isomorphism between\npulling back a grading along the identity function,\nand the identity functor."}, {"name": "category_theory.pi.iso_app", "description": " An isomorphism between `I`-indexed objects gives an isomorphism between each\npair of corresponding components."}, {"name": "category_theory.pi.comp_apply", "description": ""}, {"name": "category_theory.pi.iso_app_trans", "description": ""}, {"name": "category_theory.functor.pi_map", "description": ""}, {"name": "category_theory.pi.comap_map", "description": ""}, {"name": "category_theory.pi.comap_comp_inv_app", "description": ""}, {"name": "category_theory.pi.sum_obj_map", "description": ""}, {"name": "category_theory.pi.eval_map", "description": ""}, {"name": "category_theory.pi.comap_id_hom_app", "description": ""}, {"name": "category_theory.functor.pi'", "description": "Similar to `pi`, but all functors come from the same category `A`"}, {"name": "category_theory.pi.sum", "description": "The bifunctor combining an `I`-indexed family of objects with a `J`-indexed family of objects\nto obtain an `I \u2295 J`-indexed family of objects."}, {"name": "category_theory.pi", "description": "`pi C` gives the cartesian product of an indexed family of categories."}, {"name": "category_theory.pi.sum_obj_obj", "description": ""}, {"name": "category_theory.pi.iso_app_refl", "description": ""}, {"name": "category_theory.pi.eval", "description": "The evaluation functor at `i : I`, sending an `I`-indexed family of objects to the object over `i`."}, {"name": "category_theory.functor.pi_ext", "description": "Two functors to a product category are equal iff they agree on every coordinate."}, {"name": "category_theory.functor.pi_obj", "description": ""}, {"name": "expr.has_var_idx", "description": "`has_var_idx e n` returns true iff `e` has a free variable with de-Bruijn index `n`."}, {"name": "expr.local_pp_name", "description": ""}, {"name": "expr.is_sorry", "description": "Checks whether e is sorry, and returns its type."}, {"name": "expr.is_annotation", "description": " Expressions can be annotated using an annotation macro during compilation.\nFor example, a `have x:X, from p, q` expression will be compiled to `(\u03bb x:X,q)(p)`, but nested in an annotation macro with the name `\"have\"`.\nThese annotations have no real semantic meaning, but are useful for helping Lean's pretty printer."}, {"name": "expr.is_arrow", "description": ""}, {"name": "macro_def", "description": "Macros are basically \"promises\" to build an expr by some C++ code, you can't build them in Lean.\n  You can unfold a macro and force it to evaluate.\n  They are used for\n  - `sorry`.\n  - Term placeholders (`_`) in `pexpr`s.\n  - Expression annotations. See `expr.is_annotation`.\n  - Meta-recursive calls. Eg:\n    ```lean\n    meta def Y : (\u03b1 \u2192 \u03b1) \u2192 \u03b1 | f := f (Y f)\n    ```\n    The `Y` that appears in `f (Y f)` is a macro.\n  - Builtin projections:\n    ```lean\n    structure foo := (mynat : \u2115)\n    #print foo.mynat\n    -- @[reducible]\n    -- def foo.mynat : foo \u2192 \u2115 :=\n    -- \u03bb (c : foo), [foo.mynat c]\n    ```\n    The thing in square brackets is a macro.\n  - Ephemeral structures inside certain specialised C++ implemented tactics."}, {"name": "expr.is_iff", "description": ""}, {"name": "expr.get_app_args_aux", "description": ""}, {"name": "expr.mk_binding", "description": ""}, {"name": "expr.lam_arity", "description": ""}, {"name": "expr.macro_def_name", "description": "Get the name of the macro definition."}, {"name": "expr.has_to_string", "description": ""}, {"name": "expr.has_decidable_eq", "description": "Compares expressions, including binder names."}, {"name": "expr.inhabited", "description": ""}, {"name": "expr.is_napp_of", "description": "The same as `is_app_of` but must also have exactly `n` arguments."}, {"name": "expr_map.mk", "description": ""}, {"name": "expr.is_ne", "description": ""}, {"name": "expr.hash", "description": " Each expression created by Lean carries a hash.\nThis is calculated upon creation of the expression.\nTwo structurally equal expressions will have the same hash."}, {"name": "expr_set", "description": ""}, {"name": "expr.get_depth", "description": "Computes the maximum depth of the expression (constant time)."}, {"name": "expr.local_type", "description": ""}, {"name": "expr.is_ge", "description": ""}, {"name": "expr.binding_domain", "description": "The domain (type of bound variable) of a pi, lambda or let expression."}, {"name": "binder_info", "description": " Auxiliary annotation for binders (Lambda and Pi).\n    This information is only used for elaboration.\n      The difference between `{}` and `\u2983\u2984` is how implicit arguments are treated that are *not* followed by explicit arguments.\n  `{}` arguments are applied eagerly, while `\u2983\u2984` arguments are left partially applied:\n```lean\ndef foo {x : \u2115} : \u2115 := x\ndef bar \u2983x : \u2115\u2984 : \u2115 := x\n#check foo -- foo : \u2115\n#check bar -- bar : \u03a0 \u2983x : \u2115\u2984, \u2115\n```"}, {"name": "binder_info.default", "description": " Auxiliary annotation for binders (Lambda and Pi).\n    This information is only used for elaboration.\n      The difference between `{}` and `\u2983\u2984` is how implicit arguments are treated that are *not* followed by explicit arguments.\n  `{}` arguments are applied eagerly, while `\u2983\u2984` arguments are left partially applied:\n```lean\ndef foo {x : \u2115} : \u2115 := x\ndef bar \u2983x : \u2115\u2984 : \u2115 := x\n#check foo -- foo : \u2115\n#check bar -- bar : \u03a0 \u2983x : \u2115\u2984, \u2115\n```"}, {"name": "binder_info.implicit", "description": " Auxiliary annotation for binders (Lambda and Pi).\n    This information is only used for elaboration.\n      The difference between `{}` and `\u2983\u2984` is how implicit arguments are treated that are *not* followed by explicit arguments.\n  `{}` arguments are applied eagerly, while `\u2983\u2984` arguments are left partially applied:\n```lean\ndef foo {x : \u2115} : \u2115 := x\ndef bar \u2983x : \u2115\u2984 : \u2115 := x\n#check foo -- foo : \u2115\n#check bar -- bar : \u03a0 \u2983x : \u2115\u2984, \u2115\n```"}, {"name": "binder_info.strict_implicit", "description": " Auxiliary annotation for binders (Lambda and Pi).\n    This information is only used for elaboration.\n      The difference between `{}` and `\u2983\u2984` is how implicit arguments are treated that are *not* followed by explicit arguments.\n  `{}` arguments are applied eagerly, while `\u2983\u2984` arguments are left partially applied:\n```lean\ndef foo {x : \u2115} : \u2115 := x\ndef bar \u2983x : \u2115\u2984 : \u2115 := x\n#check foo -- foo : \u2115\n#check bar -- bar : \u03a0 \u2983x : \u2115\u2984, \u2115\n```"}, {"name": "binder_info.inst_implicit", "description": " Auxiliary annotation for binders (Lambda and Pi).\n    This information is only used for elaboration.\n      The difference between `{}` and `\u2983\u2984` is how implicit arguments are treated that are *not* followed by explicit arguments.\n  `{}` arguments are applied eagerly, while `\u2983\u2984` arguments are left partially applied:\n```lean\ndef foo {x : \u2115} : \u2115 := x\ndef bar \u2983x : \u2115\u2984 : \u2115 := x\n#check foo -- foo : \u2115\n#check bar -- bar : \u03a0 \u2983x : \u2115\u2984, \u2115\n```"}, {"name": "binder_info.aux_decl", "description": " Auxiliary annotation for binders (Lambda and Pi).\n    This information is only used for elaboration.\n      The difference between `{}` and `\u2983\u2984` is how implicit arguments are treated that are *not* followed by explicit arguments.\n  `{}` arguments are applied eagerly, while `\u2983\u2984` arguments are left partially applied:\n```lean\ndef foo {x : \u2115} : \u2115 := x\ndef bar \u2983x : \u2115\u2984 : \u2115 := x\n#check foo -- foo : \u2115\n#check bar -- bar : \u03a0 \u2983x : \u2115\u2984, \u2115\n```"}, {"name": "expr.binding_body", "description": "The body of a pi, lambda or let expression.\n This definition doesn't instantiate bound variables, and therefore produces a term that is open.\n See note [open expressions] in mathlib."}, {"name": "expr.subst", "description": " Perform beta-reduction if the left expression is a lambda, or construct an application otherwise.\nThat is: ``expr.subst `(\u03bb x, %%Y) Z = Y[x/Z]``, and\n``expr.subst X Z = X.app Z`` otherwise"}, {"name": "expr.binding_name", "description": "The name of the bound variable in a pi, lambda or let expression."}, {"name": "expr.instantiate_locals", "description": ""}, {"name": "expr.is_heq", "description": ""}, {"name": "expr.has_local_in", "description": "Returns true if any of the names in the given `name_set` are present in the given `expr`."}, {"name": "expr.occurs", "description": "`occurs e t` returns `tt` iff `e` occurs in `t` up to \u03b1-equivalence. Purely structural: no unification or definitional equality."}, {"name": "expr.instantiate_var", "description": "`instantiate_var a b` takes the 0th de-Bruijn variable in `a` and replaces each occurrence with `b`."}, {"name": "expr.lt_prop", "description": ""}, {"name": "expr.imp", "description": ""}, {"name": "expr.get_app_fn", "description": ""}, {"name": "expr.extract_opt_auto_param", "description": ""}, {"name": "expr.lambdas", "description": "`lambdas cs e` lambda binds `e` with each of the local constants in `cs`."}, {"name": "expr.replace", "description": "`expr.replace e f`\nTraverse over an expr `e` with a function `f` which can decide to replace subexpressions or not.\nFor each subexpression `s` in the expression tree, `f s n` is called where `n` is how many binders are present above the given subexpression `s`.\nIf `f s n` returns `none`, the children of `s` will be traversed.\nOtherwise if `some s'` is returned, `s'` will replace `s` and this subexpression will not be traversed further."}, {"name": "expr.has_meta_var", "description": "`has_meta_var e` returns true iff `e` contains a metavariable."}, {"name": "expr.is_constant_of", "description": ""}, {"name": "mk_expr_set", "description": ""}, {"name": "expr.is_eq", "description": ""}, {"name": "expr.has_to_format", "description": ""}, {"name": "expr.const_name", "description": ""}, {"name": "reflected.has_to_format", "description": ""}, {"name": "string.reflect", "description": ""}, {"name": "expr.mk_delayed_abstraction", "description": "`mk_delayed_abstraction m ls` creates a delayed abstraction on the metavariable `m` with the unique names of the local constants `ls`.\n   If `m` is not a metavariable then this is equivalent to `abstract_locals`."}, {"name": "expr.to_string", "description": ""}, {"name": "pos.decidable_eq", "description": ""}, {"name": "expr.is_gt", "description": ""}, {"name": "expr.is_false", "description": ""}, {"name": "expr.is_pi", "description": ""}, {"name": "expr.mk_sorry", "description": "Returns the sorry macro with the given type."}, {"name": "expr.lower_vars", "description": "`lower_vars e s d` lowers the free variables >= s in `e` by `d`. Note that this can cause variable clashes.\n   examples:\n   -  ``lower_vars `(#2 #1 #0) 1 1 = `(#1 #0 #0)``\n   -  ``lower_vars `(\u03bb x, #2 #1 #0) 1 1 = `(\u03bb x, #1 #1 #0 )``"}, {"name": "expr.pos", "description": "Get the position of the given expression in the Lean source file, if anywhere."}, {"name": "expr.erase_annotations", "description": "Remove all macro annotations from the given `expr`."}, {"name": "expr.is_lambda", "description": ""}, {"name": "expr.mk_app", "description": ""}, {"name": "expr.instantiate_univ_params", "description": " Expressions depend on `level`s, and these may depend on universe parameters which have names.\n`instantiate_univ_params e [(n\u2081,l\u2081), ...]` will traverse `e` and replace any universe parameters with name `n\u1d62` with the corresponding level `l\u1d62`."}, {"name": "expr.mk_true", "description": ""}, {"name": "expr.mk_var", "description": ""}, {"name": "expr.is_var", "description": ""}, {"name": "expr.lift_vars", "description": "Lifts free variables. `lift_vars e s d` will lift all free variables with index `\u2265 s` in `e` by `d`."}, {"name": "expr.is_or", "description": ""}, {"name": "reflected", "description": "(reflected a) is a special opaque container for a closed `expr` representing `a`.\n   It can only be obtained via type class inference, which will use the representation\n   of `a` in the calling context. Local constants in the representation are replaced\n   by nested inference of `reflected` instances.\n\n   The quotation expression `` `(a) `` (outside of patterns) is equivalent to `reflect a`\n   and thus can be used as an explicit way of inferring an instance of `reflected a`.\n   \n   Note that the `\u03b1` argument is explicit to prevent it being treated as reducible by typeclass\n   inference, as this breaks `reflected` instances on type synonyms."}, {"name": "expr.copy_pos_info", "description": "`copy_pos_info src tgt` copies position information from `src` to `tgt`."}, {"name": "expr.mfold", "description": " Fold an accumulator `a` over each subexpression in the expression `e`.\nThe `nat` passed to `fn` is the number of binders above the subexpression."}, {"name": "expr.reflect", "description": ""}, {"name": "expr.pi_arity", "description": ""}, {"name": "expr.app_fn", "description": ""}, {"name": "expr.is_le", "description": ""}, {"name": "expr.is_let", "description": ""}, {"name": "binder_info.has_repr", "description": ""}, {"name": "expr.has_coe", "description": ""}, {"name": "expr.app_of_list", "description": ""}, {"name": "expr.get_app_args", "description": ""}, {"name": "expr.is_bin_arith_app", "description": ""}, {"name": "expr.get_weight", "description": "Computes the number of sub-expressions (constant time)."}, {"name": "expr.abstract_local", "description": "`abstract_local e n` replaces each instance of the local constant with unique (not pretty) name `n` in `e` with a de-Bruijn variable."}, {"name": "expr.is_numeral", "description": ""}, {"name": "expr.is_string_macro", "description": ""}, {"name": "expr.mk_false", "description": ""}, {"name": "expr.is_aux_decl", "description": ""}, {"name": "expr.has_var", "description": "`has_var e` returns true iff e has free variables."}, {"name": "expr.alpha_eqv", "description": "Compares expressions while ignoring binder names."}, {"name": "expr.is_local_constant", "description": ""}, {"name": "expr.lt_prop.decidable_rel", "description": ""}, {"name": "expr.app_arg", "description": ""}, {"name": "reflected.subst", "description": " This is a more strongly-typed version of `expr.subst` that keeps track of the value being\nreflected. To obtain a term of type `reflected _`, use `` (`(\u03bb x y, foo x y).subst ex).subst ey`` instead of\nusing `` `(foo %%ex %%ey) `` (which returns an `expr`)."}, {"name": "expr.has_lt", "description": "Compares expressions, ignoring binder names, and sorting by hash."}, {"name": "expr.is_app", "description": ""}, {"name": "expr.instantiate_vars_core", "description": " Same as `instantiate_vars` except lifts and shifts the vars by the given amount.\n``instantiate_vars_core `(#0 #1 #2 #3) 0 [x,y] = `(x y #0 #1)``\n``instantiate_vars_core `(#0 #1 #2 #3) 1 [x,y] = `(#0 x y #1)``\n``instantiate_vars_core `(#0 #1 #2 #3) 2 [x,y] = `(#0 #1 x y)``"}, {"name": "expr.pis", "description": "Same as `expr.lambdas` but with `pi`."}, {"name": "expr.bind_lambda", "description": "(bind_lambda e l) abstracts and lambda-binds the local `l` in `e`"}, {"name": "expr.to_raw_fmt", "description": ""}, {"name": "expr.has_coe_to_fun", "description": "Coercion for letting users write (f a) instead of (expr.app f a)"}, {"name": "pos", "description": "Column and line position in a Lean source file."}, {"name": "pos.line", "description": "Column and line position in a Lean source file."}, {"name": "pos.column", "description": "Column and line position in a Lean source file."}, {"name": "expr.is_constant", "description": ""}, {"name": "expr.is_not", "description": ""}, {"name": "expr.ith_arg", "description": ""}, {"name": "expr.get_nat_value", "description": " There is a macro called a \"nat_value_macro\" holding a natural number which are used during compilation.\nThis function extracts that to a natural number. [NOTE] This is not used anywhere in Lean."}, {"name": "expr.instantiate_local", "description": "Replace each instance of the local constant with name `n` by the expression `s` in `e`."}, {"name": "reflect", "description": ""}, {"name": "expr.ith_arg_aux", "description": ""}, {"name": "expr.fold", "description": "`expr.fold e a f`: Traverses each subexpression of `e`. The `nat` passed to the folder `f` is the binder depth."}, {"name": "expr.abstract_locals", "description": "Multi version of `abstract_local`. Note that the given expression will only be traversed once, so this is not the same as `list.foldl expr.abstract_local`."}, {"name": "expr.get_delayed_abstraction_locals", "description": " If the given expression is a delayed abstraction macro, return `some ls`\nwhere `ls` is a list of unique names of locals that will be abstracted."}, {"name": "expr.is_app_of", "description": ""}, {"name": "expr.instantiate_vars", "description": "``instantiate_vars `(#0 #1 #2) [x,y,z] = `(%%x %%y %%z)``"}, {"name": "expr.is_macro", "description": ""}, {"name": "expr_map", "description": "An dictionary from `data` to expressions."}, {"name": "expr.instantiate_nth_var", "description": "`instantiate_nth_var n a b` takes the `n`th de-Bruijn variable in `a` and replaces each occurrence with `b`."}, {"name": "expr.is_internal_cnstr", "description": " Returns `some n` when the given expression is a constant with the name `..._cnstr.n`\n```lean\nis_internal_cnstr : expr \u2192 option unsigned\n|(const (mk_numeral n (mk_string \"_cnstr\" _)) _) := some n\n|_ := none\n```\n[NOTE] This is not used anywhere in core Lean."}, {"name": "expr.lt", "description": "Compares expressions, ignoring binder names, and sorting by hash."}, {"name": "expr.get_free_var_range", "description": "`get_free_var_range e` returns one plus the maximum de-Bruijn value in `e`. Eg `get_free_var_range `(#1 #0)` yields `2`"}, {"name": "expr.binding_info", "description": "The binder info of a pi or lambda expression."}, {"name": "expr.abstract", "description": "`abstract e x` Abstracts the expression `e` over the local constant `x`."}, {"name": "expr.has_local", "description": "`has_local e` returns true if `e` contains a local constant."}, {"name": "pos.has_to_format", "description": ""}, {"name": "expr.bind_pi", "description": "(bind_pi e l) abstracts and pi-binds the local `l` in `e`"}, {"name": "mk_expr_map", "description": ""}, {"name": "expr.is_lt", "description": ""}, {"name": "expr.is_and", "description": ""}, {"name": "expr", "description": "An expression. eg ```(4+5)```.\n\n   The `elab` flag is indicates whether the `expr` has been elaborated and doesn't contain any placeholder macros.\n   For example the equality `x = x` is represented in `expr ff` as ``app (app (const `eq _) x) x`` while in `expr tt` it is represented as ``app (app (app (const `eq _) t) x) x`` (one more argument).\n   The VM replaces instances of this datatype with the C++ implementation."}, {"name": "expr.var", "description": "An expression. eg ```(4+5)```.\n\n   The `elab` flag is indicates whether the `expr` has been elaborated and doesn't contain any placeholder macros.\n   For example the equality `x = x` is represented in `expr ff` as ``app (app (const `eq _) x) x`` while in `expr tt` it is represented as ``app (app (app (const `eq _) t) x) x`` (one more argument).\n   The VM replaces instances of this datatype with the C++ implementation."}, {"name": "expr.sort", "description": "An expression. eg ```(4+5)```.\n\n   The `elab` flag is indicates whether the `expr` has been elaborated and doesn't contain any placeholder macros.\n   For example the equality `x = x` is represented in `expr ff` as ``app (app (const `eq _) x) x`` while in `expr tt` it is represented as ``app (app (app (const `eq _) t) x) x`` (one more argument).\n   The VM replaces instances of this datatype with the C++ implementation."}, {"name": "expr.const", "description": "An expression. eg ```(4+5)```.\n\n   The `elab` flag is indicates whether the `expr` has been elaborated and doesn't contain any placeholder macros.\n   For example the equality `x = x` is represented in `expr ff` as ``app (app (const `eq _) x) x`` while in `expr tt` it is represented as ``app (app (app (const `eq _) t) x) x`` (one more argument).\n   The VM replaces instances of this datatype with the C++ implementation."}, {"name": "expr.mvar", "description": "An expression. eg ```(4+5)```.\n\n   The `elab` flag is indicates whether the `expr` has been elaborated and doesn't contain any placeholder macros.\n   For example the equality `x = x` is represented in `expr ff` as ``app (app (const `eq _) x) x`` while in `expr tt` it is represented as ``app (app (app (const `eq _) t) x) x`` (one more argument).\n   The VM replaces instances of this datatype with the C++ implementation."}, {"name": "expr.local_const", "description": "An expression. eg ```(4+5)```.\n\n   The `elab` flag is indicates whether the `expr` has been elaborated and doesn't contain any placeholder macros.\n   For example the equality `x = x` is represented in `expr ff` as ``app (app (const `eq _) x) x`` while in `expr tt` it is represented as ``app (app (app (const `eq _) t) x) x`` (one more argument).\n   The VM replaces instances of this datatype with the C++ implementation."}, {"name": "expr.app", "description": "An expression. eg ```(4+5)```.\n\n   The `elab` flag is indicates whether the `expr` has been elaborated and doesn't contain any placeholder macros.\n   For example the equality `x = x` is represented in `expr ff` as ``app (app (const `eq _) x) x`` while in `expr tt` it is represented as ``app (app (app (const `eq _) t) x) x`` (one more argument).\n   The VM replaces instances of this datatype with the C++ implementation."}, {"name": "expr.lam", "description": "An expression. eg ```(4+5)```.\n\n   The `elab` flag is indicates whether the `expr` has been elaborated and doesn't contain any placeholder macros.\n   For example the equality `x = x` is represented in `expr ff` as ``app (app (const `eq _) x) x`` while in `expr tt` it is represented as ``app (app (app (const `eq _) t) x) x`` (one more argument).\n   The VM replaces instances of this datatype with the C++ implementation."}, {"name": "expr.pi", "description": "An expression. eg ```(4+5)```.\n\n   The `elab` flag is indicates whether the `expr` has been elaborated and doesn't contain any placeholder macros.\n   For example the equality `x = x` is represented in `expr ff` as ``app (app (const `eq _) x) x`` while in `expr tt` it is represented as ``app (app (app (const `eq _) t) x) x`` (one more argument).\n   The VM replaces instances of this datatype with the C++ implementation."}, {"name": "expr.elet", "description": "An expression. eg ```(4+5)```.\n\n   The `elab` flag is indicates whether the `expr` has been elaborated and doesn't contain any placeholder macros.\n   For example the equality `x = x` is represented in `expr ff` as ``app (app (const `eq _) x) x`` while in `expr tt` it is represented as ``app (app (app (const `eq _) t) x) x`` (one more argument).\n   The VM replaces instances of this datatype with the C++ implementation."}, {"name": "expr.macro", "description": "An expression. eg ```(4+5)```.\n\n   The `elab` flag is indicates whether the `expr` has been elaborated and doesn't contain any placeholder macros.\n   For example the equality `x = x` is represented in `expr ff` as ``app (app (const `eq _) x) x`` while in `expr tt` it is represented as ``app (app (app (const `eq _) t) x) x`` (one more argument).\n   The VM replaces instances of this datatype with the C++ implementation."}, {"name": "expr.nth_binding_body", "description": "`nth_binding_body n e` iterates `binding_body` `n` times to an iterated pi expression `e`.\n This definition doesn't instantiate bound variables, and therefore produces a term that is open.\n See note [open expressions] in mathlib."}, {"name": "expr.lex_lt", "description": "Compares expressions, ignoring binder names."}, {"name": "reflected.to_expr", "description": ""}, {"name": "expr.local_uniq_name", "description": ""}, {"name": "expr.get_app_num_args", "description": ""}, {"name": "expr.collect_univ_params", "description": "Get a list of all of the universe parameters that the given expression depends on."}, {"name": "tactic_doc.tactic.skip", "description": "A do-nothing tactic that always succeeds."}, {"name": "tactic_doc.tactic.refl / reflexivity", "description": "This tactic applies to a goal whose target has the form `t ~ u` where `~` is a reflexive relation,\nthat is, a relation which has a reflexivity lemma tagged with the attribute `[refl]`.\nThe tactic checks whether `t` and `u` are definitionally equal and then solves the goal."}, {"name": "tactic_doc.tactic.cases_type", "description": "* `cases_type I` applies the `cases` tactic to a hypothesis `h : (I ...)`\n* `cases_type I_1 ... I_n` applies the `cases` tactic to a hypothesis\n  `h : (I_1 ...)` or ... or `h : (I_n ...)`\n* `cases_type* I` is shorthand for `focus1 { repeat { cases_type I } }`\n* `cases_type! I` only applies `cases` if the number of resulting subgoals is <= 1.\n\nExample: The following tactic destructs all conjunctions and disjunctions in the current context.\n```lean\ncases_type* or and\n```"}, {"name": "tactic_doc.tactic.unfold_projs", "description": "This tactic unfolds all structure projections."}, {"name": "tactic_doc.tactic.conv: for", "description": "Navigate into the numbered scopes matching the expression.\n\nFor a target of `| \u03bb c, 10 * c + 20 * c + 30 * c`, `for (_ * _) [1, 3] { ... }` will run the\ntactics within the `{}` with first a target of `| 10 * c`, then a target of `| 30 * c`."}, {"name": "tactic_doc.tactic.injections", "description": "`injections with h\u2081 ... h\u2099` iteratively applies `injection` to hypotheses using the names `h\u2081 ... h\u2099`."}, {"name": "tactic_doc.tactic.match_target", "description": "`match_target t` fails if target does not match pattern `t`."}, {"name": "tactic_doc.tactic.conv: to_rhs", "description": "Navigate to the right-hand-side of a relation.\nA goal of `| a = b` will turn into the goal `| b`."}, {"name": "tactic_doc.tactic.sorry / admit", "description": "Closes the main goal using `sorry`. Takes an optional ignored tactic block.\n\nThe ignored tactic block is useful for \"commenting out\" part of a proof during development:\n```lean\nbegin\n  split,\n  sorry { expensive_tactic },\n\nend\n```"}, {"name": "tactic_doc.tactic.eapply", "description": "Similar to the `apply` tactic, but only creates subgoals for non-dependent premises that have not been fixed by type inference or type class resolution."}, {"name": "tactic_doc.tactic.clear", "description": "`clear h\u2081 ... h\u2099` tries to clear each hypothesis `h\u1d62` from the local context."}, {"name": "tactic_doc.tactic.any_goals", "description": "`any_goals { t }` applies the tactic `t` to every goal, and succeeds if at least one application succeeds."}, {"name": "tactic_doc.tactic.transitivity", "description": "This tactic applies to a goal whose target has the form `t ~ u` where `~` is a transitive relation, that is, a relation which has a transitivity lemma tagged with the attribute `[trans]`.\n\n`transitivity s` replaces the goal with the two subgoals `t ~ s` and `s ~ u`. If `s` is omitted, then a metavariable is used instead."}, {"name": "tactic_doc.tactic.unfold", "description": "Given defined constants `e\u2081 ... e\u2099`, `unfold e\u2081 ... e\u2099` iteratively unfolds all occurrences in the target of the main goal, using equational lemmas associated with the definitions.\n\nAs with `simp`, the `at` modifier can be used to specify locations for the unfolding."}, {"name": "tactic_doc.tactic.case", "description": "Focuses on a goal ('case') generated by `induction`, `cases` or `with_cases`.\n\nThe goal is selected by giving one or more names which must match exactly one\ngoal. A goal is matched if the given names are a suffix of its goal tag.\nAdditionally, each name in the sequence can be abbreviated to a suffix of the\ncorresponding name in the goal tag. Thus, a goal with tag\n```lean\nnat.zero, list.nil\n```\ncan be selected with any of these invocations (among others):\n```lean\ncase nat.zero list.nil {...}\ncase nat.zero nil      {...}\ncase zero     nil      {...}\ncase          nil      {...}\n```\n\nAdditionally, the form\n```lean\ncase C : N\u2080 ... N\u2099 {...}\n```\ncan be used to rename hypotheses introduced by the preceding\n`cases`/`induction`/`with_cases`, using the names `N\u1d62`. For example:\n```lean\nexample (xs : list \u2115) : xs = xs :=\nbegin\n  induction xs,\n  case nil { reflexivity },\n  case cons : x xs ih {\n    -- x : \u2115, xs : list \u2115, ih : xs = xs\n    reflexivity }\nend\n```\n\nNote that this renaming functionality only work reliably *directly after* an\n`induction`/`cases`/`with_cases`. If you need to perform additional work after\nan `induction` or `cases` (e.g. introduce hypotheses in all goals), use\n`with_cases`.\n\nMultiple cases can be handled by the same tactic block with\n```lean\ncase [A : N\u2080 ... N\u2099, B : M\u2080 ... M\u2099] {...}\n```"}, {"name": "tactic_doc.tactic.iterate", "description": "`iterate { t }` repeatedly applies tactic `t` until `t` fails. `iterate { t }` always succeeds.\n\n`iterate n { t }` applies `t` `n` times."}, {"name": "tactic_doc.tactic.guard_target", "description": "`guard_target t` fails if the target of the main goal is not `t`.\nWe use this tactic for writing tests."}, {"name": "tactic_doc.tactic.rwa", "description": "`rewrite` followed by `assumption`."}, {"name": "tactic_doc.tactic.assumption", "description": "This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails."}, {"name": "tactic_doc.tactic.apply_auto_param", "description": "If the target of the main goal is an `auto_param`, executes the associated tactic."}, {"name": "tactic_doc.tactic.congr", "description": "The `congr` tactic attempts to identify both sides of an equality goal `A = B`,\nleaving as new goals the subterms of `A` and `B` which are not definitionally equal.\nExample: suppose the goal is `x * f y = g w * f z`. Then `congr` will produce two goals:\n`x = g w` and `y = z`.\n\nIf `x y : t`, and an instance `subsingleton t` is in scope, then any goals of the form\n`x = y` are solved automatically.\n\nNote that `congr` can be over-aggressive at times; the `congr'` tactic in mathlib\nprovides a more refined approach, by taking a parameter that limits the recursion depth."}, {"name": "tactic_doc.tactic.split", "description": "Applies the constructor when the type of the target is an inductive data type with one constructor."}, {"name": "tactic_doc.tactic.mapply", "description": "Similar to the `apply` tactic, but uses matching instead of unification.\n`apply_match t` is equivalent to `apply_with t {unify := ff}`"}, {"name": "tactic_doc.tactic.fapply", "description": "Similar to the `apply` tactic, but does not reorder goals."}, {"name": "tactic_doc.tactic.suffices", "description": "`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`."}, {"name": "tactic_doc.tactic.injection", "description": "The `injection` tactic is based on the fact that constructors of inductive data types are injections. That means that if `c` is a constructor of an inductive datatype, and if `(c t\u2081)` and `(c t\u2082)` are two terms that are equal then  `t\u2081` and `t\u2082` are equal too.\n\nIf `q` is a proof of a statement of conclusion `t\u2081 = t\u2082`, then injection applies injectivity to derive the equality of all arguments of `t\u2081` and `t\u2082` placed in the same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`. To use this tactic `t\u2081` and `t\u2082` should be constructor applications of the same constructor.\n\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types `a = c` and `b = d` to the main goal. The tactic `injection h with h\u2081 h\u2082` uses the names `h\u2081` and `h\u2082` to name the new hypotheses."}, {"name": "tactic_doc.tactic.apply_instance", "description": "This tactic tries to close the main goal `... \u22a2 t` by generating a term of type `t` using type class resolution."}, {"name": "tactic_doc.tactic.specialize", "description": "The tactic `specialize h a\u2081 ... a\u2099` works on local hypothesis `h`. The premises of this hypothesis, either universal quantifications or non-dependent implications, are instantiated by concrete terms coming either from arguments `a\u2081` ... `a\u2099`. The tactic adds a new hypothesis with the same name `h := h a\u2081 ... a\u2099` and tries to clear the previous one."}, {"name": "tactic_doc.tactic.trace_state", "description": "This tactic displays the current state in the tracing buffer."}, {"name": "tactic_doc.tactic.change", "description": "`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.\n\n`change u at h` will change a local hypothesis to `u`.\n\n`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal."}, {"name": "tactic_doc.tactic.trivial", "description": "Tries to solve the current goal using a canonical proof of `true`, or the `reflexivity` tactic, or the `contradiction` tactic."}, {"name": "tactic_doc.tactic.destruct", "description": "Assuming `x` is a variable in the local context with an inductive type, `destruct x` splits the main goal, producing one goal for each constructor of the inductive type, in which `x` is assumed to be a general instance of that constructor. In contrast to `cases`, the local context is unchanged, i.e. no elements are reverted or introduced.\n\nFor example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `destruct n` produces one goal with target `n = 0 \u2192 Q n`, and one goal with target `\u2200 (a : \u2115), (\u03bb (w : \u2115), n = w \u2192 Q n) (nat.succ a)`. Here the name `a` is chosen automatically."}, {"name": "tactic_doc.tactic.let", "description": "`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`.\nIf `t` is omitted, it will be inferred.\n\n`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`.\nThe new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh\nmetavariable.\n\nIf `h` is omitted, the name `this` is used.\n\nNote the related mathlib tactic `set a := t with h`, which adds the hypothesis `h : a = t` to\nthe local context and replaces `t` with `a` everywhere it can."}, {"name": "tactic_doc.tactic.fail_if_success", "description": "Fails if the given tactic succeeds."}, {"name": "tactic_doc.tactic.induction", "description": "Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor and an inductive hypothesis is added for each recursive argument to the constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (nat.succ a)` and `ih\u2081 : P a \u2192 Q a` and target `Q (nat.succ a)`. Here the names `a` and `ih\u2081` ire chosen automatically.\n\n`induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n\n`induction e with y\u2081 ... y\u2099`, where `e` is a variable or an expression, specifies that the sequence of names `y\u2081 ... y\u2099` should be used for the arguments to the constructors and inductive hypotheses, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically. Note that for long sequences of names, the `case` tactic provides a more convenient naming mechanism.\n\n`induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n\n`induction e generalizing z\u2081 ... z\u2099`, where `z\u2081 ... z\u2099` are variables in the local context, generalizes over `z\u2081 ... z\u2099` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n\n`induction h : t` will introduce an equality of the form `h : t = C x y`, asserting that the input term is equal to the current constructor case, to the context."}, {"name": "tactic_doc.tactic.simp_intros", "description": "`simp_intros h\u2081 h\u2082 ... h\u2099` is similar to `intros h\u2081 h\u2082 ... h\u2099` except that each hypothesis is simplified as it is introduced, and each introduced hypothesis is used to simplify later ones and the final target.\n\nAs with `simp`, a list of simplification lemmas can be provided. The modifiers `only` and `with` behave as with `simp`."}, {"name": "tactic_doc.tactic.abstract", "description": "`abstract id { t }` tries to use tactic `t` to solve the main goal. If it succeeds, it abstracts the goal as an independent definition or theorem with name `id`. If `id` is omitted, a name is generated automatically."}, {"name": "tactic_doc.tactic.existsi", "description": "`existsi e` will instantiate an existential quantifier in the target with `e` and leave the\ninstantiated body as the new target. More generally, it applies to any inductive type with one\nconstructor and at least two arguments, applying the constructor with `e` as the first argument\nand leaving the remaining arguments as goals.\n\n`existsi [e\u2081, ..., e\u2099]` iteratively does the same for each expression in the list.\n\nNote: in mathlib, the `use` tactic is an equivalent tactic which sometimes is smarter with\nunification."}, {"name": "tactic_doc.tactic.revert", "description": "`revert h\u2081 ... h\u2099` applies to any goal with hypotheses `h\u2081` ... `h\u2099`. It moves the hypotheses and their dependencies to the target of the goal. This tactic is the inverse of `intro`."}, {"name": "tactic_doc.tactic.comp_val", "description": "Close goals of the form `n \u2260 m` when `n` and `m` have type `nat`, `char`, `string`, `int`\nor `fin sz`, and they are literals. It also closes goals of the form `n < m`, `n > m`, `n \u2264 m` and\n`n \u2265 m` for `nat`. If the goal is of the form `n = m`, then it tries to close it using reflexivity.\n\nIn mathlib, consider using `norm_num` instead for numeric types."}, {"name": "tactic_doc.tactic.exact", "description": "This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified."}, {"name": "tactic_doc.tactic.exacts", "description": "Like `exact`, but takes a list of terms and checks that all goals are discharged after the tactic."}, {"name": "tactic_doc.tactic.exfalso", "description": "Replaces the target of the main goal by `false`."}, {"name": "tactic_doc.tactic.show", "description": "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`."}, {"name": "tactic_doc.tactic.by_cases", "description": "`by_cases p` splits the main goal into two cases, assuming `h : p` in the first branch, and\n`h : \u00ac p` in the second branch. You can specify the name of the new hypothesis using the syntax\n`by_cases h : p`.\n\nIf `p` is not already decidable, `by_cases` will use the instance `classical.prop_decidable p`."}, {"name": "tactic_doc.tactic.focus", "description": "`focus { t }` temporarily hides all goals other than the first, applies `t`, and then restores the other goals. It fails if there are no goals."}, {"name": "tactic_doc.tactic.erewrite / erw", "description": "A variant of `rw` that uses the unifier more aggressively, unfolding semireducible definitions."}, {"name": "tactic_doc.tactic.success_if_fail", "description": "Succeeds if the given tactic fails."}, {"name": "tactic_doc.tactic.dsimp", "description": "`dsimp` is similar to `simp`, except that it only uses definitional equalities."}, {"name": "tactic_doc.tactic.apply", "description": "The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types."}, {"name": "tactic_doc.tactic.solve1", "description": "`solve1 { t }` applies the tactic `t` to the main goal and fails if it is not solved."}, {"name": "tactic_doc.tactic.introv", "description": "The tactic `introv` allows the user to automatically introduce the variables of a theorem and explicitly name the hypotheses involved. The given names are used to name non-dependent hypotheses.\n\nExamples:\n```lean\nexample : \u2200 a b : nat, a = b \u2192 b = a :=\nbegin\n  introv h,\n  exact h.symm\nend\n```\nThe state after `introv h` is\n```lean\na b : \u2115,\nh : a = b\n\u22a2 b = a\n```\n\n```lean\nexample : \u2200 a b : nat, a = b \u2192 \u2200 c, b = c \u2192 a = c :=\nbegin\n  introv h\u2081 h\u2082,\n  exact h\u2081.trans h\u2082\nend\n```\nThe state after `introv h\u2081 h\u2082` is\n```lean\na b : \u2115,\nh\u2081 : a = b,\nc : \u2115,\nh\u2082 : b = c\n\u22a2 a = c\n```"}, {"name": "tactic_doc.tactic.repeat", "description": "`repeat { t }` applies `t` to each goal. If the application succeeds,\nthe tactic is applied recursively to all the generated subgoals until it eventually fails.\nThe recursion stops in a subgoal when the tactic has failed to make progress.\nThe tactic `repeat { t }` never fails."}, {"name": "tactic_doc.tactic.assume", "description": "Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.\n\n`assume (h\u2081 : t\u2081) ... (h\u2099 : t\u2099)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present."}, {"name": "tactic_doc.tactic.conv: congr", "description": "Navigate into every argument of the current head function.\nA target of `| (a * b) * c` will turn into the two targets `| a * b` and `| c`."}, {"name": "tactic_doc.tactic.with_cases", "description": "Apply `t` to the main goal and revert any new hypothesis in the generated goals.\nIf `t` is a supported tactic or chain of supported tactics (e.g. `induction`,\n`cases`, `apply`, `constructor`), the generated goals are also tagged with case\ntags. You can then use `case` to focus such tagged goals.\n\nTwo typical uses of `with_cases`:\n\n1. Applying a custom eliminator:\n\n   ```lean\n   lemma my_nat_rec :\n     \u2200 n {P : \u2115 \u2192 Prop} (zero : P 0) (succ : \u2200 n, P n \u2192 P (n + 1)), P n := ...\n\n   example (n : \u2115) : n = n :=\n   begin\n     with_cases { apply my_nat_rec n },\n     case zero { refl },\n     case succ : m ih { refl }\n   end\n   ```\n\n2. Enabling the use of `case` after a chain of case-splitting tactics:\n\n   ```lean\n   example (n m : \u2115) : unit :=\n   begin\n     with_cases { cases n; induction m },\n     case nat.zero nat.zero { exact () },\n     case nat.zero nat.succ : k { exact () },\n     case nat.succ nat.zero : i { exact () },\n     case nat.succ nat.succ : k i ih_i { exact () }\n   end\n   ```"}, {"name": "tactic_doc.tactic.done", "description": "Fail if there are unsolved goals."}, {"name": "tactic_doc.tactic.by_contra / by_contradiction", "description": "If the target of the main goal is a proposition `p`, `by_contra h` reduces the goal to proving\n`false` using the additional hypothesis `h : \u00ac p`. If `h` is omitted, a name is generated\nautomatically.\n\nThis tactic requires that `p` is decidable. To ensure that all propositions are decidable via\nclassical reasoning, use `open_locale classical`\n(or `local attribute [instance, priority 10] classical.prop_decidable` if you are not using\nmathlib)."}, {"name": "tactic_doc.tactic.try", "description": "`try { t }` tries to apply tactic `t`, but succeeds whether or not `t` succeeds."}, {"name": "tactic_doc.tactic.delta", "description": "Similar to `dunfold`, but performs a raw delta reduction, rather than using an equation associated with the defined constants."}, {"name": "tactic_doc.tactic.subst", "description": "Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`."}, {"name": "tactic_doc.tactic.symmetry", "description": "This tactic applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation, that is, a relation which has a symmetry lemma tagged with the attribute `[symm]`. It replaces the target with `u ~ t`."}, {"name": "tactic_doc.tactic.trace_simp_set", "description": "Just construct the simp set and trace it. Used for debugging."}, {"name": "tactic_doc.tactic.guard_hyp", "description": "`guard_hyp h : t` fails if the hypothesis `h` does not have type `t`.\nWe use this tactic for writing tests."}, {"name": "tactic_doc.tactic.assumption'", "description": "Try to apply `assumption` to all goals."}, {"name": "tactic_doc.tactic.have", "description": "`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.\n\n`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.\n\nIf `h` is omitted, the name `this` is used."}, {"name": "tactic_doc.tactic.ac_refl", "description": " Proves a goal of the form `s = t` when `s` and `t` are expressions built up out of a binary\noperation, and equality can be proved using associativity and commutativity of that operation."}, {"name": "tactic_doc.tactic.conv: to_lhs", "description": "Navigate to the left-hand-side of a relation.\nA goal of `| a = b` will turn into the goal `| a`."}, {"name": "tactic_doc.tactic.contradiction", "description": "The contradiction tactic attempts to find in the current local context a hypothesis that is equivalent to an empty inductive type (e.g. `false`), a hypothesis of the form `c_1 ... = c_2 ...` where `c_1` and `c_2` are distinct constructors, or two contradictory hypotheses."}, {"name": "tactic_doc.tactic.rename", "description": "Rename one or more local hypotheses. The renamings are given as follows:\n\n```lean\nrename x y             -- rename x to y\nrename x \u2192 y           -- ditto\nrename [x y, a b]      -- rename x to y and a to b\nrename [x \u2192 y, a \u2192 b]  -- ditto\n```\n\nNote that if there are multiple hypotheses called `x` in the context, then\n`rename x y` will rename *all* of them. If you want to rename only one, use\n`dedup` first."}, {"name": "tactic_doc.tactic.cases_matching / casesm", "description": "`cases_matching p` applies the `cases` tactic to a hypothesis `h : type`\nif `type` matches the pattern `p`.\n\n`cases_matching [p_1, ..., p_n]` applies the `cases` tactic to a hypothesis `h : type`\nif `type` matches one of the given patterns.\n\n`cases_matching* p` is a more efficient and compact version\nof `focus1 { repeat { cases_matching p } }`.\nIt is more efficient because the pattern is compiled once.\n\n`casesm` is shorthand for `cases_matching`.\n\nExample: The following tactic destructs all conjunctions and disjunctions in the current context.\n```lean\ncases_matching* [_ \u2228 _, _ \u2227 _]\n```"}, {"name": "tactic_doc.tactic.all_goals", "description": "`all_goals { t }` applies the tactic `t` to every goal, and succeeds if each application succeeds."}, {"name": "tactic_doc.tactic.subst_vars", "description": "Apply `subst` to all hypotheses of the form `h : x = t` or `h : t = x`."}, {"name": "tactic_doc.tactic.from", "description": "A synonym for `exact` that allows writing `have/suffices/show ..., from ...` in tactic mode."}, {"name": "tactic_doc.tactic.left / right", "description": "`left` applies the first constructor when the type of the target is an inductive data type with\ntwo constructors.\n\nSimilarly, `right` applies the second constructor."}, {"name": "tactic_doc.tactic.econstructor", "description": "Similar to `constructor`, but only non-dependent premises are added as new goals."}, {"name": "tactic_doc.tactic.generalize", "description": "`generalize : e = x` replaces all occurrences of `e` in the target with a new hypothesis `x` of the same type.\n\n`generalize h : e = x` in addition registers the hypothesis `h : e = x`."}, {"name": "tactic_doc.tactic.funext", "description": "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible\nto\n```lean\n  |-  ((fun x, ...) = (fun x, ...))\n```\nThe variant `funext h\u2081 ... h\u2099` applies `funext` `n` times, and uses the given identifiers to name\nthe new hypotheses.\n\nNote also the mathlib tactic `ext`, which applies as many extensionality lemmas as possible."}, {"name": "tactic_doc.tactic.rw / rewrite", "description": "`rw e` applies an equation or iff `e` as a rewrite rule to the main goal. If `e` is preceded by\nleft arrow (`\u2190` or `<-`), the rewrite is applied in the reverse direction. If `e` is a defined\nconstant, then the equational lemmas associated with `e` are used. This provides a convenient\nway to unfold `e`.\n\n`rw [e\u2081, ..., e\u2099]` applies the given rules sequentially.\n\n`rw e at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a list of hypotheses\nin the local context. In the latter case, a turnstile `\u22a2` or `|-` can also be used, to signify\nthe target of the goal.\n\n`rewrite` is synonymous with `rw`."}, {"name": "tactic_doc.tactic.conv: funext", "description": "Navigate into the contents of top-level `\u03bb` binders.\nA target of `| \u03bb a, a + b` will turn into the target `| a + b` and introduce `a` into the local\ncontext.\nIf there are multiple binders, all of them will be entered, and if there are none, this tactic is a\nno-op."}, {"name": "tactic_doc.tactic.conv: find", "description": "Navigate into the first scope matching the expression.\n\nFor a target of `| \u2200 c, a + (b + c) = 1`, `find (b + _) { ... }` will run the tactics within the\n`{}` with a target of `| b + c`."}, {"name": "tactic_doc.tactic.refine", "description": "This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.\n\nNote that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat \u2192 Prop)`."}, {"name": "tactic_doc.tactic.trace", "description": "`trace a` displays `a` in the tracing buffer."}, {"name": "tactic_doc.tactic.type_check", "description": "Type check the given expression, and trace its type."}, {"name": "tactic_doc.tactic.async", "description": "Proves the first goal asynchronously as a separate lemma."}, {"name": "tactic_doc.tactic.apply_with", "description": "Similar to the `apply` tactic, but allows the user to provide a `apply_cfg` configuration object."}, {"name": "tactic_doc.tactic.conv: skip", "description": "End conversion of the current goal. This is often what is needed when muscle memory would type\n`sorry`."}, {"name": "tactic_doc.tactic.cases", "description": "Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.\n\nFor example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.\n\n`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n\n`cases e with y\u2081 ... y\u2099`, where `e` is a variable or an expression, specifies that the sequence of names `y\u2081 ... y\u2099` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.\n\n`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case."}, {"name": "tactic_doc.tactic.dunfold", "description": "Similar to `unfold`, but only uses definitional equalities."}, {"name": "tactic_doc.tactic.intro / intros", "description": "If the current goal is a Pi/forall `\u2200 x : t, u` (resp. `let x := t in u`) then `intro` puts\n`x : t` (resp. `x := t`) in the local context. The new subgoal target is `u`.\n\nIf the goal is an arrow `t \u2192 u`, then it puts `h : t` in the local context and the new goal\ntarget is `u`.\n\nIf the goal is neither a Pi/forall nor begins with a let binder, the tactic `intro` applies the\ntactic `whnf` until an introduction can be applied or the goal is not head reducible. In the latter\ncase, the tactic fails.\n\nThe variant `intro z` uses the identifier `z` to name the new hypothesis.\n\nThe variant `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall\nor let binder.\n\nThe variant `intros h\u2081 ... h\u2099` introduces `n` new hypotheses using the given identifiers to name\nthem."}, {"name": "tactic_doc.tactic.constructor", "description": "This tactic applies to a goal such that its conclusion is an inductive type (say `I`). It tries to apply each constructor of `I` until it succeeds."}, {"name": "tactic_doc.tactic.unfold1", "description": "Similar to `unfold`, but does not iterate the unfolding."}, {"name": "tactic_doc.tactic.apply_opt_param", "description": "If the target of the main goal is an `opt_param`, assigns the default value."}, {"name": "category_theory.core.inclusion", "description": "The core of a category is naturally included in the category."}, {"name": "category_theory.of_equiv_functor", "description": "`of_equiv_functor m` lifts a type-level `equiv_functor`\nto a categorical functor `core (Type u\u2081) \u2964 core (Type u\u2082)`."}, {"name": "category_theory.core.id_hom", "description": ""}, {"name": "category_theory.core", "description": " The core of a category C is the groupoid whose morphisms are all the\nisomorphisms of C."}, {"name": "category_theory.core_category", "description": ""}, {"name": "category_theory.core.functor_to_core", "description": "A functor from a groupoid to a category C factors through the core of C."}, {"name": "category_theory.core.forget_functor_to_core", "description": "We can functorially associate to any functor from a groupoid to the core of a category `C`,\na functor from the groupoid to `C`, simply by composing with the embedding `core C \u2964 C`."}, {"name": "category_theory.core.comp_hom", "description": ""}, {"name": "category_theory.core.inclusion.category_theory.faithful", "description": ""}, {"name": "equiv.functor", "description": " The function `equiv.map` transfers the functoriality of `t` to\n`t'` using the equivalences `eqv`."}, {"name": "equiv.traversable", "description": " The function `equiv.traverse` transfers a traversable functor\ninstance across the equivalences `eqv`."}, {"name": "equiv.traverse_eq_map_id", "description": ""}, {"name": "equiv.comp_traverse", "description": ""}, {"name": "equiv.is_lawful_traversable", "description": " The fact that `t` is a lawful traversable functor carries over the\nequivalences to `t'`, with the traversable functor structure given by\n`equiv.traversable`."}, {"name": "equiv.map", "description": " Given a functor `t`, a function `t' : Type u \u2192 Type u`, and\nequivalences `t \u03b1 \u2243 t' \u03b1` for all `\u03b1`, then every function `\u03b1 \u2192 \u03b2` can\nbe mapped to a function `t' \u03b1 \u2192 t' \u03b2` functorially (see\n`equiv.functor`)."}, {"name": "equiv.is_lawful_functor'", "description": ""}, {"name": "equiv.is_lawful_traversable'", "description": " If the `traversable t'` instance has the properties that `map`,\n`map_const`, and `traverse` are equal to the ones that come from\ncarrying the traversable functor structure from `t` over the\nequivalences, then the fact that `t` is a lawful traversable functor\ncarries over as well."}, {"name": "equiv.comp_map", "description": ""}, {"name": "equiv.naturality", "description": ""}, {"name": "equiv.id_map", "description": ""}, {"name": "equiv.id_traverse", "description": ""}, {"name": "equiv.traverse", "description": " Like `equiv.map`, a function `t' : Type u \u2192 Type u` can be given\nthe structure of a traversable functor using a traversable functor\n`t'` and equivalences `t \u03b1 \u2243 t' \u03b1` for all \u03b1.  See `equiv.traversable`."}, {"name": "equiv.is_lawful_functor", "description": ""}, {"name": "encodable.encode_ff", "description": ""}, {"name": "sigma.encodable", "description": ""}, {"name": "fin.encodable", "description": ""}, {"name": "pnat.encodable", "description": ""}, {"name": "encodable.choose_x", "description": "Constructive choice function for a decidable subtype of an encodable type."}, {"name": "directed.sequence", "description": " Given a `directed r` function `f : \u03b1 \u2192 \u03b2` defined on an encodable inhabited type,\nconstruct a noncomputable sequence such that `r (f (x n)) (f (x (n + 1)))`\nand `r (f a) (f (x (encode a + 1))`."}, {"name": "punit.encodable", "description": ""}, {"name": "ulower.ext", "description": ""}, {"name": "encodable.choose", "description": "Constructive choice function for a decidable predicate over an encodable type."}, {"name": "encodable.decode_unit_zero", "description": ""}, {"name": "encodable.of_left_injection", "description": "If `\u03b1` is encodable and there is an injection `f : \u03b2 \u2192 \u03b1`, then `\u03b2` is encodable as well."}, {"name": "encodable.decode_sum", "description": "Explicit decoding function for the sum of two encodable types."}, {"name": "encodable.mem_decode\u2082", "description": ""}, {"name": "encodable.mem_decode\u2082'", "description": ""}, {"name": "quotient.rep_spec", "description": ""}, {"name": "encodable.axiom_of_choice", "description": "A constructive version of `classical.axiom_of_choice` for `encodable` types."}, {"name": "encodable.choose_spec", "description": ""}, {"name": "encodable.decode\u2082_encode", "description": ""}, {"name": "encodable.decode\u2082_ne_none_iff", "description": ""}, {"name": "option.encodable", "description": "If `\u03b1` is encodable, then so is `option \u03b1`."}, {"name": "ulower.up", "description": "Lifts an `a : ulower \u03b1` into `\u03b1`."}, {"name": "directed.sequence_mono", "description": ""}, {"name": "ulower.inhabited", "description": ""}, {"name": "encodable.encode_inj", "description": ""}, {"name": "encodable.surjective_decode_iget", "description": ""}, {"name": "encodable.decode_sigma_val", "description": ""}, {"name": "ulower.decidable_eq", "description": ""}, {"name": "sum.encodable", "description": "If `\u03b1` and `\u03b2` are encodable, then so is their sum."}, {"name": "unique.encodable", "description": "A type with unique element is encodable. This is not an instance to avoid diamonds."}, {"name": "encodable.decode_ge_two", "description": ""}, {"name": "encodable.encode_inl", "description": ""}, {"name": "encodable.decode_zero", "description": ""}, {"name": "encodable.decode_sigma", "description": "Explicit decoding function for `sigma \u03b3`"}, {"name": "encodable.decode_unit_succ", "description": ""}, {"name": "directed.le_sequence", "description": ""}, {"name": "encodable.decidable_eq_of_encodable", "description": " An encodable type has decidable equality. Not set as an instance because this is usually not the\nbest way to infer decidability."}, {"name": "encodable.order.preimage.is_trans", "description": ""}, {"name": "ulower.down", "description": "Lowers an `a : \u03b1` into `ulower \u03b1`."}, {"name": "encodable.encode_of_equiv", "description": ""}, {"name": "encodable.encode_inr", "description": ""}, {"name": "plift.encodable", "description": "The lift of an encodable type is encodable."}, {"name": "encodable.encode_sum", "description": "Explicit encoding function for the sum of two encodable types."}, {"name": "encodable.subtype.encode_eq", "description": ""}, {"name": "int.encodable", "description": ""}, {"name": "ulower.equiv", "description": "The equivalence between the encodable type `\u03b1` and `ulower \u03b1 : Type`."}, {"name": "encodable.decode_one", "description": ""}, {"name": "encodable.encode_none", "description": ""}, {"name": "encodable.decode\u2082_eq_some", "description": ""}, {"name": "ulower.up_down", "description": ""}, {"name": "encodable.of_left_inverse", "description": "If `\u03b1` is encodable and `f : \u03b2 \u2192 \u03b1` is invertible, then `\u03b2` is encodable as well."}, {"name": "encodable.decode_option_zero", "description": ""}, {"name": "encodable.encode_some", "description": ""}, {"name": "pnat.countable", "description": ""}, {"name": "encodable", "description": " Constructively countable type. Made from an explicit injection `encode : \u03b1 \u2192 \u2115` and a partial\ninverse `decode : \u2115 \u2192 option \u03b1`. Note that finite types *are* countable. See `denumerable` if you\nwish to enforce infiniteness."}, {"name": "encodable.encode", "description": " Constructively countable type. Made from an explicit injection `encode : \u03b1 \u2192 \u2115` and a partial\ninverse `decode : \u2115 \u2192 option \u03b1`. Note that finite types *are* countable. See `denumerable` if you\nwish to enforce infiniteness."}, {"name": "encodable.decode", "description": " Constructively countable type. Made from an explicit injection `encode : \u03b1 \u2192 \u2115` and a partial\ninverse `decode : \u2115 \u2192 option \u03b1`. Note that finite types *are* countable. See `denumerable` if you\nwish to enforce infiniteness."}, {"name": "encodable.encodek", "description": " Constructively countable type. Made from an explicit injection `encode : \u03b1 \u2192 \u2115` and a partial\ninverse `decode : \u2115 \u2192 option \u03b1`. Note that finite types *are* countable. See `denumerable` if you\nwish to enforce infiniteness."}, {"name": "encodable.skolem", "description": "A constructive version of `classical.skolem` for `encodable` types."}, {"name": "encodable.encodek\u2082", "description": ""}, {"name": "encodable.order.preimage.is_antisymm", "description": ""}, {"name": "encodable_quotient", "description": "The quotient of an encodable space by a decidable equivalence relation is encodable."}, {"name": "encodable.decode\u2082", "description": " Failsafe variant of `decode`. `decode\u2082 \u03b1 n` returns the preimage of `n` under `encode` if it\nexists, and returns `none` if it doesn't. This requirement could be imposed directly on `decode` but\nis not to help make the definition easier to use."}, {"name": "encodable.countable", "description": ""}, {"name": "ulower", "description": "`ulower \u03b1 : Type` is an equivalent type in the lowest universe, given `encodable \u03b1`."}, {"name": "ulift.encodable", "description": "The lift of an encodable type is encodable."}, {"name": "subtype.encodable", "description": "A decidable subtype of an encodable type is encodable."}, {"name": "ulower.encodable", "description": ""}, {"name": "encodable.encode_nat", "description": ""}, {"name": "quotient.rep", "description": " Representative of an equivalence class. This is a computable version of `quot.out` for a setoid\non an encodable type."}, {"name": "encodable.encode_subtype", "description": "Explicit encoding function for a decidable subtype of an encodable type"}, {"name": "encodable.order.preimage.is_total", "description": ""}, {"name": "encodable.encode_injective", "description": ""}, {"name": "nat.encodable", "description": ""}, {"name": "encodable.decode\u2082_is_partial_inv", "description": ""}, {"name": "encodable.encode_sigma_val", "description": ""}, {"name": "directed.rel_sequence", "description": ""}, {"name": "encodable.decode_sum_val", "description": ""}, {"name": "ulower.up_eq_up", "description": ""}, {"name": "prod.encodable", "description": "If `\u03b1` and `\u03b2` are encodable, then so is their product."}, {"name": "encodable.encode_tt", "description": ""}, {"name": "is_empty.to_encodable", "description": ""}, {"name": "encodable.decode_option_succ", "description": ""}, {"name": "Prop.encodable", "description": ""}, {"name": "encodable.decode_of_equiv", "description": ""}, {"name": "encodable.equiv_range_encode", "description": "An encodable type is equivalent to the range of its encoding function."}, {"name": "encodable.of_equiv", "description": "Encodability is preserved by equivalence."}, {"name": "encodable.encode_prod_val", "description": ""}, {"name": "encodable.nonempty_encodable", "description": ""}, {"name": "encodable.of_inj", "description": "If `\u03b2` is encodable and there is an injection `f : \u03b1 \u2192 \u03b2`, then `\u03b1` is encodable as well."}, {"name": "encodable.decode_nat", "description": ""}, {"name": "ulower.down_up", "description": ""}, {"name": "encodable.decode\u2082_inj", "description": ""}, {"name": "encodable.encode'", "description": "The `encode` function, viewed as an embedding."}, {"name": "directed.sequence_mono_nat", "description": ""}, {"name": "bool.encodable", "description": ""}, {"name": "encodable.decidable_range_encode", "description": "The encoding function has decidable range."}, {"name": "ulower.down_eq_down", "description": ""}, {"name": "encodable.of_countable", "description": "If `\u03b1` is countable, then it has a (non-canonical) `encodable` structure."}, {"name": "encodable.encode_star", "description": ""}, {"name": "encodable.decode_prod_val", "description": ""}, {"name": "encodable.decode_subtype", "description": "Explicit decoding function for a decidable subtype of an encodable type"}, {"name": "encodable.encode_sigma", "description": "Explicit encoding function for `sigma \u03b3`"}, {"name": "native.float.acosh", "description": ""}, {"name": "native.float.infinity", "description": "Positive infinity."}, {"name": "native.float.pow", "description": ""}, {"name": "native.float.is_nan", "description": "Returns true when the value is qNaN or sNaN"}, {"name": "native.float.sub", "description": ""}, {"name": "native.float.is_normal", "description": "Reference: https://en.cppreference.com/w/cpp/numeric/math/isnormal\n   https://stackoverflow.com/questions/8341395/what-is-a-subnormal-floating-point-number"}, {"name": "native.float.sign", "description": "The sign `s` of the float. `tt` if negative."}, {"name": "native.float.atan", "description": ""}, {"name": "native.float.has_one", "description": ""}, {"name": "native.float.specification.emin", "description": "The minimum exponent. `= 1 - emax`"}, {"name": "native.float.specification.emax", "description": "The maximum exponent."}, {"name": "native.float.log2", "description": ""}, {"name": "native.float.atan2", "description": "`atan2 y x` finds the angle anticlockwise from the x-axis to the point `[x,y]`."}, {"name": "native.float.of_nat", "description": ""}, {"name": "native.float.has_add", "description": ""}, {"name": "native.float.of_string", "description": ""}, {"name": "native.float.sqrt", "description": "Square root."}, {"name": "native.float.is_infinite", "description": "Returns true when the value is positive or negative infinity."}, {"name": "native.float.to_repr", "description": ""}, {"name": "native.float.cos", "description": ""}, {"name": "native.float.cbrt", "description": "Cube root."}, {"name": "native.float.min", "description": ""}, {"name": "native.float.cosh", "description": ""}, {"name": "native.float", "description": ""}, {"name": "native.float.exponent", "description": "The exponent `e` of the float in the base given by `radix`. `emin \u2264 e \u2264 emax`. Returns none if the number is not finite."}, {"name": "native.float.sin", "description": ""}, {"name": "native.float.neg", "description": ""}, {"name": "native.float.asinh", "description": ""}, {"name": "native.float.fmod", "description": "remainder of the floating point division operation."}, {"name": "native.float.exp", "description": "Exponential function."}, {"name": "native.float.has_to_string", "description": ""}, {"name": "native.float.sinh", "description": ""}, {"name": "native.float.frexp", "description": "Decompose the number `f` in to `(s,e)` where `0.5 \u2264 s < 1.0` and `emin \u2264 e \u2264 emax` such that `f = s * 2 ^ e`."}, {"name": "native.float.log", "description": "Natural logarithm."}, {"name": "native.float.pi", "description": ""}, {"name": "native.float.ceil", "description": " Nearest integer not less than the given value.\nReturns 0 if the input is not finite."}, {"name": "native.float.remainder", "description": "signed remainder of the division operation."}, {"name": "native.float.acos", "description": ""}, {"name": "native.float.round_error", "description": "returns the maximum rounding error"}, {"name": "native.float.asin", "description": ""}, {"name": "native.float.specification.radix", "description": "The base. Either 2 or 10."}, {"name": "native.float.of_int_coe", "description": ""}, {"name": "native.float.log10", "description": ""}, {"name": "native.float.add", "description": ""}, {"name": "native.float.has_zero", "description": ""}, {"name": "native.float.qNaN", "description": "Quiet NaN."}, {"name": "native.float.has_div", "description": ""}, {"name": "native.float.max", "description": ""}, {"name": "native.float.atanh", "description": ""}, {"name": "native.float.one", "description": ""}, {"name": "native.float.has_neg", "description": ""}, {"name": "native.float.has_le", "description": ""}, {"name": "native.float.hypot", "description": "Computes `sqrt(x^2 + y^2)`."}, {"name": "native.float.mantissa", "description": "`mantissa f` returns a number `s` where `0.5 \u2264 s < 1.0` such that there exists an integer `e` such that `f = s * 2 ^ e`"}, {"name": "native.float.exp2", "description": "2 raised to the given power."}, {"name": "native.float.zero", "description": ""}, {"name": "native.float.sNaN", "description": "Signalling NaN."}, {"name": "native.float.has_repr", "description": ""}, {"name": "native.float.div", "description": ""}, {"name": "native.float.epsilon", "description": "Returns the difference between 1.0 and the next representable value of the given floating-point type.\n   Reference: https://en.cppreference.com/w/cpp/types/numeric_limits/epsilon"}, {"name": "native.float.has_mul", "description": ""}, {"name": "native.float.decidable_le", "description": ""}, {"name": "native.float.has_float_pow", "description": ""}, {"name": "native.float.mul", "description": ""}, {"name": "native.float.le", "description": ""}, {"name": "native.float.modf", "description": "Decompose in to integer `fst` and fractional `snd` parts."}, {"name": "native.float.abs", "description": ""}, {"name": "native.float.trunc", "description": " Nearest integer not greater in magnitude than the given value.\nReturns 0 if the input is not finite."}, {"name": "native.float.of_nat_coe", "description": ""}, {"name": "native.float.has_to_format", "description": ""}, {"name": "native.float.of_int", "description": ""}, {"name": "native.float.tanh", "description": ""}, {"name": "native.float.lt", "description": ""}, {"name": "native.float.has_lt", "description": ""}, {"name": "native.float.round", "description": " Round to the nearest integer, rounding away from zero in halfway cases.\nReturns 0 if the input is not finite."}, {"name": "native.float.dec_eq", "description": ""}, {"name": "native.float.decidable_lt", "description": ""}, {"name": "native.float.floor", "description": " Nearest integer not greater than the given value.\nReturns 0 if the input is not finite."}, {"name": "native.float.has_sub", "description": ""}, {"name": "native.float.specification.precision", "description": "The length of the mantissa."}, {"name": "native.float.tan", "description": ""}, {"name": "native.float.is_finite", "description": ""}, {"name": "native.float.has_nat_pow", "description": ""}, {"name": "list.permutations_aux2", "description": " An auxiliary function for defining `permutations`. `permutations_aux2 t ts r ys f` is equal to\n`(ys ++ ts, (insert_left ys t ts).map f ++ r)`, where `insert_left ys t ts` (not explicitly\ndefined) is the list of lists of the form `insert_nth n t (ys ++ ts)` for `0 \u2264 n < length ys`.\n\n    permutations_aux2 10 [4, 5, 6] [] [1, 2, 3] id =\n      ([1, 2, 3, 4, 5, 6],\n       [[10, 1, 2, 3, 4, 5, 6],\n        [1, 10, 2, 3, 4, 5, 6],\n        [1, 2, 10, 3, 4, 5, 6]])"}, {"name": "list.prod", "description": "Product of a list.\n\n    prod [a, b, c] = ((1 * a) * b) * c"}, {"name": "list.foldr_with_index_aux", "description": "Auxiliary definition for `foldr_with_index`."}, {"name": "list.permutations'_aux", "description": " `permutations'_aux t ts` inserts `t` into every position in `ts`, including the last.\nThis function is intended for use in specifications, so it is simpler than `permutations_aux2`,\nwhich plays roughly the same role in `permutations`.\n\nNote that `(permutations_aux2 t [] [] ts id).2` is similar to this function, but skips the last\nposition:\n\n    permutations'_aux 10 [1, 2, 3] =\n      [[10, 1, 2, 3], [1, 10, 2, 3], [1, 2, 10, 3], [1, 2, 3, 10]]\n    (permutations_aux2 10 [] [] [1, 2, 3] id).2 =\n      [[10, 1, 2, 3], [1, 10, 2, 3], [1, 2, 10, 3]]"}, {"name": "list.all_some", "description": "If all elements of `xs` are `some x\u1d62`, `all_some xs` returns the `x\u1d62`. Otherwise\nit returns `none`.\n\n```lean\nall_some [some 1, some 2] = some [1, 2]\nall_some [some 1, none  ] = none\n```"}, {"name": "list.to_chunks_aux", "description": "Auxliary definition used to define `to_chunks`.\n\n `to_chunks_aux n xs i` returns `(xs.take i, (xs.drop i).to_chunks (n+1))`,\n that is, the first `i` elements of `xs`, and the remaining elements chunked into\n sublists of length `n+1`."}, {"name": "list.split_on_p_aux", "description": "An auxiliary function for `split_on_p`."}, {"name": "list.mbfind'", "description": " `mbfind' p l` returns the first element `a` of `l` for which `p a` returns\ntrue. `mbfind'` short-circuits, so `p` is not necessarily run on every `a` in\n`l`. This is a monadic version of `list.find`."}, {"name": "list.mall", "description": " `mall p as` returns true iff `p` returns true for all elements of `l`.\n`mall` short-circuits, so if `p` returns false for any element of `l`, later\nelements are not checked. This is a monadic version of `list.all`."}, {"name": "list.concat", "description": "Concatenate an element at the end of a list.\n\n    concat [a, b] c = [a, b, c]"}, {"name": "list.nthd", "description": "\"default\" `nth` function: returns `d` instead of `none` in the case\n that the index is out of bounds."}, {"name": "list.inits", "description": "`inits l` is the list of initial segments of `l`.\n\n    inits [1, 2, 3] = [[], [1], [1, 2], [1, 2, 3]]"}, {"name": "list.transpose_aux", "description": "Auxiliary definition used to define `transpose`.\n `transpose_aux l L` takes each element of `l` and appends it to the start of\n each element of `L`.\n\n `transpose_aux [a, b, c] [l\u2081, l\u2082, l\u2083] = [a::l\u2081, b::l\u2082, c::l\u2083]`"}, {"name": "list.is_prefix", "description": "`is_prefix l\u2081 l\u2082`, or `l\u2081 <+: l\u2082`, means that `l\u2081` is a prefix of `l\u2082`,\n that is, `l\u2082` has the form `l\u2081 ++ t` for some `t`."}, {"name": "list.sigma", "description": "`sigma l\u2081 l\u2082` is the list of dependent pairs `(a, b)` where `a \u2208 l\u2081` and `b \u2208 l\u2082 a`.\n\n    sigma [1, 2] (\u03bb_, [(5 : \u2115), 6]) = [(1, 5), (1, 6), (2, 5), (2, 6)]"}, {"name": "list.of_fn", "description": "`of_fn f` with `f : fin n \u2192 \u03b1` returns the list whose ith element is `f i`\n `of_fun f = [f 0, f 1, ... , f(n - 1)]`"}, {"name": "list.map\u2082_right'", "description": "Right-biased version of `list.map\u2082`. `map\u2082_right' f as bs` applies `f` to each\npair of elements `a\u1d62 \u2208 as` and `b\u1d62 \u2208 bs`. If `as` is shorter than `bs`, `f` is\napplied to `none` for the remaining `b\u1d62`. Returns the results of the `f`\napplications and the remaining `as`.\n\n```lean\nmap\u2082_right' prod.mk [1] ['a', 'b'] = ([(some 1, 'a'), (none, 'b')], [])\n\nmap\u2082_right' prod.mk [1, 2] ['a'] = ([(some 1, 'a')], [2])\n```"}, {"name": "list.mmap'_diag", "description": "`mmap'_diag f l` calls `f` on all elements in the upper triangular part of `l \u00d7 l`.\nThat is, for each `e \u2208 l`, it will run `f e e` and then `f e e'`\nfor each `e'` that appears after `e` in `l`.\n\nExample: suppose `l = [1, 2, 3]`. `mmap'_diag f l` will evaluate, in this order,\n`f 1 1`, `f 1 2`, `f 1 3`, `f 2 2`, `f 2 3`, `f 3 3`."}, {"name": "list.range'", "description": "`range' s n` is the list of numbers `[s, s+1, ..., s+n-1]`.\n It is intended mainly for proving properties of `range` and `iota`."}, {"name": "list.sublists_aux\u2081", "description": ""}, {"name": "list.scanr_aux", "description": " Auxiliary definition used to define `scanr`. If `scanr_aux f b l = (b', l')`\nthen `scanr f b l = b' :: l'`"}, {"name": "list.find", "description": "`find p l` is the first element of `l` satisfying `p`, or `none` if no such\n element exists."}, {"name": "list.chain'", "description": "`chain' R l` means that `R` holds between adjacent elements of `l`.\n\n    chain' R [a, b, c, d] \u2194 R a b \u2227 R b c \u2227 R c d"}, {"name": "list.split_at", "description": "Split a list at an index.\n\n    split_at 2 [a, b, c] = ([a, b], [c])"}, {"name": "list.zip_with4", "description": "Quaternary version of `list.zip_with`."}, {"name": "list.erasep", "description": "`erasep p l` removes the first element of `l` satisfying the predicate `p`."}, {"name": "list.is_infix", "description": "`is_infix l\u2081 l\u2082`, or `l\u2081 <:+: l\u2082`, means that `l\u2081` is a contiguous\n substring of `l\u2082`, that is, `l\u2082` has the form `s ++ l\u2081 ++ t` for some `s, t`."}, {"name": "list.mfoldl_with_index", "description": "Monadic variant of `foldl_with_index`."}, {"name": "list.chain_cons", "description": ""}, {"name": "list.has_sdiff", "description": ""}, {"name": "list.zip_right", "description": "Right-biased version of `list.zip`. `zip_right as bs` returns the list of pairs\n`(a\u1d62, b\u1d62)` for `a\u1d62 \u2208 as` and `b\u1d62 \u2208 bs`. If `as` is shorter than `bs`, the\nremaining `b\u1d62` are paired with `none`.\n\n```lean\nzip_right [1, 2] ['a'] = [(some 1, 'a')]\n\nzip_right [1] ['a', 'b'] = [(some 1, 'a'), (none, 'b')]\n\nzip_right = map\u2082_right prod.mk\n```"}, {"name": "list.modify_nth", "description": "Apply `f` to the nth element of the list, if it exists."}, {"name": "list.choose_x", "description": " Given a decidable predicate `p` and a proof of existence of `a \u2208 l` such that `p a`,\nchoose the first element with this property. This version returns both `a` and proofs\nof `a \u2208 l` and `p a`."}, {"name": "list.map\u2082_left", "description": "Left-biased version of `list.map\u2082`. `map\u2082_left f as bs` applies `f` to each pair\n`a\u1d62 \u2208 as` and `b\u1d62 \u200c\u2208 bs`. If `bs` is shorter than `as`, `f` is applied to `none`\nfor the remaining `a\u1d62`.\n\n```lean\nmap\u2082_left prod.mk [1, 2] ['a'] = [(1, some 'a'), (2, none)]\n\nmap\u2082_left prod.mk [1] ['a', 'b'] = [(1, some 'a')]\n\nmap\u2082_left f as bs = (map\u2082_left' f as bs).fst\n```"}, {"name": "list.rotate", "description": "`rotate l n` rotates the elements of `l` to the left by `n`\n\n    rotate [0, 1, 2, 3, 4, 5] 2 = [2, 3, 4, 5, 0, 1]"}, {"name": "list.map_with_complement", "description": "`list.map_with_complement f l` is a variant of `list.map_with_prefix_suffix`\nthat maps `f` across a list `l`.\nFor each `a \u2208 l` with `l = pref ++ [a] ++ suff`, `a` is mapped to `f a (pref ++ suff)`,\ni.e., the list input to `f` is `l` with `a` removed.\n\nExample: if `f : \u2115 \u2192 list \u2115 \u2192 \u03b2`, `list.map_with_complement f [1, 2, 3]` will produce the list\n`[f 1 [2, 3], f 2 [1, 3], f 3 [1, 2]]`."}, {"name": "list.mmap_filter", "description": "Filters and maps elements of a list"}, {"name": "list.extractp", "description": "`extractp p l` returns a pair of an element `a` of `l` satisfying the predicate\n `p`, and `l`, with `a` removed. If there is no such element `a` it returns `(none, l)`."}, {"name": "list.pairwise", "description": "`pairwise R l` means that all the elements with earlier indexes are\n `R`-related to all the elements with later indexes.\n\n    pairwise R [1, 2, 3] \u2194 R 1 2 \u2227 R 1 3 \u2227 R 2 3\n\n For example if `R = (\u2260)` then it asserts `l` has no duplicates,\n and if `R = (<)` then it asserts that `l` is (strictly) sorted."}, {"name": "list.pairwise.nil", "description": "`pairwise R l` means that all the elements with earlier indexes are\n `R`-related to all the elements with later indexes.\n\n    pairwise R [1, 2, 3] \u2194 R 1 2 \u2227 R 1 3 \u2227 R 2 3\n\n For example if `R = (\u2260)` then it asserts `l` has no duplicates,\n and if `R = (<)` then it asserts that `l` is (strictly) sorted."}, {"name": "list.pairwise.cons", "description": "`pairwise R l` means that all the elements with earlier indexes are\n `R`-related to all the elements with later indexes.\n\n    pairwise R [1, 2, 3] \u2194 R 1 2 \u2227 R 1 3 \u2227 R 2 3\n\n For example if `R = (\u2260)` then it asserts `l` has no duplicates,\n and if `R = (<)` then it asserts that `l` is (strictly) sorted."}, {"name": "list.mmap_upper_triangle", "description": "`mmap_upper_triangle f l` calls `f` on all elements in the upper triangular part of `l \u00d7 l`.\nThat is, for each `e \u2208 l`, it will run `f e e` and then `f e e'`\nfor each `e'` that appears after `e` in `l`.\n\nExample: suppose `l = [1, 2, 3]`. `mmap_upper_triangle f l` will produce the list\n`[f 1 1, f 1 2, f 1 3, f 2 2, f 2 3, f 3 3]`."}, {"name": "list.split_on", "description": "Split a list at every occurrence of an element.\n\n   [1,1,2,3,2,4,4].split_on 2 = [[1,1],[3],[4,4]]"}, {"name": "list.rotate'", "description": "rotate' is the same as `rotate`, but slower. Used for proofs about `rotate`"}, {"name": "list.permutations", "description": "List of all permutations of `l`.\n\n    permutations [1, 2, 3] =\n      [[1, 2, 3], [2, 1, 3], [3, 2, 1],\n       [2, 3, 1], [3, 1, 2], [1, 3, 2]]"}, {"name": "list.permutations'", "description": " List of all permutations of `l`. This version of `permutations` is less efficient but has\nsimpler definitional equations. The permutations are in a different order,\nbut are equal up to permutation, as shown by `list.permutations_perm_permutations'`.\n\n     permutations [1, 2, 3] =\n       [[1, 2, 3], [2, 1, 3], [2, 3, 1],\n        [1, 3, 2], [3, 1, 2], [3, 2, 1]]"}, {"name": "list.sublists", "description": "`sublists l` is the list of all (non-contiguous) sublists of `l`; cf. `sublists'`\n for a different ordering.\n\n    sublists [1, 2, 3] = [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]"}, {"name": "list.mbfind", "description": "A variant of `mbfind'` with more restrictive universe levels."}, {"name": "list.indexes_of", "description": " `indexes_of a l` is the list of all indexes of `a` in `l`. For example:\n```lean\nindexes_of a [a, b, a, a] = [0, 2, 3]\n```"}, {"name": "list.is_suffix", "description": "`is_suffix l\u2081 l\u2082`, or `l\u2081 <:+ l\u2082`, means that `l\u2081` is a suffix of `l\u2082`,\n that is, `l\u2082` has the form `t ++ l\u2081` for some `t`."}, {"name": "list.nodup", "description": "`nodup l` means that `l` has no duplicates, that is, any element appears at most\n once in the list. It is defined as `pairwise (\u2260)`."}, {"name": "list.decidable_chain", "description": ""}, {"name": "list.zip_left'", "description": "Left-biased version of `list.zip`. `zip_left' as bs` returns the list of\npairs `(a\u1d62, b\u1d62)` for `a\u1d62 \u2208 as` and `b\u1d62 \u2208 bs`. If `bs` is shorter than `as`, the\nremaining `a\u1d62` are paired with `none`. Also returns the remaining `bs`.\n\n```lean\nzip_left' [1, 2] ['a'] = ([(1, some 'a'), (2, none)], [])\n\nzip_left' [1] ['a', 'b'] = ([(1, some 'a')], ['b'])\n\nzip_left' = map\u2082_left' prod.mk\n\n```"}, {"name": "list.indexes_values", "description": " Returns the elements of `l` that satisfy `p` together with their indexes in\n`l`. The returned list is ordered by index."}, {"name": "list.revzip", "description": " `revzip l` returns a list of pairs of the elements of `l` paired\n  with the elements of `l` in reverse order.\n\n`revzip [1,2,3,4,5] = [(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)]`"}, {"name": "list.fill_nones", "description": "`fill_nones xs ys` replaces the `none`s in `xs` with elements of `ys`. If there\nare not enough `ys` to replace all the `none`s, the remaining `none`s are\ndropped from `xs`.\n\n```lean\nfill_nones [none, some 1, none, none] [2, 3] = [2, 1, 3]\n```"}, {"name": "list.alternating_sum", "description": "The alternating sum of a list."}, {"name": "list.sublists'", "description": "`sublists' l` is the list of all (non-contiguous) sublists of `l`.\n It differs from `sublists` only in the order of appearance of the sublists;\n `sublists'` uses the first element of the list as the MSB,\n `sublists` uses the first element of the list as the LSB.\n\n    sublists' [1, 2, 3] = [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]"}, {"name": "list.take_list", "description": "`take_list as ns` extracts successive sublists from `as`. For `ns = n\u2081 ... n\u2098`,\nit first takes the `n\u2081` initial elements from `as`, then the next `n\u2082` ones,\netc. It returns the sublists of `as` -- one for each `n\u1d62` -- and the remaining\nelements of `as`. If `as` does not have at least as many elements as the sum of\nthe `n\u1d62`, the corresponding sublists will have less than `n\u1d62` elements.\n\n```lean\ntake_list ['a', 'b', 'c', 'd', 'e'] [2, 1, 1] = ([['a', 'b'], ['c'], ['d']], ['e'])\ntake_list ['a', 'b'] [3, 1] = ([['a', 'b'], []], [])\n```"}, {"name": "list.map_with_prefix_suffix", "description": "`list.map_with_prefix_suffix f l` maps `f` across a list `l`.\nFor each `a \u2208 l` with `l = pref ++ [a] ++ suff`, `a` is mapped to `f pref a suff`.\n\nExample: if `f : list \u2115 \u2192 \u2115 \u2192 list \u2115 \u2192 \u03b2`,\n`list.map_with_prefix_suffix f [1, 2, 3]` will produce the list\n`[f [] 1 [2, 3], f [1] 2 [3], f [1, 2] 3 []]`."}, {"name": "list.choose", "description": " Given a decidable predicate `p` and a proof of existence of `a \u2208 l` such that `p a`,\nchoose the first element with this property. This version returns `a : \u03b1`, and properties\nare given by `choose_mem` and `choose_property`."}, {"name": "list.mmap_with_index", "description": "Applicative variant of `map_with_index`."}, {"name": "list.alternating_prod", "description": "The alternating product of a list."}, {"name": "list.decidable_chain'", "description": ""}, {"name": "list.map_async_chunked", "description": "Asynchronous version of `list.map`."}, {"name": "list.foldl_with_index", "description": " Fold a list from left to right as with `foldl`, but the combining function\nalso receives each element's index."}, {"name": "list.of_fn_nth_val", "description": "`of_fn_nth_val f i` returns `some (f i)` if `i < n` and `none` otherwise."}, {"name": "list.ilast'", "description": " `ilast' x xs` returns the last element of `xs` if `xs` is non-empty;\nit returns `x` otherwise"}, {"name": "list.find_indexes", "description": "`find_indexes p l` is the list of indexes of elements of `l` that satisfy `p`."}, {"name": "list.sublists_aux", "description": ""}, {"name": "list.forall\u2082", "description": "`forall\u2082 R l\u2081 l\u2082` means that `l\u2081` and `l\u2082` have the same length,\n and whenever `a` is the nth element of `l\u2081`, and `b` is the nth element of `l\u2082`,\n then `R a b` is satisfied."}, {"name": "list.forall\u2082.nil", "description": "`forall\u2082 R l\u2081 l\u2082` means that `l\u2081` and `l\u2082` have the same length,\n and whenever `a` is the nth element of `l\u2081`, and `b` is the nth element of `l\u2082`,\n then `R a b` is satisfied."}, {"name": "list.forall\u2082.cons", "description": "`forall\u2082 R l\u2081 l\u2082` means that `l\u2081` and `l\u2082` have the same length,\n and whenever `a` is the nth element of `l\u2081`, and `b` is the nth element of `l\u2082`,\n then `R a b` is satisfied."}, {"name": "list.destutter'", "description": " Greedily create a sublist of `a :: l` such that, for every two adjacent elements `a, b`,\n`R a b` holds. Mostly used with \u2260; for example, `destutter' (\u2260) 1 [2, 2, 1, 1] = [1, 2, 1]`,\n`destutter' (\u2260) 1, [2, 3, 3] = [1, 2, 3]`, `destutter' (<) 1 [2, 5, 2, 3, 4, 9] = [1, 2, 5, 9]`."}, {"name": "list.modify_last", "description": "Apply `f` to the last element of `l`, if it exists."}, {"name": "list.replace_if", "description": "  Given a starting list `old`, a list of booleans and a replacement list `new`,\nread the items in `old` in succession and either replace them with the next element of `new` or\nnot, according as to whether the corresponding boolean is `tt` or `ff`."}, {"name": "list.scanr", "description": "Fold a function `f` over the list from the right, returning the list\n of partial results.\n\n    scanr (+) 0 [1, 2, 3] = [6, 5, 3, 0]"}, {"name": "list.many", "description": " `many p as` returns true iff `p` returns true for any element of `l`.\n`many` short-circuits, so if `p` returns true for any element of `l`, later\nelements are not checked. This is a monadic version of `list.any`."}, {"name": "list.of_fn_aux", "description": "Auxliary definition used to define `of_fn`.\n\n `of_fn_aux f m h l` returns the first `m` elements of `of_fn f`\n appended to `l`"}, {"name": "list.mmap_with_index'", "description": " A variant of `mmap_with_index` specialised to applicative actions which\nreturn `unit`."}, {"name": "list.zip_with3", "description": "Ternary version of `list.zip_with`."}, {"name": "list.transpose", "description": "transpose of a list of lists, treated as a matrix.\n\n    transpose [[1, 2], [3, 4], [5, 6]] = [[1, 3, 5], [2, 4, 6]]"}, {"name": "list.sum", "description": "Sum of a list.\n\n    sum [a, b, c] = ((0 + a) + b) + c"}, {"name": "list.split_on_p", "description": "Split a list at every element satisfying a predicate."}, {"name": "list.mfind", "description": " `mfind tac l` returns the first element of `l` on which `tac` succeeds, and\nfails otherwise."}, {"name": "list.reduce_option", "description": "Drop `none`s from a list, and replace each remaining `some a` with `a`."}, {"name": "list.count", "description": "`count a l` is the number of occurrences of `a` in `l`."}, {"name": "list.sections", "description": "List of all sections through a list of lists. A section\n of `[L\u2081, L\u2082, ..., L\u2099]` is a list whose first element comes from\n `L\u2081`, whose second element comes from `L\u2082`, and so on."}, {"name": "list.scanl", "description": "Fold a function `f` over the list from the left, returning the list\n of partial results.\n\n    scanl (+) 0 [1, 2, 3] = [0, 1, 3, 6]"}, {"name": "list.countp", "description": "`countp p l` is the number of elements of `l` that satisfy `p`."}, {"name": "list.head'", "description": " `head' xs` returns the first element of `xs` if `xs` is non-empty;\nit returns `none` otherwise"}, {"name": "list.lookmap", "description": "`lookmap` is a combination of `lookup` and `filter_map`.\n `lookmap f l` will apply `f : \u03b1 \u2192 option \u03b1` to each element of the list,\n replacing `a \u2192 b` at the first value `a` in the list such that `f a = some b`."}, {"name": "list.inth", "description": "\"inhabited\" `nth` function: returns `default` instead of `none` in the case\n that the index is out of bounds."}, {"name": "list.to_chunks", "description": "`xs.to_chunks n` splits the list into sublists of size at most `n`,\nsuch that `(xs.to_chunks n).join = xs`.\n\n```lean\n[1, 2, 3, 4, 5, 6, 7, 8].to_chunks 10 = [[1, 2, 3, 4, 5, 6, 7, 8]]\n[1, 2, 3, 4, 5, 6, 7, 8].to_chunks 3 = [[1, 2, 3], [4, 5, 6], [7, 8]]\n[1, 2, 3, 4, 5, 6, 7, 8].to_chunks 2 = [[1, 2], [3, 4], [5, 6], [7, 8]]\n[1, 2, 3, 4, 5, 6, 7, 8].to_chunks 0 = [[1, 2, 3, 4, 5, 6, 7, 8]]\n```"}, {"name": "list.permutations_aux", "description": " An auxiliary function for defining `permutations`. `permutations_aux ts is` is the set of all\npermutations of `is ++ ts` that do not fix `ts`."}, {"name": "list.disjoint", "description": "`disjoint l\u2081 l\u2082` means that `l\u2081` and `l\u2082` have no elements in common."}, {"name": "list.destutter", "description": " Greedily create a sublist of `l` such that, for every two adjacent elements `a, b \u2208 l`,\n`R a b` holds. Mostly used with \u2260; for example, `destutter (\u2260) [1, 2, 2, 1, 1] = [1, 2, 1]`,\n`destutter (\u2260) [1, 2, 3, 3] = [1, 2, 3]`, `destutter (<) [1, 2, 5, 2, 3, 4, 9] = [1, 2, 5, 9]`."}, {"name": "list.sublists'_aux", "description": ""}, {"name": "list.slice", "description": "`list.slice n m xs` removes a slice of length `m` at index `n` in list `xs`."}, {"name": "list.foldl_with_index_aux", "description": "Auxiliary definition for `foldl_with_index`."}, {"name": "list.modify_nth_tail", "description": "Apply a function to the nth tail of `l`. Returns the input without\n using `f` if the index is larger than the length of the list.\n\n    modify_nth_tail f 2 [a, b, c] = [a, b] ++ f [c]"}, {"name": "list.take'", "description": " Take `n` elements from a list `l`. If `l` has less than `n` elements, append `n - length l`\nelements `default`."}, {"name": "list.mfoldr_with_index", "description": "Monadic variant of `foldr_with_index`."}, {"name": "list.mmap_with_index'_aux", "description": "Auxiliary definition for `mmap_with_index'`."}, {"name": "list.foldr_with_index", "description": " Fold a list from right to left as with `foldr`, but the combining function\nalso receives each element's index."}, {"name": "list.pw_filter", "description": "`pw_filter R l` is a maximal sublist of `l` which is `pairwise R`.\n `pw_filter (\u2260)` is the erase duplicates function (cf. `dedup`), and `pw_filter (<)` finds\n a maximal increasing subsequence in `l`. For example,\n\n    pw_filter (<) [0, 1, 5, 2, 6, 3, 4] = [0, 1, 2, 3, 4]"}, {"name": "list.product", "description": "`product l\u2081 l\u2082` is the list of pairs `(a, b)` where `a \u2208 l\u2081` and `b \u2208 l\u2082`.\n\n    product [1, 2] [5, 6] = [(1, 5), (1, 6), (2, 5), (2, 6)]"}, {"name": "list.mbor", "description": " `mbor xs` runs the actions in `xs`, returning true if any of them returns\ntrue. `mbor` short-circuits, so if an action returns true, later actions are\nnot run. This is a monadic version of `list.bor`."}, {"name": "list.take_while", "description": "Get the longest initial segment of the list whose members all satisfy `p`.\n\n    take_while (\u03bb x, x < 3) [0, 2, 5, 1] = [0, 2]"}, {"name": "list.pairwise_cons", "description": ""}, {"name": "list.zip_with5", "description": "Quinary version of `list.zip_with`."}, {"name": "list.map\u2082_left'", "description": "Left-biased version of `list.map\u2082`. `map\u2082_left' f as bs` applies `f` to each\npair of elements `a\u1d62 \u2208 as` and `b\u1d62 \u2208 bs`. If `bs` is shorter than `as`, `f` is\napplied to `none` for the remaining `a\u1d62`. Returns the results of the `f`\napplications and the remaining `bs`.\n\n```lean\nmap\u2082_left' prod.mk [1, 2] ['a'] = ([(1, some 'a'), (2, none)], [])\n\nmap\u2082_left' prod.mk [1] ['a', 'b'] = ([(1, some 'a')], ['b'])\n```"}, {"name": "list.last'", "description": " `last' xs` returns the last element of `xs` if `xs` is non-empty;\nit returns `none` otherwise"}, {"name": "list.partition_map", "description": "Given a function `f : \u03b1 \u2192 \u03b2 \u2295 \u03b3`, `partition_map f l` maps the list by `f`\n whilst partitioning the result it into a pair of lists, `list \u03b2 \u00d7 list \u03b3`,\n partitioning the `sum.inl _` into the left list, and the `sum.inr _` into the right list.\n `partition_map (id : \u2115 \u2295 \u2115 \u2192 \u2115 \u2295 \u2115) [inl 0, inr 1, inl 2] = ([0,2], [1])`"}, {"name": "list.mband", "description": " `mband xs` runs the actions in `xs`, returning true if all of them return\ntrue. `mband` short-circuits, so if an action returns false, later actions are\nnot run. This is a monadic version of `list.band`."}, {"name": "list.get_rest", "description": "`get_rest l l\u2081` returns `some l\u2082` if `l = l\u2081 ++ l\u2082`.\n If `l\u2081` is not a prefix of `l`, returns `none`"}, {"name": "list.nodup_decidable", "description": ""}, {"name": "list.map_with_prefix_suffix_aux", "description": "An auxiliary function for `list.map_with_prefix_suffix`."}, {"name": "list.zip_left", "description": "Left-biased version of `list.zip`. `zip_left as bs` returns the list of pairs\n`(a\u1d62, b\u1d62)` for `a\u1d62 \u2208 as` and `b\u1d62 \u2208 bs`. If `bs` is shorter than `as`, the\nremaining `a\u1d62` are paired with `none`.\n\n```lean\nzip_left [1, 2] ['a'] = [(1, some 'a'), (2, none)]\n\nzip_left [1] ['a', 'b'] = [(1, some 'a')]\n\nzip_left = map\u2082_left prod.mk\n```"}, {"name": "list.to_rbmap", "description": "`to_rbmap as` is the map that associates each index `i` of `as` with the\ncorresponding element of `as`.\n\n```lean\nto_rbmap ['a', 'b', 'c'] = rbmap_of [(0, 'a'), (1, 'b'), (2, 'c')]\n```"}, {"name": "list.modify_head", "description": "Apply `f` to the head of the list, if it exists."}, {"name": "list.map\u2082_right", "description": "Right-biased version of `list.map\u2082`. `map\u2082_right f as bs` applies `f` to each\npair `a\u1d62 \u2208 as` and `b\u1d62 \u200c\u2208 bs`. If `as` is shorter than `bs`, `f` is applied to\n`none` for the remaining `b\u1d62`.\n\n```lean\nmap\u2082_right prod.mk [1, 2] ['a'] = [(some 1, 'a')]\n\nmap\u2082_right prod.mk [1] ['a', 'b'] = [(some 1, 'a'), (none, 'b')]\n\nmap\u2082_right f as bs = (map\u2082_right' f as bs).fst\n```"}, {"name": "list.all\u2082", "description": " `l.all\u2082 p` is equivalent to `\u2200 a \u2208 l, p a`, but unfolds directly to a conjunction, i.e.\n`list.all\u2082 p [0, 1, 2] = p 0 \u2227 p 1 \u2227 p 2`."}, {"name": "list.traverse", "description": ""}, {"name": "list.insert_nth", "description": "`insert_nth n a l` inserts `a` into the list `l` after the first `n` elements of `l`\n`insert_nth 2 1 [1, 2, 3, 4] = [1, 2, 1, 3, 4]`"}, {"name": "list.permutations_aux.rec", "description": " A recursor for pairs of lists. To have `C l\u2081 l\u2082` for all `l\u2081`, `l\u2082`, it suffices to have it for\n`l\u2082 = []` and to be able to pour the elements of `l\u2081` into `l\u2082`."}, {"name": "list.mmap_with_index_aux", "description": "Auxiliary definition for `mmap_with_index`."}, {"name": "list.decidable_pairwise", "description": ""}, {"name": "list.zip_right'", "description": "Right-biased version of `list.zip`. `zip_right' as bs` returns the list of\npairs `(a\u1d62, b\u1d62)` for `a\u1d62 \u2208 as` and `b\u1d62 \u2208 bs`. If `as` is shorter than `bs`, the\nremaining `b\u1d62` are paired with `none`. Also returns the remaining `as`.\n\n```lean\nzip_right' [1] ['a', 'b'] = ([(some 1, 'a'), (none, 'b')], [])\n\nzip_right' [1, 2] ['a'] = ([(some 1, 'a')], [2])\n\nzip_right' = map\u2082_right' prod.mk\n```"}, {"name": "list.chain", "description": "`chain R a l` means that `R` holds between adjacent elements of `a::l`.\n\n    chain R a [b, c, d] \u2194 R a b \u2227 R b c \u2227 R c d"}, {"name": "list.chain.nil", "description": "`chain R a l` means that `R` holds between adjacent elements of `a::l`.\n\n    chain R a [b, c, d] \u2194 R a b \u2227 R b c \u2227 R c d"}, {"name": "list.chain.cons", "description": "`chain R a l` means that `R` holds between adjacent elements of `a::l`.\n\n    chain R a [b, c, d] \u2194 R a b \u2227 R b c \u2227 R c d"}, {"name": "list.dedup", "description": "`dedup l` removes duplicates from `l` (taking only the first occurrence).\n Defined as `pw_filter (\u2260)`.\n\n    dedup [1, 0, 2, 2, 1] = [0, 2, 1]"}, {"name": "list.tails", "description": "`tails l` is the list of terminal segments of `l`.\n\n    tails [1, 2, 3] = [[1, 2, 3], [2, 3], [3], []]"}, {"name": "list.to_array", "description": "Convert a list into an array (whose length is the length of `l`)."}, {"name": "set.univ", "description": "The set that contains all elements of a type."}, {"name": "set.has_sep", "description": ""}, {"name": "set", "description": "A set of elements of type `\u03b1`; implemented as a predicate `\u03b1 \u2192 Prop`."}, {"name": "set.has_emptyc", "description": ""}, {"name": "set.has_mem", "description": ""}, {"name": "set.is_lawful_singleton", "description": ""}, {"name": "set_of", "description": "The set `{x | p x}` of elements satisfying the predicate `p`."}, {"name": "set.mem_set_of_eq", "description": ""}, {"name": "set.has_insert", "description": ""}, {"name": "set.has_singleton", "description": ""}, {"name": "add_units.coe_op_equiv_symm", "description": ""}, {"name": "add_monoid_hom.to_opposite_apply", "description": ""}, {"name": "mul_opposite.group", "description": ""}, {"name": "semiconj_by.op", "description": ""}, {"name": "add_opposite.commute.unop", "description": ""}, {"name": "add_equiv.neg'_symm_apply", "description": ""}, {"name": "add_units.coe_unop_op_equiv", "description": ""}, {"name": "add_hom.mul_unop", "description": " The 'unopposite' of an additive semigroup hom `\u03b1\u1d50\u1d52\u1d56 \u2192+ \u03b2\u1d50\u1d52\u1d56`. Inverse to\n`add_hom.mul_op`."}, {"name": "add_hom.mul_op_apply_apply", "description": ""}, {"name": "mul_opposite.add_comm_semigroup", "description": ""}, {"name": "add_hom.from_opposite", "description": "An additive semigroup homomorphism `f : add_hom M N` such that `f x` additively\ncommutes with `f y` for all `x`, `y` defines an additive semigroup homomorphism from `M\u1d43\u1d52\u1d56`."}, {"name": "add_opposite.commute_op", "description": ""}, {"name": "mul_opposite.add_comm_monoid", "description": ""}, {"name": "add_monoid_hom.mul_op", "description": " An additive homomorphism `M \u2192+ N` can equivalently be viewed as an additive homomorphism\n`M\u1d50\u1d52\u1d56 \u2192+ N\u1d50\u1d52\u1d56`. This is the action of the (fully faithful) `\u1d50\u1d52\u1d56`-functor on morphisms."}, {"name": "mul_opposite.add_semigroup", "description": ""}, {"name": "mul_opposite.comm_semigroup", "description": ""}, {"name": "mul_equiv.unop", "description": "The 'unopposite' of an iso `\u03b1\u1d50\u1d52\u1d56 \u2243* \u03b2\u1d50\u1d52\u1d56`. Inverse to `mul_equiv.op`."}, {"name": "add_units.op_equiv", "description": "The additive units of the additive opposites are equivalent to the additive opposites\nof the additive units."}, {"name": "mul_opposite.right_cancel_semigroup", "description": ""}, {"name": "mul_equiv.inv'_symm_apply", "description": ""}, {"name": "mul_opposite.left_cancel_monoid", "description": ""}, {"name": "add_opposite.group", "description": ""}, {"name": "add_equiv.op_symm_apply_symm_apply", "description": ""}, {"name": "add_monoid_hom.op", "description": "An additive monoid homomorphism `M \u2192+ N` can equivalently be viewed as an\nadditive monoid homomorphism `M\u1d43\u1d52\u1d56 \u2192+ N\u1d43\u1d52\u1d56`. This is the action of the (fully faithful)\n`\u1d43\u1d52\u1d56`-functor on morphisms."}, {"name": "add_opposite.sub_neg_monoid", "description": ""}, {"name": "mul_opposite.add_monoid", "description": ""}, {"name": "mul_hom.to_opposite_apply", "description": ""}, {"name": "add_opposite.semiconj_by_op", "description": ""}, {"name": "add_monoid_hom.from_opposite", "description": "An additive monoid homomorphism `f : M \u2192+ N` such that `f x` additively commutes\nwith `f y` for all `x`, `y` defines an additive monoid homomorphism from `M\u1d43\u1d52\u1d56`."}, {"name": "monoid_hom.op", "description": " A monoid homomorphism `M \u2192* N` can equivalently be viewed as a monoid homomorphism\n`M\u1d50\u1d52\u1d56 \u2192* N\u1d50\u1d52\u1d56`. This is the action of the (fully faithful) `\u1d50\u1d52\u1d56`-functor on morphisms."}, {"name": "add_equiv.neg'", "description": "Negation on an additive group is an `add_equiv` to the opposite group. When `G`\nis commutative, there is `add_equiv.inv`."}, {"name": "add_opposite.add_semigroup", "description": ""}, {"name": "mul_opposite.mul_one_class", "description": ""}, {"name": "semiconj_by.unop", "description": ""}, {"name": "mul_opposite.comm_group", "description": ""}, {"name": "mul_opposite.monoid", "description": ""}, {"name": "add_monoid_hom.mul_unop", "description": " The 'unopposite' of an additive monoid hom `\u03b1\u1d50\u1d52\u1d56 \u2192+ \u03b2\u1d50\u1d52\u1d56`. Inverse to\n`add_monoid_hom.mul_op`."}, {"name": "add_equiv.neg'_apply", "description": ""}, {"name": "mul_equiv.inv'_apply", "description": ""}, {"name": "add_hom.op_apply_apply", "description": ""}, {"name": "units.op_equiv", "description": "The units of the opposites are equivalent to the opposites of the units."}, {"name": "monoid_hom.op_apply_apply", "description": ""}, {"name": "mul_opposite.add_comm_group", "description": ""}, {"name": "mul_opposite.commute_op", "description": ""}, {"name": "mul_hom.op_symm_apply_apply", "description": ""}, {"name": "add_opposite.right_cancel_semigroup", "description": ""}, {"name": "units.coe_op_equiv_symm", "description": ""}, {"name": "mul_opposite.left_cancel_semigroup", "description": ""}, {"name": "add_hom.from_opposite_apply", "description": ""}, {"name": "monoid_hom.op_symm_apply_apply", "description": ""}, {"name": "add_opposite.subtraction_monoid", "description": ""}, {"name": "add_opposite.left_cancel_semigroup", "description": ""}, {"name": "add_opposite.op_mul_equiv_to_equiv", "description": ""}, {"name": "add_hom.op", "description": "An additive semigroup homomorphism `add_hom M N` can equivalently be viewed as an\nadditive semigroup homomorphism `add_hom M\u1d43\u1d52\u1d56 N\u1d43\u1d52\u1d56`. This is the action of the (fully faithful)\n`\u1d43\u1d52\u1d56`-functor on morphisms."}, {"name": "add_hom.to_opposite", "description": "An additive semigroup homomorphism `f : add_hom M N` such that `f x` additively\ncommutes with `f y` for all `x, y` defines an additive semigroup homomorphism to `S\u1d43\u1d52\u1d56`."}, {"name": "mul_hom.from_opposite_apply", "description": ""}, {"name": "mul_equiv.op_symm_apply_apply", "description": ""}, {"name": "add_opposite.unop_pow", "description": ""}, {"name": "add_opposite.unop_sub", "description": ""}, {"name": "mul_equiv.op_symm_apply_symm_apply", "description": ""}, {"name": "add_semiconj_by.op", "description": ""}, {"name": "add_equiv.op", "description": "A iso `\u03b1 \u2243+ \u03b2` can equivalently be viewed as an iso `\u03b1\u1d43\u1d52\u1d56 \u2243+ \u03b2\u1d43\u1d52\u1d56`."}, {"name": "add_hom.mul_op_symm_apply_apply", "description": ""}, {"name": "mul_opposite.add_group", "description": ""}, {"name": "add_equiv.unop", "description": "The 'unopposite' of an iso `\u03b1\u1d43\u1d52\u1d56 \u2243+ \u03b2\u1d43\u1d52\u1d56`. Inverse to `add_equiv.op`."}, {"name": "add_hom.mul_op", "description": " An additive semigroup homomorphism `add_hom M N` can equivalently be viewed as an additive\nhomomorphism `add_hom M\u1d50\u1d52\u1d56 N\u1d50\u1d52\u1d56`. This is the action of the (fully faithful) `\u1d50\u1d52\u1d56`-functor on\nmorphisms."}, {"name": "add_opposite.comm_monoid", "description": ""}, {"name": "add_opposite.add_monoid", "description": ""}, {"name": "mul_equiv.inv'", "description": " Inversion on a group is a `mul_equiv` to the opposite group. When `G` is commutative, there is\n`mul_equiv.inv`."}, {"name": "mul_opposite.add_monoid_with_one", "description": ""}, {"name": "add_opposite.op_mul_equiv_apply", "description": ""}, {"name": "add_monoid_hom.op_apply_apply", "description": ""}, {"name": "add_equiv.op_apply_symm_apply", "description": ""}, {"name": "add_equiv.mul_unop", "description": "The 'unopposite' of an iso `\u03b1\u1d50\u1d52\u1d56 \u2243+ \u03b2\u1d50\u1d52\u1d56`. Inverse to `add_equiv.mul_op`."}, {"name": "add_monoid_hom.op_symm_apply_apply", "description": ""}, {"name": "add_opposite.cancel_add_monoid", "description": ""}, {"name": "mul_hom.op", "description": " A semigroup homomorphism `M \u2192\u2099* N` can equivalently be viewed as a semigroup homomorphism\n`M\u1d50\u1d52\u1d56 \u2192\u2099* N\u1d50\u1d52\u1d56`. This is the action of the (fully faithful) `\u1d50\u1d52\u1d56`-functor on morphisms."}, {"name": "add_opposite.left_cancel_add_monoid", "description": ""}, {"name": "add_opposite.mul_one_class", "description": ""}, {"name": "add_monoid_hom.unop", "description": "The 'unopposite' of an additive monoid homomorphism `M\u1d43\u1d52\u1d56 \u2192+ N\u1d43\u1d52\u1d56`. Inverse to\n`add_monoid_hom.op`."}, {"name": "add_equiv.op_symm_apply_apply", "description": ""}, {"name": "mul_equiv.op", "description": "A iso `\u03b1 \u2243* \u03b2` can equivalently be viewed as an iso `\u03b1\u1d50\u1d52\u1d56 \u2243* \u03b2\u1d50\u1d52\u1d56`."}, {"name": "add_opposite.has_pow", "description": ""}, {"name": "add_monoid_hom.mul_op_symm_apply_apply", "description": ""}, {"name": "add_monoid_hom.from_opposite_apply", "description": ""}, {"name": "mul_opposite.op_add_equiv_symm_apply", "description": ""}, {"name": "add_opposite.add_zero_class", "description": ""}, {"name": "add_hom.to_opposite_apply", "description": ""}, {"name": "mul_hom.from_opposite", "description": " A semigroup homomorphism `f : M \u2192\u2099* N` such that `f x` commutes with `f y` for all `x, y`\ndefines a semigroup homomorphism from `M\u1d50\u1d52\u1d56`."}, {"name": "add_opposite.op_sub", "description": ""}, {"name": "add_semiconj_by.unop", "description": ""}, {"name": "mul_opposite.cancel_monoid", "description": ""}, {"name": "monoid_hom.from_opposite", "description": " A monoid homomorphism `f : M \u2192* N` such that `f x` commutes with `f y` for all `x, y` defines\na monoid homomorphism from `M\u1d50\u1d52\u1d56`."}, {"name": "mul_opposite.op_add_equiv", "description": "The function `mul_opposite.op` is an additive equivalence."}, {"name": "mul_opposite.commute_unop", "description": ""}, {"name": "add_opposite.op_mul_equiv_symm_apply", "description": ""}, {"name": "mul_opposite.cancel_comm_monoid", "description": ""}, {"name": "monoid_hom.from_opposite_apply", "description": ""}, {"name": "add_monoid_hom.to_opposite", "description": "An additive monoid homomorphism `f : M \u2192+ N` such that `f x` additively commutes\nwith `f y` for all `x, y` defines an additive monoid homomorphism to `S\u1d43\u1d52\u1d56`."}, {"name": "add_opposite.comm_semigroup", "description": ""}, {"name": "add_monoid_hom.mul_op_apply_apply", "description": ""}, {"name": "add_opposite.op_pow", "description": ""}, {"name": "mul_opposite.op_div", "description": ""}, {"name": "add_opposite.semiconj_by_unop", "description": ""}, {"name": "add_opposite.add_comm_monoid", "description": ""}, {"name": "mul_hom.unop", "description": "The 'unopposite' of a semigroup homomorphism `M\u1d50\u1d52\u1d56 \u2192\u2099* N\u1d50\u1d52\u1d56`. Inverse to `mul_hom.op`."}, {"name": "add_hom.unop", "description": "The 'unopposite' of an additive semigroup homomorphism `M\u1d43\u1d52\u1d56 \u2192\u2099+ N\u1d43\u1d52\u1d56`. Inverse\nto `add_hom.op`."}, {"name": "commute.op", "description": ""}, {"name": "mul_equiv.op_apply_symm_apply", "description": ""}, {"name": "add_equiv.mul_op_apply", "description": ""}, {"name": "add_opposite.op_mul_equiv", "description": "The function `add_opposite.op` is a multiplicative equivalence."}, {"name": "mul_opposite.semiconj_by_unop", "description": ""}, {"name": "mul_opposite.add_group_with_one", "description": ""}, {"name": "add_opposite.right_cancel_add_monoid", "description": ""}, {"name": "add_opposite.cancel_add_comm_monoid", "description": ""}, {"name": "mul_opposite.add_right_cancel_semigroup", "description": ""}, {"name": "mul_opposite.commute.unop", "description": ""}, {"name": "add_equiv.mul_op_symm_apply", "description": ""}, {"name": "mul_opposite.right_cancel_monoid", "description": ""}, {"name": "monoid_hom.unop", "description": "The 'unopposite' of a monoid homomorphism `M\u1d50\u1d52\u1d56 \u2192* N\u1d50\u1d52\u1d56`. Inverse to `monoid_hom.op`."}, {"name": "mul_opposite.sub_neg_monoid", "description": ""}, {"name": "mul_opposite.division_monoid", "description": ""}, {"name": "mul_equiv.op_apply_apply", "description": ""}, {"name": "add_equiv.op_apply_apply", "description": ""}, {"name": "mul_opposite.div_inv_monoid", "description": ""}, {"name": "add_opposite.monoid", "description": ""}, {"name": "mul_opposite.division_comm_monoid", "description": ""}, {"name": "mul_opposite.op_add_equiv_apply", "description": ""}, {"name": "add_opposite.commute_unop", "description": ""}, {"name": "mul_hom.to_opposite", "description": " A semigroup homomorphism `f : M \u2192\u2099* N` such that `f x` commutes with `f y` for all `x, y`\ndefines a semigroup homomorphism to `N\u1d50\u1d52\u1d56`."}, {"name": "add_monoid_hom.mul_op_ext", "description": " This ext lemma change equalities on `\u03b1\u1d50\u1d52\u1d56 \u2192+ \u03b2` to equalities on `\u03b1 \u2192+ \u03b2`.\nThis is useful because there are often ext lemmas for specific `\u03b1`s that will apply\nto an equality of `\u03b1 \u2192+ \u03b2` such as `finsupp.add_hom_ext'`."}, {"name": "add_opposite.add_comm_group", "description": ""}, {"name": "mul_opposite.op_add_equiv_to_equiv", "description": ""}, {"name": "units.coe_unop_op_equiv", "description": ""}, {"name": "mul_opposite.unop_div", "description": ""}, {"name": "monoid_hom.to_opposite_apply", "description": ""}, {"name": "add_opposite.left_cancel_add_semigroup", "description": ""}, {"name": "add_opposite.semigroup", "description": ""}, {"name": "mul_opposite.comm_monoid", "description": ""}, {"name": "mul_hom.op_apply_apply", "description": ""}, {"name": "add_opposite.right_cancel_add_semigroup", "description": ""}, {"name": "add_opposite.add_group", "description": ""}, {"name": "mul_opposite.semigroup", "description": ""}, {"name": "monoid_hom.to_opposite", "description": " A monoid homomorphism `f : M \u2192* N` such that `f x` commutes with `f y` for all `x, y` defines\na monoid homomorphism to `N\u1d50\u1d52\u1d56`."}, {"name": "add_opposite.subtraction_comm_monoid", "description": ""}, {"name": "add_hom.op_symm_apply_apply", "description": ""}, {"name": "mul_opposite.add_zero_class", "description": ""}, {"name": "add_commute.op", "description": ""}, {"name": "mul_opposite.add_left_cancel_semigroup", "description": ""}, {"name": "add_opposite.comm_group", "description": ""}, {"name": "add_equiv.mul_op", "description": "A iso `\u03b1 \u2243+ \u03b2` can equivalently be viewed as an iso `\u03b1\u1d50\u1d52\u1d56 \u2243+ \u03b2\u1d50\u1d52\u1d56`."}, {"name": "mul_opposite.semiconj_by_op", "description": ""}, {"name": "add_opposite.add_comm_semigroup", "description": ""}, {"name": "add_opposite.div_inv_monoid", "description": ""}, {"name": "tactic.library_search_hole_cmd", "description": " Invoking the hole command `library_search` (\"Use `library_search` to complete the goal\") calls\nthe tactic `library_search` to produce a proof term with the type of the hole.\n\nRunning it on\n\n```lean\nexample : 0 < 1 :=\n{!!}\n```\n\nproduces\n\n```lean\nexample : 0 < 1 :=\nnat.one_pos\n```"}, {"name": "tactic.suggest.unpack_iff_both", "description": "We unpack any element of a list of `decl_data` corresponding to an `\u2194` statement that could apply\nin both directions into two separate elements.\n\nThis ensures that both directions can be independently returned by `suggest`,\nand avoids a problem where the application of one direction prevents\nthe application of the other direction. (See `exp_le_exp` in the tests.)"}, {"name": "tactic.suggest.head_symbol_match.decidable_eq", "description": ""}, {"name": "tactic.suggest.head_symbol_match.inhabited", "description": ""}, {"name": "tactic.suggest.suggest_opt.mk_accept", "description": "Convert a `suggest_opt` structure to a `opt` structure suitable for `solve_by_elim`,\nby setting the `accept` parameter to require that all complete solutions\nuse everything in `compulsory_hyps`."}, {"name": "tactic.suggest_scripts", "description": "Returns a list of at most `limit` strings, of the form `Try this: exact ...` or\n`Try this: refine ...`, which make progress on the current goal using a declaration\nfrom the library."}, {"name": "tactic.library_search", "description": "Returns a string of the form `Try this: exact ...`, which closes the current goal."}, {"name": "tactic.suggest.head_symbol_match.to_string", "description": "a textual representation of a `head_symbol_match`, for trace debugging."}, {"name": "tactic_doc.hole_command.library_search", "description": " Invoking the hole command `library_search` (\"Use `library_search` to complete the goal\") calls\nthe tactic `library_search` to produce a proof term with the type of the hole.\n\nRunning it on\n\n```lean\nexample : 0 < 1 :=\n{!!}\n```\n\nproduces\n\n```lean\nexample : 0 < 1 :=\nnat.one_pos\n```"}, {"name": "tactic.suggest.normalize_synonym", "description": " Map a name (typically a head symbol) to a \"canonical\" definitional synonym.\nGiven a name `n`, we want a name `n'` such that a sufficiently applied\nexpression with head symbol `n` is always definitionally equal to an expression\nwith head symbol `n'`.\nThus, we can search through all lemmas with a result type of `n'`\nto solve a goal with head symbol `n`.\n\nFor example, `>` is mapped to `<` because `a > b` is definitionally equal to `b < a`,\nand `not` is mapped to `false` because `\u00ac a` is definitionally equal to `p \u2192 false`\nThe default is that the original argument is returned, so `<` is just mapped to `<`.\n\n`normalize_synonym` is called for every lemma in the library, so it needs to be fast."}, {"name": "tactic.suggest.match_head_symbol", "description": "Determine if, and in which way, a given expression matches the specified head symbol."}, {"name": "tactic.interactive.library_search", "description": "`library_search` is a tactic to identify existing lemmas in the library. It tries to close the\ncurrent goal by applying a lemma from the library, then discharging any new goals using\n`solve_by_elim`.\n\nIf it succeeds, it prints a trace message `exact ...` which can replace the invocation\nof `library_search`.\n\nTypical usage is:\n```lean\nexample (n m k : \u2115) : n * (m - k) = n * m - n * k :=\nby library_search -- Try this: exact mul_tsub n m k\n```\n\n`library_search using h\u2081 h\u2082` will only show solutions\nthat make use of the local hypotheses `h\u2081` and `h\u2082`.\n\nBy default `library_search` only unfolds `reducible` definitions\nwhen attempting to match lemmas against the goal.\nPreviously, it would unfold most definitions, sometimes giving surprising answers, or slow answers.\nThe old behaviour is still available via `library_search!`.\n\nYou can add additional lemmas to be used along with local hypotheses\nafter the application of a library lemma,\nusing the same syntax as for `solve_by_elim`, e.g.\n```lean\nexample {a b c d: nat} (h\u2081 : a < c) (h\u2082 : b < d) : max (c + d) (a + b) = (c + d) :=\nbegin\n  library_search [add_lt_add], -- Says: `Try this: exact max_eq_left_of_lt (add_lt_add h\u2081 h\u2082)`\nend\n```\nYou can also use `library_search with attr` to include all lemmas with the attribute `attr`."}, {"name": "tactic.suggest.apply_and_solve", "description": "Apply the lemma `e`, then attempt to close all goals using\n`solve_by_elim opt`, failing if `close_goals = tt`\nand there are any goals remaining.\n\nReturns the number of subgoals which were closed using `solve_by_elim`."}, {"name": "tactic.suggest_core", "description": "The core `suggest` tactic.\nIt attempts to apply a declaration from the library,\nthen solve new goals using `solve_by_elim`.\n\nIt returns a list of `application`s consisting of fields:\n* `state`, a tactic state resulting from the successful application of a declaration from\n  the library,\n* `script`, a string of the form `Try this: refine ...` or `Try this: exact ...` which will\n  reproduce that tactic state,\n* `decl`, an `option declaration` indicating the declaration that was applied\n  (or none, if `solve_by_elim` succeeded),\n* `num_goals`, the number of remaining goals, and\n* `hyps_used`, the number of local hypotheses used in the solution."}, {"name": "tactic.suggest.head_symbol_match", "description": "A declaration can match the head symbol of the current goal in four possible ways:\n* `ex`  : an exact match\n* `mp`  : the declaration returns an `iff`, and the right hand side matches the goal\n* `mpr` : the declaration returns an `iff`, and the left hand side matches the goal\n* `both`: the declaration returns an `iff`, and the both sides match the goal"}, {"name": "tactic.suggest.head_symbol_match.ex", "description": "A declaration can match the head symbol of the current goal in four possible ways:\n* `ex`  : an exact match\n* `mp`  : the declaration returns an `iff`, and the right hand side matches the goal\n* `mpr` : the declaration returns an `iff`, and the left hand side matches the goal\n* `both`: the declaration returns an `iff`, and the both sides match the goal"}, {"name": "tactic.suggest.head_symbol_match.mp", "description": "A declaration can match the head symbol of the current goal in four possible ways:\n* `ex`  : an exact match\n* `mp`  : the declaration returns an `iff`, and the right hand side matches the goal\n* `mpr` : the declaration returns an `iff`, and the left hand side matches the goal\n* `both`: the declaration returns an `iff`, and the both sides match the goal"}, {"name": "tactic.suggest.head_symbol_match.mpr", "description": "A declaration can match the head symbol of the current goal in four possible ways:\n* `ex`  : an exact match\n* `mp`  : the declaration returns an `iff`, and the right hand side matches the goal\n* `mpr` : the declaration returns an `iff`, and the left hand side matches the goal\n* `both`: the declaration returns an `iff`, and the both sides match the goal"}, {"name": "tactic.suggest.head_symbol_match.both", "description": "A declaration can match the head symbol of the current goal in four possible ways:\n* `ex`  : an exact match\n* `mp`  : the declaration returns an `iff`, and the right hand side matches the goal\n* `mpr` : the declaration returns an `iff`, and the left hand side matches the goal\n* `both`: the declaration returns an `iff`, and the both sides match the goal"}, {"name": "tactic.suggest.process_declaration", "description": "Generate a `decl_data` from the given declaration if\nit matches the head symbol `hs` for the current goal."}, {"name": "tactic.suggest.allowed_head_symbols", "description": "Compute the head symbol of an expression, then normalise synonyms.\n\nThis is only used when analysing the goal, so it is okay to do more expensive analysis here."}, {"name": "tactic.suggest.decl_data", "description": " A package of `declaration` metadata, including the way in which its type matches the head symbol\nwhich we are searching for."}, {"name": "tactic.suggest.decl_data.d", "description": " A package of `declaration` metadata, including the way in which its type matches the head symbol\nwhich we are searching for."}, {"name": "tactic.suggest.decl_data.n", "description": " A package of `declaration` metadata, including the way in which its type matches the head symbol\nwhich we are searching for."}, {"name": "tactic.suggest.decl_data.m", "description": " A package of `declaration` metadata, including the way in which its type matches the head symbol\nwhich we are searching for."}, {"name": "tactic.suggest.decl_data.l", "description": " A package of `declaration` metadata, including the way in which its type matches the head symbol\nwhich we are searching for."}, {"name": "tactic.suggest", "description": "See `suggest_core`.\n\nReturns a list of at most `limit` `application`s,\nsorted by number of goals, and then (reverse) number of hypotheses used."}, {"name": "tactic.suggest.application", "description": "An `application` records the result of a successful application of a library lemma."}, {"name": "tactic.suggest.application.state", "description": "An `application` records the result of a successful application of a library lemma."}, {"name": "tactic.suggest.application.script", "description": "An `application` records the result of a successful application of a library lemma."}, {"name": "tactic.suggest.application.decl", "description": "An `application` records the result of a successful application of a library lemma."}, {"name": "tactic.suggest.application.num_goals", "description": "An `application` records the result of a successful application of a library lemma."}, {"name": "tactic.suggest.application.hyps_used", "description": "An `application` records the result of a successful application of a library lemma."}, {"name": "tactic.suggest.suggest_opt", "description": " An extension to the option structure for `solve_by_elim`.\n* `compulsory_hyps` specifies a list of local hypotheses which must appear in any solution.\n  These are useful for constraining the results from `library_search` and `suggest`.\n* `try_this` is a flag (default: `tt`) that controls whether a \"Try this:\"-line should be traced."}, {"name": "tactic.suggest.suggest_opt.to_opt", "description": " An extension to the option structure for `solve_by_elim`.\n* `compulsory_hyps` specifies a list of local hypotheses which must appear in any solution.\n  These are useful for constraining the results from `library_search` and `suggest`.\n* `try_this` is a flag (default: `tt`) that controls whether a \"Try this:\"-line should be traced."}, {"name": "tactic.suggest.suggest_opt.compulsory_hyps", "description": " An extension to the option structure for `solve_by_elim`.\n* `compulsory_hyps` specifies a list of local hypotheses which must appear in any solution.\n  These are useful for constraining the results from `library_search` and `suggest`.\n* `try_this` is a flag (default: `tt`) that controls whether a \"Try this:\"-line should be traced."}, {"name": "tactic.suggest.suggest_opt.try_this", "description": " An extension to the option structure for `solve_by_elim`.\n* `compulsory_hyps` specifies a list of local hypotheses which must appear in any solution.\n  These are useful for constraining the results from `library_search` and `suggest`.\n* `try_this` is a flag (default: `tt`) that controls whether a \"Try this:\"-line should be traced."}, {"name": "tactic.interactive.suggest", "description": "`suggest` tries to apply suitable theorems/defs from the library, and generates\na list of `exact ...` or `refine ...` scripts that could be used at this step.\nIt leaves the tactic state unchanged. It is intended as a complement of the search\nfunction in your editor, the `#find` tactic, and `library_search`.\n\n`suggest` takes an optional natural number `num` as input and returns the first `num`\n(or less, if all possibilities are exhausted) possibilities ordered by length of lemma names.\nThe default for `num` is `50`.\nFor performance reasons `suggest` uses monadic lazy lists (`mllist`). This means that\n`suggest` might miss some results if `num` is not large enough. However, because\n`suggest` uses monadic lazy lists, smaller values of `num` run faster than larger values.\n\nYou can add additional lemmas to be used along with local hypotheses\nafter the application of a library lemma,\nusing the same syntax as for `solve_by_elim`, e.g.\n```lean\nexample {a b c d: nat} (h\u2081 : a < c) (h\u2082 : b < d) : max (c + d) (a + b) = (c + d) :=\nbegin\n  suggest [add_lt_add], -- Says: `Try this: exact max_eq_left_of_lt (add_lt_add h\u2081 h\u2082)`\nend\n```\nYou can also use `suggest with attr` to include all lemmas with the attribute `attr`."}, {"name": "tactic_doc.tactic.library_search", "description": "`library_search` is a tactic to identify existing lemmas in the library. It tries to close the\ncurrent goal by applying a lemma from the library, then discharging any new goals using\n`solve_by_elim`.\n\nIf it succeeds, it prints a trace message `exact ...` which can replace the invocation\nof `library_search`.\n\nTypical usage is:\n```lean\nexample (n m k : \u2115) : n * (m - k) = n * m - n * k :=\nby library_search -- Try this: exact mul_tsub n m k\n```\n\n`library_search using h\u2081 h\u2082` will only show solutions\nthat make use of the local hypotheses `h\u2081` and `h\u2082`.\n\nBy default `library_search` only unfolds `reducible` definitions\nwhen attempting to match lemmas against the goal.\nPreviously, it would unfold most definitions, sometimes giving surprising answers, or slow answers.\nThe old behaviour is still available via `library_search!`.\n\nYou can add additional lemmas to be used along with local hypotheses\nafter the application of a library lemma,\nusing the same syntax as for `solve_by_elim`, e.g.\n```lean\nexample {a b c d: nat} (h\u2081 : a < c) (h\u2082 : b < d) : max (c + d) (a + b) = (c + d) :=\nbegin\n  library_search [add_lt_add], -- Says: `Try this: exact max_eq_left_of_lt (add_lt_add h\u2081 h\u2082)`\nend\n```\nYou can also use `library_search with attr` to include all lemmas with the attribute `attr`."}, {"name": "tactic.suggest.library_defs", "description": "Retrieve all library definitions with a given head symbol."}, {"name": "tactic_doc.tactic.suggest", "description": "`suggest` lists possible usages of the `refine` tactic and leaves the tactic state unchanged.\nIt is intended as a complement of the search function in your editor, the `#find` tactic, and\n`library_search`.\n\n`suggest` takes an optional natural number `num` as input and returns the first `num` (or less, if\nall possibilities are exhausted) possibilities ordered by length of lemma names.\nThe default for `num` is `50`.\n\n`suggest using h\u2081 h\u2082` will only show solutions that make use of the local hypotheses `h\u2081` and `h\u2082`.\n\nFor performance reasons `suggest` uses monadic lazy lists (`mllist`). This means that `suggest`\nmight miss some results if `num` is not large enough. However, because `suggest` uses monadic\nlazy lists, smaller values of `num` run faster than larger values.\n\nAn example of `suggest` in action,\n\n```lean\nexample (n : nat) : n < n + 1 :=\nbegin suggest, sorry end\n```\n\nprints the list,\n\n```lean\nTry this: exact nat.lt.base n\nTry this: exact nat.lt_succ_self n\nTry this: refine not_le.mp _\nTry this: refine gt_iff_lt.mp _\nTry this: refine nat.lt.step _\nTry this: refine lt_of_not_ge _\n...\n```"}, {"name": "tactic.suggest.apply_declaration", "description": "Apply the declaration `d` (or the forward and backward implications separately, if it is an `iff`),\nand then attempt to solve the subgoal using `apply_and_solve`.\n\nReturns the number of subgoals successfully closed."}, {"name": "module_info.has_repr", "description": ""}, {"name": "module_info.of_module_name", "description": "Retrieves the module with the given `module_name`.\n\n**ONLY USE THIS FUNCTION IN (CI) SCRIPTS!**\n\nThis function is constant-time if the module is already a dependency."}, {"name": "module_info.of_module_id", "description": "Retrieves the module with the given `module_id`.\n\n**ONLY USE THIS FUNCTION IN (CI) SCRIPTS!**\n\nThis function is constant-time if the module is already a dependency."}, {"name": "environment.for_decl_of_imported_module", "description": "Creates an environment containing the module `id` until `decl_name` including dependencies.\n\n**ONLY USE THIS FUNCTION IN (CI) SCRIPTS!**"}, {"name": "module_info.id", "description": "Returns the `module_id` of the module."}, {"name": "environment.from_imported_module_name", "description": "Creates an environment containing the module `name` including dependencies.\n\n**ONLY USE THIS FUNCTION IN (CI) SCRIPTS!**"}, {"name": "module_info.has_to_tactic_format", "description": ""}, {"name": "module_info.module_id", "description": "The absolute path to the `.lean` file containing the module (e.g. `\".../data/dlist.lean\"`)."}, {"name": "environment.import_only", "description": "Imports only the module (without the dependencies) into an environment.\n\n**ONLY USE THIS FUNCTION IN (CI) SCRIPTS!**"}, {"name": "environment.import_dependencies", "description": "Imports the dependencies of a module into an environment.\n\n**ONLY USE THIS FUNCTION IN (CI) SCRIPTS!**\n\nAlready imported dependencies will not be imported twice."}, {"name": "module_info", "description": "Information about a currently loaded module (such as `data.dlist`)."}, {"name": "module_info.resolve_module_name", "description": "Resolves a `module_name` to `module_id`, using the global search path.\n\n**ONLY USE THIS FUNCTION IN (CI) SCRIPTS!**"}, {"name": "environment.for_decl_of_imported_module_name", "description": "Creates an environment containing the module `name` until declaration `decl_name`\nincluding dependencies.\n\n**ONLY USE THIS FUNCTION IN (CI) SCRIPTS!**"}, {"name": "environment.import_only_until_decl", "description": "Imports all declarations until `decl_name` of the module (without the dependencies) into an environment.\n\n**ONLY USE THIS FUNCTION IN (CI) SCRIPTS!**"}, {"name": "environment.from_imported_module", "description": "Creates an environment containing the module `id` including dependencies.\n\n**ONLY USE THIS FUNCTION IN (CI) SCRIPTS!**\n\nThe environment `from_imported_module \".../data/dlist.lean\"` is roughly equivalent to\nthe environment at the end of a file containing just `import data.dlist`."}, {"name": "module_info.module_name", "description": "The name of the module, as used in an import command (e.g. `data.dlist`)."}, {"name": "environment.import'", "description": "Imports a module including dependencies into an environment.\n\n**ONLY USE THIS FUNCTION IN (CI) SCRIPTS!**"}, {"name": "environment.import_until_decl", "description": "Imports a module until `decl_name` including dependencies into an environment.\n\n**ONLY USE THIS FUNCTION IN (CI) SCRIPTS!**"}, {"name": "module_info.has_to_string", "description": ""}, {"name": "module_info.has_to_format", "description": ""}, {"name": "cc_state.mk_using_hs_core", "description": "Create a congruence closure state object using the hypotheses in the current goal."}, {"name": "tactic.cc_dbg_core", "description": ""}, {"name": "cc_state.mk_using_hs", "description": ""}, {"name": "tactic.cc_core", "description": ""}, {"name": "cc_state.roots", "description": ""}, {"name": "cc_state.mt", "description": " \"Modification Time\". The field m_mt is used to implement the mod-time optimization introduce by the Simplify theorem prover.\nThe basic idea is to introduce a counter gmt that records the number of heuristic instantiation that have\noccurred in the current branch. It is incremented after each round of heuristic instantiation.\nThe field m_mt records the last time any proper descendant of of thie entry was involved in a merge."}, {"name": "cc_state.proof_for", "description": "`proof_for cc e` constructs a proof for e if it is equivalent to true in cc_state"}, {"name": "cc_state.add", "description": " Add the given proof term as a new rule.\nThe proof term p must be an `eq _ _`, `heq _ _`, `iff _ _`, or a negation of these."}, {"name": "tactic.cc", "description": ""}, {"name": "cc_state.refutation_for", "description": "`refutation_for cc e` constructs a proof for `not e` if it is equivalent to false in cc_state"}, {"name": "cc_state.pp_eqc", "description": "Pretty print the entry associated with the given expression."}, {"name": "cc_state.is_cg_root", "description": "Check if `e` is the root of the congruence class."}, {"name": "cc_state.eqc_size", "description": ""}, {"name": "cc_state.eqc_of", "description": ""}, {"name": "cc_state.eqc_of_core", "description": ""}, {"name": "cc_state.root", "description": "Get the root representative of the given expression."}, {"name": "cc_state", "description": " Congruence closure state.\nThis may be considered to be a set of expressions and an equivalence class over this set.\nThe equivalence class is generated by the equational rules that are added to the cc_state and congruence,\nthat is, if `a = b` then `f(a) = f(b)` and so on."}, {"name": "cc_state.mk_core", "description": ""}, {"name": "tactic.ac_refl", "description": ""}, {"name": "tactic.cc_dbg", "description": ""}, {"name": "cc_state.roots_core", "description": " Returns the root expression for each equivalence class in the graph.\nIf the bool argument is set to true then it only returns roots of non-singleton classes."}, {"name": "cc_state.gmt", "description": " \"Global Modification Time\". gmt is a number stored on the cc_state,\nit is compared with the modification time of a cc_entry in e-matching. See `cc_state.mt`."}, {"name": "cc_state.mk", "description": ""}, {"name": "cc_state.inconsistent", "description": "Returns true if the cc_state is inconsistent. For example if it had both `a = b` and `a \u2260 b` in it."}, {"name": "cc_state.in_singlenton_eqc", "description": ""}, {"name": "cc_state.mfold_eqc", "description": ""}, {"name": "cc_state.pp_core", "description": " Pretty print the entire cc graph.\nIf the bool argument is set to true then singleton equivalence classes will be omitted."}, {"name": "cc_state.fold_eqc_core", "description": ""}, {"name": "cc_state.inc_gmt", "description": "Increment the Global Modification time."}, {"name": "cc_state.has_to_tactic_format", "description": ""}, {"name": "cc_state.is_not_eqv", "description": "Check whether two expressions are not in the same equivalence class."}, {"name": "cc_state.next", "description": " Get the next element in the equivalence class.\nNote that if the given expr e is not in the graph then it will just return e."}, {"name": "cc_state.proof_for_false", "description": "If the given state is inconsistent, return a proof for false. Otherwise fail."}, {"name": "cc_state.internalize", "description": "Add the given expression to the graph."}, {"name": "cc_config", "description": ""}, {"name": "cc_config.ignore_instances", "description": ""}, {"name": "cc_config.ac", "description": ""}, {"name": "cc_config.ho_fns", "description": ""}, {"name": "cc_config.em", "description": ""}, {"name": "cc_state.is_eqv", "description": "Check whether two expressions are in the same equivalence class."}, {"name": "cc_state.eqv_proof", "description": "Returns a proof term that the given terms are equivalent in the given cc_state"}, {"name": "cc_state.fold_eqc", "description": ""}, {"name": "put", "description": "Set the top-most state of a monad stack."}, {"name": "state", "description": ""}, {"name": "state_t.monad_map", "description": ""}, {"name": "state_t.bind", "description": ""}, {"name": "state_t", "description": ""}, {"name": "state_t.run", "description": ""}, {"name": "state_t.put", "description": ""}, {"name": "monad_state_adapter_trans", "description": ""}, {"name": "monad_state", "description": "An implementation of [MonadState](https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html).\n   In contrast to the Haskell implementation, we use overlapping instances to derive instances\n   automatically from `monad_lift`.\n\n   Note: This class can be seen as a simplification of the more \"principled\" definition\n   ```lean\n   class monad_state_lift (\u03c3 : out_param (Type u)) (n : Type u \u2192 Type u) :=\n   (lift {\u03b1 : Type u} : (\u2200 {m : Type u \u2192 Type u} [monad m], state_t \u03c3 m \u03b1) \u2192 n \u03b1)\n   ```\n   which better describes the intent of \"we can lift a `state_t` from anywhere in the monad stack\".\n   However, by parametricity the types `\u2200 m [monad m], \u03c3 \u2192 m (\u03b1 \u00d7 \u03c3)` and `\u03c3 \u2192 \u03b1 \u00d7 \u03c3` should be\n   equivalent because the only way to obtain an `m` is through `pure`."}, {"name": "monad_state.lift", "description": "An implementation of [MonadState](https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html).\n   In contrast to the Haskell implementation, we use overlapping instances to derive instances\n   automatically from `monad_lift`.\n\n   Note: This class can be seen as a simplification of the more \"principled\" definition\n   ```lean\n   class monad_state_lift (\u03c3 : out_param (Type u)) (n : Type u \u2192 Type u) :=\n   (lift {\u03b1 : Type u} : (\u2200 {m : Type u \u2192 Type u} [monad m], state_t \u03c3 m \u03b1) \u2192 n \u03b1)\n   ```\n   which better describes the intent of \"we can lift a `state_t` from anywhere in the monad stack\".\n   However, by parametricity the types `\u2200 m [monad m], \u03c3 \u2192 m (\u03b1 \u00d7 \u03c3)` and `\u03c3 \u2192 \u03b1 \u00d7 \u03c3` should be\n   equivalent because the only way to obtain an `m` is through `pure`."}, {"name": "state_t.monad_except", "description": ""}, {"name": "monad_state_adapter", "description": "Adapt a monad stack, changing the type of its top-most state.\n\n   This class is comparable to [Control.Lens.Zoom](https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Zoom.html#t:Zoom), but does not use lenses (yet?), and is derived automatically for any transformer implementing `monad_functor`.\n\n   For zooming into a part of the state, the `split` function should split \u03c3 into the part \u03c3' and the \"context\" \u03c3'' so that the potentially modified \u03c3' and the context can be rejoined by `join` in the end.\n   In the simplest case, the context can be chosen as the full outer state (ie. `\u03c3'' = \u03c3`), which makes `split` and `join` simpler to define. However, note that the state will not be used linearly in this case.\n\n   Example:\n   ```lean\n   def zoom_fst {\u03b1 \u03c3 \u03c3' : Type} : state \u03c3 \u03b1 \u2192 state (\u03c3 \u00d7 \u03c3') \u03b1 :=\n   adapt_state id prod.mk\n   ```\n\n   The function can also zoom out into a \"larger\" state, where the new parts are supplied by `split` and discarded by `join` in the end. The state is therefore not used linearly anymore but merely affinely, which is not a practically relevant distinction in Lean.\n\n   Example:\n   ```lean\n   def with_snd {\u03b1 \u03c3 \u03c3' : Type} (snd : \u03c3') : state (\u03c3 \u00d7 \u03c3') \u03b1 \u2192 state \u03c3 \u03b1 :=\n   adapt_state (\u03bb st, ((st, snd), ())) (\u03bb \u27e8st,snd\u27e9 _, st)\n   ```\n\n   Note: This class can be seen as a simplification of the more \"principled\" definition\n   ```lean\n   class monad_state_functor (\u03c3 \u03c3' : out_param (Type u)) (n n' : Type u \u2192 Type u) :=\n   (map {\u03b1 : Type u} : (\u2200 {m : Type u \u2192 Type u} [monad m], state_t \u03c3 m \u03b1 \u2192 state_t \u03c3' m \u03b1) \u2192 n \u03b1 \u2192 n' \u03b1)\n   ```\n   which better describes the intent of \"we can map a `state_t` anywhere in the monad stack\".\n   If we look at the unfolded type of the first argument `\u2200 m [monad m], (\u03c3 \u2192 m (\u03b1 \u00d7 \u03c3)) \u2192 \u03c3' \u2192 m (\u03b1 \u00d7 \u03c3')`, we see that it has the lens type `\u2200 f [functor f], (\u03b1 \u2192 f \u03b1) \u2192 \u03b2 \u2192 f \u03b2` with `f` specialized to `\u03bb \u03c3, m (\u03b1 \u00d7 \u03c3)` (exercise: show that this is a lawful functor). We can build all lenses we are insterested in from the functions `split` and `join` as\n   ```lean\n   \u03bb f _ st, let (st, ctx) := split st in\n             (\u03bb st', join st' ctx) <$> f st\n   ```"}, {"name": "monad_state_adapter.adapt_state", "description": "Adapt a monad stack, changing the type of its top-most state.\n\n   This class is comparable to [Control.Lens.Zoom](https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Zoom.html#t:Zoom), but does not use lenses (yet?), and is derived automatically for any transformer implementing `monad_functor`.\n\n   For zooming into a part of the state, the `split` function should split \u03c3 into the part \u03c3' and the \"context\" \u03c3'' so that the potentially modified \u03c3' and the context can be rejoined by `join` in the end.\n   In the simplest case, the context can be chosen as the full outer state (ie. `\u03c3'' = \u03c3`), which makes `split` and `join` simpler to define. However, note that the state will not be used linearly in this case.\n\n   Example:\n   ```lean\n   def zoom_fst {\u03b1 \u03c3 \u03c3' : Type} : state \u03c3 \u03b1 \u2192 state (\u03c3 \u00d7 \u03c3') \u03b1 :=\n   adapt_state id prod.mk\n   ```\n\n   The function can also zoom out into a \"larger\" state, where the new parts are supplied by `split` and discarded by `join` in the end. The state is therefore not used linearly anymore but merely affinely, which is not a practically relevant distinction in Lean.\n\n   Example:\n   ```lean\n   def with_snd {\u03b1 \u03c3 \u03c3' : Type} (snd : \u03c3') : state (\u03c3 \u00d7 \u03c3') \u03b1 \u2192 state \u03c3 \u03b1 :=\n   adapt_state (\u03bb st, ((st, snd), ())) (\u03bb \u27e8st,snd\u27e9 _, st)\n   ```\n\n   Note: This class can be seen as a simplification of the more \"principled\" definition\n   ```lean\n   class monad_state_functor (\u03c3 \u03c3' : out_param (Type u)) (n n' : Type u \u2192 Type u) :=\n   (map {\u03b1 : Type u} : (\u2200 {m : Type u \u2192 Type u} [monad m], state_t \u03c3 m \u03b1 \u2192 state_t \u03c3' m \u03b1) \u2192 n \u03b1 \u2192 n' \u03b1)\n   ```\n   which better describes the intent of \"we can map a `state_t` anywhere in the monad stack\".\n   If we look at the unfolded type of the first argument `\u2200 m [monad m], (\u03c3 \u2192 m (\u03b1 \u00d7 \u03c3)) \u2192 \u03c3' \u2192 m (\u03b1 \u00d7 \u03c3')`, we see that it has the lens type `\u2200 f [functor f], (\u03b1 \u2192 f \u03b1) \u2192 \u03b2 \u2192 f \u03b2` with `f` specialized to `\u03bb \u03c3, m (\u03b1 \u00d7 \u03c3)` (exercise: show that this is a lawful functor). We can build all lenses we are insterested in from the functions `split` and `join` as\n   ```lean\n   \u03bb f _ st, let (st, ctx) := split st in\n             (\u03bb st', join st' ctx) <$> f st\n   ```"}, {"name": "state_t.adapt", "description": ""}, {"name": "state_t.alternative", "description": ""}, {"name": "state_t.lift", "description": ""}, {"name": "state_t.monad_state_adapter", "description": ""}, {"name": "monad_state_trans", "description": ""}, {"name": "modify", "description": "Map the top-most state of a monad stack.\n\n   Note: `modify f` may be preferable to `f <$> get >>= put` because the latter\n   does not use the state linearly (without sufficient inlining)."}, {"name": "state_t.has_monad_lift", "description": ""}, {"name": "state_t.orelse", "description": ""}, {"name": "state_t.monad_state", "description": ""}, {"name": "state_t.modify", "description": ""}, {"name": "state_t.monad_run", "description": ""}, {"name": "state_t.pure", "description": ""}, {"name": "state_t.monad", "description": ""}, {"name": "state_t.failure", "description": ""}, {"name": "state_t.monad_functor", "description": ""}, {"name": "state_t.get", "description": ""}, {"name": "get", "description": "Obtain the top-most state of a monad stack."}, {"name": "bool.band_bor_distrib_right", "description": ""}, {"name": "bool.bor_inl", "description": ""}, {"name": "bool.bxor_comm", "description": ""}, {"name": "bool.coe_bool_iff", "description": ""}, {"name": "bool.band_le_right", "description": ""}, {"name": "bool.to_bool_not", "description": ""}, {"name": "bool.bor_band_distrib_right", "description": ""}, {"name": "bool.ff_le", "description": ""}, {"name": "bool.bxor_ff_left", "description": ""}, {"name": "bool.band_comm", "description": ""}, {"name": "bool.ne_bnot", "description": ""}, {"name": "bool.band_bor_distrib_left", "description": ""}, {"name": "bool.le_band", "description": ""}, {"name": "bool.bor_le", "description": ""}, {"name": "bool.bxor_iff_ne", "description": ""}, {"name": "bool.bnot_band_self", "description": ""}, {"name": "bool.to_bool_false", "description": ""}, {"name": "bool.to_nat", "description": "convert a `bool` to a `\u2115`, `false -> 0`, `true -> 1`"}, {"name": "bool.bnot_band", "description": ""}, {"name": "bool.to_bool_true", "description": ""}, {"name": "bool.lt_iff", "description": ""}, {"name": "bool.dichotomy", "description": ""}, {"name": "bool.of_to_bool_iff", "description": ""}, {"name": "bool.bnot_inj", "description": ""}, {"name": "bool.coe_sort_ff", "description": ""}, {"name": "bool.band_le_left", "description": ""}, {"name": "bool.band_elim_left", "description": ""}, {"name": "bool.bnot_iff_not", "description": ""}, {"name": "bool.ff_eq_to_bool_iff", "description": ""}, {"name": "bool.bnot_bor", "description": ""}, {"name": "bool.eq_tt_of_bnot_eq_ff", "description": ""}, {"name": "bool.band_bxor_distrib_left", "description": ""}, {"name": "bool.coe_sort_tt", "description": ""}, {"name": "bool.ff_lt_tt", "description": ""}, {"name": "bool.forall_bool", "description": ""}, {"name": "bool.eq_tt_of_ne_ff", "description": ""}, {"name": "bool.le_tt", "description": ""}, {"name": "bool.eq_ff_of_bnot_eq_tt", "description": ""}, {"name": "bool.bnot_not_eq", "description": ""}, {"name": "bool.band_bnot_self", "description": ""}, {"name": "bool.to_bool_and", "description": ""}, {"name": "bool.cond_ff", "description": ""}, {"name": "bool.bnot_bor_self", "description": ""}, {"name": "bool.to_nat_le_to_nat", "description": ""}, {"name": "bool.eq_ff_of_ne_tt", "description": ""}, {"name": "bool.left_le_bor", "description": ""}, {"name": "bool.apply_apply_apply", "description": "**Kaminski's Equation**"}, {"name": "bool.bor_assoc", "description": ""}, {"name": "bool.cond_tt", "description": ""}, {"name": "bool.cond_to_bool", "description": ""}, {"name": "bool.to_bool_coe", "description": ""}, {"name": "bool.bnot_false", "description": ""}, {"name": "bool.bor_bnot_self", "description": ""}, {"name": "bool.bor_band_distrib_left", "description": ""}, {"name": "bool.exists_bool", "description": ""}, {"name": "bool.bxor_bnot_bnot", "description": ""}, {"name": "bool.le_iff_imp", "description": ""}, {"name": "bool.tt_eq_to_bool_iff", "description": ""}, {"name": "bool.default_bool", "description": ""}, {"name": "bool.of_nat_le_of_nat", "description": ""}, {"name": "bool.decidable_forall_bool", "description": "If `p b` is decidable for all `b : bool`, then `\u2200 b, p b` is decidable"}, {"name": "bool.bnot_ne", "description": ""}, {"name": "bool.band_intro", "description": ""}, {"name": "bool.bor_inr", "description": ""}, {"name": "bool.bxor_ff_right", "description": ""}, {"name": "bool.bnot_true", "description": ""}, {"name": "bool.decidable_exists_bool", "description": "If `p b` is decidable for all `b : bool`, then `\u2203 b, p b` is decidable"}, {"name": "bool.band_assoc", "description": ""}, {"name": "bool.bxor_left_comm", "description": ""}, {"name": "bool.band_left_comm", "description": ""}, {"name": "bool.not_eq_bnot", "description": ""}, {"name": "bool.coe_to_bool", "description": ""}, {"name": "bool.bor_left_comm", "description": ""}, {"name": "bool.right_le_bor", "description": ""}, {"name": "bool.of_nat_to_nat", "description": ""}, {"name": "bool.bxor_bnot_right", "description": ""}, {"name": "bool.band_elim_right", "description": ""}, {"name": "bool.to_bool_or", "description": ""}, {"name": "bool.of_nat", "description": "convert a `\u2115` to a `bool`, `0 -> false`, everything else -> `true`"}, {"name": "bool.linear_order", "description": ""}, {"name": "bool.bor_comm", "description": ""}, {"name": "bool.cond_bnot", "description": ""}, {"name": "bool.bxor_bnot_left", "description": ""}, {"name": "bool.injective_iff", "description": ""}, {"name": "bool.to_bool_eq", "description": ""}, {"name": "bool.band_bxor_distrib_right", "description": ""}, {"name": "bool.not_ff", "description": ""}, {"name": "bool.bxor_assoc", "description": ""}, {"name": "occurrences_repr", "description": ""}, {"name": "occurrences_to_format", "description": ""}, {"name": "occurrences.has_repr", "description": ""}, {"name": "occurrences.has_to_format", "description": ""}, {"name": "occurrences.contains", "description": ""}, {"name": "occurrences", "description": "We can specify the scope of application of some tactics using\n the following type.\n\n - all : all occurrences of a given term are considered.\n\n - pos [1, 3] : only the first and third occurrences of a given\n   term are consiered.\n\n - neg [2] : all but the second occurrence of a given term\n   are considered."}, {"name": "occurrences.all", "description": "We can specify the scope of application of some tactics using\n the following type.\n\n - all : all occurrences of a given term are considered.\n\n - pos [1, 3] : only the first and third occurrences of a given\n   term are consiered.\n\n - neg [2] : all but the second occurrence of a given term\n   are considered."}, {"name": "occurrences.pos", "description": "We can specify the scope of application of some tactics using\n the following type.\n\n - all : all occurrences of a given term are considered.\n\n - pos [1, 3] : only the first and third occurrences of a given\n   term are consiered.\n\n - neg [2] : all but the second occurrence of a given term\n   are considered."}, {"name": "occurrences.neg", "description": "We can specify the scope of application of some tactics using\n the following type.\n\n - all : all occurrences of a given term are considered.\n\n - pos [1, 3] : only the first and third occurrences of a given\n   term are consiered.\n\n - neg [2] : all but the second occurrence of a given term\n   are considered."}, {"name": "occurrences.inhabited", "description": ""}, {"name": "equiv.finite_iff", "description": ""}, {"name": "finite_iff_exists_equiv_fin", "description": ""}, {"name": "finite.of_equiv", "description": ""}, {"name": "function.bijective.finite_iff", "description": ""}, {"name": "finite.exists_equiv_fin", "description": ""}, {"name": "finite", "description": " A type is `finite` if it is in bijective correspondence to some\n`fin n`.\n\nWhile this could be defined as `nonempty (fintype \u03b1)`, it is defined\nin this way to allow there to be `finite` instances for propositions."}, {"name": "finite.intro", "description": " A type is `finite` if it is in bijective correspondence to some\n`fin n`.\n\nWhile this could be defined as `nonempty (fintype \u03b1)`, it is defined\nin this way to allow there to be `finite` instances for propositions."}, {"name": "finite.ulift.finite", "description": ""}, {"name": "finite.plift.finite", "description": ""}, {"name": "finite.of_bijective", "description": ""}, {"name": "preorder.lift", "description": " Transfer a `preorder` on `\u03b2` to a `preorder` on `\u03b1` using a function `f : \u03b1 \u2192 \u03b2`.\nSee note [reducible non-instances]."}, {"name": "order_dual.has_lt", "description": ""}, {"name": "le_trans'", "description": ""}, {"name": "dense_or_discrete", "description": ""}, {"name": "min_rec", "description": ""}, {"name": "has_compl", "description": "Set / lattice complement"}, {"name": "has_compl.compl", "description": "Set / lattice complement"}, {"name": "lt_self_iff_false", "description": ""}, {"name": "prod.swap_lt_swap", "description": ""}, {"name": "order_dual.inhabited", "description": ""}, {"name": "eq.ge", "description": " If `x = y` then `y \u2264 x`. Note: this lemma uses `y \u2264 x` instead of `x \u2265 y`, because `le` is used\nalmost exclusively in mathlib."}, {"name": "eq.le", "description": "**Alias** of `le_of_eq`."}, {"name": "has_lt.lt.trans'", "description": "**Alias** of `lt_trans'`."}, {"name": "ge_antisymm", "description": ""}, {"name": "has_le.le.antisymm", "description": "**Alias** of `le_antisymm`."}, {"name": "order_dual.has_le", "description": ""}, {"name": "has_lt.lt.not_le", "description": "**Alias** of `not_le_of_lt`."}, {"name": "partial_order.to_preorder_injective", "description": ""}, {"name": "subtype.mk_le_mk", "description": ""}, {"name": "has_lt.lt.asymm", "description": "**Alias** of `lt_asymm`."}, {"name": "has_le.le.lt_of_ne", "description": "**Alias** of `lt_of_le_of_ne`."}, {"name": "pi.sdiff_def", "description": ""}, {"name": "exists_ge_of_linear", "description": ""}, {"name": "ge.le", "description": ""}, {"name": "order_dual.partial_order.dual_dual", "description": ""}, {"name": "has_lt.lt.trans_eq'", "description": "**Alias** of `lt_of_lt_of_eq'`."}, {"name": "ne.le_iff_lt", "description": ""}, {"name": "eq_or_gt_of_le", "description": ""}, {"name": "ne.lt_or_lt", "description": ""}, {"name": "partial_order.ext", "description": ""}, {"name": "has_le.le.le_or_le", "description": ""}, {"name": "ne.not_le_or_not_le", "description": ""}, {"name": "has_le.le.eq_of_not_lt", "description": "**Alias** of `eq_of_le_of_not_lt`."}, {"name": "decidable.le_iff_eq_or_lt", "description": ""}, {"name": "le_of_le_of_eq", "description": ""}, {"name": "lt_imp_lt_of_le_imp_le", "description": ""}, {"name": "le_rfl", "description": "A version of `le_refl` where the argument is implicit"}, {"name": "forall_lt_iff_le", "description": ""}, {"name": "exists_between", "description": ""}, {"name": "order_dual.linear_order.dual_dual", "description": ""}, {"name": "has_lt.lt.gt", "description": ""}, {"name": "has_le.le.trans_lt'", "description": "**Alias** of `lt_of_le_of_lt'`."}, {"name": "pi.lt_def", "description": ""}, {"name": "le_of_forall_lt'", "description": ""}, {"name": "has_le.le.trans'", "description": "**Alias** of `le_trans'`."}, {"name": "not_lt_of_le", "description": ""}, {"name": "has_le.le.lt_or_le", "description": ""}, {"name": "has_le.le.eq_or_gt", "description": "**Alias** of `eq_or_gt_of_le`."}, {"name": "order_dual.preorder.dual_dual", "description": ""}, {"name": "lt_or_lt_iff_ne", "description": "A version of `ne_iff_lt_or_gt` with LHS and RHS reversed."}, {"name": "lt_of_lt_of_eq'", "description": ""}, {"name": "is_irrefl.compl", "description": ""}, {"name": "eq_of_le_of_forall_ge_of_dense", "description": ""}, {"name": "subtype.mk_lt_mk", "description": ""}, {"name": "prod.lt_iff", "description": ""}, {"name": "as_linear_order", "description": " Type synonym to create an instance of `linear_order` from a `partial_order` and\n`is_total \u03b1 (\u2264)`"}, {"name": "subrelation_iff_le", "description": ""}, {"name": "gt.lt", "description": ""}, {"name": "subtype.preorder", "description": ""}, {"name": "ne.lt_of_le", "description": ""}, {"name": "gt_iff_lt", "description": ""}, {"name": "pi.partial_order", "description": ""}, {"name": "has_inf", "description": "Typeclass for the `\u2293` (`\\glb`) notation"}, {"name": "has_inf.inf", "description": "Typeclass for the `\u2293` (`\\glb`) notation"}, {"name": "punit.densely_ordered", "description": ""}, {"name": "prod.preorder", "description": ""}, {"name": "densely_ordered", "description": "An order is dense if there is an element between any pair of distinct elements."}, {"name": "densely_ordered.dense", "description": "An order is dense if there is an element between any pair of distinct elements."}, {"name": "subtype.partial_order", "description": ""}, {"name": "linear_order.lift", "description": " Transfer a `linear_order` on `\u03b2` to a `linear_order` on `\u03b1` using an injective\nfunction `f : \u03b1 \u2192 \u03b2`. This version takes `[has_sup \u03b1]` and `[has_inf \u03b1]` as arguments, then uses\nthem for `max` and `min` fields. See `linear_order.lift'` for a version that autogenerates `min` and\n`max` fields. See note [reducible non-instances]."}, {"name": "eq.trans_lt", "description": "**Alias** of `lt_of_eq_of_lt`."}, {"name": "ge_of_eq", "description": ""}, {"name": "le_of_eq_of_le'", "description": ""}, {"name": "pi.sdiff_apply", "description": ""}, {"name": "has_lt.lt.ne", "description": "**Alias** of `ne_of_lt`."}, {"name": "order_dual.has_zero", "description": ""}, {"name": "not_le_of_lt", "description": ""}, {"name": "has_lt.lt.not_lt", "description": "**Alias** of `lt_asymm`."}, {"name": "pi.compl_apply", "description": ""}, {"name": "punit.max_eq", "description": ""}, {"name": "has_lt.lt.trans", "description": "**Alias** of `lt_trans`."}, {"name": "order_dual.subsingleton", "description": ""}, {"name": "partial_order.lift", "description": " Transfer a `partial_order` on `\u03b2` to a `partial_order` on `\u03b1` using an injective\nfunction `f : \u03b1 \u2192 \u03b2`. See note [reducible non-instances]."}, {"name": "max_rec'", "description": ""}, {"name": "not_lt_iff_eq_or_lt", "description": ""}, {"name": "order_dual.nonempty", "description": ""}, {"name": "max_rec", "description": ""}, {"name": "update_le_iff", "description": ""}, {"name": "as_linear_order.linear_order", "description": ""}, {"name": "le_of_forall_ge_of_dense", "description": ""}, {"name": "pi.has_compl", "description": ""}, {"name": "has_lt.lt.trans_le", "description": "**Alias** of `lt_of_lt_of_le`."}, {"name": "is_refl.compl", "description": ""}, {"name": "punit.min_eq", "description": ""}, {"name": "order_dual.preorder", "description": ""}, {"name": "has_le.le.trans_eq'", "description": "**Alias** of `le_of_le_of_eq'`."}, {"name": "order.preimage.decidable", "description": "The preimage of a decidable order is decidable."}, {"name": "punit.le", "description": ""}, {"name": "ge_iff_le", "description": ""}, {"name": "has_le.le.lt_of_not_le", "description": "**Alias** of `lt_of_le_not_le`."}, {"name": "eq_of_forall_ge_iff", "description": ""}, {"name": "rel_imp_eq_of_rel_imp_le", "description": "A symmetric relation implies two values are equal, when it implies they're less-equal."}, {"name": "eq.not_lt", "description": ""}, {"name": "has_le.le.lt_or_eq", "description": "**Alias** of `lt_or_eq_of_le`."}, {"name": "lt_of_le_of_lt'", "description": ""}, {"name": "order_dual.linear_order", "description": ""}, {"name": "le_Prop_eq", "description": ""}, {"name": "le_of_forall_lt", "description": ""}, {"name": "decidable.ne_iff_lt_iff_le", "description": ""}, {"name": "has_le.le.antisymm'", "description": "**Alias** of `ge_antisymm`."}, {"name": "punit.not_lt", "description": ""}, {"name": "Prop.partial_order", "description": ""}, {"name": "pi.has_le", "description": ""}, {"name": "prod.swap_le_swap", "description": ""}, {"name": "lt_of_lt_of_eq", "description": ""}, {"name": "order_dual", "description": " Type synonym to equip a type with the dual order: `\u2264` means `\u2265` and `<` means `>`. `\u03b1\u1d52\u1d48` is\nnotation for `order_dual \u03b1`."}, {"name": "Prop.has_le", "description": "Propositions form a complete boolean algebra, where the `\u2264` relation is given by implication."}, {"name": "le_implies_le_of_le_of_le", "description": "monotonicity of `\u2264` with respect to `\u2192`"}, {"name": "prod.partial_order", "description": "The pointwise partial order on a product.\n   (The lexicographic ordering is defined in order/lexicographic.lean, and the instances are\n   available via the type synonym `\u03b1 \u00d7\u2097 \u03b2 = \u03b1 \u00d7 \u03b2`.)"}, {"name": "min_rec'", "description": ""}, {"name": "ne.lt_of_le'", "description": ""}, {"name": "prod.mk_le_mk_iff_left", "description": ""}, {"name": "subtype.linear_order", "description": " A subtype of a linear order is a linear order. We explicitly give the proofs of decidable\nequality and decidable order in order to ensure the decidability instances are all definitionally\nequal."}, {"name": "has_le.le.eq_of_not_gt", "description": "**Alias** of `eq_of_ge_of_not_gt`."}, {"name": "as_linear_order.inhabited", "description": ""}, {"name": "punit.linear_order", "description": ""}, {"name": "lt_of_eq_of_lt", "description": ""}, {"name": "pi.le_def", "description": ""}, {"name": "linear_order.lift'", "description": " Transfer a `linear_order` on `\u03b2` to a `linear_order` on `\u03b1` using an injective\nfunction `f : \u03b1 \u2192 \u03b2`. This version autogenerates `min` and `max` fields. See `linear_order.lift`\nfor a version that takes `[has_sup \u03b1]` and `[has_inf \u03b1]`, then uses them as `max` and `min`.\nSee note [reducible non-instances]."}, {"name": "has_le.le.not_lt", "description": "**Alias** of `not_lt_of_le`."}, {"name": "eq.trans_le", "description": "**Alias** of `le_of_eq_of_le`."}, {"name": "pi.compl_def", "description": ""}, {"name": "le_imp_le_iff_lt_imp_lt", "description": ""}, {"name": "order_dual.densely_ordered", "description": ""}, {"name": "prod.has_le", "description": ""}, {"name": "order.preimage", "description": " Given a relation `R` on `\u03b2` and a function `f : \u03b1 \u2192 \u03b2`, the preimage relation on `\u03b1` is defined\nby `x \u2264 y \u2194 f x \u2264 f y`. It is the unique relation on `\u03b1` making `f` a `rel_embedding` (assuming `f`\nis injective)."}, {"name": "lt_iff_lt_of_le_iff_le", "description": ""}, {"name": "lt_iff_not_le", "description": ""}, {"name": "le_of_forall_le'", "description": ""}, {"name": "eq_iff_le_not_lt", "description": ""}, {"name": "lt_trans'", "description": ""}, {"name": "pi.preorder", "description": ""}, {"name": "lt_of_eq_of_lt'", "description": ""}, {"name": "has_lt.lt.trans_le'", "description": "**Alias** of `lt_of_lt_of_le'`."}, {"name": "has_le.le.lt_of_ne'", "description": "**Alias** of `lt_of_le_of_ne'`."}, {"name": "le_iff_eq_or_lt", "description": ""}, {"name": "eq_of_le_of_not_lt", "description": ""}, {"name": "le_of_le_of_eq'", "description": ""}, {"name": "has_le.le.eq_or_lt", "description": "**Alias** of `eq_or_lt_of_le`."}, {"name": "le_of_forall_le", "description": ""}, {"name": "has_lt.lt.trans_eq", "description": "**Alias** of `lt_of_lt_of_eq`."}, {"name": "linear_order.ext", "description": ""}, {"name": "prod.mk_le_mk", "description": ""}, {"name": "le_update_iff", "description": ""}, {"name": "preorder.ext", "description": ""}, {"name": "subtype.coe_le_coe", "description": ""}, {"name": "has_le.le.le_or_lt", "description": ""}, {"name": "eq.trans_ge", "description": "**Alias** of `le_of_eq_of_le'`."}, {"name": "ne_iff_lt_iff_le", "description": ""}, {"name": "prod.mk_lt_mk_iff_right", "description": ""}, {"name": "prod.le_def", "description": ""}, {"name": "has_sup", "description": "Typeclass for the `\u2294` (`\\lub`) notation"}, {"name": "has_sup.sup", "description": "Typeclass for the `\u2294` (`\\lub`) notation"}, {"name": "has_le.le.eq_or_lt_dec", "description": "**Alias** of `decidable.eq_or_lt_of_le`."}, {"name": "subtype.has_lt", "description": ""}, {"name": "prod.mk_lt_mk", "description": ""}, {"name": "has_lt.lt.ne'", "description": ""}, {"name": "ne_of_not_le", "description": ""}, {"name": "has_le.le.lt_or_eq_dec", "description": "**Alias** of `decidable.lt_or_eq_of_le`."}, {"name": "has_le.le.trans_eq", "description": "**Alias** of `le_of_le_of_eq`."}, {"name": "lt_of_le_of_ne'", "description": ""}, {"name": "has_le.le.le_iff_eq", "description": ""}, {"name": "prod.mk_lt_mk_iff_left", "description": ""}, {"name": "has_le.le.trans", "description": "**Alias** of `le_trans`."}, {"name": "lt_iff_le_and_ne", "description": ""}, {"name": "has_le.ext", "description": ""}, {"name": "subtype.coe_lt_coe", "description": ""}, {"name": "eq.not_gt", "description": ""}, {"name": "Prop.has_compl", "description": ""}, {"name": "subtype.decidable_lt", "description": ""}, {"name": "eq_or_lt_of_le", "description": ""}, {"name": "lt_of_not_le", "description": ""}, {"name": "eq_of_forall_le_iff", "description": ""}, {"name": "has_lt.lt.lt_or_lt", "description": ""}, {"name": "subtype.has_le", "description": ""}, {"name": "has_le.le.trans_lt", "description": "**Alias** of `lt_of_le_of_lt`."}, {"name": "prod.mk_le_mk_iff_right", "description": ""}, {"name": "subtype.decidable_le", "description": ""}, {"name": "has_le.ext_iff", "description": ""}, {"name": "lt_iff_lt_of_le_iff_le'", "description": ""}, {"name": "eq_of_le_of_forall_le_of_dense", "description": ""}, {"name": "le_of_eq_of_le", "description": ""}, {"name": "has_lt.lt.le", "description": "**Alias** of `le_of_lt`."}, {"name": "le_iff_le_iff_lt_iff_lt", "description": ""}, {"name": "eq_of_ge_of_not_gt", "description": ""}, {"name": "has_lt.lt.false", "description": ""}, {"name": "has_le.le.ge", "description": ""}, {"name": "update_le_update_iff", "description": ""}, {"name": "le_of_forall_le_of_dense", "description": ""}, {"name": "eq.trans_gt", "description": "**Alias** of `lt_of_eq_of_lt'`."}, {"name": "preorder.to_has_le_injective", "description": ""}, {"name": "lt_of_lt_of_le'", "description": ""}, {"name": "has_le.le.lt_iff_ne", "description": ""}, {"name": "order_dual.partial_order", "description": ""}, {"name": "pi.has_sdiff", "description": ""}, {"name": "decidable.eq_iff_le_not_lt", "description": ""}, {"name": "forall_lt_iff_le'", "description": ""}, {"name": "linear_order.to_partial_order_injective", "description": ""}, {"name": "category_theory.adjunction.left_adjoint_of_equiv_obj", "description": ""}, {"name": "category_theory.adjunction.adjunction_of_equiv_right_hom_equiv", "description": ""}, {"name": "category_theory.adjunction.of_nat_iso_right", "description": "Transport an adjunction along an natural isomorphism on the right."}, {"name": "category_theory.adjunction.core_unit_counit.left_triangle", "description": ""}, {"name": "category_theory.adjunction.mk_of_unit_counit", "description": " Construct an adjunction between functors `F` and `G` given a unit and counit for the adjunction\nsatisfying the triangle identities."}, {"name": "category_theory.adjunction.mk_of_unit_counit_hom_equiv_symm_apply", "description": ""}, {"name": "category_theory.adjunction.equiv_homset_left_of_nat_iso_symm_apply", "description": ""}, {"name": "category_theory.adjunction.is_right_adjoint_to_is_equivalence_inverse", "description": ""}, {"name": "category_theory.functor.left_adjoint_of_is_equivalence", "description": ""}, {"name": "category_theory.functor.right_adjoint_of_equivalence", "description": "If `F` is an equivalence, it's a right adjoint."}, {"name": "category_theory.adjunction.adjunction_of_equiv_left_unit_app", "description": ""}, {"name": "category_theory.adjunction.mk_of_unit_counit_unit", "description": ""}, {"name": "category_theory.adjunction.adjunction_of_equiv_right_counit_app", "description": ""}, {"name": "category_theory.adjunction.hom_equiv_naturality_right", "description": ""}, {"name": "category_theory.adjunction.equiv_homset_right_of_nat_iso_apply", "description": ""}, {"name": "category_theory.adjunction.right_triangle_components", "description": ""}, {"name": "category_theory.adjunction.hom_equiv_naturality_right_symm", "description": ""}, {"name": "category_theory.adjunction.core_hom_equiv", "description": "This is an auxiliary data structure useful for constructing adjunctions.\nSee `adjunction.mk_of_hom_equiv`.\nThis structure won't typically be used anywhere else."}, {"name": "category_theory.adjunction.core_hom_equiv.hom_equiv", "description": "This is an auxiliary data structure useful for constructing adjunctions.\nSee `adjunction.mk_of_hom_equiv`.\nThis structure won't typically be used anywhere else."}, {"name": "category_theory.adjunction.core_hom_equiv.hom_equiv_naturality_left_symm'", "description": "This is an auxiliary data structure useful for constructing adjunctions.\nSee `adjunction.mk_of_hom_equiv`.\nThis structure won't typically be used anywhere else."}, {"name": "category_theory.adjunction.core_hom_equiv.hom_equiv_naturality_right'", "description": "This is an auxiliary data structure useful for constructing adjunctions.\nSee `adjunction.mk_of_hom_equiv`.\nThis structure won't typically be used anywhere else."}, {"name": "category_theory.adjunction.eq_hom_equiv_apply", "description": ""}, {"name": "category_theory.adjunction.left_triangle", "description": ""}, {"name": "category_theory.adjunction.id", "description": "The adjunction between the identity functor on a category and itself."}, {"name": "category_theory.adjunction.equiv_homset_right_of_nat_iso", "description": "If G and H are naturally isomorphic functors, establish an equivalence of hom-sets."}, {"name": "category_theory.adjunction.equiv_homset_right_of_nat_iso_symm_apply", "description": ""}, {"name": "category_theory.adjunction.is_right_adjoint_to_is_equivalence_counit_iso_hom_app", "description": ""}, {"name": "category_theory.adjunction.left_adjoint_of_nat_iso", "description": "Transport being a left adjoint along a natural isomorphism."}, {"name": "category_theory.adjunction.of_right_adjoint", "description": "The adjunction associated to a functor known to be a right adjoint."}, {"name": "category_theory.adjunction.left_adjoint_of_equiv_map", "description": ""}, {"name": "category_theory.adjunction.adjunction_of_equiv_left_counit_app", "description": ""}, {"name": "category_theory.is_right_adjoint", "description": "A class giving a chosen left adjoint to the functor `right`."}, {"name": "category_theory.is_right_adjoint.left", "description": "A class giving a chosen left adjoint to the functor `right`."}, {"name": "category_theory.is_right_adjoint.adj", "description": "A class giving a chosen left adjoint to the functor `right`."}, {"name": "category_theory.adjunction.right_adjoint_of_comp", "description": "If `F` and `G` are right adjoints then `F \u22d9 G` is a right adjoint too."}, {"name": "category_theory.adjunction.unit_naturality_assoc", "description": ""}, {"name": "category_theory.adjunction.mk_of_hom_equiv_unit_app", "description": ""}, {"name": "category_theory.adjunction.right_triangle", "description": ""}, {"name": "category_theory.adjunction.counit_naturality_assoc", "description": ""}, {"name": "category_theory.adjunction.mk_of_unit_counit_counit", "description": ""}, {"name": "category_theory.adjunction.hom_equiv_symm_id", "description": ""}, {"name": "category_theory.adjunction.core_hom_equiv.hom_equiv_naturality_right_symm", "description": ""}, {"name": "category_theory.adjunction.is_right_adjoint_to_is_equivalence_counit_iso_inv_app", "description": ""}, {"name": "category_theory.adjunction.hom_equiv_apply_eq", "description": ""}, {"name": "category_theory.equivalence.to_adjunction", "description": " The adjunction given by an equivalence of categories. (To obtain the opposite adjunction,\nsimply use `e.symm.to_adjunction`."}, {"name": "category_theory.adjunction.is_right_adjoint_to_is_equivalence", "description": "If the unit and counit for the adjunction corresponding to a right adjoint functor are (pointwise)\nisomorphisms, then the functor is an equivalence of categories."}, {"name": "category_theory.adjunction.counit_naturality", "description": ""}, {"name": "category_theory.left_adjoint", "description": "Extract the left adjoint from the instance giving the chosen adjoint."}, {"name": "category_theory.adjunction.unit_naturality", "description": ""}, {"name": "category_theory.adjunction", "description": "`F \u22a3 G` represents the data of an adjunction between two functors\n`F : C \u2964 D` and `G : D \u2964 C`. `F` is the left adjoint and `G` is the right adjoint.\n\nTo construct an `adjunction` between two functors, it's often easier to instead use the\nconstructors `mk_of_hom_equiv` or `mk_of_unit_counit`. To construct a left adjoint,\nthere are also constructors `left_adjoint_of_equiv` and `adjunction_of_equiv_left` (as\nwell as their duals) which can be simpler in practice.\n\nUniqueness of adjoints is shown in `category_theory.adjunction.opposites`.\n\nSee <https://stacks.math.columbia.edu/tag/0037>."}, {"name": "category_theory.adjunction.hom_equiv", "description": "`F \u22a3 G` represents the data of an adjunction between two functors\n`F : C \u2964 D` and `G : D \u2964 C`. `F` is the left adjoint and `G` is the right adjoint.\n\nTo construct an `adjunction` between two functors, it's often easier to instead use the\nconstructors `mk_of_hom_equiv` or `mk_of_unit_counit`. To construct a left adjoint,\nthere are also constructors `left_adjoint_of_equiv` and `adjunction_of_equiv_left` (as\nwell as their duals) which can be simpler in practice.\n\nUniqueness of adjoints is shown in `category_theory.adjunction.opposites`.\n\nSee <https://stacks.math.columbia.edu/tag/0037>."}, {"name": "category_theory.adjunction.unit", "description": "`F \u22a3 G` represents the data of an adjunction between two functors\n`F : C \u2964 D` and `G : D \u2964 C`. `F` is the left adjoint and `G` is the right adjoint.\n\nTo construct an `adjunction` between two functors, it's often easier to instead use the\nconstructors `mk_of_hom_equiv` or `mk_of_unit_counit`. To construct a left adjoint,\nthere are also constructors `left_adjoint_of_equiv` and `adjunction_of_equiv_left` (as\nwell as their duals) which can be simpler in practice.\n\nUniqueness of adjoints is shown in `category_theory.adjunction.opposites`.\n\nSee <https://stacks.math.columbia.edu/tag/0037>."}, {"name": "category_theory.adjunction.counit", "description": "`F \u22a3 G` represents the data of an adjunction between two functors\n`F : C \u2964 D` and `G : D \u2964 C`. `F` is the left adjoint and `G` is the right adjoint.\n\nTo construct an `adjunction` between two functors, it's often easier to instead use the\nconstructors `mk_of_hom_equiv` or `mk_of_unit_counit`. To construct a left adjoint,\nthere are also constructors `left_adjoint_of_equiv` and `adjunction_of_equiv_left` (as\nwell as their duals) which can be simpler in practice.\n\nUniqueness of adjoints is shown in `category_theory.adjunction.opposites`.\n\nSee <https://stacks.math.columbia.edu/tag/0037>."}, {"name": "category_theory.adjunction.hom_equiv_unit'", "description": "`F \u22a3 G` represents the data of an adjunction between two functors\n`F : C \u2964 D` and `G : D \u2964 C`. `F` is the left adjoint and `G` is the right adjoint.\n\nTo construct an `adjunction` between two functors, it's often easier to instead use the\nconstructors `mk_of_hom_equiv` or `mk_of_unit_counit`. To construct a left adjoint,\nthere are also constructors `left_adjoint_of_equiv` and `adjunction_of_equiv_left` (as\nwell as their duals) which can be simpler in practice.\n\nUniqueness of adjoints is shown in `category_theory.adjunction.opposites`.\n\nSee <https://stacks.math.columbia.edu/tag/0037>."}, {"name": "category_theory.adjunction.hom_equiv_counit'", "description": "`F \u22a3 G` represents the data of an adjunction between two functors\n`F : C \u2964 D` and `G : D \u2964 C`. `F` is the left adjoint and `G` is the right adjoint.\n\nTo construct an `adjunction` between two functors, it's often easier to instead use the\nconstructors `mk_of_hom_equiv` or `mk_of_unit_counit`. To construct a left adjoint,\nthere are also constructors `left_adjoint_of_equiv` and `adjunction_of_equiv_left` (as\nwell as their duals) which can be simpler in practice.\n\nUniqueness of adjoints is shown in `category_theory.adjunction.opposites`.\n\nSee <https://stacks.math.columbia.edu/tag/0037>."}, {"name": "category_theory.adjunction.core_unit_counit.right_triangle", "description": ""}, {"name": "category_theory.adjunction.equiv_homset_left_of_nat_iso", "description": "If F and G are naturally isomorphic functors, establish an equivalence of hom-sets."}, {"name": "category_theory.adjunction.right_adjoint_of_nat_iso", "description": "Transport being a right adjoint along a natural isomorphism."}, {"name": "category_theory.adjunction.left_triangle_components", "description": ""}, {"name": "category_theory.adjunction.hom_equiv_id", "description": ""}, {"name": "category_theory.adjunction.equiv_homset_left_of_nat_iso_apply", "description": ""}, {"name": "category_theory.adjunction.to_equivalence_inverse", "description": ""}, {"name": "category_theory.adjunction.of_nat_iso_left", "description": "Transport an adjunction along an natural isomorphism on the left."}, {"name": "category_theory.adjunction.adjunction_of_equiv_right", "description": " Show that the functor given by `right_adjoint_of_equiv` is indeed right adjoint to `F`. Dual\nto `adjunction_of_equiv_left`."}, {"name": "category_theory.adjunction.inhabited", "description": ""}, {"name": "category_theory.functor.adjunction", "description": "An equivalence `E` is left adjoint to its inverse."}, {"name": "category_theory.adjunction.to_equivalence_functor", "description": ""}, {"name": "category_theory.adjunction.mk_of_hom_equiv", "description": " Construct an adjunction between `F` and `G` out of a natural bijection between each\n`F.obj X \u27f6 Y` and `X \u27f6 G.obj Y`."}, {"name": "category_theory.adjunction.left_adjoint_of_equiv", "description": " Construct a left adjoint functor to `G`, given the functor's value on objects `F_obj` and\na bijection `e` between `F_obj X \u27f6 Y` and `X \u27f6 G.obj Y` satisfying a naturality law\n`he : \u2200 X Y Y' g h, e X Y' (h \u226b g) = e X Y h \u226b G.map g`.\nDual to `right_adjoint_of_equiv`."}, {"name": "category_theory.adjunction.left_adjoint_of_comp", "description": "If `F` and `G` are left adjoints then `F \u22d9 G` is a left adjoint too."}, {"name": "category_theory.adjunction.left_triangle_components_assoc", "description": ""}, {"name": "category_theory.equivalence.as_equivalence_to_adjunction_counit", "description": ""}, {"name": "category_theory.adjunction.to_equivalence_unit_iso", "description": ""}, {"name": "category_theory.equivalence.as_equivalence_to_adjunction_unit", "description": ""}, {"name": "category_theory.adjunction.right_adjoint_of_equiv", "description": " Construct a right adjoint functor to `F`, given the functor's value on objects `G_obj` and\na bijection `e` between `F.obj X \u27f6 Y` and `X \u27f6 G_obj Y` satisfying a naturality law\n`he : \u2200 X Y Y' g h, e X' Y (F.map f \u226b g) = f \u226b e X Y g`.\nDual to `left_adjoint_of_equiv`."}, {"name": "category_theory.adjunction.hom_equiv_naturality_left", "description": ""}, {"name": "category_theory.adjunction.hom_equiv_naturality_left_symm", "description": ""}, {"name": "category_theory.adjunction.core_hom_equiv.hom_equiv_naturality_left", "description": ""}, {"name": "category_theory.adjunction.comp", "description": "Composition of adjunctions.\n\nSee <https://stacks.math.columbia.edu/tag/0DV0>."}, {"name": "category_theory.functor.left_adjoint_of_equivalence", "description": "If `F` is an equivalence, it's a left adjoint."}, {"name": "category_theory.adjunction.is_right_adjoint_to_is_equivalence_unit_iso_hom_app", "description": ""}, {"name": "category_theory.adjunction.adjunction_of_equiv_left_hom_equiv", "description": ""}, {"name": "category_theory.functor.right_adjoint_of_is_equivalence", "description": ""}, {"name": "category_theory.adjunction.core_hom_equiv.hom_equiv_naturality_right", "description": ""}, {"name": "category_theory.adjunction.right_adjoint_of_equiv_obj", "description": ""}, {"name": "category_theory.adjunction.hom_equiv_unit", "description": ""}, {"name": "category_theory.adjunction.mk_of_hom_equiv_hom_equiv", "description": ""}, {"name": "category_theory.adjunction.to_equivalence_counit_iso", "description": ""}, {"name": "category_theory.adjunction.mk_of_hom_equiv_counit_app", "description": ""}, {"name": "category_theory.adjunction.hom_equiv_counit", "description": ""}, {"name": "category_theory.adjunction.to_equivalence", "description": "If the unit and counit of a given adjunction are (pointwise) isomorphisms, then we can upgrade the\nadjunction to an equivalence."}, {"name": "category_theory.adjunction.right_triangle_components_assoc", "description": ""}, {"name": "category_theory.adjunction.of_left_adjoint", "description": "The adjunction associated to a functor known to be a left adjoint."}, {"name": "category_theory.adjunction.adjunction_of_equiv_left", "description": " Show that the functor given by `left_adjoint_of_equiv` is indeed left adjoint to `G`. Dual\nto `adjunction_of_equiv_right`."}, {"name": "category_theory.adjunction.mk_of_unit_counit_hom_equiv_apply", "description": ""}, {"name": "category_theory.adjunction.right_adjoint_of_equiv_map", "description": ""}, {"name": "category_theory.right_adjoint", "description": "Extract the right adjoint from the instance giving the chosen adjoint."}, {"name": "category_theory.adjunction.core_unit_counit", "description": "This is an auxiliary data structure useful for constructing adjunctions.\nSee `adjunction.mk_of_unit_counit`.\nThis structure won't typically be used anywhere else."}, {"name": "category_theory.adjunction.core_unit_counit.unit", "description": "This is an auxiliary data structure useful for constructing adjunctions.\nSee `adjunction.mk_of_unit_counit`.\nThis structure won't typically be used anywhere else."}, {"name": "category_theory.adjunction.core_unit_counit.counit", "description": "This is an auxiliary data structure useful for constructing adjunctions.\nSee `adjunction.mk_of_unit_counit`.\nThis structure won't typically be used anywhere else."}, {"name": "category_theory.adjunction.core_unit_counit.left_triangle'", "description": "This is an auxiliary data structure useful for constructing adjunctions.\nSee `adjunction.mk_of_unit_counit`.\nThis structure won't typically be used anywhere else."}, {"name": "category_theory.adjunction.core_unit_counit.right_triangle'", "description": "This is an auxiliary data structure useful for constructing adjunctions.\nSee `adjunction.mk_of_unit_counit`.\nThis structure won't typically be used anywhere else."}, {"name": "category_theory.is_left_adjoint", "description": "A class giving a chosen right adjoint to the functor `left`."}, {"name": "category_theory.is_left_adjoint.right", "description": "A class giving a chosen right adjoint to the functor `left`."}, {"name": "category_theory.is_left_adjoint.adj", "description": "A class giving a chosen right adjoint to the functor `left`."}, {"name": "category_theory.adjunction.adjunction_of_equiv_right_unit_app", "description": ""}, {"name": "category_theory.adjunction.core_hom_equiv.hom_equiv_naturality_left_symm", "description": ""}, {"name": "category_theory.adjunction.is_right_adjoint_to_is_equivalence_unit_iso_inv_app", "description": ""}, {"name": "widget.tactic_view_action", "description": ""}, {"name": "widget.tactic_view_action.out", "description": ""}, {"name": "widget.tactic_view_action.filter", "description": ""}, {"name": "widget.interactive_expression.sf.of_eformat", "description": ""}, {"name": "widget.tactic_view_term_goal", "description": "Component that displays the term-mode goal."}, {"name": "widget.interactive_expression.sf.has_to_string", "description": ""}, {"name": "widget.to_local_collection", "description": "Group consecutive locals according to whether they have the same type"}, {"name": "widget.show_type_component", "description": ""}, {"name": "widget.interactive_expression.view", "description": ""}, {"name": "widget.tactic_render", "description": ""}, {"name": "widget.interactive_expression.mk", "description": "Make an interactive expression."}, {"name": "widget.interactive_expression.sf.flatten", "description": ""}, {"name": "widget.interactive_expression.sf.has_to_format", "description": ""}, {"name": "widget.interactive_expression.action", "description": ""}, {"name": "widget.interactive_expression.action.on_mouse_enter", "description": ""}, {"name": "widget.interactive_expression.action.on_mouse_leave_all", "description": ""}, {"name": "widget.interactive_expression.action.on_click", "description": ""}, {"name": "widget.interactive_expression.action.on_tooltip_action", "description": ""}, {"name": "widget.interactive_expression.action.on_close_tooltip", "description": ""}, {"name": "subexpr", "description": ""}, {"name": "widget.tactic_view_goal", "description": "Component that displays the main (first) goal."}, {"name": "widget.filter_component", "description": ""}, {"name": "widget.local_collection", "description": "A group of local constants in the context that should be rendered as one line."}, {"name": "widget.local_collection.key", "description": "A group of local constants in the context that should be rendered as one line."}, {"name": "widget.local_collection.locals", "description": "A group of local constants in the context that should be rendered as one line."}, {"name": "widget.local_collection.type", "description": "A group of local constants in the context that should be rendered as one line."}, {"name": "widget.filter_type", "description": ""}, {"name": "widget.filter_type.none", "description": ""}, {"name": "widget.filter_type.no_instances", "description": ""}, {"name": "widget.filter_type.only_props", "description": ""}, {"name": "widget.interactive_expression.type_tooltip", "description": ""}, {"name": "widget.filter_type.decidable_eq", "description": ""}, {"name": "widget.tactic_state_widget", "description": ""}, {"name": "widget.local_collection.decidable_eq", "description": ""}, {"name": "widget.filter_local", "description": ""}, {"name": "widget.interactive_expression.sf.has_repr", "description": ""}, {"name": "widget.term_goal_widget", "description": "Widget used to display term-proof goals."}, {"name": "widget.tactic_view_component", "description": "Component that displays all goals, together with the `$n goals` message."}, {"name": "widget.interactive_expression.sf.repr", "description": ""}, {"name": "widget.show_local_collection_component", "description": ""}, {"name": "widget.interactive_expression.implicit_arg_list", "description": "Render the implicit arguments for an expression in fancy, little pills."}, {"name": "widget.interactive_expression.sf", "description": "eformat but without any of the formatting stuff like highlighting, groups etc."}, {"name": "widget.interactive_expression.sf.tag_expr", "description": "eformat but without any of the formatting stuff like highlighting, groups etc."}, {"name": "widget.interactive_expression.sf.compose", "description": "eformat but without any of the formatting stuff like highlighting, groups etc."}, {"name": "widget.interactive_expression.sf.of_string", "description": "eformat but without any of the formatting stuff like highlighting, groups etc."}, {"name": "int.cast_add_hom", "description": "`coe : \u2124 \u2192 \u03b1` as an `add_monoid_hom`."}, {"name": "int.coe_cast_ring_hom", "description": ""}, {"name": "int.cast_ring_hom", "description": "`coe : \u2124 \u2192 \u03b1` as a `ring_hom`."}, {"name": "prod.add_group_with_one", "description": ""}, {"name": "pi.has_int_cast", "description": ""}, {"name": "int.cast_nat_abs", "description": ""}, {"name": "int.cast_comm", "description": ""}, {"name": "ring_hom.ext_int", "description": ""}, {"name": "int.cast_nonpos", "description": ""}, {"name": "int.cast_id", "description": ""}, {"name": "int.nneg_mul_add_sq_of_abs_le_one", "description": ""}, {"name": "ring_hom.eq_int_cast", "description": ""}, {"name": "ring_hom.map_int_cast", "description": ""}, {"name": "monoid_hom.ext_int", "description": "If two `monoid_hom`s agree on `-1` and the naturals then they are equal."}, {"name": "int.cast_lt", "description": ""}, {"name": "prod.snd_int_cast", "description": ""}, {"name": "int.cast_mono", "description": ""}, {"name": "int.cast_nonneg", "description": ""}, {"name": "int.coe_int_dvd", "description": ""}, {"name": "int.cast_max", "description": ""}, {"name": "int.cast_min", "description": ""}, {"name": "int.cast_strict_mono", "description": ""}, {"name": "int.cast_le_neg_one_of_neg", "description": ""}, {"name": "int.cast_mul", "description": ""}, {"name": "int.commute_cast", "description": ""}, {"name": "mul_opposite.op_int_cast", "description": ""}, {"name": "monoid_with_zero_hom.ext_int'", "description": "If two `monoid_with_zero_hom`s agree on `-1` and the _positive_ naturals then they are equal."}, {"name": "int.cast_pos", "description": ""}, {"name": "pi.add_group_with_one", "description": ""}, {"name": "int.of_nat_hom", "description": "Coercion `\u2115 \u2192 \u2124` as a `ring_hom`."}, {"name": "pi.int_apply", "description": ""}, {"name": "add_monoid_hom.eq_int_cast_hom", "description": ""}, {"name": "int.cast_add_hom_int", "description": ""}, {"name": "int.cast_ite", "description": ""}, {"name": "ring_hom.int.subsingleton_ring_hom", "description": ""}, {"name": "int.coe_cast_add_hom", "description": ""}, {"name": "int.cast_one_le_of_pos", "description": ""}, {"name": "int.cast_le", "description": ""}, {"name": "sum.elim_int_cast_int_cast", "description": ""}, {"name": "pi.coe_int", "description": ""}, {"name": "int.cast_ring_hom_int", "description": ""}, {"name": "int.cast_lt_zero", "description": ""}, {"name": "monoid_with_zero_hom.ext_int", "description": "If two `monoid_with_zero_hom`s agree on `-1` and the naturals then they are equal."}, {"name": "ring_hom.eq_int_cast'", "description": ""}, {"name": "mul_opposite.unop_int_cast", "description": ""}, {"name": "prod.fst_int_cast", "description": ""}, {"name": "int.cast_commute", "description": ""}, {"name": "add_monoid_hom.ext_int", "description": " Two additive monoid homomorphisms `f`, `g` from `\u2124` to an additive monoid are equal\nif `f 1 = g 1`."}, {"name": "monoid_hom.ext_mint", "description": ""}, {"name": "add_monoid_hom.eq_int_cast", "description": ""}, {"name": "int.cast_abs", "description": ""}, {"name": "fin.of_nat_zero", "description": ""}, {"name": "fin.has_one", "description": ""}, {"name": "fin.mod", "description": ""}, {"name": "fin.succ", "description": ""}, {"name": "fin.sub", "description": ""}, {"name": "fin.has_sub", "description": ""}, {"name": "fin.le_def", "description": ""}, {"name": "fin.mod_def", "description": ""}, {"name": "fin.mul", "description": ""}, {"name": "fin.has_add", "description": ""}, {"name": "fin.add_def", "description": ""}, {"name": "fin.mul_def", "description": ""}, {"name": "fin.of_nat", "description": ""}, {"name": "fin.lt_def", "description": ""}, {"name": "fin.sub_def", "description": ""}, {"name": "fin.div", "description": ""}, {"name": "fin.has_mod", "description": ""}, {"name": "fin.has_mul", "description": ""}, {"name": "fin.add", "description": ""}, {"name": "fin.has_div", "description": ""}, {"name": "fin.div_def", "description": ""}, {"name": "fin.pred", "description": ""}, {"name": "fin.val_zero", "description": ""}, {"name": "fin.has_zero", "description": ""}, {"name": "multiset.sum_to_list", "description": ""}, {"name": "multiset.sum_map_neg", "description": ""}, {"name": "commute.multiset_sum_right", "description": ""}, {"name": "multiset.sum_le_sum_of_rel_le", "description": ""}, {"name": "multiset.sum_map_mul_left", "description": ""}, {"name": "multiset.prod_map_pow", "description": ""}, {"name": "multiset.sum_map_mul_right", "description": ""}, {"name": "multiset.le_sum_of_subadditive_on_pred", "description": ""}, {"name": "multiset.prod_eq_zero_iff", "description": ""}, {"name": "multiset.all_one_of_le_one_le_of_prod_eq_one", "description": ""}, {"name": "multiset.sum_nonneg", "description": ""}, {"name": "multiset.sum_eq_nsmul_single", "description": ""}, {"name": "multiset.le_prod_nonempty_of_submultiplicative_on_pred", "description": ""}, {"name": "multiset.prod_erase", "description": ""}, {"name": "monoid_hom.map_multiset_prod", "description": ""}, {"name": "multiset.prod_cons", "description": ""}, {"name": "multiset.sum_map_neg'", "description": ""}, {"name": "multiset.prod_map_inv", "description": ""}, {"name": "add_monoid_hom.map_multiset_sum", "description": ""}, {"name": "multiset.sum_hom", "description": ""}, {"name": "multiset.prod_repeat", "description": ""}, {"name": "multiset.card_nsmul_le_sum", "description": ""}, {"name": "multiset.prod_ne_zero", "description": ""}, {"name": "multiset.prod_map_le_prod", "description": ""}, {"name": "multiset.sum", "description": "Sum of a multiset given a commutative additive monoid structure on `\u03b1`.\n  `sum {a, b, c} = a + b + c`"}, {"name": "multiset.prod_le_pow_card", "description": ""}, {"name": "multiset.prod_singleton", "description": ""}, {"name": "multiset.le_sum_nonempty_of_subadditive_on_pred", "description": ""}, {"name": "multiset.pow_count", "description": ""}, {"name": "multiset.prod_eq_foldl", "description": ""}, {"name": "multiset.prod_eq_pow_single", "description": ""}, {"name": "multiset.le_prod_of_submultiplicative_on_pred", "description": ""}, {"name": "multiset.prod_nsmul", "description": ""}, {"name": "multiset.prod_eq_one", "description": "Slightly more general version of `multiset.prod_eq_one_iff` for a non-ordered `monoid`"}, {"name": "multiset.sum_induction_nonempty", "description": ""}, {"name": "multiset.le_prod_of_submultiplicative", "description": ""}, {"name": "multiset.le_sum_of_subadditive", "description": ""}, {"name": "multiset.prod_hom", "description": ""}, {"name": "multiset.prod_pair", "description": ""}, {"name": "multiset.sum_map_erase", "description": ""}, {"name": "multiset.sum_map_zero", "description": ""}, {"name": "multiset.sum_repeat", "description": ""}, {"name": "multiset.le_sum_nonempty_of_subadditive", "description": ""}, {"name": "multiset.sum_map_add", "description": ""}, {"name": "multiset.prod_map_inv'", "description": ""}, {"name": "multiset.sum_map_sub", "description": ""}, {"name": "multiset.pow_card_le_prod", "description": ""}, {"name": "multiset.coe_sum", "description": ""}, {"name": "multiset.prod_dvd_prod_of_le", "description": ""}, {"name": "multiset.sum_hom_rel", "description": ""}, {"name": "multiset.prod_map_div", "description": ""}, {"name": "multiset.sum_cons", "description": ""}, {"name": "multiset.sum_eq_foldr", "description": ""}, {"name": "multiset.prod_to_list", "description": ""}, {"name": "multiset.prod_induction", "description": ""}, {"name": "commute.multiset_sum_left", "description": ""}, {"name": "multiset.sum_eq_zero", "description": "Slightly more general version of `multiset.sum_eq_zero_iff`\n  for a non-ordered `add_monoid`"}, {"name": "multiset.prod_map_prod_map", "description": ""}, {"name": "multiset.prod_hom_rel", "description": ""}, {"name": "multiset.prod_eq_foldr", "description": ""}, {"name": "multiset.sum_pair", "description": ""}, {"name": "multiset.prod_map_erase", "description": ""}, {"name": "multiset.sum_le_sum_sum", "description": ""}, {"name": "multiset.prod_add", "description": ""}, {"name": "multiset.one_le_prod_of_one_le", "description": ""}, {"name": "multiset.sum_map_nsmul", "description": ""}, {"name": "multiset.prod_map_eq_pow_single", "description": ""}, {"name": "multiset.prod_dvd_prod_of_dvd", "description": ""}, {"name": "multiset.sum_singleton", "description": ""}, {"name": "multiset.prod_map_one", "description": ""}, {"name": "multiset.prod_induction_nonempty", "description": ""}, {"name": "multiset.single_le_prod", "description": ""}, {"name": "multiset.prod_hom\u2082", "description": ""}, {"name": "multiset.prod_eq_zero", "description": ""}, {"name": "multiset.prod", "description": "Product of a multiset given a commutative monoid structure on `\u03b1`.\n `prod {a, b, c} = a * b * c`"}, {"name": "multiset.prod_zero", "description": ""}, {"name": "multiset.all_zero_of_le_zero_le_of_sum_eq_zero", "description": ""}, {"name": "multiset.coe_prod", "description": ""}, {"name": "multiset.sum_induction", "description": ""}, {"name": "multiset.sum_hom'", "description": ""}, {"name": "multiset.sum_eq_zero_iff", "description": ""}, {"name": "multiset.le_prod_nonempty_of_submultiplicative", "description": ""}, {"name": "map_multiset_prod", "description": ""}, {"name": "multiset.sum_map_singleton", "description": ""}, {"name": "multiset.coe_sum_add_monoid_hom", "description": ""}, {"name": "multiset.dvd_prod", "description": ""}, {"name": "multiset.prod_map_mul", "description": ""}, {"name": "multiset.abs_sum_le_sum_abs", "description": ""}, {"name": "multiset.sum_erase", "description": ""}, {"name": "multiset.prod_nonneg", "description": ""}, {"name": "map_multiset_sum", "description": ""}, {"name": "multiset.dvd_sum", "description": ""}, {"name": "multiset.prod_le_prod_of_rel_le", "description": ""}, {"name": "multiset.prod_eq_one_iff", "description": ""}, {"name": "multiset.prod_hom'", "description": ""}, {"name": "multiset.le_sum_of_mem", "description": ""}, {"name": "multiset.sum_add", "description": ""}, {"name": "multiset.sum_le_card_nsmul", "description": ""}, {"name": "multiset.prod_map_zpow", "description": ""}, {"name": "multiset.prod_le_sum_prod", "description": ""}, {"name": "multiset.sum_map_eq_nsmul_single", "description": ""}, {"name": "multiset.sum_map_le_sum", "description": ""}, {"name": "multiset.single_le_sum", "description": ""}, {"name": "multiset.sum_map_zsmul", "description": ""}, {"name": "multiset.sum_zero", "description": ""}, {"name": "multiset.nsmul_count", "description": ""}, {"name": "multiset.le_prod_of_mem", "description": ""}, {"name": "multiset.sum_eq_foldl", "description": ""}, {"name": "multiset.sum_hom\u2082", "description": ""}, {"name": "multiset.sum_add_monoid_hom", "description": " `multiset.sum`, the sum of the elements of a multiset, promoted to a morphism of\n`add_comm_monoid`s."}, {"name": "multiset.sum_map_sum_map", "description": ""}, {"name": "list.not_mem_of_count_eq_zero", "description": ""}, {"name": "list.count_le_count_cons", "description": ""}, {"name": "list.count_nil", "description": ""}, {"name": "list.count_singleton'", "description": ""}, {"name": "list.countp_eq_length", "description": ""}, {"name": "list.prod_map_eq_pow_single", "description": ""}, {"name": "list.countp_eq_zero", "description": ""}, {"name": "list.count_eq_zero_of_not_mem", "description": ""}, {"name": "list.length_eq_countp_add_countp", "description": ""}, {"name": "list.count_concat", "description": ""}, {"name": "list.count_cons'", "description": ""}, {"name": "list.prod_eq_pow_single", "description": ""}, {"name": "list.sum_map_eq_nsmul_single", "description": ""}, {"name": "list.count_filter", "description": ""}, {"name": "list.le_count_iff_repeat_sublist", "description": ""}, {"name": "list.count_eq_zero", "description": ""}, {"name": "list.count_eq_length", "description": ""}, {"name": "list.countp_eq_length_filter", "description": ""}, {"name": "list.count_cons_self", "description": ""}, {"name": "list.count_tail", "description": ""}, {"name": "list.countp_le_length", "description": ""}, {"name": "list.count_append", "description": ""}, {"name": "list.countp_cons", "description": ""}, {"name": "list.sum_eq_nsmul_single", "description": ""}, {"name": "list.repeat_count_eq_of_count_eq_length", "description": ""}, {"name": "list.count_pos", "description": ""}, {"name": "list.countp_append", "description": ""}, {"name": "list.sublist.countp_le", "description": ""}, {"name": "list.sublist.count_le", "description": ""}, {"name": "list.count_erase_self", "description": ""}, {"name": "list.count_map_of_injective", "description": ""}, {"name": "list.count_erase_of_ne", "description": ""}, {"name": "list.count_repeat", "description": ""}, {"name": "list.count_cons", "description": ""}, {"name": "list.countp_true", "description": ""}, {"name": "list.count_bind", "description": ""}, {"name": "list.countp_pos", "description": ""}, {"name": "list.count_le_length", "description": ""}, {"name": "list.countp_false", "description": ""}, {"name": "list.count_cons_of_ne", "description": ""}, {"name": "list.count_le_count_map", "description": ""}, {"name": "list.countp_cons_of_neg", "description": ""}, {"name": "list.countp_filter", "description": ""}, {"name": "list.countp_cons_of_pos", "description": ""}, {"name": "list.length_filter_lt_length_iff_exists", "description": ""}, {"name": "list.countp_nil", "description": ""}, {"name": "list.count_singleton", "description": ""}, {"name": "list.one_le_count_iff_mem", "description": ""}, {"name": "linter.has_coe_to_fun", "description": "Linter that checks whether `has_coe_to_fun` instances comply with Note [function coercion]."}, {"name": "check_reducible_non_instances", "description": "Checks whether an instance contains a semireducible non-instance with a class as\ntype in its value. We add some restrictions to get not too many false positives:\n* We only consider classes with an `add` or `mul` field, since those classes are most likely to\n  occur as a field to another class, and be an extension of another class.\n* We only consider instances of type-valued classes and non-instances that are definitions.\n* We currently ignore declarations `foo` that have a `foo._main` declaration. We could look inside,\nor at the generated equation lemmas, but it's unlikely that there are many problematic instances\ndefined using the equation compiler."}, {"name": "linter.incorrect_type_class_argument", "description": "A linter object for `incorrect_type_class_argument`."}, {"name": "print_arguments", "description": " Pretty prints a list of arguments of a declaration. Assumes `l` is a list of argument positions\nand binders (or any other element that can be pretty printed).\n`l` can be obtained e.g. by applying `list.indexes_values` to a list obtained by\n`get_pi_binders`."}, {"name": "linter.impossible_instance", "description": "A linter object for `impossible_instance`."}, {"name": "find_nondep", "description": "Finds all hypotheses that don't occur in the target or other hypotheses."}, {"name": "linter.fails_quickly", "description": "A linter object for `fails_quickly`.\nWe currently set the number of steps in the type-class search pretty high.\nSome instances take quite some time to fail, and we seem to run against the caching issue in\nhttps://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/odd.20repeated.20type.20class.20search"}, {"name": "library_note.lower instance priority", "description": "Certain instances always apply during type-class resolution. For example, the instance\n`add_comm_group.to_add_group {\u03b1} [add_comm_group \u03b1] : add_group \u03b1` applies to all type-class\nresolution problems of the form `add_group _`, and type-class inference will then do an\nexhaustive search to find a commutative group. These instances take a long time to fail.\nOther instances will only apply if the goal has a certain shape. For example\n`int.add_group : add_group \u2124` or\n`add_group.prod {\u03b1 \u03b2} [add_group \u03b1] [add_group \u03b2] : add_group (\u03b1 \u00d7 \u03b2)`. Usually these instances\nwill fail quickly, and when they apply, they are almost always the desired instance.\nFor this reason, we want the instances of the second type (that only apply in specific cases) to\nalways have higher priority than the instances of the first type (that always apply).\nSee also #1561.\n\nTherefore, if we create an instance that always applies, we set the priority of these instances to\n100 (or something similar, which is below the default value of 1000)."}, {"name": "find_nondep_aux", "description": "Auxilliary definition for `find_nondep`"}, {"name": "linter.class_structure", "description": "A linter object for `class_structure`."}, {"name": "linter.fintype_finite", "description": "A linter object for `fintype` vs `finite`."}, {"name": "linter.check_reducibility", "description": "A linter that checks whether an instance contains a semireducible non-instance."}, {"name": "linter.has_coe_variable", "description": "A linter object for `has_coe_variable`."}, {"name": "linter.has_nonempty_instance", "description": "A linter for missing `nonempty` instances."}, {"name": "linter.fintype_finite_fun", "description": " Checks whether a declaration is `Prop`-valued and takes a `fintype _`\nhypothesis that is unused elsewhere in the type.\nIn this case, that hypothesis can be replaced with `casesI nonempty_fintype _` in the proof."}, {"name": "linter.decidable_classical", "description": "A linter object for `decidable_classical`."}, {"name": "linter.instance_priority", "description": " A linter object for checking instance priorities of instances that always apply.\nThis is in the default linter set."}, {"name": "fails_quickly", "description": "Tests whether type-class inference search will end quickly on certain unsolvable\ntype-class problems. This is to detect loops or very slow searches, which are problematic\n(recall that normal type-class search often creates unsolvable subproblems, which have to fail\nquickly for type-class inference to perform well.\nWe create these type-class problems by taking an instance, and removing the last hypothesis that\ndoesn't appear in the goal (or a later hypothesis). Note: this argument is necessarily an\ninstance-implicit argument if it passes the `linter.incorrect_type_class_argument`.\nThis tactic succeeds if `mk_instance` succeeds quickly or fails quickly with the error\nmessage that it cannot find an instance. It fails if the tactic takes too long, or if any other\nerror message is raised (usually a maximum depth in the search)."}, {"name": "linter.inhabited_nonempty", "description": "A linter object for `inhabited_nonempty`."}, {"name": "linter.dangerous_instance", "description": "A linter object for `dangerous_instance`."}, {"name": "library_note.implicit instance arguments", "description": "There are places where typeclass arguments are specified with implicit `{}` brackets instead of\nthe usual `[]` brackets. This is done when the instances can be inferred because they are implicit\narguments to the type of one of the other arguments. When they can be inferred from these other\narguments,  it is faster to use this method than to use type class inference.\n\nFor example, when writing lemmas about `(f : \u03b1 \u2192+* \u03b2)`, it is faster to specify the fact that `\u03b1`\nand `\u03b2` are `semiring`s as `{r\u03b1 : semiring \u03b1} {r\u03b2 : semiring \u03b2}` rather than the usual\n`[semiring \u03b1] [semiring \u03b2]`."}, {"name": "fun_like.congr", "description": ""}, {"name": "fun_like.coe_fn_eq", "description": ""}, {"name": "fun_like.coe_injective", "description": ""}, {"name": "fun_like.ext", "description": ""}, {"name": "fun_like.congr_fun", "description": ""}, {"name": "fun_like.coe_eq_coe_fn", "description": ""}, {"name": "fun_like.exists_ne", "description": ""}, {"name": "fun_like.congr_arg", "description": ""}, {"name": "fun_like.ext'_iff", "description": ""}, {"name": "fun_like.ext'", "description": ""}, {"name": "fun_like", "description": " The class `fun_like F \u03b1 \u03b2` expresses that terms of type `F` have an\ninjective coercion to functions from `\u03b1` to `\u03b2`.\n\nThis typeclass is used in the definition of the homomorphism typeclasses,\nsuch as `zero_hom_class`, `mul_hom_class`, `monoid_hom_class`, ...."}, {"name": "fun_like.coe", "description": " The class `fun_like F \u03b1 \u03b2` expresses that terms of type `F` have an\ninjective coercion to functions from `\u03b1` to `\u03b2`.\n\nThis typeclass is used in the definition of the homomorphism typeclasses,\nsuch as `zero_hom_class`, `mul_hom_class`, `monoid_hom_class`, ...."}, {"name": "fun_like.coe_injective'", "description": " The class `fun_like F \u03b1 \u03b2` expresses that terms of type `F` have an\ninjective coercion to functions from `\u03b1` to `\u03b2`.\n\nThis typeclass is used in the definition of the homomorphism typeclasses,\nsuch as `zero_hom_class`, `mul_hom_class`, `monoid_hom_class`, ...."}, {"name": "fun_like.ne_iff", "description": ""}, {"name": "fun_like.ext_iff", "description": ""}, {"name": "fun_like.has_coe_to_fun", "description": ""}, {"name": "list.chain'.cons", "description": ""}, {"name": "list.chain'_iff_pairwise", "description": ""}, {"name": "list.chain'_reverse", "description": ""}, {"name": "list.chain.imp'", "description": ""}, {"name": "list.chain.sublist", "description": ""}, {"name": "list.chain'.iff", "description": ""}, {"name": "list.chain'.imp_head", "description": ""}, {"name": "list.chain_iff_forall\u2082", "description": ""}, {"name": "list.chain_map", "description": ""}, {"name": "list.chain_map_of_chain", "description": ""}, {"name": "list.chain'.tail", "description": ""}, {"name": "list.pairwise.chain", "description": ""}, {"name": "list.chain'.cons'", "description": ""}, {"name": "list.chain_of_chain_pmap", "description": ""}, {"name": "list.chain.rel", "description": ""}, {"name": "list.rel_of_chain_cons", "description": ""}, {"name": "list.chain'_pair", "description": ""}, {"name": "list.chain_of_chain_map", "description": ""}, {"name": "list.chain.imp", "description": ""}, {"name": "list.chain'_singleton", "description": ""}, {"name": "list.chain_split", "description": ""}, {"name": "list.chain.induction_head", "description": "Given a chain from `a` to `b`, and a predicate true at `b`, if `r x y \u2192 p y \u2192 p x` then\nthe predicate is true at `a`.\nThat is, we can propagate the predicate all the way up the chain."}, {"name": "list.chain'.rel_head", "description": ""}, {"name": "list.relation_refl_trans_gen_of_exists_chain", "description": "If there is an `r`-chain starting from `a` and ending at `b`, then `a` and `b` are related by the\nreflexive transitive closure of `r`. The converse of `exists_chain_of_relation_refl_trans_gen`."}, {"name": "list.chain'.append", "description": ""}, {"name": "list.chain'_split", "description": ""}, {"name": "list.chain'.append_overlap", "description": "If `l\u2081 l\u2082` and `l\u2083` are lists and `l\u2081 ++ l\u2082` and `l\u2082 ++ l\u2083` both satisfy\n `chain' R`, then so does `l\u2081 ++ l\u2082 ++ l\u2083` provided `l\u2082 \u2260 []`"}, {"name": "list.chain_iff_pairwise", "description": ""}, {"name": "list.chain.pairwise", "description": ""}, {"name": "list.chain_pmap_of_chain", "description": ""}, {"name": "list.chain'.imp", "description": ""}, {"name": "list.chain.iff_mem", "description": ""}, {"name": "list.exists_chain_of_relation_refl_trans_gen", "description": "If `a` and `b` are related by the reflexive transitive closure of `r`, then there is a `r`-chain\nstarting from `a` and ending on `b`.\nThe converse of `relation_refl_trans_gen_of_exists_chain`."}, {"name": "list.chain'_cons'", "description": ""}, {"name": "list.chain'_append_cons_cons", "description": ""}, {"name": "list.chain'.rel_head'", "description": ""}, {"name": "list.chain_singleton", "description": ""}, {"name": "list.chain'_nil", "description": ""}, {"name": "list.chain_of_chain_cons", "description": ""}, {"name": "list.chain_append_cons_cons", "description": ""}, {"name": "list.chain'_map", "description": ""}, {"name": "list.pairwise.chain'", "description": ""}, {"name": "list.chain'_cons", "description": ""}, {"name": "list.chain_append_singleton_iff_forall\u2082", "description": ""}, {"name": "list.chain_iff_nth_le", "description": ""}, {"name": "list.chain'_of_chain'_map", "description": ""}, {"name": "list.chain.induction", "description": "Given a chain from `a` to `b`, and a predicate true at `b`, if `r x y \u2192 p y \u2192 p x` then\nthe predicate is true everywhere in the chain and at `a`.\nThat is, we can propagate the predicate up the chain."}, {"name": "list.chain_iff", "description": ""}, {"name": "list.chain.iff", "description": ""}, {"name": "list.chain'_map_of_chain'", "description": ""}, {"name": "list.chain'.iff_mem", "description": ""}, {"name": "list.chain'.sublist", "description": ""}, {"name": "list.chain'.drop", "description": ""}, {"name": "list.chain'_iff_nth_le", "description": ""}, {"name": "multiset.ndinsert_of_not_mem", "description": ""}, {"name": "multiset.le_ndinter", "description": ""}, {"name": "multiset.ndinter_eq_zero_iff_disjoint", "description": ""}, {"name": "multiset.subset_ndunion_right", "description": ""}, {"name": "multiset.ndinter", "description": "`ndinter s t` is the lift of the list `\u2229` operation. This operation\n does not respect multiplicities, unlike `s \u2229 t`, but it is suitable as\n an intersection operation on `finset`. (`s \u2229 t` would also work as a union operation\n on finset, but this is more efficient.)"}, {"name": "multiset.dedup_cons", "description": ""}, {"name": "multiset.inter_le_ndinter", "description": ""}, {"name": "multiset.length_ndinsert_of_mem", "description": ""}, {"name": "multiset.nodup.ndinsert", "description": ""}, {"name": "multiset.ndunion_le", "description": ""}, {"name": "multiset.ndunion_le_union", "description": ""}, {"name": "multiset.coe_ndunion", "description": ""}, {"name": "multiset.ndinter_subset_left", "description": ""}, {"name": "multiset.length_ndinsert_of_not_mem", "description": ""}, {"name": "multiset.attach_ndinsert", "description": ""}, {"name": "multiset.mem_ndinter", "description": ""}, {"name": "multiset.ndinter_le_right", "description": ""}, {"name": "multiset.ndinsert", "description": "`ndinsert a s` is the lift of the list `insert` operation. This operation\n does not respect multiplicities, unlike `cons`, but it is suitable as\n an insert operation on `finset`."}, {"name": "multiset.mem_ndinsert", "description": ""}, {"name": "multiset.ndinter_le_left", "description": ""}, {"name": "multiset.mem_ndinsert_of_mem", "description": ""}, {"name": "multiset.ndunion", "description": "`ndunion s t` is the lift of the list `union` operation. This operation\n does not respect multiplicities, unlike `s \u222a t`, but it is suitable as\n a union operation on `finset`. (`s \u222a t` would also work as a union operation\n on finset, but this is more efficient.)"}, {"name": "multiset.cons_ndunion", "description": ""}, {"name": "multiset.ndinsert_zero", "description": ""}, {"name": "multiset.mem_ndunion", "description": ""}, {"name": "multiset.coe_ndinsert", "description": ""}, {"name": "multiset.mem_ndinsert_self", "description": ""}, {"name": "multiset.coe_ndinter", "description": ""}, {"name": "multiset.subset_ndunion_left", "description": ""}, {"name": "multiset.cons_ndinter_of_mem", "description": ""}, {"name": "multiset.dedup_add", "description": ""}, {"name": "multiset.le_ndinsert_self", "description": ""}, {"name": "multiset.le_ndunion_left", "description": ""}, {"name": "multiset.nodup.ndinter", "description": ""}, {"name": "multiset.le_ndunion_right", "description": ""}, {"name": "multiset.ndunion_le_add", "description": ""}, {"name": "multiset.ndinter_subset_right", "description": ""}, {"name": "multiset.ndinsert_of_mem", "description": ""}, {"name": "multiset.disjoint_ndinsert_right", "description": ""}, {"name": "multiset.zero_ndunion", "description": ""}, {"name": "multiset.ndinter_eq_inter", "description": ""}, {"name": "multiset.zero_ndinter", "description": ""}, {"name": "multiset.disjoint_ndinsert_left", "description": ""}, {"name": "multiset.nodup.ndunion", "description": ""}, {"name": "multiset.ndunion_eq_union", "description": ""}, {"name": "multiset.ndinter_cons_of_not_mem", "description": ""}, {"name": "multiset.ndinsert_le", "description": ""}, {"name": "min_eq_iff", "description": ""}, {"name": "min_lt_of_left_lt", "description": ""}, {"name": "min_eq_right_iff", "description": ""}, {"name": "max_min_distrib_right", "description": ""}, {"name": "max_associative", "description": ""}, {"name": "min_lt_min", "description": ""}, {"name": "max_lt_max", "description": ""}, {"name": "min_eq_left_iff", "description": ""}, {"name": "min_idem", "description": "An instance asserting that `min a a = a`"}, {"name": "monotone.map_max", "description": ""}, {"name": "max_left_commutative", "description": ""}, {"name": "max_le_iff", "description": ""}, {"name": "min_le_of_left_le", "description": ""}, {"name": "monotone_on.map_max", "description": ""}, {"name": "min_lt_of_right_lt", "description": ""}, {"name": "min_lt_min_left_iff", "description": ""}, {"name": "antitone_on.map_max", "description": ""}, {"name": "antitone_on.map_min", "description": ""}, {"name": "min_lt_iff", "description": ""}, {"name": "le_max_of_le_left", "description": ""}, {"name": "monotone.map_min", "description": ""}, {"name": "max_lt_max_right_iff", "description": ""}, {"name": "le_of_max_le_left", "description": ""}, {"name": "max.right_comm", "description": ""}, {"name": "max_lt_iff", "description": ""}, {"name": "lt_min_iff", "description": ""}, {"name": "le_min_iff", "description": ""}, {"name": "max_eq_right_iff", "description": ""}, {"name": "lt_max_iff", "description": ""}, {"name": "max_idem", "description": "An instance asserting that `max a a = a`"}, {"name": "max_commutative", "description": ""}, {"name": "min_cases", "description": "For elements `a` and `b` of a linear order, either `min a b = a` and `a \u2264 b`,\n   or `min a b = b` and `b < a`.\n   Use cases on this lemma to automate linarith in inequalities"}, {"name": "max_eq_left_iff", "description": ""}, {"name": "min_left_commutative", "description": ""}, {"name": "min_commutative", "description": ""}, {"name": "min_max_distrib_right", "description": ""}, {"name": "min_choice", "description": ""}, {"name": "min_lt_min_right_iff", "description": ""}, {"name": "min_associative", "description": ""}, {"name": "min_right_comm", "description": ""}, {"name": "max.left_comm", "description": ""}, {"name": "min_le_iff", "description": ""}, {"name": "max_min_distrib_left", "description": ""}, {"name": "min_le_min", "description": ""}, {"name": "antitone.map_min", "description": ""}, {"name": "max_eq_iff", "description": ""}, {"name": "max_choice", "description": ""}, {"name": "lt_max_of_lt_left", "description": ""}, {"name": "min_lt_max", "description": ""}, {"name": "monotone_on.map_min", "description": ""}, {"name": "le_max_iff", "description": ""}, {"name": "antitone.map_max", "description": ""}, {"name": "min_max_distrib_left", "description": ""}, {"name": "le_max_of_le_right", "description": ""}, {"name": "max_cases", "description": "For elements `a` and `b` of a linear order, either `max a b = a` and `b \u2264 a`,\n   or `max a b = b` and `a < b`.\n   Use cases on this lemma to automate linarith in inequalities"}, {"name": "min_le_of_right_le", "description": ""}, {"name": "min_le_max", "description": ""}, {"name": "max_lt_max_left_iff", "description": ""}, {"name": "le_of_max_le_right", "description": ""}, {"name": "max_le_max", "description": ""}, {"name": "lt_max_of_lt_right", "description": ""}, {"name": "nat.one_lt_two_pow", "description": ""}, {"name": "nat.pow_le_pow_of_le_left", "description": ""}, {"name": "nat.one_le_two_pow", "description": ""}, {"name": "nat.shiftl_eq_mul_pow", "description": ""}, {"name": "nat.one_le_pow", "description": ""}, {"name": "nat.one_lt_two_pow'", "description": ""}, {"name": "nat.shiftl'_tt_ne_zero", "description": ""}, {"name": "nat.pow_left_injective", "description": ""}, {"name": "nat.size_one", "description": ""}, {"name": "nat.pow_lt_pow_succ", "description": ""}, {"name": "nat.pow_dvd_of_le_of_pow_dvd", "description": ""}, {"name": "nat.not_pos_pow_dvd", "description": ""}, {"name": "nat.pow_lt_pow_of_lt_right", "description": ""}, {"name": "nat.shiftr_eq_div_pow", "description": ""}, {"name": "nat.size_pos", "description": ""}, {"name": "nat.pow_le_iff_le_left", "description": ""}, {"name": "nat.pow_lt_iff_lt_right", "description": ""}, {"name": "nat.pow_le_pow_of_le_right", "description": ""}, {"name": "nat.zero_shiftr", "description": ""}, {"name": "nat.size_le", "description": ""}, {"name": "nat.size_le_size", "description": ""}, {"name": "nat.one_shiftl", "description": ""}, {"name": "nat.lt_size_self", "description": ""}, {"name": "nat.pow_lt_iff_lt_left", "description": ""}, {"name": "nat.one_lt_pow_iff", "description": ""}, {"name": "nat.pow_dvd_pow_iff_pow_le_pow", "description": ""}, {"name": "strict_mono.nat_pow", "description": ""}, {"name": "nat.lt_size", "description": ""}, {"name": "nat.pow_right_strict_mono", "description": ""}, {"name": "nat.one_lt_pow'", "description": ""}, {"name": "nat.size_shiftl'", "description": ""}, {"name": "nat.pow_div", "description": ""}, {"name": "nat.pow_right_injective", "description": ""}, {"name": "nat.size_eq_zero", "description": ""}, {"name": "nat.size_bit0", "description": ""}, {"name": "nat.shiftl'_ne_zero_left", "description": ""}, {"name": "nat.one_lt_pow", "description": ""}, {"name": "nat.sq_sub_sq", "description": ""}, {"name": "nat.one_le_pow'", "description": ""}, {"name": "nat.pow_left_strict_mono", "description": ""}, {"name": "nat.pow_lt_pow_of_lt_left", "description": ""}, {"name": "nat.size_bit", "description": ""}, {"name": "nat.dvd_of_pow_dvd", "description": ""}, {"name": "nat.lt_pow_self", "description": ""}, {"name": "nat.zero_shiftl", "description": ""}, {"name": "nat.pow_le_iff_le_right", "description": ""}, {"name": "nat.size_zero", "description": ""}, {"name": "nat.size_shiftl", "description": ""}, {"name": "nat.mod_pow_succ", "description": ""}, {"name": "nat.lt_two_pow", "description": ""}, {"name": "nat.size_pow", "description": ""}, {"name": "nat.pow_two_sub_pow_two", "description": "**Alias** of `nat.sq_sub_sq`."}, {"name": "nat.mul_lt_mul_pow_succ", "description": ""}, {"name": "nat.lt_of_pow_dvd_right", "description": ""}, {"name": "nat.shiftl'_tt_eq_mul_pow", "description": ""}, {"name": "nat.pow_dvd_pow_iff_le_right'", "description": ""}, {"name": "nat.pow_dvd_pow_iff_le_right", "description": "If `1 < x`, then `x^k` divides `x^l` if and only if `k` is at most `l`."}, {"name": "nat.size_bit1", "description": ""}, {"name": "nat.pow_mod", "description": ""}, {"name": "pi.lex.is_strict_order", "description": ""}, {"name": "pi.is_trichotomous_lex", "description": ""}, {"name": "pi.lex.linear_order", "description": "`\u03a0\u2097 i, \u03b1 i` is a linear order if the original order is well-founded."}, {"name": "pi.lex.order_bot", "description": ""}, {"name": "pi.to_lex_apply", "description": ""}, {"name": "pi.lex.ordered_comm_group", "description": ""}, {"name": "pi.of_lex_apply", "description": ""}, {"name": "pi.lex", "description": "The lexicographic relation on `\u03a0 i : \u03b9, \u03b2 i`, where `\u03b9` is ordered by `r`,\n and each `\u03b2 i` is ordered by `s`."}, {"name": "pi.lex.ordered_add_comm_group", "description": ""}, {"name": "pi.lex.le_of_forall_le", "description": ""}, {"name": "pi.lex.partial_order", "description": ""}, {"name": "pi.lex.bounded_order", "description": ""}, {"name": "pi.lex.le_of_of_lex_le", "description": ""}, {"name": "pi.lex.order_top", "description": ""}, {"name": "pi.lex.inhabited", "description": ""}, {"name": "pi.lex.has_lt", "description": ""}, {"name": "pi.to_lex_monotone", "description": ""}, {"name": "rat.cast_injective", "description": ""}, {"name": "rat.cast_pos", "description": ""}, {"name": "rat.cast_multiset_sum", "description": ""}, {"name": "rat.cast_sub_of_ne_zero", "description": ""}, {"name": "rat.cast_list_sum", "description": ""}, {"name": "rat.cast_inv_of_ne_zero", "description": ""}, {"name": "rat.cast_hom_rat", "description": ""}, {"name": "rat.cast_coe_nat", "description": ""}, {"name": "rat.cast_mk", "description": ""}, {"name": "rat.cast_abs", "description": ""}, {"name": "map_rat_cast", "description": ""}, {"name": "ring_hom.ext_rat", "description": ""}, {"name": "rat.cast_pow", "description": ""}, {"name": "rat.cast_div", "description": ""}, {"name": "mul_opposite.unop_rat_cast", "description": ""}, {"name": "rat.cast_inv", "description": ""}, {"name": "monoid_with_zero_hom.ext_rat", "description": " If `f` and `g` agree on the integers then they are equal `\u03c6`.\n\nSee note [partially-applied ext lemmas] for why `comp` is used here."}, {"name": "rat.cast_one", "description": ""}, {"name": "rat.cast_id", "description": ""}, {"name": "rat.cast_list_prod", "description": ""}, {"name": "rat.cast_inv_nat", "description": ""}, {"name": "rat.cast_of_int", "description": ""}, {"name": "rat.cast_hom", "description": "Coercion `\u211a \u2192 \u03b1` as a `ring_hom`."}, {"name": "rat.cast_bit0", "description": ""}, {"name": "rat.cast_lt", "description": ""}, {"name": "rat.cast_lt_zero", "description": ""}, {"name": "rat.cast_neg", "description": ""}, {"name": "rat.cast_mk_of_ne_zero", "description": ""}, {"name": "rat.cast_add", "description": ""}, {"name": "rat.cast_ne_zero", "description": ""}, {"name": "rat.cast_nonpos", "description": ""}, {"name": "rat.cast_prod", "description": ""}, {"name": "rat.cast_bit1", "description": ""}, {"name": "rat.cast_coe_int", "description": ""}, {"name": "monoid_with_zero_hom.ext_rat_on_pnat", "description": "Positive integer values of a morphism `\u03c6` and its value on `-1` completely determine `\u03c6`."}, {"name": "rat.cast_add_of_ne_zero", "description": ""}, {"name": "rat.cast_inv_int", "description": ""}, {"name": "rat.coe_cast_hom", "description": ""}, {"name": "ring_hom.eq_rat_cast", "description": ""}, {"name": "rat.cast_nonneg", "description": ""}, {"name": "rat.cast_min", "description": ""}, {"name": "rat.cast_max", "description": ""}, {"name": "mul_opposite.op_rat_cast", "description": ""}, {"name": "rat.subsingleton_ring_hom", "description": ""}, {"name": "rat.cast_multiset_prod", "description": ""}, {"name": "rat.cast_commute", "description": ""}, {"name": "rat.cast_mul", "description": ""}, {"name": "rat.cast_mul_of_ne_zero", "description": ""}, {"name": "rat.cast_inj", "description": ""}, {"name": "rat.cast_div_of_ne_zero", "description": ""}, {"name": "rat.cast_sub", "description": ""}, {"name": "rat.cast_le", "description": ""}, {"name": "rat.cast_eq_zero", "description": ""}, {"name": "rat.commute_cast", "description": ""}, {"name": "rat.cast_sum", "description": ""}, {"name": "rat.cast_comm", "description": ""}, {"name": "rat.cast_zero", "description": ""}, {"name": "io.set_rand_gen", "description": ""}, {"name": "monad_io_environment_impl", "description": ""}, {"name": "io_rand_nat", "description": ""}, {"name": "io.stderr", "description": ""}, {"name": "io.fs.read_file", "description": ""}, {"name": "format.print", "description": ""}, {"name": "monad_io_process_impl", "description": ""}, {"name": "pp", "description": ""}, {"name": "io.proc.sleep", "description": ""}, {"name": "io.catch", "description": ""}, {"name": "io.finally", "description": ""}, {"name": "io.net.send", "description": ""}, {"name": "io.handle", "description": ""}, {"name": "io.fs.put_str_ln", "description": ""}, {"name": "io_core", "description": ""}, {"name": "io.fs.get_char", "description": ""}, {"name": "monad_io_random_impl", "description": ""}, {"name": "io.env.set_cwd", "description": "set the current working directory"}, {"name": "io.run_tactic", "description": "Execute the given tactic with a tactic_state object that contains:\n- The current environment in the virtual machine.\n- The current set of options in the virtual machine.\n- Empty metavariable and local contexts.\n- One single goal of the form `\u22a2 true`.\nThis action is mainly useful for writing tactics that inspect\nthe environment."}, {"name": "io.iterate", "description": ""}, {"name": "io.proc.child", "description": ""}, {"name": "io", "description": ""}, {"name": "io.fs.rename", "description": ""}, {"name": "io.cmdline_args", "description": ""}, {"name": "io.fs.get_line", "description": ""}, {"name": "monad_io_file_system_impl", "description": ""}, {"name": "io.fs.flush", "description": ""}, {"name": "io.cmd", "description": "Run the external process specified by `args`.\n\n   The process will run to completion with its output captured by a pipe, and\n   read into `string` which is then returned."}, {"name": "io.put_str_ln", "description": ""}, {"name": "monad_io_impl", "description": ""}, {"name": "io.mk_file_handle", "description": ""}, {"name": "io.print", "description": ""}, {"name": "format.print_using", "description": ""}, {"name": "io.fs.put_char", "description": ""}, {"name": "io.net.connect", "description": ""}, {"name": "io.fs.rmdir", "description": ""}, {"name": "io.proc.child.stdin", "description": ""}, {"name": "io.proc.child.stderr", "description": ""}, {"name": "io.deserialize", "description": ""}, {"name": "io.fs.read", "description": ""}, {"name": "io.serialize", "description": ""}, {"name": "io.rand", "description": ""}, {"name": "io.print_ln", "description": ""}, {"name": "io_core_is_monad_fail", "description": ""}, {"name": "io.fs.write", "description": ""}, {"name": "io.env.get_cwd", "description": "get the current working directory"}, {"name": "io.net.close", "description": ""}, {"name": "io.proc.wait", "description": ""}, {"name": "io.env.get", "description": ""}, {"name": "monad_io_net_system_impl", "description": ""}, {"name": "io.net.socket", "description": ""}, {"name": "io.unsafe_perform_io", "description": " Similarly to `tactic.unsafe_run_io`, this gives an unsafe backdoor to run io inside a pure function.\n\nIf `unsafe_perform_io` is used to perform side-effects, users need to take the following\nprecautions:\n\n- Use `@[noinline]` attribute in any function to invokes `tactic.unsafe_perform_io`.\n  Reason: if the call is inlined, the IO may be performed more than once.\n\n- Set `set_option compiler.cse false` before any function that invokes `tactic.unsafe_perform_io`.\n  This option disables common subexpression elimination. Common subexpression elimination\n  might combine two side effects that were meant to be separate.\n\nTODO[Leo]: add `[noinline]` attribute and option `compiler.cse`."}, {"name": "monad_io_serial_impl", "description": ""}, {"name": "monad_io_terminal_impl", "description": ""}, {"name": "io.net.accept", "description": ""}, {"name": "io_core_is_alternative", "description": ""}, {"name": "io_core_is_monad", "description": ""}, {"name": "io.fs.remove", "description": ""}, {"name": "io.fs.close", "description": ""}, {"name": "io.fs.read_to_end", "description": ""}, {"name": "io.stdin", "description": ""}, {"name": "io.put_str", "description": ""}, {"name": "io.fs.dir_exists", "description": ""}, {"name": "io.net.listen", "description": ""}, {"name": "tactic.unsafe_run_io", "description": "This is the \"back door\" into the `io` monad, allowing IO computation to be performed during tactic execution.\nFor this to be safe, the IO computation should be ideally free of side effects and independent of its environment.\nThis primitive is used to invoke external tools (e.g., SAT and SMT solvers) from a tactic."}, {"name": "io.fs.file_exists", "description": ""}, {"name": "io.get_line", "description": ""}, {"name": "io.proc.spawn", "description": ""}, {"name": "io.forever", "description": ""}, {"name": "io.fs.put_str", "description": ""}, {"name": "io.net.recv", "description": ""}, {"name": "io.proc.child.stdout", "description": ""}, {"name": "io.fail", "description": ""}, {"name": "io.stdout", "description": ""}, {"name": "io.fs.is_eof", "description": ""}, {"name": "pp_using", "description": ""}, {"name": "io.fs.mkdir", "description": ""}, {"name": "quot.induction_on\u2082", "description": ""}, {"name": "quot.lift_on.decidable", "description": ""}, {"name": "trunc.nonempty", "description": ""}, {"name": "quotient.lift_on'.decidable", "description": ""}, {"name": "quotient.induction_on_pi", "description": ""}, {"name": "setoid.ext", "description": ""}, {"name": "quotient.ind'", "description": " A version of `quotient.ind` taking `{s : setoid \u03b1}` as an implicit argument instead of an\ninstance argument."}, {"name": "quotient.subsingleton", "description": ""}, {"name": "quotient.hrec_on\u2082'_mk'", "description": ""}, {"name": "quotient.lift_on'_mk", "description": ""}, {"name": "quotient.map'_mk", "description": ""}, {"name": "quotient.lift_on'_mk'", "description": ""}, {"name": "trunc.rec", "description": "Recursion/induction principle for `trunc`."}, {"name": "quotient.map\u2082'_mk'", "description": ""}, {"name": "quotient.map", "description": " Map a function `f : \u03b1 \u2192 \u03b2` that sends equivalent elements to equivalent elements\nto a function `quotient sa \u2192 quotient sb`. Useful to define unary operations on quotients."}, {"name": "quot.lift\u2082_mk", "description": ""}, {"name": "quotient.lift_on_mk", "description": ""}, {"name": "trunc.mk", "description": "Constructor for `trunc \u03b1`"}, {"name": "quotient.rec_on_subsingleton'", "description": " A version of `quotient.rec_on_subsingleton` taking `{s\u2081 : setoid \u03b1}` as an implicit argument\ninstead of an instance argument."}, {"name": "quot.map\u2082", "description": " Descends a function `f : \u03b1 \u2192 \u03b2 \u2192 \u03b3` to quotients of `\u03b1` and `\u03b2` wih values in a quotient of\n`\u03b3`."}, {"name": "quot.induction_on\u2083", "description": ""}, {"name": "quotient.map_mk", "description": ""}, {"name": "quotient.choice_eq", "description": ""}, {"name": "quotient.lift_mk", "description": ""}, {"name": "trunc.lift", "description": "Any constant function lifts to a function out of the truncation"}, {"name": "quotient.exact'", "description": ""}, {"name": "quot.out", "description": "Choose an element of the equivalence class using the axiom of choice.\n Sound but noncomputable."}, {"name": "quotient.lift\u2082.decidable_pred", "description": "Note that this provides `decidable_rel (quotient.lift\u2082 f h)` when `\u03b1 = \u03b2`."}, {"name": "trunc", "description": "`trunc \u03b1` is the quotient of `\u03b1` by the always-true relation. This\n is related to the propositional truncation in HoTT, and is similar\n in effect to `nonempty \u03b1`, but unlike `nonempty \u03b1`, `trunc \u03b1` is data,\n so the VM representation is the same as `\u03b1`, and so this can be used to\n maintain computability."}, {"name": "quot.unquot", "description": "Unwrap the VM representation of a quotient to obtain an element of the equivalence class.\n Computable but unsound."}, {"name": "quotient.map'_mk'", "description": ""}, {"name": "quotient.map\u2082", "description": " Map a function `f : \u03b1 \u2192 \u03b2 \u2192 \u03b3` that sends equivalent elements to equivalent elements\nto a function `f : quotient sa \u2192 quotient sb \u2192 quotient sc`.\nUseful to define binary operations on quotients."}, {"name": "surjective_quot_mk", "description": "`quot.mk r` is a surjective function."}, {"name": "quotient.mk_out", "description": ""}, {"name": "quotient.sound'", "description": ""}, {"name": "quotient.out_eq'", "description": ""}, {"name": "quotient.ind\u2082'", "description": " A version of `quotient.ind\u2082` taking `{s\u2081 : setoid \u03b1} {s\u2082 : setoid \u03b2}` as implicit arguments\ninstead of instance arguments."}, {"name": "quotient.map\u2082_mk", "description": ""}, {"name": "quotient.map'", "description": " Map a function `f : \u03b1 \u2192 \u03b2` that sends equivalent elements to equivalent elements\nto a function `quotient sa \u2192 quotient sb`. Useful to define unary operations on quotients."}, {"name": "quotient.lift_on\u2082'_mk", "description": ""}, {"name": "quotient.induction_on\u2082'", "description": " A version of `quotient.induction_on\u2082` taking `{s\u2081 : setoid \u03b1} {s\u2082 : setoid \u03b2}` as implicit\narguments instead of instance arguments."}, {"name": "pi_setoid", "description": ""}, {"name": "trunc.inhabited", "description": ""}, {"name": "trunc.out", "description": "Noncomputably extract a representative of `trunc \u03b1` (using the axiom of choice)."}, {"name": "surjective_quotient_mk", "description": "`quotient.mk` is a surjective function."}, {"name": "quotient.eq_mk_iff_out", "description": ""}, {"name": "quotient.lift.decidable_pred", "description": ""}, {"name": "true_equivalence", "description": ""}, {"name": "quotient.out_injective", "description": ""}, {"name": "quotient.out'", "description": " A version of `quotient.out` taking `{s\u2081 : setoid \u03b1}` as an implicit argument instead of an\ninstance argument."}, {"name": "quot.inhabited", "description": ""}, {"name": "quot.lift_on\u2082.decidable", "description": ""}, {"name": "quotient.hrec_on'", "description": "Recursion on a `quotient` argument `a`, result type depends on `\u27e6a\u27e7`."}, {"name": "trunc.monad", "description": ""}, {"name": "quotient.lift_on\u2082'.decidable", "description": ""}, {"name": "quotient.eq'", "description": ""}, {"name": "quotient.lift_on.decidable", "description": ""}, {"name": "quot.factor", "description": "Weaken the relation of a quotient. This is the same as `quot.map id`."}, {"name": "nonempty_quotient_iff", "description": ""}, {"name": "quotient.surjective_quotient_mk'", "description": "`quotient.mk'` is a surjective function."}, {"name": "quotient.out_inj", "description": ""}, {"name": "quotient.choice", "description": " Given a function `f : \u03a0 i, quotient (S i)`, returns the class of functions `\u03a0 i, \u03b1 i` sending\neach `i` to an element of the class `f i`."}, {"name": "trunc.rec_on", "description": "A version of `trunc.rec` taking `q : trunc \u03b1` as the first argument."}, {"name": "quotient.rec_on_subsingleton\u2082'", "description": " A version of `quotient.rec_on_subsingleton\u2082` taking `{s\u2081 : setoid \u03b1} {s\u2082 : setoid \u03b1}`\nas implicit arguments instead of instance arguments."}, {"name": "quot.lift_on\u2082_mk", "description": ""}, {"name": "quotient.lift_comp_mk", "description": ""}, {"name": "quot.factor_mk_eq", "description": ""}, {"name": "quot.map", "description": " Map a function `f : \u03b1 \u2192 \u03b2` such that `ra x y` implies `rb (f x) (f y)`\nto a map `quot ra \u2192 quot rb`."}, {"name": "quotient.mk_out'", "description": ""}, {"name": "trunc.bind", "description": "The `bind` operator for the `trunc` monad."}, {"name": "quotient.lift_on\u2082.decidable", "description": ""}, {"name": "trunc.rec_on_subsingleton", "description": "A version of `trunc.rec_on` assuming the codomain is a `subsingleton`."}, {"name": "quot.map_right", "description": "If `ra` is a subrelation of `ra'`, then we have a natural map `quot ra \u2192 quot ra'`."}, {"name": "quot.rec_on_subsingleton\u2082", "description": "A binary version of `quot.rec_on_subsingleton`."}, {"name": "quot.lift_mk", "description": "**Alias** of `quot.lift_beta`."}, {"name": "forall_quotient_iff", "description": ""}, {"name": "quot.lift_on_mk", "description": ""}, {"name": "quotient.lift\u2082_mk", "description": ""}, {"name": "quotient.mk_eq_iff_out", "description": ""}, {"name": "quotient.map\u2082'", "description": "A version of `quotient.map\u2082` using curly braces and unification."}, {"name": "quot.lift_on\u2082", "description": "Descends a function `f : \u03b1 \u2192 \u03b2 \u2192 \u03b3` to quotients of `\u03b1` and `\u03b2` and applies it."}, {"name": "quotient.mk'", "description": " A version of `quotient.mk` taking `{s : setoid \u03b1}` as an implicit argument instead of an\ninstance argument."}, {"name": "quot.lift\u2082.decidable_pred", "description": "Note that this provides `decidable_rel (quot.lift\u2082 f ha hb)` when `\u03b1 = \u03b2`."}, {"name": "trunc.map", "description": "A function `f : \u03b1 \u2192 \u03b2` defines a function `map f : trunc \u03b1 \u2192 trunc \u03b2`."}, {"name": "quot.eq", "description": ""}, {"name": "trunc.out_eq", "description": ""}, {"name": "quot.lift\u2082", "description": "Descends a function `f : \u03b1 \u2192 \u03b2 \u2192 \u03b3` to quotients of `\u03b1` and `\u03b2`."}, {"name": "trunc.ind", "description": ""}, {"name": "trunc.eq", "description": ""}, {"name": "quotient.hrec_on'_mk'", "description": ""}, {"name": "quotient.lift_on\u2082'", "description": " A version of `quotient.lift_on\u2082` taking `{s\u2081 : setoid \u03b1} {s\u2082 : setoid \u03b2}` as implicit arguments\ninstead of instance arguments."}, {"name": "quotient.lift_on\u2082_mk", "description": ""}, {"name": "quotient.inhabited", "description": ""}, {"name": "trunc.subsingleton", "description": ""}, {"name": "quotient.hrec_on\u2082", "description": "Induction on two `quotient` arguments `a` and `b`, result type depends on `\u27e6a\u27e7` and `\u27e6b\u27e7`."}, {"name": "quotient.out_eq", "description": ""}, {"name": "quot.subsingleton", "description": ""}, {"name": "quot.map\u2082_mk", "description": ""}, {"name": "quotient.lift_on'", "description": " A version of `quotient.lift_on` taking `{s : setoid \u03b1}` as an implicit argument instead of an\ninstance argument."}, {"name": "trunc.exists_rep", "description": ""}, {"name": "quotient.lift_on\u2082'_mk'", "description": ""}, {"name": "trunc.induction_on\u2082", "description": ""}, {"name": "quot.out_eq", "description": ""}, {"name": "quotient.out_equiv_out", "description": ""}, {"name": "quotient.has_equiv.equiv.is_equiv", "description": ""}, {"name": "trunc.is_lawful_monad", "description": ""}, {"name": "trunc.lift_on", "description": "Lift a constant function on `q : trunc \u03b1`."}, {"name": "quotient.eq", "description": ""}, {"name": "trunc.induction_on", "description": ""}, {"name": "quotient.induction_on'", "description": " A version of `quotient.induction_on` taking `{s : setoid \u03b1}` as an implicit argument instead\nof an instance argument."}, {"name": "quot.lift.decidable_pred", "description": ""}, {"name": "quotient.induction_on\u2083'", "description": " A version of `quotient.induction_on\u2083` taking `{s\u2081 : setoid \u03b1} {s\u2082 : setoid \u03b2} {s\u2083 : setoid \u03b3}`\nas implicit arguments instead of instance arguments."}, {"name": "quotient.out", "description": "Choose an element of the equivalence class using the axiom of choice.\n Sound but noncomputable."}, {"name": "quot.hrec_on\u2082", "description": "Recursion on two `quotient` arguments `a` and `b`, result type depends on `\u27e6a\u27e7` and `\u27e6b\u27e7`."}, {"name": "quotient.mk'_eq_mk", "description": ""}, {"name": "quotient.hrec_on\u2082'", "description": "Recursion on two `quotient` arguments `a` and `b`, result type depends on `\u27e6a\u27e7` and `\u27e6b\u27e7`."}, {"name": "trunc.lift_mk", "description": ""}, {"name": "div_zero", "description": ""}, {"name": "group_with_zero.to_division_monoid", "description": ""}, {"name": "comm_group_with_zero_of_is_unit_or_eq_zero", "description": "Constructs a `comm_group_with_zero` structure on a `comm_monoid_with_zero`\n consisting only of units and 0."}, {"name": "mul_inv_mul_self", "description": " Multiplying `a` by its inverse and then by itself results in `a`\n(whether or not `a` is zero)."}, {"name": "ring.inverse", "description": " Introduce a function `inverse` on a monoid with zero `M\u2080`, which sends `x` to `x\u207b\u00b9` if `x` is\ninvertible and to `0` otherwise.  This definition is somewhat ad hoc, but one needs a fully (rather\nthan partially) defined inverse function for some purposes, including for calculus.\n\nNote that while this is in the `ring` namespace for brevity, it requires the weaker assumption\n`monoid_with_zero M\u2080` instead of `ring M\u2080`."}, {"name": "inv_monoid_with_zero_hom", "description": "Inversion on a commutative group with zero, considered as a monoid with zero homomorphism."}, {"name": "group_with_zero.eq_zero_or_unit", "description": ""}, {"name": "div_eq_of_eq_mul", "description": ""}, {"name": "mul_ne_zero_comm", "description": " If `\u03b1` has no zero divisors, then for elements `a, b : \u03b1`, `a * b` is nonzero iff so is\n`b * a`."}, {"name": "units.mk0_inj", "description": ""}, {"name": "ne.is_unit", "description": "**Alias** of the reverse direction of `is_unit_iff_ne_zero`."}, {"name": "group_with_zero.no_zero_divisors", "description": ""}, {"name": "mul_inv_cancel_left\u2080", "description": ""}, {"name": "ring.inverse_mul_cancel_left", "description": ""}, {"name": "commute.zero_right", "description": ""}, {"name": "div_eq_zero_iff", "description": ""}, {"name": "comm_group_with_zero.to_division_comm_monoid", "description": ""}, {"name": "mul_ne_zero_iff", "description": " If `\u03b1` has no zero divisors, then the product of two elements is nonzero iff both of them\nare nonzero."}, {"name": "mul_inv_cancel_right\u2080", "description": ""}, {"name": "inv_mul_eq_iff_eq_mul\u2080", "description": ""}, {"name": "mul_eq_one_iff_eq_inv\u2080", "description": ""}, {"name": "mul_self_div_self", "description": " Multiplying `a` by itself and then dividing by itself results in `a`, whether or not `a` is\nzero."}, {"name": "mul_right_eq_self\u2080", "description": ""}, {"name": "eq_zero_of_mul_eq_self_right", "description": " An element of a `cancel_monoid_with_zero` fixed by right multiplication by an element other\nthan one must be zero."}, {"name": "monoid_with_zero_hom.map_units_inv", "description": ""}, {"name": "eq_of_zero_eq_one", "description": ""}, {"name": "semiconj_by.inv_right\u2080", "description": ""}, {"name": "right_ne_zero_of_mul", "description": ""}, {"name": "function.injective.comm_group_with_zero", "description": " Pullback a `comm_group_with_zero` class along an injective function.\nSee note [reducible non-instances]."}, {"name": "function.injective.mul_zero_class", "description": " Pullback a `mul_zero_class` instance along an injective function.\nSee note [reducible non-instances]."}, {"name": "mul_div_cancel_of_imp'", "description": ""}, {"name": "units.mk0_coe", "description": ""}, {"name": "function.surjective.comm_monoid_with_zero", "description": " Pushforward a `monoid_with_zero` class along a surjective function.\nSee note [reducible non-instances]."}, {"name": "inv_ne_zero", "description": ""}, {"name": "ring.mul_inverse_rev'", "description": ""}, {"name": "div_mul_div_cancel", "description": ""}, {"name": "function.surjective.mul_zero_class", "description": " Pushforward a `mul_zero_class` instance along an surjective function.\nSee note [reducible non-instances]."}, {"name": "ring.inverse_non_unit", "description": "By definition, if `x` is not invertible then `inverse x = 0`."}, {"name": "function.injective.cancel_monoid_with_zero", "description": " Pullback a `monoid_with_zero` class along an injective function.\nSee note [reducible non-instances]."}, {"name": "mul_left_inj'", "description": ""}, {"name": "div_mul_cancel", "description": ""}, {"name": "mul_ne_zero", "description": ""}, {"name": "cancel_monoid_with_zero.to_no_zero_divisors", "description": ""}, {"name": "mul_div_cancel_left", "description": ""}, {"name": "div_self", "description": ""}, {"name": "commute.inv_left_iff\u2080", "description": ""}, {"name": "div_div_self", "description": " Dividing `a` by the result of dividing `a` by itself results in\n`a` (whether or not `a` is zero)."}, {"name": "eq_zero_of_mul_self_eq_zero", "description": ""}, {"name": "zero_ne_mul_self", "description": ""}, {"name": "div_helper", "description": ""}, {"name": "ring.inverse_unit", "description": "By definition, if `x` is invertible then `inverse x = x\u207b\u00b9`."}, {"name": "div_mul_left", "description": ""}, {"name": "mul_eq_zero_of_right", "description": ""}, {"name": "mul_self_mul_inv", "description": " Multiplying `a` by itself and then by its inverse results in `a`\n(whether or not `a` is zero)."}, {"name": "units.exists0'", "description": " An alternative version of `units.exists0`. This one is useful if Lean cannot\nfigure out `p` when using `units.exists0` from right to left."}, {"name": "units.exists0", "description": "In a group with zero, an existential over a unit can be rewritten in terms of `units.mk0`."}, {"name": "right_ne_zero_of_mul_eq_one", "description": ""}, {"name": "function.injective.group_with_zero", "description": " Pullback a `group_with_zero` class along an injective function.\nSee note [reducible non-instances]."}, {"name": "units.exists_iff_ne_zero", "description": ""}, {"name": "mul_one_div_cancel", "description": ""}, {"name": "commute.inv_right\u2080", "description": ""}, {"name": "div_ne_zero_iff", "description": ""}, {"name": "left_ne_zero_of_mul", "description": ""}, {"name": "zero_div", "description": ""}, {"name": "monoid_hom.map_units_inv", "description": ""}, {"name": "zero_ne_one_or_forall_eq_0", "description": "In a monoid with zero, either zero and one are nonequal, or zero is the only element."}, {"name": "mul_eq_mul_left_iff", "description": ""}, {"name": "ne_zero_of_eq_one", "description": ""}, {"name": "units.mk0_mul", "description": ""}, {"name": "group_with_zero_of_is_unit_or_eq_zero", "description": "Constructs a `group_with_zero` structure on a `monoid_with_zero`\n consisting only of units and 0."}, {"name": "eq_div_of_mul_eq", "description": ""}, {"name": "inv_eq_zero", "description": ""}, {"name": "mul_zero_eq_const", "description": "To match `mul_one_eq_id`."}, {"name": "div_ne_zero", "description": ""}, {"name": "units.ne_zero", "description": "An element of the unit group of a nonzero monoid with zero represented as an element\n   of the monoid is nonzero."}, {"name": "eq_mul_inv_iff_mul_eq\u2080", "description": ""}, {"name": "function.injective.comm_monoid_with_zero", "description": " Pullback a `monoid_with_zero` class along an injective function.\nSee note [reducible non-instances]."}, {"name": "function.injective.mul_zero_one_class", "description": " Pullback a `mul_zero_one_class` instance along an injective function.\nSee note [reducible non-instances]."}, {"name": "ring.inverse_eq_inv'", "description": ""}, {"name": "mul_eq_one_iff_inv_eq\u2080", "description": ""}, {"name": "mul_eq_zero_of_left", "description": ""}, {"name": "ne_zero_of_one_div_ne_zero", "description": ""}, {"name": "mul_right_inj'", "description": ""}, {"name": "one_div_ne_zero", "description": ""}, {"name": "inv_mul_eq_one\u2080", "description": ""}, {"name": "monoid_with_zero_hom.map_div", "description": ""}, {"name": "ring.inverse_one", "description": ""}, {"name": "semiconj_by.div_right", "description": ""}, {"name": "is_unit_zero_iff", "description": ""}, {"name": "units.coe_mk0", "description": ""}, {"name": "monoid_with_zero_hom.map_ne_zero", "description": ""}, {"name": "unique_of_zero_eq_one", "description": " In a monoid with zero, if zero equals one, then zero is the unique element.\n\nSomewhat arbitrarily, we define the default element to be `0`.\nAll other elements will be provably equal to it, but not necessarily definitionally equal."}, {"name": "commute.inv_right_iff\u2080", "description": ""}, {"name": "eq_inv_mul_iff_mul_eq\u2080", "description": ""}, {"name": "one_div_mul_cancel", "description": ""}, {"name": "units.mul_right_eq_zero", "description": ""}, {"name": "div_mul_right", "description": ""}, {"name": "semiconj_by.inv_symm_left_iff\u2080", "description": ""}, {"name": "not_is_unit_zero", "description": ""}, {"name": "monoid_with_zero.inverse_apply", "description": ""}, {"name": "units.smul_mk0", "description": ""}, {"name": "div_self_mul_self", "description": " Dividing `a` by itself and then multiplying by itself results in `a`, whether or not `a` is\nzero."}, {"name": "function.surjective.semigroup_with_zero", "description": " Pushforward a `semigroup_with_zero` class along an surjective function.\nSee note [reducible non-instances]."}, {"name": "monoid_with_zero_hom.map_eq_zero", "description": ""}, {"name": "commute.inv_left\u2080", "description": ""}, {"name": "units.mk0_one", "description": ""}, {"name": "div_div_div_cancel_right", "description": ""}, {"name": "eq_zero_of_zero_eq_one", "description": "In a monoid with zero, if zero equals one, then zero is the only element."}, {"name": "monoid_with_zero.coe_inverse", "description": ""}, {"name": "div_eq_iff_mul_eq", "description": ""}, {"name": "ring.mul_inverse_cancel", "description": ""}, {"name": "is_unit.ne_zero", "description": ""}, {"name": "div_eq_iff", "description": ""}, {"name": "div_div_cancel'", "description": ""}, {"name": "pullback_nonzero", "description": "Pullback a `nontrivial` instance along a function sending `0` to `0` and `1` to `1`."}, {"name": "semiconj_by.inv_symm_left\u2080", "description": ""}, {"name": "function.injective.monoid_with_zero", "description": " Pullback a `monoid_with_zero` class along an injective function.\nSee note [reducible non-instances]."}, {"name": "ring.inverse_zero", "description": ""}, {"name": "mul_eq_mul_of_div_eq_div", "description": ""}, {"name": "subsingleton_iff_zero_eq_one", "description": " In a monoid with zero, zero equals one if and only if all elements of that semiring\nare equal."}, {"name": "is_unit_iff_ne_zero", "description": ""}, {"name": "zero_mul_eq_const", "description": "To match `one_mul_eq_id`."}, {"name": "comm_group_with_zero.cancel_comm_monoid_with_zero", "description": ""}, {"name": "div_eq_one_iff_eq", "description": ""}, {"name": "mul_div_mul_left", "description": ""}, {"name": "units.inv_mul'", "description": ""}, {"name": "one_ne_zero", "description": ""}, {"name": "mul_inv_eq_iff_eq_mul\u2080", "description": ""}, {"name": "units.mul_left_eq_zero", "description": ""}, {"name": "mul_div_cancel'", "description": ""}, {"name": "semiconj_by.inv_right_iff\u2080", "description": ""}, {"name": "mul_div_mul_right", "description": ""}, {"name": "eq_zero_of_mul_eq_self_left", "description": " An element of a `cancel_monoid_with_zero` fixed by left multiplication by an element other\nthan one must be zero."}, {"name": "semiconj_by.zero_left", "description": ""}, {"name": "commute.div_left", "description": ""}, {"name": "zero_eq_mul_self", "description": ""}, {"name": "units.mk0", "description": "Embed a non-zero element of a `group_with_zero` into the unit group.\n By combining this function with the operations on units,\n or the `/\u209a` operation, it is possible to write a division\n as a partial function with three arguments."}, {"name": "eq_div_iff", "description": ""}, {"name": "mul_div_cancel", "description": ""}, {"name": "inv_mul_cancel", "description": ""}, {"name": "semiconj_by.zero_right", "description": ""}, {"name": "group_with_zero.mul_left_injective", "description": ""}, {"name": "units.mul_inv'", "description": ""}, {"name": "function.surjective.mul_zero_one_class", "description": " Pushforward a `mul_zero_one_class` instance along an surjective function.\nSee note [reducible non-instances]."}, {"name": "inv_mul_cancel_right\u2080", "description": ""}, {"name": "commute.zero_left", "description": ""}, {"name": "mul_self_eq_zero", "description": ""}, {"name": "group_with_zero.mul_right_injective", "description": ""}, {"name": "mul_inv_eq_one\u2080", "description": ""}, {"name": "zero_eq_mul", "description": " If `\u03b1` has no zero divisors, then the product of two elements equals zero iff one of them\nequals zero."}, {"name": "is_unit_ring_inverse", "description": ""}, {"name": "zero_eq_inv", "description": ""}, {"name": "div_left_inj'", "description": ""}, {"name": "mul_self_ne_zero", "description": ""}, {"name": "is_unit.mk0", "description": ""}, {"name": "zero_ne_one", "description": "In a nontrivial monoid with zero, zero and one are different."}, {"name": "inv_mul_cancel_left\u2080", "description": ""}, {"name": "mul_eq_mul_right_iff", "description": ""}, {"name": "function.injective.cancel_comm_monoid_with_zero", "description": " Pullback a `cancel_comm_monoid_with_zero` class along an injective function.\nSee note [reducible non-instances]."}, {"name": "function.surjective.comm_group_with_zero", "description": "Pushforward a `comm_group_with_zero` class along a surjective function."}, {"name": "group_with_zero.cancel_monoid_with_zero", "description": ""}, {"name": "ring.mul_inverse_cancel_right", "description": ""}, {"name": "mul_mul_div", "description": ""}, {"name": "ring.inverse_eq_inv", "description": ""}, {"name": "mul_eq_zero_of_ne_zero_imp_eq_zero", "description": ""}, {"name": "mul_left_eq_self\u2080", "description": ""}, {"name": "ne_zero_and_ne_zero_of_mul", "description": ""}, {"name": "mul_eq_zero_comm", "description": " If `\u03b1` has no zero divisors, then for elements `a, b : \u03b1`, `a * b` equals zero iff so is\n`b * a`."}, {"name": "is_unit.mul_right_eq_zero", "description": ""}, {"name": "left_ne_zero_of_mul_eq_one", "description": ""}, {"name": "is_unit.mul_left_eq_zero", "description": ""}, {"name": "is_unit.ring_inverse", "description": ""}, {"name": "div_self_mul_self'", "description": ""}, {"name": "eq_zero_of_one_div_eq_zero", "description": ""}, {"name": "ring.inverse_mul_cancel", "description": ""}, {"name": "function.injective.no_zero_divisors", "description": "Pushforward a `no_zero_divisors` instance along an injective function."}, {"name": "div_mul_cancel_of_imp", "description": ""}, {"name": "ring.mul_inverse_rev", "description": ""}, {"name": "commute.ring_inverse_ring_inverse", "description": ""}, {"name": "ring.inverse_mul_cancel_right", "description": ""}, {"name": "subsingleton_of_zero_eq_one", "description": "**Alias** of the forward direction of `subsingleton_iff_zero_eq_one`."}, {"name": "div_eq_div_iff", "description": ""}, {"name": "mul_div_cancel_of_imp", "description": ""}, {"name": "function.surjective.group_with_zero", "description": " Pushforward a `group_with_zero` class along an surjective function.\nSee note [reducible non-instances]."}, {"name": "function.injective.semigroup_with_zero", "description": " Pullback a `semigroup_with_zero` class along an injective function.\nSee note [reducible non-instances]."}, {"name": "ring.mul_inverse_cancel_left", "description": ""}, {"name": "mul_div_cancel_left_of_imp", "description": ""}, {"name": "divp_mk0", "description": ""}, {"name": "eq_div_iff_mul_eq", "description": ""}, {"name": "mul_eq_zero", "description": " If `\u03b1` has no zero divisors, then the product of two elements equals zero iff one of them\nequals zero."}, {"name": "monoid_with_zero_hom.map_inv", "description": "A monoid homomorphism between groups with zeros sending `0` to `0` sends `a\u207b\u00b9` to `(f a)\u207b\u00b9`."}, {"name": "monoid_with_zero.inverse", "description": " We define the inverse as a `monoid_with_zero_hom` by extending the inverse map by zero\non non-units."}, {"name": "function.surjective.monoid_with_zero", "description": " Pushforward a `monoid_with_zero` class along a surjective function.\nSee note [reducible non-instances]."}, {"name": "inv_mul_mul_self", "description": " Multiplying `a\u207b\u00b9` by `a` twice results in `a` (whether or not `a`\nis zero)."}, {"name": "commute.div_right", "description": ""}, {"name": "nat.lt_add_left", "description": ""}, {"name": "well_founded_tactics.clear_internals", "description": ""}, {"name": "nat.zero_lt_one_add", "description": ""}, {"name": "well_founded_tactics.default", "description": ""}, {"name": "nat.lt_add_of_zero_lt_left", "description": ""}, {"name": "well_founded_tactics.cancel_nat_add_lt", "description": ""}, {"name": "well_founded_tactics.is_psigma_mk", "description": ""}, {"name": "psum.has_sizeof_alt", "description": ""}, {"name": "well_founded_tactics.unfold_sizeof", "description": ""}, {"name": "well_founded_tactics.mk_alt_sizeof", "description": ""}, {"name": "well_founded_tactics.id_tag.wf", "description": ""}, {"name": "well_founded_tactics.unfold_wf_rel", "description": ""}, {"name": "well_founded_tactics.trivial_nat_lt", "description": ""}, {"name": "well_founded_tactics.default_rel_tac", "description": ""}, {"name": "well_founded_tactics.process_lex", "description": ""}, {"name": "nat.lt_add_right", "description": ""}, {"name": "well_founded_tactics", "description": "Argument for using_well_founded\n\n The tactic `rel_tac` has to synthesize an element of type (has_well_founded A).\n The two arguments are: a local representing the function being defined by well\n founded recursion, and a list of recursive equations.\n The equations can be used to decide which well founded relation should be used.\n\n The tactic `dec_tac` has to synthesize decreasing proofs."}, {"name": "well_founded_tactics.rel_tac", "description": "Argument for using_well_founded\n\n The tactic `rel_tac` has to synthesize an element of type (has_well_founded A).\n The two arguments are: a local representing the function being defined by well\n founded recursion, and a list of recursive equations.\n The equations can be used to decide which well founded relation should be used.\n\n The tactic `dec_tac` has to synthesize decreasing proofs."}, {"name": "well_founded_tactics.dec_tac", "description": "Argument for using_well_founded\n\n The tactic `rel_tac` has to synthesize an element of type (has_well_founded A).\n The two arguments are: a local representing the function being defined by well\n founded recursion, and a list of recursive equations.\n The equations can be used to decide which well founded relation should be used.\n\n The tactic `dec_tac` has to synthesize decreasing proofs."}, {"name": "psum.alt.sizeof", "description": ""}, {"name": "well_founded_tactics.default_dec_tac", "description": ""}, {"name": "well_founded_tactics.check_target_is_value_lt", "description": ""}, {"name": "subrel.is_well_order", "description": ""}, {"name": "rel_iso.eq_iff_eq", "description": ""}, {"name": "rel_embedding.sum_lift_rel_inl_apply", "description": ""}, {"name": "rel_iso.rel_symm_apply", "description": ""}, {"name": "rel_iso.simps.apply", "description": "See Note [custom simps projection]. We need to specify this projection explicitly in this case,\n because it is a composition of multiple projections."}, {"name": "rel_embedding.well_founded", "description": ""}, {"name": "rel_embedding.ext", "description": ""}, {"name": "well_founded.of_quotient_lift\u2082", "description": "**Alias** of the forward direction of `well_founded_lift\u2082_iff`."}, {"name": "rel_iso.trans", "description": "Composition of two relation isomorphisms is a relation isomorphism."}, {"name": "rel_embedding.coe_trans", "description": ""}, {"name": "rel_hom_class.map_inf", "description": ""}, {"name": "rel_iso.inv_apply_self", "description": ""}, {"name": "rel_embedding.is_refl", "description": ""}, {"name": "rel_iso.to_rel_embedding_eq_coe", "description": ""}, {"name": "rel_embedding.prod_lex_mk_left", "description": "`\u03bb b, prod.mk a b` as a relation embedding."}, {"name": "rel_embedding.trans", "description": "Composition of two relation embeddings is a relation embedding."}, {"name": "rel_iso.cast_refl", "description": ""}, {"name": "rel_hom.comp_apply", "description": ""}, {"name": "rel_iso.injective", "description": ""}, {"name": "rel_embedding.prod_lex_mk_right", "description": "`\u03bb a, prod.mk a b` as a relation embedding."}, {"name": "rel_iso.prod_lex_congr", "description": "Given relation isomorphisms `r\u2081 \u2243r s\u2081` and `r\u2082 \u2243r s\u2082`, construct a relation isomorphism for the\nlexicographic orders on the product."}, {"name": "rel_embedding.of_is_empty", "description": "A relation embedding from an empty type."}, {"name": "rel_iso.cast_symm", "description": ""}, {"name": "rel_embedding.is_trans", "description": ""}, {"name": "surjective.well_founded_iff", "description": ""}, {"name": "rel_hom_class.acc", "description": ""}, {"name": "rel_embedding.refl_apply", "description": ""}, {"name": "rel_iso.coe_coe_fn", "description": ""}, {"name": "rel_iso.default_def", "description": ""}, {"name": "rel_embedding.of_map_rel_iff_coe", "description": ""}, {"name": "rel_iso.symm_apply_rel", "description": ""}, {"name": "rel_embedding.is_asymm", "description": ""}, {"name": "rel_embedding.simps.apply", "description": " See Note [custom simps projection]. We need to specify this projection explicitly in this case,\nbecause it is a composition of multiple projections."}, {"name": "rel_hom", "description": " A relation homomorphism with respect to a given pair of relations `r` and `s`\nis a function `f : \u03b1 \u2192 \u03b2` such that `r a b \u2192 s (f a) (f b)`."}, {"name": "rel_hom.to_fun", "description": " A relation homomorphism with respect to a given pair of relations `r` and `s`\nis a function `f : \u03b1 \u2192 \u03b2` such that `r a b \u2192 s (f a) (f b)`."}, {"name": "rel_hom.map_rel'", "description": " A relation homomorphism with respect to a given pair of relations `r` and `s`\nis a function `f : \u03b1 \u2192 \u03b2` such that `r a b \u2192 s (f a) (f b)`."}, {"name": "rel_iso.coe_fn_to_equiv", "description": ""}, {"name": "rel_iso.cast_trans", "description": ""}, {"name": "rel_embedding.trans_apply", "description": ""}, {"name": "rel_embedding.rel_hom_class", "description": ""}, {"name": "rel_embedding.coe_fn_injective", "description": "The map `coe_fn : (r \u21aar s) \u2192 (\u03b1 \u2192 \u03b2)` is injective."}, {"name": "rel_embedding.sum_lex_inr_apply", "description": ""}, {"name": "rel_iso.group", "description": ""}, {"name": "rel_embedding.acc", "description": ""}, {"name": "subrel", "description": "`subrel r p` is the inherited relation on a subset."}, {"name": "rel_embedding.swap", "description": "A relation embedding is also a relation embedding between dual relations."}, {"name": "rel_iso.is_well_order.preimage", "description": ""}, {"name": "subrel.is_symm", "description": ""}, {"name": "rel_embedding.coe_fn_mk", "description": ""}, {"name": "rel_embedding.to_rel_hom", "description": "A relation embedding is also a relation homomorphism"}, {"name": "rel_embedding.is_strict_order", "description": ""}, {"name": "rel_embedding.sum_lex_inl_apply", "description": ""}, {"name": "rel_iso.coe_fn_injective", "description": " The map `coe_fn : (r \u2243r s) \u2192 (\u03b1 \u2192 \u03b2)` is injective. Lean fails to parse\n`function.injective (\u03bb e : r \u2243r s, (e : \u03b1 \u2192 \u03b2))`, so we use a trick to say the same."}, {"name": "rel_embedding.eq_preimage", "description": ""}, {"name": "rel_embedding.coe_coe_fn", "description": ""}, {"name": "rel_iso.cast_apply", "description": ""}, {"name": "rel_hom.coe_fn_injective", "description": "The map `coe_fn : (r \u2192r s) \u2192 (\u03b1 \u2192 \u03b2)` is injective."}, {"name": "rel_embedding.is_symm", "description": ""}, {"name": "quotient.out_rel_embedding_apply", "description": ""}, {"name": "rel_iso.rel_hom_class", "description": ""}, {"name": "rel_hom.coe_fn_mk", "description": ""}, {"name": "subrel.is_irrefl", "description": ""}, {"name": "rel_embedding.injective", "description": ""}, {"name": "rel_embedding.prod_lex_map_apply", "description": ""}, {"name": "rel_hom.rel_hom_class", "description": ""}, {"name": "rel_iso.rel_iso_of_is_empty", "description": "Two relations on empty types are isomorphic."}, {"name": "rel_iso.map_rel_iff", "description": ""}, {"name": "rel_hom_class.is_irrefl", "description": ""}, {"name": "preimage_equivalence", "description": ""}, {"name": "subrel_val", "description": ""}, {"name": "rel_embedding.is_strict_total_order'", "description": ""}, {"name": "rel_embedding.sum_lift_rel_inl", "description": "`sum.inl` as a relation embedding into `sum.lift_rel r s`."}, {"name": "rel_iso.rel_iso_of_unique_of_refl", "description": "Two reflexive relations on a unique type are isomorphic."}, {"name": "rel_embedding.rel_hom.has_coe", "description": ""}, {"name": "rel_embedding.sum_lex_inr", "description": "`sum.inr` as a relation embedding into `sum.lex r s`."}, {"name": "rel_embedding.of_monotone_coe", "description": ""}, {"name": "rel_iso.ext", "description": ""}, {"name": "rel_iso.ext_iff", "description": ""}, {"name": "rel_iso.cast_to_equiv", "description": ""}, {"name": "rel_iso.inhabited", "description": ""}, {"name": "rel_hom.comp", "description": "Composition of two relation homomorphisms is a relation homomorphism."}, {"name": "well_founded_lift\u2082_iff", "description": "A relation is well founded iff its lift to a quotient is."}, {"name": "rel_hom_class.map_sup", "description": ""}, {"name": "rel_iso.refl", "description": "Identity map is a relation isomorphism."}, {"name": "rel_iso.symm", "description": "Inverse map of a relation isomorphism is a relation isomorphism."}, {"name": "subrel.rel_embedding_apply", "description": ""}, {"name": "rel_iso.cast", "description": "A relation isomorphism between equal relations on equal types."}, {"name": "rel_iso", "description": "A relation isomorphism is an equivalence that is also a relation embedding."}, {"name": "rel_iso.to_equiv", "description": "A relation isomorphism is an equivalence that is also a relation embedding."}, {"name": "rel_iso.map_rel_iff'", "description": "A relation isomorphism is an equivalence that is also a relation embedding."}, {"name": "rel_iso.preimage", "description": "Any equivalence lifts to a relation isomorphism between `s` and its preimage."}, {"name": "rel_embedding.cod_restrict_apply", "description": ""}, {"name": "rel_embedding.sum_lift_rel_map", "description": "`sum.map` as a relation embedding between `sum.lift_rel` relations."}, {"name": "rel_embedding.is_antisymm", "description": ""}, {"name": "rel_hom.coe_fn_to_fun", "description": ""}, {"name": "rel_iso.has_coe_to_fun", "description": ""}, {"name": "rel_iso.is_well_order.ulift", "description": ""}, {"name": "well_founded.quotient_lift\u2082", "description": "**Alias** of the reverse direction of `well_founded_lift\u2082_iff`."}, {"name": "rel_iso.coe_fn_mk", "description": ""}, {"name": "rel_hom.id_apply", "description": ""}, {"name": "rel_embedding.inhabited", "description": ""}, {"name": "rel_embedding.is_irrefl", "description": ""}, {"name": "rel_iso.swap", "description": "a relation isomorphism is also a relation isomorphism between dual relations."}, {"name": "rel_hom_class", "description": " `rel_hom_class F r s` asserts that `F` is a type of functions such that all `f : F`\nsatisfy `r a b \u2192 s (f a) (f b)`.\n\nThe relations `r` and `s` are `out_param`s since figuring them out from a goal is a higher-order\nmatching problem that Lean usually can't do unaided."}, {"name": "rel_hom_class.to_fun_like", "description": " `rel_hom_class F r s` asserts that `F` is a type of functions such that all `f : F`\nsatisfy `r a b \u2192 s (f a) (f b)`.\n\nThe relations `r` and `s` are `out_param`s since figuring them out from a goal is a higher-order\nmatching problem that Lean usually can't do unaided."}, {"name": "rel_hom_class.map_rel", "description": " `rel_hom_class F r s` asserts that `F` is a type of functions such that all `f : F`\nsatisfy `r a b \u2192 s (f a) (f b)`.\n\nThe relations `r` and `s` are `out_param`s since figuring them out from a goal is a higher-order\nmatching problem that Lean usually can't do unaided."}, {"name": "rel_hom.id", "description": "Identity map is a relation homomorphism."}, {"name": "rel_hom.swap", "description": "A relation homomorphism is also a relation homomorphism between dual relations."}, {"name": "rel_iso.symm_apply_apply", "description": ""}, {"name": "subtype.rel_embedding", "description": "The induced relation on a subtype is an embedding under the natural inclusion."}, {"name": "rel_embedding.is_preorder", "description": ""}, {"name": "rel_hom.ext_iff", "description": ""}, {"name": "rel_embedding.has_coe_to_fun", "description": ""}, {"name": "rel_iso.rel_iso_of_unique_of_irrefl", "description": "Two irreflexive relations on a unique type are isomorphic."}, {"name": "rel_embedding.sum_lex_map_apply", "description": ""}, {"name": "rel_hom.ext", "description": ""}, {"name": "rel_hom.has_coe_to_fun", "description": "Auxiliary instance if `rel_hom_class.to_fun_like.to_has_coe_to_fun` isn't found"}, {"name": "rel_embedding.prod_lex_map", "description": "`prod.map` as a relation embedding."}, {"name": "rel_iso.mul_apply", "description": ""}, {"name": "rel_embedding.ext_iff", "description": ""}, {"name": "rel_hom.preimage", "description": "A function is a relation homomorphism from the preimage relation of `s` to `s`."}, {"name": "rel_iso.simps.symm_apply", "description": "See Note [custom simps projection]."}, {"name": "rel_iso.to_rel_embedding", "description": " Convert an `rel_iso` to an `rel_embedding`. This function is also available as a coercion\nbut often it is easier to write `f.to_rel_embedding` than to write explicitly `r` and `s`\nin the target type."}, {"name": "rel_iso.surjective", "description": ""}, {"name": "rel_iso.bijective", "description": ""}, {"name": "injective_of_increasing", "description": "An increasing function is injective"}, {"name": "rel_iso.apply_symm_apply", "description": ""}, {"name": "rel_embedding.cod_restrict", "description": "Restrict the codomain of a relation embedding."}, {"name": "rel_iso.coe_mul", "description": ""}, {"name": "rel_embedding.coe_fn_to_embedding", "description": ""}, {"name": "rel_iso.of_surjective_apply", "description": ""}, {"name": "rel_iso.refl_apply", "description": ""}, {"name": "rel_embedding", "description": " A relation embedding with respect to a given pair of relations `r` and `s`\nis an embedding `f : \u03b1 \u21aa \u03b2` such that `r a b \u2194 s (f a) (f b)`."}, {"name": "rel_embedding.to_embedding", "description": " A relation embedding with respect to a given pair of relations `r` and `s`\nis an embedding `f : \u03b1 \u21aa \u03b2` such that `r a b \u2194 s (f a) (f b)`."}, {"name": "rel_embedding.map_rel_iff'", "description": " A relation embedding with respect to a given pair of relations `r` and `s`\nis an embedding `f : \u03b1 \u21aa \u03b2` such that `r a b \u2194 s (f a) (f b)`."}, {"name": "subrel.is_trans", "description": ""}, {"name": "rel_embedding.is_well_order", "description": ""}, {"name": "subrel.rel_embedding", "description": "The relation embedding from the inherited relation on a subset."}, {"name": "rel_embedding.inj", "description": ""}, {"name": "rel_iso.apply_inv_self", "description": ""}, {"name": "rel_iso.sum_lex_congr", "description": "Given relation isomorphisms `r\u2081 \u2243r s\u2081` and `r\u2082 \u2243r s\u2082`, construct a relation isomorphism for the\nlexicographic orders on the sum."}, {"name": "rel_hom_class.well_founded", "description": ""}, {"name": "rel_embedding.sum_lift_rel_map_apply", "description": ""}, {"name": "rel_embedding.of_map_rel_iff", "description": "To define an relation embedding from an antisymmetric relation `r` to a reflexive relation `s` it\nsuffices to give a function together with a proof that it satisfies `s (f a) (f b) \u2194 r a b`."}, {"name": "rel_embedding.sum_lift_rel_inr", "description": "`sum.inr` as a relation embedding into `sum.lift_rel r s`."}, {"name": "rel_hom.map_rel", "description": ""}, {"name": "quotient.out_rel_embedding", "description": "`quotient.out` as a relation embedding between the lift of a relation and the relation."}, {"name": "rel_iso.trans_apply", "description": ""}, {"name": "rel_embedding.map_rel_iff", "description": ""}, {"name": "rel_iso.of_surjective", "description": "A surjective relation embedding is a relation isomorphism."}, {"name": "rel_embedding.is_trichotomous", "description": ""}, {"name": "rel_embedding.sum_lift_rel_inr_apply", "description": ""}, {"name": "subrel.is_refl", "description": ""}, {"name": "rel_embedding.sum_lex_map", "description": "`sum.map` as a relation embedding between `sum.lex` relations."}, {"name": "rel_embedding.is_linear_order", "description": ""}, {"name": "rel_hom_class.is_asymm", "description": ""}, {"name": "rel_embedding.is_total", "description": ""}, {"name": "rel_embedding.of_monotone", "description": "It suffices to prove `f` is monotone between strict relations\n to show it is a relation embedding."}, {"name": "rel_iso.coe_one", "description": ""}, {"name": "rel_embedding.is_partial_order", "description": ""}, {"name": "rel_embedding.refl", "description": "Identity map is a relation embedding."}, {"name": "rel_embedding.preimage", "description": "If `f` is injective, then it is a relation embedding from the\n preimage relation of `s` to `s`."}, {"name": "rel_iso.rel_embedding.has_coe", "description": ""}, {"name": "rel_embedding.prod_lex_mk_right_apply", "description": ""}, {"name": "rel_iso.coe_fn_symm_mk", "description": ""}, {"name": "rel_embedding.to_rel_hom_eq_coe", "description": ""}, {"name": "rel_embedding.prod_lex_mk_left_apply", "description": ""}, {"name": "rel_iso.to_equiv_injective", "description": ""}, {"name": "rel_hom.injective_of_increasing", "description": "An increasing function is injective"}, {"name": "rel_iso.range_eq", "description": ""}, {"name": "rel_embedding.sum_lex_inl", "description": "`sum.inl` as a relation embedding into `sum.lex r s`."}, {"name": "category_theory.types_comp", "description": ""}, {"name": "category_theory.hom_inv_id_apply", "description": ""}, {"name": "category_theory.functor_to_types.hcomp", "description": ""}, {"name": "category_theory.types", "description": ""}, {"name": "category_theory.functor_to_types.inv_hom_id_app_apply", "description": ""}, {"name": "category_theory.types_hom", "description": ""}, {"name": "equiv_equiv_iso", "description": " Equivalences (between types in the same universe) are the same as (equivalent to) isomorphisms\nof types."}, {"name": "category_theory.as_hom", "description": "`as_hom f` helps Lean type check a function as a morphism in the category `Type`."}, {"name": "category_theory.functor_to_types.map_comp_apply", "description": ""}, {"name": "category_theory.sort.split_epi_category", "description": ""}, {"name": "category_theory.inv_hom_id_apply", "description": ""}, {"name": "equiv.to_iso", "description": "Any equivalence between types in the same universe gives\na categorical isomorphism between those types."}, {"name": "category_theory.ulift_functor_map", "description": ""}, {"name": "equiv.to_iso_hom", "description": ""}, {"name": "category_theory.hom_of_element_eq_iff", "description": ""}, {"name": "equiv_equiv_iso_hom", "description": ""}, {"name": "category_theory.iso.to_equiv_symm_fun", "description": ""}, {"name": "category_theory.surjective_of_epi", "description": ""}, {"name": "category_theory.types_id", "description": ""}, {"name": "category_theory.types_comp_apply", "description": ""}, {"name": "category_theory.is_iso_iff_bijective", "description": "A morphism in `Type u` is an isomorphism if and only if it is bijective."}, {"name": "category_theory.ulift_functor_trivial", "description": "The functor embedding `Type u` into `Type u` via `ulift` is isomorphic to the identity functor."}, {"name": "category_theory.ulift_trivial", "description": "The isomorphism between a `Type` which has been `ulift`ed to the same universe,\nand the original type."}, {"name": "category_theory.functor_to_types.hom_inv_id_app_apply", "description": ""}, {"name": "category_theory.injective_of_mono", "description": ""}, {"name": "category_theory.mono_iff_injective", "description": "A morphism in `Type` is a monomorphism if and only if it is injective.\n\nSee <https://stacks.math.columbia.edu/tag/003C>."}, {"name": "equiv_iso_iso", "description": " Equivalences (between types in the same universe) are the same as (isomorphic to) isomorphisms\nof types."}, {"name": "category_theory.functor_to_types.map_hom_map_inv_apply", "description": ""}, {"name": "category_theory.functor.sections", "description": "The sections of a functor `J \u2964 Type` are\nthe choices of a point `u j : F.obj j` for each `j`,\nsuch that `F.map f (u j) = u j` for every morphism `f : j \u27f6 j'`.\n\nWe later use these to define limits in `Type` and in many concrete categories."}, {"name": "equiv_equiv_iso_inv", "description": ""}, {"name": "category_theory.functor_to_types.naturality", "description": ""}, {"name": "category_theory.epi_iff_surjective", "description": "A morphism in `Type` is an epimorphism if and only if it is surjective.\n\nSee <https://stacks.math.columbia.edu/tag/003C>."}, {"name": "category_theory.hom_of_element", "description": "Any term `x` of a type `X` corresponds to a morphism `punit \u27f6 X`."}, {"name": "category_theory.ulift_functor", "description": "The functor embedding `Type u` into `Type (max u v)`.\nWrite this as `ulift_functor.{5 2}` to get `Type 2 \u2964 Type 5`."}, {"name": "category_theory.functor_to_types.comp", "description": ""}, {"name": "category_theory.iso.to_equiv_id", "description": ""}, {"name": "category_theory.functor_to_types.map_id_apply", "description": ""}, {"name": "equiv.to_iso_inv", "description": ""}, {"name": "category_theory.of_type_functor_map", "description": ""}, {"name": "category_theory.ulift_functor_full", "description": ""}, {"name": "category_theory.iso.to_equiv_fun", "description": ""}, {"name": "category_theory.of_type_functor_obj", "description": ""}, {"name": "category_theory.functor_to_types.map_inv_map_hom_apply", "description": ""}, {"name": "category_theory.iso.to_equiv_comp", "description": ""}, {"name": "category_theory.iso.to_equiv", "description": "Any isomorphism between types gives an equivalence."}, {"name": "category_theory.of_type_functor", "description": " `of_type_functor m` converts from Lean's `Type`-based `category` to `category_theory`. This\nallows us to use these functors in category theory."}, {"name": "equiv_iso_iso_inv", "description": ""}, {"name": "category_theory.types_id_apply", "description": ""}, {"name": "equiv_iso_iso_hom", "description": ""}, {"name": "category_theory.ulift_functor_faithful", "description": ""}, {"name": "sum.elim_single_zero", "description": ""}, {"name": "pi.has_vadd", "description": ""}, {"name": "function.extend_div", "description": ""}, {"name": "pi.sub_comp", "description": ""}, {"name": "pi.const_pow", "description": ""}, {"name": "pi.comp_zero", "description": ""}, {"name": "pi.apply_single", "description": ""}, {"name": "pi.bit0_apply", "description": ""}, {"name": "pi.prod_snd_fst", "description": ""}, {"name": "pi.one_def", "description": ""}, {"name": "function.extend_neg", "description": ""}, {"name": "sum.elim_zero_single", "description": ""}, {"name": "pi.mul_single_eq_of_ne'", "description": "Abbreviation for `mul_single_eq_of_ne h.symm`, for ease of use by `simp`."}, {"name": "pi.single", "description": "The function supported at `i`, with value `x` there, and `0` elsewhere."}, {"name": "pi.mul_def", "description": ""}, {"name": "pi.has_pow", "description": ""}, {"name": "sum.elim_add_add", "description": ""}, {"name": "pi.pow_apply", "description": ""}, {"name": "pi.has_zero", "description": ""}, {"name": "sum.elim_inv_inv", "description": ""}, {"name": "function.extend_inv", "description": ""}, {"name": "sum.elim_mul_single_one", "description": ""}, {"name": "pi.const_add", "description": ""}, {"name": "pi.prod_fst_snd", "description": ""}, {"name": "sum.elim_one_mul_single", "description": ""}, {"name": "sum.elim_div_div", "description": ""}, {"name": "pi.inv_comp", "description": ""}, {"name": "sum.elim_sub_sub", "description": ""}, {"name": "pi.single_inj", "description": ""}, {"name": "pi.bit1_apply", "description": ""}, {"name": "pi.vadd_def", "description": ""}, {"name": "subsingleton.pi_mul_single_eq", "description": ""}, {"name": "pi.single_apply", "description": "On non-dependent functions, `pi.single` can be expressed as an `ite`"}, {"name": "pi.has_sub", "description": ""}, {"name": "function.injective_pi_map", "description": ""}, {"name": "pi.mul_single_op\u2082", "description": ""}, {"name": "pi.single_op", "description": ""}, {"name": "pi.has_smul", "description": ""}, {"name": "pi.pow_comp", "description": ""}, {"name": "pi.vadd_apply", "description": ""}, {"name": "function.extend_add", "description": ""}, {"name": "pi.zero_def", "description": ""}, {"name": "pi.neg_comp", "description": ""}, {"name": "sum.elim_mul_mul", "description": ""}, {"name": "pi.add_apply", "description": ""}, {"name": "pi.div_apply", "description": ""}, {"name": "pi.zero_apply", "description": ""}, {"name": "pi.neg_apply", "description": ""}, {"name": "pi.const_one", "description": ""}, {"name": "pi.apply_single\u2082", "description": ""}, {"name": "pi.div_comp", "description": ""}, {"name": "pi.zero_comp", "description": ""}, {"name": "pi.apply_mul_single", "description": ""}, {"name": "pi.mul_single_inj", "description": ""}, {"name": "pi.single_op\u2082", "description": ""}, {"name": "pi.smul_comp", "description": ""}, {"name": "pi.single_zero", "description": ""}, {"name": "pi.mul_apply", "description": ""}, {"name": "pi.mul_single_one", "description": ""}, {"name": "pi.prod", "description": "The mapping into a product type built from maps into each component."}, {"name": "pi.single_comm", "description": "On non-dependent functions, `pi.single` is symmetric in the two\nindices."}, {"name": "pi.has_div", "description": ""}, {"name": "pi.has_mul", "description": ""}, {"name": "pi.mul_single", "description": "The function supported at `i`, with value `x` there, and `1` elsewhere."}, {"name": "pi.const_zero", "description": ""}, {"name": "sum.elim_neg_neg", "description": ""}, {"name": "function.extend_one", "description": ""}, {"name": "function.extend_zero", "description": ""}, {"name": "pi.mul_single_op", "description": ""}, {"name": "pi.neg_def", "description": ""}, {"name": "pi.comp_one", "description": ""}, {"name": "pi.mul_single_comm", "description": "On non-dependent functions, `pi.mul_single` is symmetric in the two indices."}, {"name": "pi.one_apply", "description": ""}, {"name": "pi.mul_single_apply", "description": "On non-dependent functions, `pi.mul_single` can be expressed as an `ite`"}, {"name": "pi.one_comp", "description": ""}, {"name": "pi.mul_single_injective", "description": ""}, {"name": "pi.vadd_const", "description": ""}, {"name": "pi.inv_def", "description": ""}, {"name": "pi.mul_comp", "description": ""}, {"name": "pi.const_inv", "description": ""}, {"name": "function.surjective_pi_map", "description": ""}, {"name": "sum.elim_one_one", "description": ""}, {"name": "pi.has_inv", "description": ""}, {"name": "pi.inv_apply", "description": ""}, {"name": "pi.add_def", "description": ""}, {"name": "pi.mul_single_eq_same", "description": ""}, {"name": "pi.apply_mul_single\u2082", "description": ""}, {"name": "pi.single_eq_of_ne", "description": ""}, {"name": "pi.has_one", "description": ""}, {"name": "pi.div_def", "description": ""}, {"name": "pi.has_neg", "description": ""}, {"name": "pi.const_neg", "description": ""}, {"name": "pi.smul_def", "description": ""}, {"name": "pi.const_sub", "description": ""}, {"name": "pi.smul_apply", "description": ""}, {"name": "pi.const_div", "description": ""}, {"name": "subsingleton.pi_single_eq", "description": ""}, {"name": "pi.const_mul", "description": ""}, {"name": "pi.pow_def", "description": ""}, {"name": "unique_of_surjective_one", "description": "If the one function is surjective, the codomain is trivial."}, {"name": "pi.sub_def", "description": ""}, {"name": "sum.elim_zero_zero", "description": ""}, {"name": "pi.single_injective", "description": ""}, {"name": "pi.add_comp", "description": ""}, {"name": "pi.vadd_comp", "description": ""}, {"name": "pi.single_eq_same", "description": ""}, {"name": "unique_of_surjective_zero", "description": "If the zero function is surjective, the codomain is trivial."}, {"name": "function.bijective_pi_map", "description": ""}, {"name": "pi.has_add", "description": ""}, {"name": "pi.single_eq_of_ne'", "description": "Abbreviation for `single_eq_of_ne h.symm`, for ease of\nuse by `simp`."}, {"name": "pi.smul_const", "description": ""}, {"name": "function.extend_sub", "description": ""}, {"name": "pi.sub_apply", "description": ""}, {"name": "pi.mul_single_eq_of_ne", "description": ""}, {"name": "function.extend_mul", "description": ""}, {"name": "conv.execute", "description": ""}, {"name": "conv.interactive.itactic", "description": ""}, {"name": "conv.interactive.skip", "description": ""}, {"name": "conv.interactive.guard_lhs", "description": ""}, {"name": "conv.interactive.done", "description": ""}, {"name": "conv.interactive.trace_lhs", "description": ""}, {"name": "conv.interactive.rw", "description": ""}, {"name": "conv.solve1", "description": ""}, {"name": "conv.interactive.change", "description": ""}, {"name": "conv.interactive.find", "description": ""}, {"name": "conv.interactive.whnf", "description": ""}, {"name": "tactic.interactive.conv", "description": ""}, {"name": "conv.interactive.for", "description": ""}, {"name": "conv.interactive.rewrite", "description": ""}, {"name": "conv.interactive.simp", "description": ""}, {"name": "conv.interactive.congr", "description": ""}, {"name": "conv.step", "description": ""}, {"name": "conv.istep", "description": ""}, {"name": "conv.save_info", "description": ""}, {"name": "conv.interactive.to_lhs", "description": ""}, {"name": "conv.interactive.to_rhs", "description": ""}, {"name": "conv.interactive.dsimp", "description": ""}, {"name": "conv.interactive.funext", "description": ""}, {"name": "list.sorted_cons", "description": ""}, {"name": "list.length_merge_sort", "description": ""}, {"name": "list.split", "description": "Split `l` into two lists of approximately equal length.\n\n    split [1, 2, 3, 4, 5] = ([1, 3, 5], [2, 4])"}, {"name": "list.insertion_sort", "description": "`insertion_sort l` returns `l` sorted using the insertion sort algorithm."}, {"name": "list.merge_sort_nil", "description": ""}, {"name": "list.sorted.rel_nth_le_of_lt", "description": ""}, {"name": "list.ordered_insert", "description": "`ordered_insert a l` inserts `a` into `l` at such that\n `ordered_insert a l` is sorted if `l` is."}, {"name": "list.perm_insertion_sort", "description": ""}, {"name": "list.split_cons_of_eq", "description": ""}, {"name": "list.ordered_insert_length", "description": ""}, {"name": "list.sorted_insertion_sort", "description": "The list `list.insertion_sort r l` is `list.sorted` with respect to `r`."}, {"name": "list.sorted.rel_of_mem_take_of_mem_drop", "description": ""}, {"name": "list.decidable_sorted", "description": ""}, {"name": "list.merge_sort_cons_cons", "description": ""}, {"name": "list.perm_ordered_insert", "description": ""}, {"name": "list.sorted.rel_nth_le_of_le", "description": ""}, {"name": "list.ordered_insert_nil", "description": ""}, {"name": "list.perm_split", "description": ""}, {"name": "list.length_split_le", "description": ""}, {"name": "list.eq_of_perm_of_sorted", "description": ""}, {"name": "list.perm_merge_sort", "description": ""}, {"name": "list.ordered_insert_eq_take_drop", "description": "An alternative definition of `ordered_insert` using `take_while` and `drop_while`."}, {"name": "list.merge_sort_eq_self", "description": ""}, {"name": "list.sorted.ordered_insert", "description": ""}, {"name": "list.insertion_sort_cons_eq_take_drop", "description": ""}, {"name": "list.length_split_lt", "description": ""}, {"name": "list.sorted.tail", "description": ""}, {"name": "list.sorted.merge", "description": ""}, {"name": "list.sorted_nil", "description": ""}, {"name": "list.ordered_insert_count", "description": ""}, {"name": "list.sorted_singleton", "description": ""}, {"name": "list.merge_sort_eq_insertion_sort", "description": ""}, {"name": "list.merge_sort", "description": "Implementation of a merge sort algorithm to sort a list."}, {"name": "list.merge", "description": "Merge two sorted lists into one in linear time.\n\n    merge [1, 2, 4, 5] [0, 1, 3, 4] = [0, 1, 1, 2, 3, 4, 4, 5]"}, {"name": "list.sorted_merge_sort", "description": ""}, {"name": "list.perm_merge", "description": ""}, {"name": "list.sorted", "description": "`sorted r l` is the same as `pairwise r l`, preferred in the case that `r`\n is a `<` or `\u2264`-like relation (transitive and antisymmetric or asymmetric)"}, {"name": "list.sublist_of_subperm_of_sorted", "description": ""}, {"name": "list.sorted.nodup", "description": ""}, {"name": "list.merge_sort_singleton", "description": ""}, {"name": "list.sorted.insertion_sort_eq", "description": " If `l` is already `list.sorted` with respect to `r`, then `insertion_sort` does not change\nit."}, {"name": "list.sorted.of_cons", "description": ""}, {"name": "list.rel_of_sorted_cons", "description": ""}, {"name": "nat.gcd_eq_zero_iff", "description": ""}, {"name": "nat.coprime_self_add_right", "description": ""}, {"name": "nat.gcd_one_right", "description": ""}, {"name": "nat.coprime.symm", "description": ""}, {"name": "nat.lcm_dvd", "description": ""}, {"name": "nat.coprime.mul_add_mul_ne_mul", "description": ""}, {"name": "nat.gcd_gcd_self_left_right", "description": ""}, {"name": "nat.gcd_le_left", "description": ""}, {"name": "nat.coprime_mul_left_add_left", "description": ""}, {"name": "nat.coprime.mul", "description": ""}, {"name": "nat.coprime.symmetric", "description": ""}, {"name": "nat.coprime_prod_left", "description": "See `is_coprime.prod_left` for the corresponding lemma about `is_coprime`"}, {"name": "nat.gcd_dvd", "description": ""}, {"name": "nat.lcm_one_right", "description": ""}, {"name": "nat.gcd_mul_right_add_right", "description": ""}, {"name": "nat.coprime_div_gcd_div_gcd", "description": ""}, {"name": "nat.coprime.eq_of_mul_eq_zero", "description": ""}, {"name": "nat.gcd_add_self_left", "description": ""}, {"name": "nat.coprime.mul_dvd_of_dvd_of_dvd", "description": ""}, {"name": "nat.coprime.pow_left", "description": ""}, {"name": "nat.eq_zero_of_gcd_eq_zero_right", "description": ""}, {"name": "nat.coprime_add_mul_left_right", "description": ""}, {"name": "nat.gcd_mul_lcm", "description": ""}, {"name": "nat.gcd_eq_right_iff_dvd", "description": ""}, {"name": "nat.gcd_eq_left_iff_dvd", "description": ""}, {"name": "nat.coprime_mul_iff_right", "description": ""}, {"name": "nat.coprime_one_right", "description": ""}, {"name": "nat.coprime_pow_left_iff", "description": ""}, {"name": "nat.coprime_mul_right_add_left", "description": ""}, {"name": "nat.gcd_gcd_self_right_right", "description": ""}, {"name": "nat.coprime.pow_right", "description": ""}, {"name": "nat.coprime_zero_left", "description": ""}, {"name": "nat.coprime.dvd_of_dvd_mul_left", "description": ""}, {"name": "nat.gcd_dvd_left", "description": ""}, {"name": "nat.lcm_comm", "description": ""}, {"name": "nat.coprime.gcd_mul_left_cancel", "description": ""}, {"name": "nat.coprime.gcd_mul_right_cancel_right", "description": ""}, {"name": "nat.coprime.dvd_of_dvd_mul_right", "description": ""}, {"name": "nat.coprime.coprime_dvd_left", "description": ""}, {"name": "nat.gcd_assoc", "description": ""}, {"name": "nat.dvd_lcm_right", "description": ""}, {"name": "nat.coprime_add_mul_right_left", "description": ""}, {"name": "nat.gcd_add_mul_left_left", "description": ""}, {"name": "nat.coprime.lcm_eq_mul", "description": ""}, {"name": "nat.gcd_self_add_left", "description": ""}, {"name": "nat.coprime_one_left_iff", "description": ""}, {"name": "nat.coprime.gcd_right", "description": ""}, {"name": "nat.coprime_add_self_right", "description": ""}, {"name": "nat.coprime.gcd_mul", "description": ""}, {"name": "nat.coprime.dvd_mul_right", "description": ""}, {"name": "nat.lcm_self", "description": ""}, {"name": "nat.gcd_mul_right_left", "description": ""}, {"name": "nat.coprime.coprime_mul_right", "description": ""}, {"name": "nat.exists_coprime'", "description": ""}, {"name": "nat.coprime_add_mul_right_right", "description": ""}, {"name": "nat.not_coprime_of_dvd_of_dvd", "description": ""}, {"name": "nat.gcd_eq_left", "description": ""}, {"name": "nat.coprime_mul_right_add_right", "description": ""}, {"name": "nat.lcm_zero_right", "description": ""}, {"name": "nat.gcd_mul_left_add_left", "description": ""}, {"name": "nat.gcd_mul_right_right", "description": ""}, {"name": "nat.coprime.pow", "description": ""}, {"name": "nat.gcd_dvd_right", "description": ""}, {"name": "nat.gcd_le_right", "description": ""}, {"name": "nat.gcd_add_mul_right_right", "description": ""}, {"name": "nat.dvd_gcd_iff", "description": ""}, {"name": "nat.coprime_one_right_iff", "description": ""}, {"name": "nat.eq_one_of_dvd_coprimes", "description": "If `k:\u2115` divides coprime `a` and `b` then `k = 1`"}, {"name": "nat.coprime.gcd_left", "description": ""}, {"name": "nat.lcm_zero_left", "description": ""}, {"name": "nat.coprime.dvd_mul_left", "description": ""}, {"name": "nat.not_coprime_zero_zero", "description": ""}, {"name": "nat.gcd_pos_of_pos_left", "description": ""}, {"name": "nat.coprime.eq_one_of_dvd", "description": ""}, {"name": "nat.exists_coprime", "description": ""}, {"name": "nat.lcm_one_left", "description": ""}, {"name": "nat.coprime_pow_right_iff", "description": ""}, {"name": "nat.coprime_mul_left_add_right", "description": ""}, {"name": "nat.coprime_mul_iff_left", "description": ""}, {"name": "nat.gcd_comm", "description": ""}, {"name": "nat.dvd_lcm_left", "description": ""}, {"name": "nat.pow_dvd_pow_iff", "description": ""}, {"name": "nat.gcd_mul_left_right", "description": ""}, {"name": "nat.coprime.decidable", "description": ""}, {"name": "nat.coprime.coprime_mul_left_right", "description": ""}, {"name": "nat.gcd_dvd_gcd_of_dvd_right", "description": ""}, {"name": "nat.coprime_self", "description": ""}, {"name": "nat.coprime_zero_right", "description": ""}, {"name": "nat.coprime_add_mul_left_left", "description": ""}, {"name": "nat.gcd_dvd_gcd_mul_right", "description": ""}, {"name": "nat.lcm_dvd_mul", "description": ""}, {"name": "nat.coprime_self_add_left", "description": ""}, {"name": "nat.coprime.gcd_mul_left_cancel_right", "description": ""}, {"name": "nat.coprime_comm", "description": ""}, {"name": "nat.coprime_iff_gcd_eq_one", "description": ""}, {"name": "nat.coprime.coprime_mul_right_right", "description": ""}, {"name": "nat.gcd_mul_of_coprime_of_dvd", "description": ""}, {"name": "nat.gcd_div", "description": ""}, {"name": "nat.coprime_prod_right", "description": "See `is_coprime.prod_right` for the corresponding lemma about `is_coprime`"}, {"name": "nat.gcd_dvd_gcd_mul_left_right", "description": ""}, {"name": "nat.eq_zero_of_gcd_eq_zero_left", "description": ""}, {"name": "nat.coprime_one_left", "description": ""}, {"name": "nat.gcd_mul_left_add_right", "description": ""}, {"name": "nat.gcd_add_mul_left_right", "description": ""}, {"name": "nat.coprime.gcd_mul_right_cancel", "description": ""}, {"name": "nat.coprime.coprime_div_left", "description": ""}, {"name": "nat.gcd_add_self_right", "description": ""}, {"name": "nat.gcd_pos_of_pos_right", "description": ""}, {"name": "nat.gcd_dvd_gcd_mul_right_right", "description": ""}, {"name": "nat.prod_dvd_and_dvd_of_dvd_prod", "description": "Represent a divisor of `m * n` as a product of a divisor of `m` and a divisor of `n`."}, {"name": "nat.coprime.gcd_eq_one", "description": ""}, {"name": "nat.lcm_ne_zero", "description": ""}, {"name": "nat.gcd_mul_left_left", "description": ""}, {"name": "nat.coprime.mul_right", "description": ""}, {"name": "nat.gcd_mul_right_add_left", "description": ""}, {"name": "nat.gcd_mul_dvd_mul_gcd", "description": ""}, {"name": "nat.gcd_mul_left", "description": ""}, {"name": "nat.gcd_add_mul_right_left", "description": ""}, {"name": "nat.coprime.coprime_div_right", "description": ""}, {"name": "nat.gcd_mul_right", "description": ""}, {"name": "nat.gcd_eq_right", "description": ""}, {"name": "nat.gcd_mul_gcd_of_coprime_of_mul_eq_mul", "description": ""}, {"name": "nat.gcd_gcd_self_right_left", "description": ""}, {"name": "nat.gcd_gcd_self_left_left", "description": ""}, {"name": "nat.lcm_dvd_iff", "description": ""}, {"name": "nat.coprime.coprime_dvd_right", "description": ""}, {"name": "nat.gcd_self_add_right", "description": ""}, {"name": "nat.coprime.coprime_mul_left", "description": ""}, {"name": "nat.dvd_gcd", "description": ""}, {"name": "nat.gcd_greatest", "description": ""}, {"name": "nat.gcd_dvd_gcd_mul_left", "description": ""}, {"name": "nat.coprime.gcd_both", "description": ""}, {"name": "nat.lcm_assoc", "description": ""}, {"name": "nat.gcd_dvd_gcd_of_dvd_left", "description": ""}, {"name": "nat.coprime_add_self_left", "description": ""}, {"name": "user_attribute.set_untyped", "description": ""}, {"name": "user_attribute.get_param_untyped", "description": ""}, {"name": "attribute.register", "description": "Registers a new user-defined attribute. The argument must be the name of a definition of type\n  `user_attribute \u03b1 \u03b2`. Once registered, you may tag declarations with this attribute."}, {"name": "attribute.get_instances", "description": " Get all of the declaration names that have the given attribute.\nEg. ``get_instances `simp`` returns a list with the names of all of the lemmas in the environment tagged with the `@[simp]` attribute."}, {"name": "user_attribute.parse_reflect", "description": ""}, {"name": "register_attribute", "description": "Alias for attribute.register"}, {"name": "user_attribute.dflt_parser", "description": ""}, {"name": "user_attribute.dflt_cache_cfg", "description": "Close the current goal by filling it with the trivial `user_attribute_cache_cfg unit`."}, {"name": "user_attribute.get_cache", "description": "Returns the attribute cache for the given user attribute."}, {"name": "attribute.fingerprint", "description": "Returns a hash of `get_instances`. You can use this to tell if your attribute instances have changed."}, {"name": "user_attribute.set", "description": ""}, {"name": "user_attribute_cache_cfg", "description": " Configuration for a user attribute cache. For example, the `simp` attribute has a cache of type simp_lemmas.\n- `mk_cache` is a function where you are given all of the declarations tagged with your attribute and you return the new value for the cache.\n  That is, `mk_cache` makes the object you want to be cached.\n- `dependencies` is a list of other attributes whose caches need to be computed first."}, {"name": "user_attribute_cache_cfg.mk_cache", "description": " Configuration for a user attribute cache. For example, the `simp` attribute has a cache of type simp_lemmas.\n- `mk_cache` is a function where you are given all of the declarations tagged with your attribute and you return the new value for the cache.\n  That is, `mk_cache` makes the object you want to be cached.\n- `dependencies` is a list of other attributes whose caches need to be computed first."}, {"name": "user_attribute_cache_cfg.dependencies", "description": " Configuration for a user attribute cache. For example, the `simp` attribute has a cache of type simp_lemmas.\n- `mk_cache` is a function where you are given all of the declarations tagged with your attribute and you return the new value for the cache.\n  That is, `mk_cache` makes the object you want to be cached.\n- `dependencies` is a list of other attributes whose caches need to be computed first."}, {"name": "get_attribute_cache_dyn", "description": ""}, {"name": "user_attribute", "description": "A __user attribute__ is an attribute defined by the user (ie, not built in to Lean).\n### Type parameters\n- `cache_ty` is the type of a cached VM object that is computed from all of the declarations in the environment tagged with this attribute.\n- `param_ty` is an argument for the attribute when it is used. For instance with `param_ty` being `\u2115` you could write `@[my_attribute 4]`.\n\n### Data\nA `user_attribute` consists of the following pieces of data:\n- `name` is the name of the attribute, eg ```simp```\n- `descr` is a plaintext description of the attribute for humans.\n- `after_set` is an optional handler that will be called after the attribute has been applied to a declaration.\n    Failing the tactic will fail the entire `attribute/def/...` command, i.e. the attribute will\n    not be applied after all.\n    Declaring an `after_set` handler without a `before_unset` handler will make the attribute\n    non-removable.\n- `before_unset` Optional handler that will be called before the attribute is removed from a declaration.\n- `cache_cfg` describes how to construct the user attribute's cache. See docstring for `user_attribute_cache_cfg`\n- `reflect_param` demands that `param_ty` can be reflected.\n    This means we have a function from `param_ty` to an expr.\n    See the docstring for `has_reflect`.\n- `parser` Parser that will be invoked after parsing the attribute's name. The parse result will be reflected\nand stored and can be retrieved with `user_attribute.get_param`."}, {"name": "user_attribute.name", "description": "A __user attribute__ is an attribute defined by the user (ie, not built in to Lean).\n### Type parameters\n- `cache_ty` is the type of a cached VM object that is computed from all of the declarations in the environment tagged with this attribute.\n- `param_ty` is an argument for the attribute when it is used. For instance with `param_ty` being `\u2115` you could write `@[my_attribute 4]`.\n\n### Data\nA `user_attribute` consists of the following pieces of data:\n- `name` is the name of the attribute, eg ```simp```\n- `descr` is a plaintext description of the attribute for humans.\n- `after_set` is an optional handler that will be called after the attribute has been applied to a declaration.\n    Failing the tactic will fail the entire `attribute/def/...` command, i.e. the attribute will\n    not be applied after all.\n    Declaring an `after_set` handler without a `before_unset` handler will make the attribute\n    non-removable.\n- `before_unset` Optional handler that will be called before the attribute is removed from a declaration.\n- `cache_cfg` describes how to construct the user attribute's cache. See docstring for `user_attribute_cache_cfg`\n- `reflect_param` demands that `param_ty` can be reflected.\n    This means we have a function from `param_ty` to an expr.\n    See the docstring for `has_reflect`.\n- `parser` Parser that will be invoked after parsing the attribute's name. The parse result will be reflected\nand stored and can be retrieved with `user_attribute.get_param`."}, {"name": "user_attribute.descr", "description": "A __user attribute__ is an attribute defined by the user (ie, not built in to Lean).\n### Type parameters\n- `cache_ty` is the type of a cached VM object that is computed from all of the declarations in the environment tagged with this attribute.\n- `param_ty` is an argument for the attribute when it is used. For instance with `param_ty` being `\u2115` you could write `@[my_attribute 4]`.\n\n### Data\nA `user_attribute` consists of the following pieces of data:\n- `name` is the name of the attribute, eg ```simp```\n- `descr` is a plaintext description of the attribute for humans.\n- `after_set` is an optional handler that will be called after the attribute has been applied to a declaration.\n    Failing the tactic will fail the entire `attribute/def/...` command, i.e. the attribute will\n    not be applied after all.\n    Declaring an `after_set` handler without a `before_unset` handler will make the attribute\n    non-removable.\n- `before_unset` Optional handler that will be called before the attribute is removed from a declaration.\n- `cache_cfg` describes how to construct the user attribute's cache. See docstring for `user_attribute_cache_cfg`\n- `reflect_param` demands that `param_ty` can be reflected.\n    This means we have a function from `param_ty` to an expr.\n    See the docstring for `has_reflect`.\n- `parser` Parser that will be invoked after parsing the attribute's name. The parse result will be reflected\nand stored and can be retrieved with `user_attribute.get_param`."}, {"name": "user_attribute.after_set", "description": "A __user attribute__ is an attribute defined by the user (ie, not built in to Lean).\n### Type parameters\n- `cache_ty` is the type of a cached VM object that is computed from all of the declarations in the environment tagged with this attribute.\n- `param_ty` is an argument for the attribute when it is used. For instance with `param_ty` being `\u2115` you could write `@[my_attribute 4]`.\n\n### Data\nA `user_attribute` consists of the following pieces of data:\n- `name` is the name of the attribute, eg ```simp```\n- `descr` is a plaintext description of the attribute for humans.\n- `after_set` is an optional handler that will be called after the attribute has been applied to a declaration.\n    Failing the tactic will fail the entire `attribute/def/...` command, i.e. the attribute will\n    not be applied after all.\n    Declaring an `after_set` handler without a `before_unset` handler will make the attribute\n    non-removable.\n- `before_unset` Optional handler that will be called before the attribute is removed from a declaration.\n- `cache_cfg` describes how to construct the user attribute's cache. See docstring for `user_attribute_cache_cfg`\n- `reflect_param` demands that `param_ty` can be reflected.\n    This means we have a function from `param_ty` to an expr.\n    See the docstring for `has_reflect`.\n- `parser` Parser that will be invoked after parsing the attribute's name. The parse result will be reflected\nand stored and can be retrieved with `user_attribute.get_param`."}, {"name": "user_attribute.before_unset", "description": "A __user attribute__ is an attribute defined by the user (ie, not built in to Lean).\n### Type parameters\n- `cache_ty` is the type of a cached VM object that is computed from all of the declarations in the environment tagged with this attribute.\n- `param_ty` is an argument for the attribute when it is used. For instance with `param_ty` being `\u2115` you could write `@[my_attribute 4]`.\n\n### Data\nA `user_attribute` consists of the following pieces of data:\n- `name` is the name of the attribute, eg ```simp```\n- `descr` is a plaintext description of the attribute for humans.\n- `after_set` is an optional handler that will be called after the attribute has been applied to a declaration.\n    Failing the tactic will fail the entire `attribute/def/...` command, i.e. the attribute will\n    not be applied after all.\n    Declaring an `after_set` handler without a `before_unset` handler will make the attribute\n    non-removable.\n- `before_unset` Optional handler that will be called before the attribute is removed from a declaration.\n- `cache_cfg` describes how to construct the user attribute's cache. See docstring for `user_attribute_cache_cfg`\n- `reflect_param` demands that `param_ty` can be reflected.\n    This means we have a function from `param_ty` to an expr.\n    See the docstring for `has_reflect`.\n- `parser` Parser that will be invoked after parsing the attribute's name. The parse result will be reflected\nand stored and can be retrieved with `user_attribute.get_param`."}, {"name": "user_attribute.cache_cfg", "description": "A __user attribute__ is an attribute defined by the user (ie, not built in to Lean).\n### Type parameters\n- `cache_ty` is the type of a cached VM object that is computed from all of the declarations in the environment tagged with this attribute.\n- `param_ty` is an argument for the attribute when it is used. For instance with `param_ty` being `\u2115` you could write `@[my_attribute 4]`.\n\n### Data\nA `user_attribute` consists of the following pieces of data:\n- `name` is the name of the attribute, eg ```simp```\n- `descr` is a plaintext description of the attribute for humans.\n- `after_set` is an optional handler that will be called after the attribute has been applied to a declaration.\n    Failing the tactic will fail the entire `attribute/def/...` command, i.e. the attribute will\n    not be applied after all.\n    Declaring an `after_set` handler without a `before_unset` handler will make the attribute\n    non-removable.\n- `before_unset` Optional handler that will be called before the attribute is removed from a declaration.\n- `cache_cfg` describes how to construct the user attribute's cache. See docstring for `user_attribute_cache_cfg`\n- `reflect_param` demands that `param_ty` can be reflected.\n    This means we have a function from `param_ty` to an expr.\n    See the docstring for `has_reflect`.\n- `parser` Parser that will be invoked after parsing the attribute's name. The parse result will be reflected\nand stored and can be retrieved with `user_attribute.get_param`."}, {"name": "user_attribute.reflect_param", "description": "A __user attribute__ is an attribute defined by the user (ie, not built in to Lean).\n### Type parameters\n- `cache_ty` is the type of a cached VM object that is computed from all of the declarations in the environment tagged with this attribute.\n- `param_ty` is an argument for the attribute when it is used. For instance with `param_ty` being `\u2115` you could write `@[my_attribute 4]`.\n\n### Data\nA `user_attribute` consists of the following pieces of data:\n- `name` is the name of the attribute, eg ```simp```\n- `descr` is a plaintext description of the attribute for humans.\n- `after_set` is an optional handler that will be called after the attribute has been applied to a declaration.\n    Failing the tactic will fail the entire `attribute/def/...` command, i.e. the attribute will\n    not be applied after all.\n    Declaring an `after_set` handler without a `before_unset` handler will make the attribute\n    non-removable.\n- `before_unset` Optional handler that will be called before the attribute is removed from a declaration.\n- `cache_cfg` describes how to construct the user attribute's cache. See docstring for `user_attribute_cache_cfg`\n- `reflect_param` demands that `param_ty` can be reflected.\n    This means we have a function from `param_ty` to an expr.\n    See the docstring for `has_reflect`.\n- `parser` Parser that will be invoked after parsing the attribute's name. The parse result will be reflected\nand stored and can be retrieved with `user_attribute.get_param`."}, {"name": "user_attribute.parser", "description": "A __user attribute__ is an attribute defined by the user (ie, not built in to Lean).\n### Type parameters\n- `cache_ty` is the type of a cached VM object that is computed from all of the declarations in the environment tagged with this attribute.\n- `param_ty` is an argument for the attribute when it is used. For instance with `param_ty` being `\u2115` you could write `@[my_attribute 4]`.\n\n### Data\nA `user_attribute` consists of the following pieces of data:\n- `name` is the name of the attribute, eg ```simp```\n- `descr` is a plaintext description of the attribute for humans.\n- `after_set` is an optional handler that will be called after the attribute has been applied to a declaration.\n    Failing the tactic will fail the entire `attribute/def/...` command, i.e. the attribute will\n    not be applied after all.\n    Declaring an `after_set` handler without a `before_unset` handler will make the attribute\n    non-removable.\n- `before_unset` Optional handler that will be called before the attribute is removed from a declaration.\n- `cache_cfg` describes how to construct the user attribute's cache. See docstring for `user_attribute_cache_cfg`\n- `reflect_param` demands that `param_ty` can be reflected.\n    This means we have a function from `param_ty` to an expr.\n    See the docstring for `has_reflect`.\n- `parser` Parser that will be invoked after parsing the attribute's name. The parse result will be reflected\nand stored and can be retrieved with `user_attribute.get_param`."}, {"name": "get_name_set_for_attr", "description": ""}, {"name": "mk_name_set_attr", "description": ""}, {"name": "user_attribute.get_param", "description": "Get the value of the parameter for the attribute on a given declatation. Will fail if the attribute does not exist."}, {"name": "list.minimum", "description": " `minimum l` returns an `with_top \u03b1`, the smallest element of `l` for nonempty lists, and `\u22a4` for\n`[]`"}, {"name": "list.mem_argmax_iff", "description": ""}, {"name": "list.argmin_concat", "description": ""}, {"name": "list.argmin_singleton", "description": ""}, {"name": "list.le_minimum_of_mem'", "description": ""}, {"name": "list.argmin_eq_none", "description": ""}, {"name": "list.not_lt_of_mem_argmin", "description": ""}, {"name": "list.not_lt_of_mem_argmax", "description": ""}, {"name": "list.le_maximum_of_mem'", "description": ""}, {"name": "list.minimum_singleton", "description": ""}, {"name": "list.minimum_le_of_mem", "description": ""}, {"name": "list.maximum_nil", "description": ""}, {"name": "list.argmax_eq_none", "description": ""}, {"name": "list.argmin_mem", "description": ""}, {"name": "list.le_min_of_forall_le", "description": ""}, {"name": "list.le_max_of_le", "description": ""}, {"name": "list.argmax_cons", "description": ""}, {"name": "list.not_lt_minimum_of_mem'", "description": ""}, {"name": "list.foldl_arg_aux_eq_none", "description": ""}, {"name": "list.argmax_concat", "description": ""}, {"name": "list.min_le_of_le", "description": ""}, {"name": "list.minimum_eq_coe_iff", "description": ""}, {"name": "list.le_of_mem_argmax", "description": ""}, {"name": "list.minimum_mem", "description": ""}, {"name": "list.mem_argmin_iff", "description": ""}, {"name": "list.le_of_mem_argmin", "description": ""}, {"name": "list.argmin_cons", "description": ""}, {"name": "list.argmax", "description": " `argmax f l` returns `some a`, where `f a` is maximal among the elements of `l`, in the sense\nthat there is no `b \u2208 l` with `f a < f b`. If `a`, `b` are such that `f a = f b`, it returns\nwhichever of `a` or `b` comes first in the list. `argmax f []` = none`."}, {"name": "list.arg_aux", "description": "Auxiliary definition for `argmax` and `argmin`."}, {"name": "list.maximum", "description": " `maximum l` returns an `with_bot \u03b1`, the largest element of `l` for nonempty lists, and `\u22a5` for\n`[]`"}, {"name": "list.not_lt_maximum_of_mem'", "description": ""}, {"name": "list.not_lt_maximum_of_mem", "description": ""}, {"name": "list.max_le_of_forall_le", "description": ""}, {"name": "list.argmin_nil", "description": ""}, {"name": "list.argmax_nil", "description": ""}, {"name": "list.index_of_argmin", "description": ""}, {"name": "list.minimum_not_lt_of_mem", "description": ""}, {"name": "list.maximum_mem", "description": ""}, {"name": "list.maximum_cons", "description": ""}, {"name": "list.maximum_singleton", "description": ""}, {"name": "list.argmin_eq_some_iff", "description": ""}, {"name": "list.index_of_argmax", "description": ""}, {"name": "list.argmax_eq_some_iff", "description": ""}, {"name": "list.minimum_cons", "description": ""}, {"name": "list.maximum_eq_none", "description": ""}, {"name": "list.arg_aux_self", "description": ""}, {"name": "list.maximum_concat", "description": ""}, {"name": "list.maximum_eq_coe_iff", "description": ""}, {"name": "list.argmax_singleton", "description": ""}, {"name": "list.argmin", "description": " `argmin f l` returns `some a`, where `f a` is minimal among the elements of `l`, in the sense\nthat there is no `b \u2208 l` with `f b < f a`. If `a`, `b` are such that `f a = f b`, it returns\nwhichever of `a` or `b` comes first in the list. `argmin f []` = none`."}, {"name": "list.minimum_nil", "description": ""}, {"name": "list.minimum_concat", "description": ""}, {"name": "list.argmax_mem", "description": ""}, {"name": "list.foldr_max_of_ne_nil", "description": ""}, {"name": "list.foldr_min_of_ne_nil", "description": ""}, {"name": "list.le_maximum_of_mem", "description": ""}, {"name": "list.minimum_eq_none", "description": ""}, {"name": "list.not_of_mem_foldl_arg_aux", "description": ""}, {"name": "sq_lt_sq", "description": ""}, {"name": "pow_le_pow_iff", "description": ""}, {"name": "pow_eq_one_iff", "description": ""}, {"name": "nsmul_lt_nsmul_iff", "description": ""}, {"name": "sq_pos_of_pos", "description": ""}, {"name": "sq_le_one_iff", "description": ""}, {"name": "one_lt_sq_iff", "description": ""}, {"name": "sq_lt_one_iff", "description": ""}, {"name": "pow_left_inj", "description": ""}, {"name": "two_mul_le_add_sq", "description": "Arithmetic mean-geometric mean (AM-GM) inequality for linearly ordered commutative rings."}, {"name": "sq_le_sq", "description": ""}, {"name": "le_of_pow_le_pow", "description": ""}, {"name": "abs_sq", "description": ""}, {"name": "sq_pos_of_ne_zero", "description": ""}, {"name": "sq_pos_iff", "description": ""}, {"name": "sq_le_one_iff_abs_le_one", "description": ""}, {"name": "one_le_zpow", "description": ""}, {"name": "nsmul_strict_mono_right", "description": ""}, {"name": "pow_lt_pow'", "description": ""}, {"name": "pow_lt_pow_iff'", "description": ""}, {"name": "abs_lt_of_sq_lt_sq'", "description": ""}, {"name": "pow_lt_one_iff", "description": ""}, {"name": "one_lt_pow", "description": ""}, {"name": "strict_anti_pow", "description": ""}, {"name": "pow_le_one'", "description": ""}, {"name": "sq_lt_sq'", "description": ""}, {"name": "abs_le_of_sq_le_sq'", "description": ""}, {"name": "pow_strict_mono_left", "description": ""}, {"name": "pow_le_pow'", "description": ""}, {"name": "one_lt_pow'", "description": ""}, {"name": "nsmul_nonpos_iff", "description": ""}, {"name": "pow_lt_pow_iff", "description": ""}, {"name": "pow_lt_pow_of_lt_left", "description": ""}, {"name": "pow_bit0_pos_of_neg", "description": ""}, {"name": "strict_mono_on_pow", "description": ""}, {"name": "sq_lt_one_iff_abs_lt_one", "description": ""}, {"name": "nsmul_le_nsmul_of_le_right", "description": ""}, {"name": "one_lt_sq_iff_one_lt_abs", "description": ""}, {"name": "pow_two_pos_of_ne_zero", "description": "**Alias** of `sq_pos_of_ne_zero`."}, {"name": "pow_bit0_pos_iff", "description": ""}, {"name": "nsmul_eq_zero_iff", "description": ""}, {"name": "pow_mono", "description": ""}, {"name": "pow_le_one", "description": ""}, {"name": "pow_bit1_neg", "description": ""}, {"name": "zero_pow_le_one", "description": ""}, {"name": "sq_eq_sq_iff_abs_eq_abs", "description": ""}, {"name": "nsmul_pos", "description": ""}, {"name": "zsmul_nonneg", "description": ""}, {"name": "sq_pos_of_neg", "description": ""}, {"name": "pow_lt_one'", "description": ""}, {"name": "abs_lt_of_sq_lt_sq", "description": ""}, {"name": "nsmul_le_nsmul_iff", "description": ""}, {"name": "abs_le_of_sq_le_sq", "description": ""}, {"name": "pow_two_nonneg", "description": "**Alias** of `sq_nonneg`."}, {"name": "pow_lt_pow_of_lt_one", "description": ""}, {"name": "two_mul_le_add_pow_two", "description": "**Alias** of `two_mul_le_add_sq`."}, {"name": "pow_four_le_pow_two_of_pow_two_le", "description": ""}, {"name": "one_lt_pow_iff_of_nonneg", "description": ""}, {"name": "nsmul_neg", "description": ""}, {"name": "sq_abs", "description": ""}, {"name": "pow_le_pow", "description": ""}, {"name": "canonically_ordered_comm_semiring.pow_pos", "description": ""}, {"name": "lt_of_mul_self_lt_mul_self", "description": ""}, {"name": "one_le_sq_iff_one_le_abs", "description": ""}, {"name": "nsmul_nonpos", "description": ""}, {"name": "pow_le_pow_iff'", "description": ""}, {"name": "one_le_sq_iff", "description": ""}, {"name": "one_le_pow_of_one_le'", "description": ""}, {"name": "le_self_pow", "description": ""}, {"name": "abs_neg_one_pow", "description": ""}, {"name": "sq_le_sq'", "description": ""}, {"name": "sq_eq_sq", "description": ""}, {"name": "pow_lt_pow_iff_of_lt_one", "description": ""}, {"name": "one_lt_pow_iff", "description": ""}, {"name": "pow_lt_one", "description": ""}, {"name": "pow_add_pow_le", "description": ""}, {"name": "pow_le_pow_of_le_left'", "description": ""}, {"name": "pow_le_one_iff", "description": ""}, {"name": "one_le_pow_of_one_le", "description": ""}, {"name": "nsmul_neg_iff", "description": ""}, {"name": "pow_lt_pow", "description": ""}, {"name": "nsmul_le_nsmul_of_nonpos", "description": ""}, {"name": "pow_le_one_iff_of_nonneg", "description": ""}, {"name": "pow_bit0_nonneg", "description": ""}, {"name": "nsmul_lt_nsmul", "description": ""}, {"name": "nsmul_nonneg_iff", "description": ""}, {"name": "one_le_pow_iff", "description": ""}, {"name": "pow_le_pow_of_le_one'", "description": ""}, {"name": "pow_le_pow_of_le_left", "description": ""}, {"name": "pow_lt_one_iff_of_nonneg", "description": ""}, {"name": "nsmul_nonneg", "description": ""}, {"name": "pow_abs", "description": ""}, {"name": "nsmul_le_nsmul", "description": ""}, {"name": "strict_mono_pow", "description": ""}, {"name": "lt_of_pow_lt_pow", "description": ""}, {"name": "nsmul_pos_iff", "description": ""}, {"name": "sq_nonneg", "description": ""}, {"name": "one_le_pow_iff_of_nonneg", "description": ""}, {"name": "pow_bit0_pos", "description": ""}, {"name": "expr_lens.to_tactic_string", "description": "Pretty print a lens."}, {"name": "expr_lens.zoom", "description": " Zoom into `e : expr` given the context of an `expr_lens`, popping out an `expr` and a new\nzoomed `expr_lens`, if this is possible (`e` has to be an application)."}, {"name": "expr_lens.mk_congr_arg_using_dsimp", "description": " Sometimes `mk_congr_arg` fails, when the function is 'superficially dependent'.\nTry to `dsimp` the function first before building the `congr_arg` expression."}, {"name": "expr_lens.dir", "description": " Inductive type with two constructors `F` and `A`,\nthat represent the function-part `f` and arg-part `a` of an application `f a`. They specify the\ndirections in which an `expr_lens` should zoom into an `expr`.\n\nThis type is used in the development of rewriting tactics such as `nth_rewrite` and\n`rewrite_search`."}, {"name": "expr_lens.dir.F", "description": " Inductive type with two constructors `F` and `A`,\nthat represent the function-part `f` and arg-part `a` of an application `f a`. They specify the\ndirections in which an `expr_lens` should zoom into an `expr`.\n\nThis type is used in the development of rewriting tactics such as `nth_rewrite` and\n`rewrite_search`."}, {"name": "expr_lens.dir.A", "description": " Inductive type with two constructors `F` and `A`,\nthat represent the function-part `f` and arg-part `a` of an application `f a`. They specify the\ndirections in which an `expr_lens` should zoom into an `expr`.\n\nThis type is used in the development of rewriting tactics such as `nth_rewrite` and\n`rewrite_search`."}, {"name": "expr_lens.to_dirs", "description": " Convert an `expr_lens` into a list of instructions needed to build it; repeatedly inspecting a\nfunction or its argument a finite number of times."}, {"name": "expr_lens.dir.decidable_eq", "description": ""}, {"name": "expr.app_map", "description": " `app_map F e` maps a function `F` which understands `expr_lens`es\nover the given `e : expr` in the natural way;\nthat is, make holes in `e` everywhere where that is possible\n(generating `expr_lens`es in the process),\nand at each stage call the function `F` passing\nboth the `expr_lens` generated and the `expr` which was removed to make the hole.\n\nAt each stage `F` returns a list of some type, and `app_map` collects these lists together and\nreturns a concatenation of them all."}, {"name": "expr_lens", "description": " You're supposed to think of an `expr_lens` as a big set of nested applications with a single\nhole which needs to be filled, either in a function spot or argument spot. `expr_lens.fill` can\nfill this hole and turn your lens back into a real `expr`."}, {"name": "expr_lens.app_fun", "description": " You're supposed to think of an `expr_lens` as a big set of nested applications with a single\nhole which needs to be filled, either in a function spot or argument spot. `expr_lens.fill` can\nfill this hole and turn your lens back into a real `expr`."}, {"name": "expr_lens.app_arg", "description": " You're supposed to think of an `expr_lens` as a big set of nested applications with a single\nhole which needs to be filled, either in a function spot or argument spot. `expr_lens.fill` can\nfill this hole and turn your lens back into a real `expr`."}, {"name": "expr_lens.entire", "description": " You're supposed to think of an `expr_lens` as a big set of nested applications with a single\nhole which needs to be filled, either in a function spot or argument spot. `expr_lens.fill` can\nfill this hole and turn your lens back into a real `expr`."}, {"name": "expr_lens.dir.inhabited", "description": ""}, {"name": "expr_lens.dir.has_to_string", "description": ""}, {"name": "expr_lens.dir.to_string", "description": "String representation of `dir`."}, {"name": "expr_lens.congr", "description": " Turn an `e : expr_lens` and a proof that `a = b` into a series of `congr_arg` or `congr_fun`\napplications showing that the expressions obtained from `e.fill a` and `e.fill b` are equal."}, {"name": "expr_lens.fill", "description": "Fill the function or argument hole in this lens with the given `expr`."}, {"name": "eq.cmp_eq_eq'", "description": ""}, {"name": "ordering.swap_eq_iff_eq_swap", "description": ""}, {"name": "ordering.compares.cmp_eq", "description": ""}, {"name": "ordering.compares.of_swap", "description": "**Alias** of the forward direction of `ordering.compares_swap`."}, {"name": "cmp_to_dual", "description": ""}, {"name": "lt_iff_lt_of_cmp_eq_cmp", "description": ""}, {"name": "cmp_le", "description": " Like `cmp`, but uses a `\u2264` on the type instead of `<`. Given two elements `x` and `y`, returns a\nthree-way comparison result `ordering`."}, {"name": "ordering.compares.le_total", "description": ""}, {"name": "ordering.compares.eq_lt", "description": ""}, {"name": "cmp_eq_lt_iff", "description": ""}, {"name": "ordering.compares.eq_gt", "description": ""}, {"name": "cmp_le_of_dual", "description": ""}, {"name": "ordering.swap_or_else", "description": ""}, {"name": "ordering.compares.inj", "description": ""}, {"name": "cmp_le_eq_cmp", "description": ""}, {"name": "ordering.compares", "description": " `compares o a b` means that `a` and `b` have the ordering relation `o` between them, assuming\nthat the relation `a < b` is defined."}, {"name": "eq_iff_eq_of_cmp_eq_cmp", "description": ""}, {"name": "has_lt.lt.cmp_eq_lt", "description": ""}, {"name": "of_dual_compares_of_dual", "description": ""}, {"name": "cmp_self_eq_eq", "description": ""}, {"name": "ordering.swap_inj", "description": ""}, {"name": "cmp_eq_eq_iff", "description": ""}, {"name": "to_dual_compares_to_dual", "description": ""}, {"name": "cmp_le_to_dual", "description": ""}, {"name": "ordering.compares_swap", "description": ""}, {"name": "cmp_compares", "description": ""}, {"name": "ordering.or_else_eq_lt", "description": ""}, {"name": "cmp_swap", "description": ""}, {"name": "cmp_eq_gt_iff", "description": ""}, {"name": "has_lt.lt.cmp_eq_gt", "description": ""}, {"name": "cmp_eq_cmp_symm", "description": ""}, {"name": "linear_order_of_compares", "description": "Generate a linear order structure from a preorder and `cmp` function."}, {"name": "cmp_le_swap", "description": ""}, {"name": "ordering.compares.ne_gt", "description": ""}, {"name": "ordering.compares.ne_lt", "description": ""}, {"name": "ordering.compares.le_antisymm", "description": ""}, {"name": "le_iff_le_of_cmp_eq_cmp", "description": ""}, {"name": "eq.cmp_eq_eq", "description": ""}, {"name": "cmp_of_dual", "description": ""}, {"name": "ordering.compares.eq_eq", "description": ""}, {"name": "ordering.compares.swap", "description": "**Alias** of the reverse direction of `ordering.compares_swap`."}, {"name": "ordering.compares_iff_of_compares_impl", "description": ""}, {"name": "list.nil_bag_inter", "description": ""}, {"name": "list.disjoint_of_disjoint_append_left_left", "description": ""}, {"name": "list.disjoint.symm", "description": ""}, {"name": "list.mem_of_mem_inter_right", "description": ""}, {"name": "list.union_sublist_append", "description": ""}, {"name": "list.cons_bag_inter_of_neg", "description": ""}, {"name": "list.forall_mem_of_forall_mem_union_left", "description": ""}, {"name": "list.disjoint_append_right", "description": ""}, {"name": "list.disjoint_of_disjoint_cons_left", "description": ""}, {"name": "list.disjoint_right", "description": ""}, {"name": "list.forall_mem_inter_of_forall_left", "description": ""}, {"name": "list.subset_inter", "description": ""}, {"name": "list.mem_bag_inter", "description": ""}, {"name": "list.mem_union", "description": ""}, {"name": "list.bag_inter_nil", "description": ""}, {"name": "list.singleton_disjoint", "description": ""}, {"name": "list.disjoint_cons_right", "description": ""}, {"name": "list.disjoint_iff_ne", "description": ""}, {"name": "list.forall_mem_inter_of_forall_right", "description": ""}, {"name": "list.disjoint_left", "description": ""}, {"name": "list.disjoint_nil_right", "description": ""}, {"name": "list.disjoint_of_disjoint_append_right_right", "description": ""}, {"name": "list.inter_cons_of_mem", "description": ""}, {"name": "list.inter_nil", "description": ""}, {"name": "list.bag_inter_sublist_left", "description": ""}, {"name": "list.inter_subset_right", "description": ""}, {"name": "list.cons_bag_inter_of_pos", "description": ""}, {"name": "list.forall_mem_union", "description": ""}, {"name": "list.mem_union_right", "description": ""}, {"name": "list.disjoint_of_disjoint_append_right_left", "description": ""}, {"name": "list.mem_inter", "description": ""}, {"name": "list.disjoint_of_subset_right", "description": ""}, {"name": "list.mem_of_mem_inter_left", "description": ""}, {"name": "list.disjoint_append_left", "description": ""}, {"name": "list.disjoint_of_disjoint_cons_right", "description": ""}, {"name": "list.mem_inter_of_mem_of_mem", "description": ""}, {"name": "list.inter_cons_of_not_mem", "description": ""}, {"name": "list.inter_eq_nil_iff_disjoint", "description": ""}, {"name": "list.disjoint_singleton", "description": ""}, {"name": "list.suffix_union_right", "description": ""}, {"name": "list.cons_union", "description": ""}, {"name": "list.bag_inter_nil_iff_inter_nil", "description": ""}, {"name": "list.disjoint_comm", "description": ""}, {"name": "list.disjoint_nil_left", "description": ""}, {"name": "list.disjoint_cons_left", "description": ""}, {"name": "list.mem_union_left", "description": ""}, {"name": "list.disjoint_of_disjoint_append_left_right", "description": ""}, {"name": "list.nil_union", "description": ""}, {"name": "list.forall_mem_of_forall_mem_union_right", "description": ""}, {"name": "list.inter_reverse", "description": ""}, {"name": "list.disjoint_of_subset_left", "description": ""}, {"name": "list.inter_subset_left", "description": ""}, {"name": "list.count_bag_inter", "description": ""}, {"name": "list.disjoint_take_drop", "description": ""}, {"name": "list.sublist_suffix_of_union", "description": ""}, {"name": "div_sq_cancel", "description": ""}, {"name": "commute.zpow_left\u2080", "description": ""}, {"name": "commute.self_zpow\u2080", "description": ""}, {"name": "semiconj_by.zpow_right\u2080", "description": ""}, {"name": "zpow_eq_zero_iff", "description": ""}, {"name": "commute.zpow_zpow\u2080", "description": ""}, {"name": "zpow_add_one\u2080", "description": ""}, {"name": "pow_inv_comm\u2080", "description": ""}, {"name": "zpow_ne_zero_of_ne_zero", "description": ""}, {"name": "inv_pow_sub_of_lt", "description": ""}, {"name": "zpow_eq_zero", "description": ""}, {"name": "commute.zpow_self\u2080", "description": ""}, {"name": "zpow_bit1'", "description": ""}, {"name": "zpow_neg_mul_zpow_self", "description": ""}, {"name": "pow_sub_of_lt", "description": ""}, {"name": "zero_zpow_eq", "description": ""}, {"name": "zpow_sub\u2080", "description": ""}, {"name": "zpow_add'", "description": ""}, {"name": "zero_zpow", "description": ""}, {"name": "zpow_ne_zero", "description": ""}, {"name": "pow_sub\u2080", "description": ""}, {"name": "zpow_bit1\u2080", "description": ""}, {"name": "commute.zpow_zpow_self\u2080", "description": ""}, {"name": "zpow_sub_one\u2080", "description": ""}, {"name": "commute.zpow_right\u2080", "description": ""}, {"name": "zpow_add\u2080", "description": ""}, {"name": "inv_pow_sub\u2080", "description": ""}, {"name": "monoid_with_zero_hom.map_zpow", "description": " If a monoid homomorphism `f` between two `group_with_zero`s maps `0` to `0`, then it maps `x^n`,\n`n : \u2124`, to `(f x)^n`."}, {"name": "zpow_one_add\u2080", "description": ""}, {"name": "mul_zero_one_class", "description": "A typeclass for non-associative monoids with zero elements."}, {"name": "mul_zero_one_class.one", "description": "A typeclass for non-associative monoids with zero elements."}, {"name": "mul_zero_one_class.mul", "description": "A typeclass for non-associative monoids with zero elements."}, {"name": "mul_zero_one_class.one_mul", "description": "A typeclass for non-associative monoids with zero elements."}, {"name": "mul_zero_one_class.mul_one", "description": "A typeclass for non-associative monoids with zero elements."}, {"name": "mul_zero_one_class.zero", "description": "A typeclass for non-associative monoids with zero elements."}, {"name": "mul_zero_one_class.zero_mul", "description": "A typeclass for non-associative monoids with zero elements."}, {"name": "mul_zero_one_class.mul_zero", "description": "A typeclass for non-associative monoids with zero elements."}, {"name": "semigroup_with_zero", "description": " A type `S\u2080` is a \"semigroup with zero\u201d if it is a semigroup with zero element, and `0` is left\nand right absorbing."}, {"name": "semigroup_with_zero.mul", "description": " A type `S\u2080` is a \"semigroup with zero\u201d if it is a semigroup with zero element, and `0` is left\nand right absorbing."}, {"name": "semigroup_with_zero.mul_assoc", "description": " A type `S\u2080` is a \"semigroup with zero\u201d if it is a semigroup with zero element, and `0` is left\nand right absorbing."}, {"name": "semigroup_with_zero.zero", "description": " A type `S\u2080` is a \"semigroup with zero\u201d if it is a semigroup with zero element, and `0` is left\nand right absorbing."}, {"name": "semigroup_with_zero.zero_mul", "description": " A type `S\u2080` is a \"semigroup with zero\u201d if it is a semigroup with zero element, and `0` is left\nand right absorbing."}, {"name": "semigroup_with_zero.mul_zero", "description": " A type `S\u2080` is a \"semigroup with zero\u201d if it is a semigroup with zero element, and `0` is left\nand right absorbing."}, {"name": "cancel_monoid_with_zero.to_monoid_with_zero", "description": ""}, {"name": "cancel_comm_monoid_with_zero", "description": "A type `M` is a `cancel_comm_monoid_with_zero` if it is a commutative monoid with zero element,\n`0` is left and right absorbing,\n and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_comm_monoid_with_zero.mul", "description": "A type `M` is a `cancel_comm_monoid_with_zero` if it is a commutative monoid with zero element,\n`0` is left and right absorbing,\n and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_comm_monoid_with_zero.mul_assoc", "description": "A type `M` is a `cancel_comm_monoid_with_zero` if it is a commutative monoid with zero element,\n`0` is left and right absorbing,\n and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_comm_monoid_with_zero.one", "description": "A type `M` is a `cancel_comm_monoid_with_zero` if it is a commutative monoid with zero element,\n`0` is left and right absorbing,\n and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_comm_monoid_with_zero.one_mul", "description": "A type `M` is a `cancel_comm_monoid_with_zero` if it is a commutative monoid with zero element,\n`0` is left and right absorbing,\n and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_comm_monoid_with_zero.mul_one", "description": "A type `M` is a `cancel_comm_monoid_with_zero` if it is a commutative monoid with zero element,\n`0` is left and right absorbing,\n and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_comm_monoid_with_zero.npow", "description": "A type `M` is a `cancel_comm_monoid_with_zero` if it is a commutative monoid with zero element,\n`0` is left and right absorbing,\n and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_comm_monoid_with_zero.npow_zero'", "description": "A type `M` is a `cancel_comm_monoid_with_zero` if it is a commutative monoid with zero element,\n`0` is left and right absorbing,\n and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_comm_monoid_with_zero.npow_succ'", "description": "A type `M` is a `cancel_comm_monoid_with_zero` if it is a commutative monoid with zero element,\n`0` is left and right absorbing,\n and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_comm_monoid_with_zero.mul_comm", "description": "A type `M` is a `cancel_comm_monoid_with_zero` if it is a commutative monoid with zero element,\n`0` is left and right absorbing,\n and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_comm_monoid_with_zero.zero", "description": "A type `M` is a `cancel_comm_monoid_with_zero` if it is a commutative monoid with zero element,\n`0` is left and right absorbing,\n and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_comm_monoid_with_zero.zero_mul", "description": "A type `M` is a `cancel_comm_monoid_with_zero` if it is a commutative monoid with zero element,\n`0` is left and right absorbing,\n and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_comm_monoid_with_zero.mul_zero", "description": "A type `M` is a `cancel_comm_monoid_with_zero` if it is a commutative monoid with zero element,\n`0` is left and right absorbing,\n and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_comm_monoid_with_zero.mul_left_cancel_of_ne_zero", "description": "A type `M` is a `cancel_comm_monoid_with_zero` if it is a commutative monoid with zero element,\n`0` is left and right absorbing,\n and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_comm_monoid_with_zero.mul_right_cancel_of_ne_zero", "description": "A type `M` is a `cancel_comm_monoid_with_zero` if it is a commutative monoid with zero element,\n`0` is left and right absorbing,\n and left/right multiplication by a non-zero element is injective."}, {"name": "monoid_with_zero.to_semigroup_with_zero", "description": ""}, {"name": "monoid_with_zero.to_mul_zero_one_class", "description": ""}, {"name": "mul_zero_class.to_has_mul", "description": ""}, {"name": "mul_zero_class", "description": " Typeclass for expressing that a type `M\u2080` with multiplication and a zero satisfies\n`0 * a = 0` and `a * 0 = 0` for all `a : M\u2080`."}, {"name": "mul_zero_class.mul", "description": " Typeclass for expressing that a type `M\u2080` with multiplication and a zero satisfies\n`0 * a = 0` and `a * 0 = 0` for all `a : M\u2080`."}, {"name": "mul_zero_class.zero", "description": " Typeclass for expressing that a type `M\u2080` with multiplication and a zero satisfies\n`0 * a = 0` and `a * 0 = 0` for all `a : M\u2080`."}, {"name": "mul_zero_class.zero_mul", "description": " Typeclass for expressing that a type `M\u2080` with multiplication and a zero satisfies\n`0 * a = 0` and `a * 0 = 0` for all `a : M\u2080`."}, {"name": "mul_zero_class.mul_zero", "description": " Typeclass for expressing that a type `M\u2080` with multiplication and a zero satisfies\n`0 * a = 0` and `a * 0 = 0` for all `a : M\u2080`."}, {"name": "comm_monoid_with_zero.to_comm_monoid", "description": ""}, {"name": "mul_left_injective\u2080", "description": ""}, {"name": "cancel_comm_monoid_with_zero.to_comm_monoid_with_zero", "description": ""}, {"name": "no_zero_divisors", "description": " Predicate typeclass for expressing that `a * b = 0` implies `a = 0` or `b = 0`\nfor all `a` and `b` of type `G\u2080`."}, {"name": "no_zero_divisors.eq_zero_or_eq_zero_of_mul_eq_zero", "description": " Predicate typeclass for expressing that `a * b = 0` implies `a = 0` or `b = 0`\nfor all `a` and `b` of type `G\u2080`."}, {"name": "comm_group_with_zero", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.mul", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.mul_assoc", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.one", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.one_mul", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.mul_one", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.npow", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.npow_zero'", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.npow_succ'", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.mul_comm", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.zero", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.zero_mul", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.mul_zero", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.inv", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.div", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.div_eq_mul_inv", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.zpow", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.zpow_zero'", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.zpow_succ'", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.zpow_neg'", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.exists_pair_ne", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.inv_zero", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "comm_group_with_zero.mul_inv_cancel", "description": " A type `G\u2080` is a commutative \u201cgroup with zero\u201d\nif it is a commutative monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`."}, {"name": "mul_zero_class.to_has_zero", "description": ""}, {"name": "zero_mul", "description": ""}, {"name": "comm_monoid_with_zero.to_monoid_with_zero", "description": ""}, {"name": "comm_monoid_with_zero", "description": " A type `M` is a commutative \u201cmonoid with zero\u201d if it is a commutative monoid with zero\nelement, and `0` is left and right absorbing."}, {"name": "comm_monoid_with_zero.mul", "description": " A type `M` is a commutative \u201cmonoid with zero\u201d if it is a commutative monoid with zero\nelement, and `0` is left and right absorbing."}, {"name": "comm_monoid_with_zero.mul_assoc", "description": " A type `M` is a commutative \u201cmonoid with zero\u201d if it is a commutative monoid with zero\nelement, and `0` is left and right absorbing."}, {"name": "comm_monoid_with_zero.one", "description": " A type `M` is a commutative \u201cmonoid with zero\u201d if it is a commutative monoid with zero\nelement, and `0` is left and right absorbing."}, {"name": "comm_monoid_with_zero.one_mul", "description": " A type `M` is a commutative \u201cmonoid with zero\u201d if it is a commutative monoid with zero\nelement, and `0` is left and right absorbing."}, {"name": "comm_monoid_with_zero.mul_one", "description": " A type `M` is a commutative \u201cmonoid with zero\u201d if it is a commutative monoid with zero\nelement, and `0` is left and right absorbing."}, {"name": "comm_monoid_with_zero.npow", "description": " A type `M` is a commutative \u201cmonoid with zero\u201d if it is a commutative monoid with zero\nelement, and `0` is left and right absorbing."}, {"name": "comm_monoid_with_zero.npow_zero'", "description": " A type `M` is a commutative \u201cmonoid with zero\u201d if it is a commutative monoid with zero\nelement, and `0` is left and right absorbing."}, {"name": "comm_monoid_with_zero.npow_succ'", "description": " A type `M` is a commutative \u201cmonoid with zero\u201d if it is a commutative monoid with zero\nelement, and `0` is left and right absorbing."}, {"name": "comm_monoid_with_zero.mul_comm", "description": " A type `M` is a commutative \u201cmonoid with zero\u201d if it is a commutative monoid with zero\nelement, and `0` is left and right absorbing."}, {"name": "comm_monoid_with_zero.zero", "description": " A type `M` is a commutative \u201cmonoid with zero\u201d if it is a commutative monoid with zero\nelement, and `0` is left and right absorbing."}, {"name": "comm_monoid_with_zero.zero_mul", "description": " A type `M` is a commutative \u201cmonoid with zero\u201d if it is a commutative monoid with zero\nelement, and `0` is left and right absorbing."}, {"name": "comm_monoid_with_zero.mul_zero", "description": " A type `M` is a commutative \u201cmonoid with zero\u201d if it is a commutative monoid with zero\nelement, and `0` is left and right absorbing."}, {"name": "mul_zero_one_class.to_mul_zero_class", "description": ""}, {"name": "semigroup_with_zero.to_mul_zero_class", "description": ""}, {"name": "mul_inv_cancel", "description": ""}, {"name": "inv_zero", "description": ""}, {"name": "mul_left_cancel\u2080", "description": ""}, {"name": "comm_group_with_zero.to_group_with_zero", "description": ""}, {"name": "cancel_monoid_with_zero", "description": " A type `M` is a `cancel_monoid_with_zero` if it is a monoid with zero element, `0` is left\nand right absorbing, and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_monoid_with_zero.mul", "description": " A type `M` is a `cancel_monoid_with_zero` if it is a monoid with zero element, `0` is left\nand right absorbing, and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_monoid_with_zero.mul_assoc", "description": " A type `M` is a `cancel_monoid_with_zero` if it is a monoid with zero element, `0` is left\nand right absorbing, and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_monoid_with_zero.one", "description": " A type `M` is a `cancel_monoid_with_zero` if it is a monoid with zero element, `0` is left\nand right absorbing, and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_monoid_with_zero.one_mul", "description": " A type `M` is a `cancel_monoid_with_zero` if it is a monoid with zero element, `0` is left\nand right absorbing, and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_monoid_with_zero.mul_one", "description": " A type `M` is a `cancel_monoid_with_zero` if it is a monoid with zero element, `0` is left\nand right absorbing, and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_monoid_with_zero.npow", "description": " A type `M` is a `cancel_monoid_with_zero` if it is a monoid with zero element, `0` is left\nand right absorbing, and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_monoid_with_zero.npow_zero'", "description": " A type `M` is a `cancel_monoid_with_zero` if it is a monoid with zero element, `0` is left\nand right absorbing, and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_monoid_with_zero.npow_succ'", "description": " A type `M` is a `cancel_monoid_with_zero` if it is a monoid with zero element, `0` is left\nand right absorbing, and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_monoid_with_zero.zero", "description": " A type `M` is a `cancel_monoid_with_zero` if it is a monoid with zero element, `0` is left\nand right absorbing, and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_monoid_with_zero.zero_mul", "description": " A type `M` is a `cancel_monoid_with_zero` if it is a monoid with zero element, `0` is left\nand right absorbing, and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_monoid_with_zero.mul_zero", "description": " A type `M` is a `cancel_monoid_with_zero` if it is a monoid with zero element, `0` is left\nand right absorbing, and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_monoid_with_zero.mul_left_cancel_of_ne_zero", "description": " A type `M` is a `cancel_monoid_with_zero` if it is a monoid with zero element, `0` is left\nand right absorbing, and left/right multiplication by a non-zero element is injective."}, {"name": "cancel_monoid_with_zero.mul_right_cancel_of_ne_zero", "description": " A type `M` is a `cancel_monoid_with_zero` if it is a monoid with zero element, `0` is left\nand right absorbing, and left/right multiplication by a non-zero element is injective."}, {"name": "group_with_zero.to_nontrivial", "description": ""}, {"name": "mul_right_injective\u2080", "description": ""}, {"name": "mul_right_cancel\u2080", "description": ""}, {"name": "comm_group_with_zero.to_comm_monoid_with_zero", "description": ""}, {"name": "semigroup_with_zero.to_semigroup", "description": ""}, {"name": "group_with_zero.to_monoid_with_zero", "description": ""}, {"name": "mul_zero_one_class.to_mul_one_class", "description": ""}, {"name": "monoid_with_zero.to_monoid", "description": ""}, {"name": "group_with_zero", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.mul", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.mul_assoc", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.one", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.one_mul", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.mul_one", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.npow", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.npow_zero'", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.npow_succ'", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.zero", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.zero_mul", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.mul_zero", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.inv", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.div", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.div_eq_mul_inv", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.zpow", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.zpow_zero'", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.zpow_succ'", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.zpow_neg'", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.exists_pair_ne", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.inv_zero", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "group_with_zero.mul_inv_cancel", "description": " A type `G\u2080` is a \u201cgroup with zero\u201d if it is a monoid with zero element (distinct from `1`)\nsuch that every nonzero element is invertible.\nThe type is required to come with an \u201cinverse\u201d function, and the inverse of `0` must be `0`.\n\nExamples include division rings and the ordered monoids that are the\ntarget of valuations in general valuation theory."}, {"name": "mul_zero", "description": ""}, {"name": "monoid_with_zero", "description": " A type `M\u2080` is a \u201cmonoid with zero\u201d if it is a monoid with zero element, and `0` is left\nand right absorbing."}, {"name": "monoid_with_zero.mul", "description": " A type `M\u2080` is a \u201cmonoid with zero\u201d if it is a monoid with zero element, and `0` is left\nand right absorbing."}, {"name": "monoid_with_zero.mul_assoc", "description": " A type `M\u2080` is a \u201cmonoid with zero\u201d if it is a monoid with zero element, and `0` is left\nand right absorbing."}, {"name": "monoid_with_zero.one", "description": " A type `M\u2080` is a \u201cmonoid with zero\u201d if it is a monoid with zero element, and `0` is left\nand right absorbing."}, {"name": "monoid_with_zero.one_mul", "description": " A type `M\u2080` is a \u201cmonoid with zero\u201d if it is a monoid with zero element, and `0` is left\nand right absorbing."}, {"name": "monoid_with_zero.mul_one", "description": " A type `M\u2080` is a \u201cmonoid with zero\u201d if it is a monoid with zero element, and `0` is left\nand right absorbing."}, {"name": "monoid_with_zero.npow", "description": " A type `M\u2080` is a \u201cmonoid with zero\u201d if it is a monoid with zero element, and `0` is left\nand right absorbing."}, {"name": "monoid_with_zero.npow_zero'", "description": " A type `M\u2080` is a \u201cmonoid with zero\u201d if it is a monoid with zero element, and `0` is left\nand right absorbing."}, {"name": "monoid_with_zero.npow_succ'", "description": " A type `M\u2080` is a \u201cmonoid with zero\u201d if it is a monoid with zero element, and `0` is left\nand right absorbing."}, {"name": "monoid_with_zero.zero", "description": " A type `M\u2080` is a \u201cmonoid with zero\u201d if it is a monoid with zero element, and `0` is left\nand right absorbing."}, {"name": "monoid_with_zero.zero_mul", "description": " A type `M\u2080` is a \u201cmonoid with zero\u201d if it is a monoid with zero element, and `0` is left\nand right absorbing."}, {"name": "monoid_with_zero.mul_zero", "description": " A type `M\u2080` is a \u201cmonoid with zero\u201d if it is a monoid with zero element, and `0` is left\nand right absorbing."}, {"name": "group_with_zero.to_div_inv_monoid", "description": ""}, {"name": "cancel_comm_monoid_with_zero.to_cancel_monoid_with_zero", "description": ""}, {"name": "semiconj_by.reflexive", "description": " The relation \u201cthere exists an element that semiconjugates `a` to `b`\u201d on a monoid (or, more\ngenerally, on ` mul_one_class` type) is reflexive."}, {"name": "semiconj_by.mul_left", "description": "If both `a` and `b` semiconjugate `x` to `y`, then so does `a * b`."}, {"name": "add_semiconj_by.add_left", "description": "If both `a` and `b` semiconjugate `x` to `y`, then so does `a + b`."}, {"name": "semiconj_by.mul_right", "description": " If `a` semiconjugates `x` to `y` and `x'` to `y'`,\nthen it semiconjugates `x * x'` to `y * y'`."}, {"name": "add_semiconj_by.add_units_neg_symm_left_iff", "description": ""}, {"name": "semiconj_by.conj_mk", "description": "`a` semiconjugates `x` to `a * x * a\u207b\u00b9`."}, {"name": "semiconj_by.units_coe", "description": ""}, {"name": "semiconj_by_iff_eq", "description": ""}, {"name": "add_semiconj_by.neg_neg_symm", "description": ""}, {"name": "semiconj_by.eq", "description": "Equality behind `semiconj_by a x y`; useful for rewriting."}, {"name": "add_semiconj_by.neg_right_iff", "description": ""}, {"name": "add_semiconj_by.conj_mk", "description": "`a` semiconjugates `x` to `a + x + -a`."}, {"name": "add_semiconj_by.add_right", "description": "If `a` semiconjugates `x` to `y` and `x'` to `y'`, then it semiconjugates\n`x + x'` to `y + y'`."}, {"name": "add_semiconj_by.reflexive", "description": "The relation \u201cthere exists an element that semiconjugates `a` to `b`\u201d on an additive\nmonoid (or, more generally, on a `add_zero_class` type) is reflexive."}, {"name": "add_semiconj_by.neg_right", "description": ""}, {"name": "add_units.mk_semiconj_by", "description": "`a` semiconjugates `x` to `a + x + -a`."}, {"name": "semiconj_by.inv_right", "description": ""}, {"name": "add_semiconj_by.add_units_neg_right", "description": "If `a` semiconjugates an additive unit `x` to an additive unit `y`, then it\nsemiconjugates `-x` to `-y`."}, {"name": "semiconj_by.units_inv_right", "description": "If `a` semiconjugates a unit `x` to a unit `y`, then it semiconjugates `x\u207b\u00b9` to `y\u207b\u00b9`."}, {"name": "add_semiconj_by.add_units_coe_iff", "description": ""}, {"name": "add_semiconj_by.eq", "description": "Equality behind `add_semiconj_by a x y`; useful for rewriting."}, {"name": "units.mk_semiconj_by", "description": "`a` semiconjugates `x` to `a * x * a\u207b\u00b9`."}, {"name": "add_semiconj_by.add_units_neg_right_iff", "description": ""}, {"name": "add_semiconj_by.neg_symm_left", "description": ""}, {"name": "semiconj_by.inv_symm_left", "description": ""}, {"name": "semiconj_by.transitive", "description": " The relation \u201cthere exists an element that semiconjugates `a` to `b`\u201d on a semigroup\nis transitive."}, {"name": "semiconj_by.inv_right_iff", "description": ""}, {"name": "add_semiconj_by.add_units_neg_symm_left", "description": "If an additive unit `a` semiconjugates `x` to `y`, then `-a` semiconjugates `y` to\n`x`."}, {"name": "semiconj_by.units_inv_right_iff", "description": ""}, {"name": "add_semiconj_by", "description": "`x` is additive semiconjugate to `y` by `a` if `a + x = y + a`"}, {"name": "add_semiconj_by.zero_right", "description": "Any element additively semiconjugates `0` to `0`."}, {"name": "add_semiconj_by.zero_left", "description": "Zero additively semiconjugates any element to itself."}, {"name": "semiconj_by.units_of_coe", "description": ""}, {"name": "add_semiconj_by.nsmul_right", "description": ""}, {"name": "semiconj_by.inv_inv_symm_iff", "description": ""}, {"name": "semiconj_by.units_inv_symm_left_iff", "description": ""}, {"name": "semiconj_by.inv_inv_symm", "description": ""}, {"name": "add_semiconj_by_iff_eq", "description": ""}, {"name": "semiconj_by.units_inv_symm_left", "description": "If a unit `a` semiconjugates `x` to `y`, then `a\u207b\u00b9` semiconjugates `y` to `x`."}, {"name": "semiconj_by.inv_symm_left_iff", "description": ""}, {"name": "semiconj_by.one_left", "description": "One semiconjugates any element to itself."}, {"name": "semiconj_by", "description": "`x` is semiconjugate to `y` by `a`, if `a * x = y * a`."}, {"name": "add_semiconj_by.transitive", "description": "The relation \u201cthere exists an element that semiconjugates `a` to `b`\u201d on an additive\nsemigroup is transitive."}, {"name": "semiconj_by.pow_right", "description": ""}, {"name": "add_semiconj_by.neg_neg_symm_iff", "description": ""}, {"name": "semiconj_by.units_coe_iff", "description": ""}, {"name": "add_semiconj_by.neg_symm_left_iff", "description": ""}, {"name": "add_semiconj_by.add_units_of_coe", "description": ""}, {"name": "semiconj_by.one_right", "description": "Any element semiconjugates `1` to `1`."}, {"name": "add_semiconj_by.add_units_coe", "description": ""}, {"name": "array.reverse", "description": ""}, {"name": "array.take", "description": ""}, {"name": "array.take_right", "description": ""}, {"name": "array.drop", "description": ""}, {"name": "array.slice", "description": ""}, {"name": "where.where_cmd", "description": "When working in a Lean file with namespaces, parameters, and variables, it can be confusing to\nidentify what the current \"parser context\" is. The command `#where` identifies and prints\ninformation about the current location, including the active namespace, open namespaces, and\ndeclared variables.\n\nIt is a bug for `#where` to incorrectly report this information (this was not formerly the case);\nplease file an issue on GitHub if you observe a failure."}, {"name": "where.build_str_includes", "description": "`#where` output helper which traces the includes."}, {"name": "where.build_str_end", "description": "`#where` output helper which traces the namespace end."}, {"name": "where.sort_variable_list", "description": "Sort the variables by their priority as defined by `where.binder_priority`."}, {"name": "where.collect_implicit_names", "description": "Separate out the names of implicit variables (commonly instances with no name)."}, {"name": "where.build_str_variables", "description": "`#where` output helper which traces the variables."}, {"name": "where.build_msg", "description": "`#where` output main function."}, {"name": "where.get_open_namespaces", "description": " `get_open_namespaces ns` returns a list of the open namespaces, given that we are currently in\nthe namespace `ns` (which we do not include)."}, {"name": "where.binder_priority", "description": "Assigns a priority to each binder for determining the order in which variables are traced."}, {"name": "where.binder_less_important", "description": "The relation on binder priorities."}, {"name": "where.format_variable", "description": "Format an individual variable definition for printing."}, {"name": "tactic_doc.command.#where", "description": "When working in a Lean file with namespaces, parameters, and variables, it can be confusing to\nidentify what the current \"parser context\" is. The command `#where` identifies and prints\ninformation about the current location, including the active namespace, open namespaces, and\ndeclared variables.\n\nIt is a bug for `#where` to incorrectly report this information (this was not formerly the case);\nplease file an issue on GitHub if you observe a failure."}, {"name": "where.compile_variable_list", "description": "Turn a list of triples of variable names, binder info, and types, into a pretty list."}, {"name": "where.collect_by", "description": " Returns the elements of `l` under the image of `p`, collecting together elements with the same\n`\u03b2` component, deleting duplicates."}, {"name": "where.build_str_open_namespaces", "description": "`#where` output helper which traces the open namespaces."}, {"name": "where.build_str_namespace", "description": "`#where` output helper which traces the current namespace."}, {"name": "where.select_for_which", "description": " Selects the elements of the given `list \u03b1` which under the image of `p : \u03b1 \u2192 \u03b2 \u00d7 \u03b3` have `\u03b2`\ncomponent equal to `b'`. Returns the `\u03b3` components of the selected elements under the image of `p`,\nand the elements of the original `list \u03b1` which were not selected."}, {"name": "finset.card_singleton_inter", "description": ""}, {"name": "finset.exists_subset_or_subset_of_two_mul_lt_card", "description": ""}, {"name": "finset.strong_induction_eq", "description": ""}, {"name": "finset.strong_induction_on_eq", "description": ""}, {"name": "finset.two_lt_card", "description": ""}, {"name": "finset.card_lt_card", "description": ""}, {"name": "finset.card_eq_one", "description": ""}, {"name": "finset.map_eq_of_subset", "description": ""}, {"name": "finset.card_image_of_inj_on", "description": ""}, {"name": "finset.card_empty", "description": ""}, {"name": "finset.card_insert_of_mem", "description": ""}, {"name": "finset.card_doubleton", "description": ""}, {"name": "finset.card_sdiff", "description": ""}, {"name": "finset.strong_induction_on", "description": "Analogue of `strong_induction` with order of arguments swapped."}, {"name": "finset.card_insert_le", "description": ""}, {"name": "finset.le_card_sdiff", "description": ""}, {"name": "finset.strong_downward_induction_eq", "description": ""}, {"name": "finset.card_mk", "description": ""}, {"name": "finset.card_eq_of_bijective", "description": ""}, {"name": "multiset.to_finset_card_of_nodup", "description": ""}, {"name": "finset.inj_on_of_surj_on_of_card_le", "description": ""}, {"name": "finset.card_filter_le", "description": ""}, {"name": "list.card_to_finset", "description": ""}, {"name": "finset.card_erase_eq_ite", "description": "If `a \u2208 s` is known, see also `finset.card_erase_of_mem` and `finset.erase_eq_of_not_mem`."}, {"name": "multiset.to_finset_card_le", "description": ""}, {"name": "finset.card_union_eq", "description": ""}, {"name": "finset.card_le_one_iff_subset_singleton", "description": ""}, {"name": "finset.exists_ne_of_one_lt_card", "description": ""}, {"name": "finset.card_sdiff_add_card", "description": ""}, {"name": "finset.card_subtype", "description": ""}, {"name": "finset.card_le_one", "description": ""}, {"name": "list.to_finset_card_le", "description": ""}, {"name": "finset.strong_downward_induction_on_eq", "description": ""}, {"name": "finset.nonempty.card_pos", "description": "**Alias** of the reverse direction of `finset.card_pos`."}, {"name": "finset.card_eq_two", "description": ""}, {"name": "finset.card_pos", "description": ""}, {"name": "finset.card_image_of_injective", "description": ""}, {"name": "finset.card_le_card_of_inj_on", "description": ""}, {"name": "finset.card_eq_zero", "description": ""}, {"name": "finset.card_erase_add_one", "description": ""}, {"name": "finset.one_lt_card_iff", "description": ""}, {"name": "finset.filter_card_add_filter_neg_card_eq_card", "description": ""}, {"name": "finset.exists_eq_insert_iff", "description": ""}, {"name": "finset.card_le_of_subset", "description": ""}, {"name": "finset.card_mono", "description": ""}, {"name": "finset.card_erase_of_mem", "description": ""}, {"name": "finset.fiber_card_ne_zero_iff_mem_image", "description": ""}, {"name": "finset.card_ne_zero_of_mem", "description": ""}, {"name": "finset.card_erase_le", "description": ""}, {"name": "finset.lt_wf", "description": ""}, {"name": "finset.card_sdiff_add_card_eq_card", "description": ""}, {"name": "finset.one_lt_card", "description": ""}, {"name": "finset.card_disjoint_union", "description": ""}, {"name": "finset.strong_downward_induction_on", "description": "Analogue of `strong_downward_induction` with order of arguments swapped."}, {"name": "finset.case_strong_induction_on", "description": ""}, {"name": "finset.le_card_of_inj_on_range", "description": ""}, {"name": "finset.card_cons", "description": ""}, {"name": "finset.card_range", "description": ""}, {"name": "finset.card_le_one_iff", "description": ""}, {"name": "finset.surj_on_of_inj_on_of_card_le", "description": ""}, {"name": "finset.card_image_le", "description": ""}, {"name": "finset.pred_card_le_card_erase", "description": ""}, {"name": "finset.card_le_one_of_subsingleton", "description": "A `finset` of a subsingleton type has cardinality at most one."}, {"name": "finset.card_eq_three", "description": ""}, {"name": "finset.eq_of_subset_of_card_le", "description": ""}, {"name": "finset.card_attach", "description": ""}, {"name": "finset.two_lt_card_iff", "description": ""}, {"name": "finset.card_insert_eq_ite", "description": "If `a \u2208 s` is known, see also `finset.card_insert_of_mem` and `finset.card_insert_of_not_mem`."}, {"name": "finset.exists_intermediate_set", "description": " Given a set `A` and a set `B` inside it, we can shrink `A` to any appropriate size, and keep `B`\ninside it."}, {"name": "finset.card", "description": "`s.card` is the number of elements of `s`, aka its cardinality."}, {"name": "finset.length_to_list", "description": ""}, {"name": "finset.exists_smaller_set", "description": "We can shrink `A` to any smaller size."}, {"name": "finset.card_union_add_card_inter", "description": ""}, {"name": "finset.card_insert_of_not_mem", "description": ""}, {"name": "finset.card_map", "description": ""}, {"name": "finset.inj_on_of_card_image_eq", "description": ""}, {"name": "finset.card_def", "description": ""}, {"name": "finset.exists_ne_map_eq_of_card_lt_of_maps_to", "description": "If there are more pigeons than pigeonholes, then there are two pigeons in the same pigeonhole."}, {"name": "finset.card_union_le", "description": ""}, {"name": "finset.card_congr", "description": ""}, {"name": "multiset.card_to_finset", "description": ""}, {"name": "finset.card_disj_union", "description": ""}, {"name": "list.to_finset_card_of_nodup", "description": ""}, {"name": "finset.strong_downward_induction", "description": " Suppose that, given that `p t` can be defined on all supersets of `s` of cardinality less than\n`n`, one knows how to define `p s`. Then one can inductively define `p s` for all finsets `s` of\ncardinality less than `n`, starting from finsets of card `n` and iterating. This\ncan be used either to define data, or to prove properties."}, {"name": "finset.card_singleton", "description": ""}, {"name": "finset.card_eq_succ", "description": ""}, {"name": "finset.filter_card_eq", "description": ""}, {"name": "finset.strong_induction", "description": " Suppose that, given objects defined on all strict subsets of any finset `s`, one knows how to\ndefine an object on `s`. Then one can inductively define an object on all finsets, starting from\nthe empty set and iterating. This can be used either to define data, or to prove properties."}, {"name": "finset.card_erase_lt_of_mem", "description": ""}, {"name": "finset.card_image_iff", "description": ""}, {"name": "multiset.range_disjoint_map_add", "description": ""}, {"name": "multiset.self_mem_range_succ", "description": ""}, {"name": "multiset.range_add_eq_union", "description": ""}, {"name": "multiset.not_mem_range_self", "description": ""}, {"name": "multiset.range", "description": "`range n` is the multiset lifted from the list `range n`,\n that is, the set `{0, 1, ..., n-1}`."}, {"name": "multiset.range_zero", "description": ""}, {"name": "multiset.mem_range", "description": ""}, {"name": "multiset.coe_range", "description": ""}, {"name": "multiset.range_add", "description": ""}, {"name": "multiset.range_succ", "description": ""}, {"name": "multiset.card_range", "description": ""}, {"name": "multiset.range_subset", "description": ""}, {"name": "list.enum_eq_zip_range", "description": ""}, {"name": "list.mem_range", "description": ""}, {"name": "list.nodup_of_fn", "description": ""}, {"name": "list.range_eq_range'", "description": ""}, {"name": "list.range'_eq_map_range", "description": ""}, {"name": "list.chain'_range_succ", "description": ""}, {"name": "list.length_fin_range", "description": ""}, {"name": "list.unzip_enum_from_eq_prod", "description": ""}, {"name": "list.nodup_iota", "description": ""}, {"name": "list.chain_lt_range'", "description": ""}, {"name": "list.fin_range", "description": "All elements of `fin n`, from `0` to `n-1`."}, {"name": "list.nth_le_range", "description": ""}, {"name": "list.pairwise_gt_iota", "description": ""}, {"name": "list.range_add", "description": ""}, {"name": "list.fin_range_succ_eq_map", "description": ""}, {"name": "list.mem_fin_range", "description": ""}, {"name": "list.of_fn_eq_pmap", "description": ""}, {"name": "list.fin_range_eq_nil", "description": ""}, {"name": "list.nth_le_range'", "description": ""}, {"name": "list.mem_range'", "description": ""}, {"name": "list.chain_succ_range'", "description": ""}, {"name": "list.range'_subset_right", "description": ""}, {"name": "list.range_succ_eq_map", "description": ""}, {"name": "list.nth_range", "description": ""}, {"name": "list.range_succ", "description": ""}, {"name": "list.map_add_range'", "description": ""}, {"name": "list.prod_range_succ", "description": ""}, {"name": "list.range'_eq_nil", "description": ""}, {"name": "list.range_subset", "description": ""}, {"name": "list.not_mem_range_self", "description": ""}, {"name": "list.range_core_range'", "description": ""}, {"name": "list.enum_from_eq_zip_range'", "description": ""}, {"name": "list.fin_range_zero", "description": ""}, {"name": "list.iota_eq_reverse_range'", "description": ""}, {"name": "list.range'_append", "description": ""}, {"name": "list.pairwise_lt_range'", "description": ""}, {"name": "list.nth_le_fin_range", "description": ""}, {"name": "list.length_range'", "description": ""}, {"name": "list.nodup_range", "description": ""}, {"name": "list.enum_from_map_fst", "description": ""}, {"name": "list.nth_range'", "description": ""}, {"name": "list.enum_map_fst", "description": ""}, {"name": "list.prod_range_succ'", "description": "A variant of `prod_range_succ` which pulls off the first\n term in the product rather than the last."}, {"name": "list.of_fn_id", "description": ""}, {"name": "list.map_sub_range'", "description": ""}, {"name": "list.range_zero", "description": ""}, {"name": "list.range_sublist", "description": ""}, {"name": "list.reverse_range'", "description": ""}, {"name": "list.range'_concat", "description": ""}, {"name": "list.range'_sublist_right", "description": ""}, {"name": "list.chain_range_succ", "description": ""}, {"name": "list.sum_range_succ", "description": ""}, {"name": "list.self_mem_range_succ", "description": ""}, {"name": "list.of_fn_eq_map", "description": ""}, {"name": "list.mem_iota", "description": ""}, {"name": "list.length_iota", "description": ""}, {"name": "list.unzip_enum_eq_prod", "description": ""}, {"name": "list.range_eq_nil", "description": ""}, {"name": "list.map_coe_fin_range", "description": ""}, {"name": "list.pairwise_lt_range", "description": ""}, {"name": "list.nodup_fin_range", "description": ""}, {"name": "list.length_range", "description": ""}, {"name": "list.nodup_range'", "description": ""}, {"name": "list.sum_range_succ'", "description": "A variant of `sum_range_succ` which pulls off the first term in the sum\n  rather than the last."}, {"name": "function.commute.self_iterate", "description": ""}, {"name": "function.iterate_succ_apply", "description": ""}, {"name": "list.foldl_const", "description": ""}, {"name": "function.commute.iterate_left", "description": ""}, {"name": "list.foldr_const", "description": ""}, {"name": "function.commute.iterate_iterate", "description": ""}, {"name": "function.commute.comp_iterate", "description": ""}, {"name": "function.iterate_succ_apply'", "description": ""}, {"name": "function.iterate_pred_comp_of_pos", "description": ""}, {"name": "function.iterate_succ'", "description": ""}, {"name": "function.commute.iterate_right", "description": ""}, {"name": "function.commute.iterate_eq_of_map_eq", "description": ""}, {"name": "function.iterate_one", "description": ""}, {"name": "function.iterate_add_apply", "description": ""}, {"name": "function.iterate.rec", "description": "A recursor for the iterate of a function."}, {"name": "function.commute.iterate_self", "description": ""}, {"name": "function.iterate_zero_apply", "description": ""}, {"name": "function.semiconj.iterate_left", "description": ""}, {"name": "function.surjective.iterate", "description": ""}, {"name": "function.injective.iterate", "description": ""}, {"name": "function.comp_iterate_pred_of_pos", "description": ""}, {"name": "function.iterate_id", "description": ""}, {"name": "function.iterate_zero", "description": ""}, {"name": "function.iterate_comm", "description": ""}, {"name": "function.iterate_succ", "description": ""}, {"name": "function.iterate_add", "description": ""}, {"name": "function.commute.iterate_iterate_self", "description": ""}, {"name": "function.left_inverse.iterate", "description": ""}, {"name": "function.iterate_mul", "description": ""}, {"name": "function.semiconj\u2082.iterate", "description": ""}, {"name": "function.right_inverse.iterate", "description": ""}, {"name": "function.iterate_fixed", "description": ""}, {"name": "function.iterate_commute", "description": ""}, {"name": "function.bijective.iterate", "description": ""}, {"name": "function.semiconj.iterate_right", "description": ""}, {"name": "function.iterate.rec_zero", "description": ""}, {"name": "classical.inhabited_of_exists", "description": ""}, {"name": "classical.by_cases", "description": ""}, {"name": "classical.by_contradiction", "description": ""}, {"name": "classical.type_decidable", "description": ""}, {"name": "classical.epsilon_spec", "description": ""}, {"name": "classical.choice", "description": ""}, {"name": "classical.cases_true_false", "description": ""}, {"name": "classical.decidable_inhabited", "description": ""}, {"name": "classical.skolem", "description": ""}, {"name": "classical.epsilon_spec_aux", "description": ""}, {"name": "classical.cases_on", "description": ""}, {"name": "classical.prop_complete", "description": ""}, {"name": "classical.strong_indefinite_description", "description": ""}, {"name": "classical.inhabited_of_nonempty", "description": ""}, {"name": "classical.prop_decidable", "description": ""}, {"name": "classical.some_spec", "description": ""}, {"name": "classical.epsilon", "description": ""}, {"name": "classical.indefinite_description", "description": ""}, {"name": "classical.eq_false_or_eq_true", "description": ""}, {"name": "classical.exists_true_of_nonempty", "description": ""}, {"name": "classical.epsilon_singleton", "description": ""}, {"name": "classical.some", "description": ""}, {"name": "classical.axiom_of_choice", "description": ""}, {"name": "classical.em", "description": ""}, {"name": "classical.type_decidable_eq", "description": ""}, {"name": "ne_zero_of_dvd_ne_zero", "description": ""}, {"name": "units.mul_left_dvd", "description": "In a commutative monoid, an element `a` divides an element `b` iff all\n left associates of `a` divide `b`."}, {"name": "dvd.intro", "description": ""}, {"name": "eq_zero_of_zero_dvd", "description": ""}, {"name": "mul_dvd_mul", "description": ""}, {"name": "dvd_mul_left", "description": ""}, {"name": "dvd_of_mul_left_dvd", "description": ""}, {"name": "semigroup_has_dvd", "description": "There are two possible conventions for divisibility, which coincide in a `comm_monoid`.\n   This matches the convention for ordinals."}, {"name": "one_dvd", "description": ""}, {"name": "units.mul_right_dvd", "description": "In a monoid, an element `a` divides an element `b` iff all associates of `a` divide `b`."}, {"name": "zero_dvd_iff", "description": "Given an element `a` of a commutative semigroup with zero, there exists another element whose\n   product with zero equals `a` iff `a` equals zero."}, {"name": "dvd_of_mul_right_dvd", "description": ""}, {"name": "has_dvd.dvd.trans", "description": "**Alias** of `dvd_trans`."}, {"name": "exists_eq_mul_left_of_dvd", "description": ""}, {"name": "dvd.elim", "description": ""}, {"name": "dvd_not_unit_of_dvd_of_not_dvd", "description": ""}, {"name": "exists_eq_mul_right_of_dvd", "description": ""}, {"name": "dvd.intro_left", "description": ""}, {"name": "dvd_and_not_dvd_iff", "description": ""}, {"name": "monoid_hom.map_dvd", "description": ""}, {"name": "mul_dvd_mul_iff_left", "description": "Given two elements `b`, `c` of a `cancel_monoid_with_zero` and a nonzero element `a`,\n`a*b` divides `a*c` iff `b` divides `c`."}, {"name": "is_unit.dvd_mul_left", "description": "In a commutative monoid, an element `a` divides an element `b` iff `a` divides all left\n   associates of `b`."}, {"name": "is_unit.mul_left_dvd", "description": "In a commutative monoid, an element `a` divides an element `b` iff all\n left associates of `a` divide `b`."}, {"name": "dvd_trans", "description": ""}, {"name": "mul_dvd_mul_iff_right", "description": "Given two elements `a`, `b` of a commutative `cancel_monoid_with_zero` and a nonzero\n element `c`, `a*c` divides `b*c` iff `a` divides `b`."}, {"name": "dvd_mul_of_dvd_right", "description": ""}, {"name": "dvd_mul_of_dvd_left", "description": ""}, {"name": "dvd_iff_exists_eq_mul_left", "description": ""}, {"name": "is_unit_of_dvd_one", "description": ""}, {"name": "not_is_unit_of_not_is_unit_dvd", "description": ""}, {"name": "has_dvd.dvd.is_trans", "description": ""}, {"name": "units.dvd_mul_left", "description": "In a commutative monoid, an element `a` divides an element `b` iff `a` divides all left\n   associates of `b`."}, {"name": "mul_dvd_mul_left", "description": ""}, {"name": "dvd_mul_right", "description": ""}, {"name": "mul_dvd_mul_right", "description": ""}, {"name": "is_unit_iff_forall_dvd", "description": ""}, {"name": "units.dvd_mul_right", "description": "In a monoid, an element `a` divides an element `b` iff `a` divides all\n   associates of `b`."}, {"name": "has_dvd.dvd.is_refl", "description": ""}, {"name": "dvd.elim_left", "description": ""}, {"name": "dvd_refl", "description": ""}, {"name": "dvd_of_mul_left_eq", "description": "**Alias** of `dvd.intro_left`."}, {"name": "dvd_rfl", "description": ""}, {"name": "units.coe_dvd", "description": "Elements of the unit group of a monoid represented as elements of the monoid\n   divide any element of the monoid."}, {"name": "is_unit.mul_right_dvd", "description": "In a monoid, an element a divides an element b iff all associates of `a` divide `b`."}, {"name": "is_unit_iff_dvd_one", "description": ""}, {"name": "is_unit.dvd", "description": "Units of a monoid divide any element of the monoid."}, {"name": "is_unit_of_dvd_unit", "description": ""}, {"name": "dvd_not_unit", "description": " `dvd_not_unit a b` expresses that `a` divides `b` \"strictly\", i.e. that `b` divided by `a`\nis not a unit."}, {"name": "dvd_zero", "description": ""}, {"name": "has_dvd.dvd.mul_left", "description": "**Alias** of `dvd_mul_of_dvd_right`."}, {"name": "has_dvd.dvd.mul_right", "description": "**Alias** of `dvd_mul_of_dvd_left`."}, {"name": "map_dvd", "description": ""}, {"name": "mul_hom.map_dvd", "description": ""}, {"name": "dvd_of_mul_right_eq", "description": "**Alias** of `dvd.intro`."}, {"name": "is_unit.dvd_mul_right", "description": ""}, {"name": "category_theory.prod.sectr_map", "description": ""}, {"name": "category_theory.prod.braiding_unit_iso_inv_app", "description": ""}, {"name": "category_theory.functor.prod_map", "description": ""}, {"name": "category_theory.evaluation_uncurried_map", "description": ""}, {"name": "category_theory.prod.braiding_functor_map", "description": ""}, {"name": "category_theory.nat_trans.prod", "description": "The cartesian product of two natural transformations."}, {"name": "category_theory.is_iso_prod_iff", "description": ""}, {"name": "category_theory.iso.prod", "description": "Construct an isomorphism in `C \u00d7 D` out of two isomorphisms in `C` and `D`."}, {"name": "category_theory.prod.snd_map", "description": ""}, {"name": "category_theory.evaluation_map_app", "description": ""}, {"name": "category_theory.prod.snd_obj", "description": ""}, {"name": "category_theory.flip_comp_evaluation_hom_app", "description": ""}, {"name": "category_theory.iso.prod_hom", "description": ""}, {"name": "category_theory.prod.sectl_map", "description": ""}, {"name": "category_theory.evaluation", "description": "The \"evaluation at `X`\" functor, such that\n`(evaluation.obj X).obj F = F.obj X`,\nwhich is functorial in both `X` and `F`."}, {"name": "category_theory.prod.braiding_inverse_map", "description": ""}, {"name": "category_theory.prod_comp", "description": ""}, {"name": "category_theory.nat_trans.prod_app", "description": ""}, {"name": "category_theory.prod.fst", "description": "`fst` is the functor `(X, Y) \u21a6 X`."}, {"name": "category_theory.prod_id_fst", "description": ""}, {"name": "category_theory.prod.symmetry_hom_app", "description": ""}, {"name": "category_theory.prod.sectl", "description": "`sectl C Z` is the functor `C \u2964 C \u00d7 D` given by `X \u21a6 (X, Z)`."}, {"name": "category_theory.prod.sectr", "description": "`sectr Z D` is the functor `D \u2964 C \u00d7 D` given by `Y \u21a6 (Z, Y)` ."}, {"name": "category_theory.prod.braiding_counit_iso_hom_app", "description": ""}, {"name": "category_theory.prod.fst_map", "description": ""}, {"name": "category_theory.prod.swap_obj", "description": ""}, {"name": "category_theory.prod.symmetry", "description": "Swapping the factors of a cartesion product of categories twice is naturally isomorphic\nto the identity functor."}, {"name": "category_theory.evaluation_uncurried", "description": "The \"evaluation of `F` at `X`\" functor,\nas a functor `C \u00d7 (C \u2964 D) \u2964 D`."}, {"name": "category_theory.prod.braiding", "description": "The equivalence, given by swapping factors, between `C \u00d7 D` and `D \u00d7 C`."}, {"name": "category_theory.uniform_prod", "description": "`prod.category.uniform C D` is an additional instance specialised so both factors have the same\nuniverse levels. This helps typeclass resolution."}, {"name": "category_theory.prod_id_snd", "description": ""}, {"name": "category_theory.prod_id", "description": "Two rfl lemmas that cannot be generated by `@[simps]`."}, {"name": "category_theory.functor.prod'_map", "description": ""}, {"name": "category_theory.functor.prod_obj", "description": ""}, {"name": "category_theory.prod.braiding_inverse_obj", "description": ""}, {"name": "category_theory.flip_comp_evaluation_inv_app", "description": ""}, {"name": "category_theory.prod.braiding_functor_obj", "description": ""}, {"name": "category_theory.evaluation_uncurried_obj", "description": ""}, {"name": "category_theory.functor.prod", "description": "The cartesian product of two functors."}, {"name": "category_theory.functor.prod'_obj", "description": ""}, {"name": "category_theory.prod.braiding_unit_iso_hom_app", "description": ""}, {"name": "category_theory.prod.swap_map", "description": ""}, {"name": "category_theory.prod_comp_fst", "description": ""}, {"name": "category_theory.iso.prod_inv", "description": ""}, {"name": "category_theory.prod.symmetry_inv_app", "description": ""}, {"name": "category_theory.functor.diag_map", "description": ""}, {"name": "category_theory.prod.swap_is_equivalence", "description": ""}, {"name": "category_theory.prod_hom", "description": ""}, {"name": "category_theory.functor.prod'", "description": "Similar to `prod`, but both functors start from the same category `A`"}, {"name": "category_theory.prod.sectl_obj", "description": ""}, {"name": "category_theory.prod.swap", "description": "The functor swapping the factors of a cartesian product of categories, `C \u00d7 D \u2964 D \u00d7 C`."}, {"name": "category_theory.functor.diag_obj", "description": ""}, {"name": "category_theory.prod", "description": "`prod C D` gives the cartesian product of two categories.\n\nSee <https://stacks.math.columbia.edu/tag/001K>."}, {"name": "category_theory.evaluation_obj_obj", "description": ""}, {"name": "category_theory.prod.sectr_obj", "description": ""}, {"name": "category_theory.prod.braiding_counit_iso_inv_app", "description": ""}, {"name": "category_theory.prod.snd", "description": "`snd` is the functor `(X, Y) \u21a6 Y`."}, {"name": "category_theory.prod.fst_obj", "description": ""}, {"name": "category_theory.evaluation_obj_map", "description": ""}, {"name": "category_theory.flip_comp_evaluation", "description": "`F.flip` composed with evaluation is the same as evaluating `F`."}, {"name": "category_theory.functor.diag", "description": "The diagonal functor."}, {"name": "category_theory.prod_comp_snd", "description": ""}, {"name": "tactic_doc.tactic.revert_target_deps", "description": "Reverts all local constants on which the target depends (recursively)."}, {"name": "tactic.interactive.format_names", "description": ""}, {"name": "tactic.interactive.guard_proof_term", "description": "`guard_proof_term { t } e` applies tactic `t` and tests whether the resulting proof term\n unifies with `p`."}, {"name": "tactic.interactive.recover", "description": " For debugging only. This tactic checks the current state for any\nmissing dropped goals and restores them. Useful when there are no\ngoals to solve but \"result contains meta-variables\"."}, {"name": "tactic_doc.tactic.generalize'", "description": "`generalize' : e = x` replaces all occurrences of `e` in the target with a new hypothesis `x` of\nthe same type.\n\n`generalize' h : e = x` in addition registers the hypothesis `h : e = x`.\n\n`generalize'` is similar to `generalize`. The difference is that `generalize' : e = x` also\nsucceeds when `e` does not occur in the goal. It is similar to `set`, but the resulting hypothesis\n`x` is not a local definition."}, {"name": "tactic.interactive.loc.get_local_pp_names", "description": ""}, {"name": "tactic_doc.tactic.generalize_hyp", "description": "Like `generalize` but also considers assumptions\nspecified by the user. The user can also specify to\nomit the goal."}, {"name": "tactic.interactive.guard_tags", "description": "Test that `t` is the tag of the main goal."}, {"name": "tactic.interactive.guard_target_strict", "description": "`guard_target_strict t` fails if the target of the main goal is not syntactically `t`.\nWe use this tactic for writing tests."}, {"name": "tactic_doc.tactic.trivial'", "description": "A weaker version of `trivial` that tries to solve the goal using a canonical proof of `true` or the\n`reflexivity` tactic (unfolding only `reducible` constants, so can fail faster than `trivial`),\nand otherwise tries the `contradiction` tactic."}, {"name": "tactic_doc.tactic.guard_target'", "description": "`guard_target' t` fails if the target of the main goal is not definitionally equal to `t`.\nWe use this tactic for writing tests.\nThe difference with `guard_target` is that this uses definitional equality instead of\nalpha-equivalence."}, {"name": "tactic.interactive.unfold_coes", "description": "Unfold coercion-related definitions"}, {"name": "tactic_doc.tactic.fconstructor", "description": "Similar to `constructor`, but does not reorder goals."}, {"name": "tactic_doc.tactic.classical", "description": " Make every proposition in the context decidable.\n\n`classical!` does this more aggressively, such that even if a decidable instance is already\navailable for a specific proposition, the noncomputable one will be used instead."}, {"name": "tactic.interactive.rotate", "description": "`rotate` moves the first goal to the back. `rotate n` will do this `n` times.\n\nSee also `tactic.interactive.swap`, which moves the `n`th goal to the front."}, {"name": "tactic.interactive.triv", "description": "Tries to solve the goal using a canonical proof of `true` or the `reflexivity` tactic.\nUnlike `trivial` or `trivial'`, does not the `contradiction` tactic."}, {"name": "tactic.interactive.have_field", "description": "`have_field`, used after `refine_struct _` poses `field` as a local constant\nwith the type of the field of the current goal:\n\n```lean\nrefine_struct ({ .. } : semigroup \u03b1),\n{ have_field, ... },\n{ have_field, ... },\n```\nbehaves like\n```lean\nrefine_struct ({ .. } : semigroup \u03b1),\n{ have field := @semigroup.mul, ... },\n{ have field := @semigroup.mul_assoc, ... },\n```"}, {"name": "tactic_doc.tactic.h_generalize", "description": "`h_generalize Hx : e == x` matches on `cast _ e` in the goal and replaces it with\n`x`. It also adds `Hx : e == x` as an assumption. If `cast _ e` appears multiple\ntimes (not necessarily with the same proof), they are all replaced by `x`. `cast`\n`eq.mp`, `eq.mpr`, `eq.subst`, `eq.substr`, `eq.rec` and `eq.rec_on` are all treated\nas casts.\n\n- `h_generalize Hx : e == x with h` adds hypothesis `\u03b1 = \u03b2` with `e : \u03b1, x : \u03b2`;\n- `h_generalize Hx : e == x with _` chooses automatically chooses the name of\n  assumption `\u03b1 = \u03b2`;\n- `h_generalize! Hx : e == x` reverts `Hx`;\n- when `Hx` is omitted, assumption `Hx : e == x` is not added."}, {"name": "tactic.interactive.clear_aux_decl", "description": "`clear_aux_decl` clears every `aux_decl` in the local context for the current goal.\nThis includes the induction hypothesis when using the equation compiler and\n`_let_match` and `_fun_match`.\n\nIt is useful when using a tactic such as `finish`, `simp *` or `subst` that may use these\nauxiliary declarations, and produce an error saying the recursion is not well founded.\n\n```lean\nexample (n m : \u2115) (h\u2081 : n = m) (h\u2082 : \u2203 a : \u2115, a = n \u2227 a = m) : 2 * m = 2 * n :=\nlet \u27e8a, ha\u27e9 := h\u2082 in\nbegin\n  clear_aux_decl, -- subst will fail without this line\n  subst h\u2081\nend\n\nexample (x y : \u2115) (h\u2081 : \u2203 n : \u2115, n * 1 = 2) (h\u2082 : 1 + 1 = 2 \u2192 x * 1 = y) : x = y :=\nlet \u27e8n, hn\u27e9 := h\u2081 in\nbegin\n  clear_aux_decl, -- finish produces an error without this line\n  finish\nend\n```"}, {"name": "tactic.interactive.generalize_hyp", "description": "Like `generalize` but also considers assumptions\nspecified by the user. The user can also specify to\nomit the goal."}, {"name": "tactic.interactive.continue", "description": " Like `try { tac }`, but in the case of failure it continues\nfrom the failure state instead of reverting to the original state."}, {"name": "tactic_doc.tactic.substs", "description": "Multiple `subst`. `substs x y z` is the same as `subst x, subst y, subst z`."}, {"name": "tactic.interactive.apply_field", "description": "`apply_field` functions as `have_field, apply field, clear field`"}, {"name": "tactic.interactive.generalize'", "description": "`generalize' : e = x` replaces all occurrences of `e` in the target with a new hypothesis `x` of\nthe same type.\n\n`generalize' h : e = x` in addition registers the hypothesis `h : e = x`.\n\n`generalize'` is similar to `generalize`. The difference is that `generalize' : e = x` also\nsucceeds when `e` does not occur in the goal. It is similar to `set`, but the resulting hypothesis\n`x` is not a local definition."}, {"name": "tactic_doc.tactic.subst'", "description": "If the expression `q` is a local variable with type `x = t` or `t = x`, where `x` is a local\nconstant, `tactic.interactive.subst' q` substitutes `x` by `t` everywhere in the main goal and\nthen clears `q`.\nIf `q` is another local variable, then we find a local constant with type `q = t` or `t = q` and\nsubstitute `t` for `q`.\n\nLike `tactic.interactive.subst`, but fails with a nicer error message if the substituted variable is\na local definition. It is trickier to fix this in core, since `tactic.is_local_def` is in mathlib."}, {"name": "tactic.interactive.set", "description": "`set a := t with h` is a variant of `let a := t`. It adds the hypothesis `h : a = t` to\nthe local context and replaces `t` with `a` everywhere it can.\n\n`set a := t with \u2190h` will add `h : t = a` instead.\n\n`set! a := t with h` does not do any replacing.\n\n```lean\nexample (x : \u2115) (h : x = 3)  : x + x + x = 9 :=\nbegin\n  set y := x with \u2190h_xy,\n/-\nx : \u2115,\ny : \u2115 := x,\nh_xy : x = y,\nh : y = 3\n\u22a2 y + y + y = 9\n-/\nend\n```"}, {"name": "tactic.interactive.guard_target_mod_implicit", "description": "`guard_target_mod_implicit t` fails if the target of the main goal\nis not definitionally equal to `t` modulo none transparency\n(i.e., unifying the implicit arguments modulo semireducible transparency).\nWe use this tactic for writing tests."}, {"name": "tactic.interactive.change'", "description": "The logic of `change x with y at l` fails when there are dependencies.\n`change'` mimics the behavior of `change`, except in the case of `change x with y at l`.\nIn this case, it will correctly replace occurences of `x` with `y` at all possible hypotheses\nin `l`. As long as `x` and `y` are defeq, it should never fail."}, {"name": "tactic.interactive.id", "description": " `id { tac }` is the same as `tac`, but it is useful for creating a block scope without\nrequiring the goal to be solved at the end like `{ tac }`. It can also be used to enclose a\nnon-interactive tactic for patterns like `tac1; id {tac2}` where `tac2` is non-interactive."}, {"name": "tactic_doc.tactic.inhabit", "description": "`inhabit \u03b1` tries to derive a `nonempty \u03b1` instance and then upgrades this\nto an `inhabited \u03b1` instance.\nIf the target is a `Prop`, this is done constructively;\notherwise, it uses `classical.choice`.\n\n```lean\nexample (\u03b1) [nonempty \u03b1] : \u2203 a : \u03b1, true :=\nbegin\n  inhabit \u03b1,\n  existsi default,\n  trivial\nend\n```"}, {"name": "tactic.interactive.generalize_a_aux", "description": ""}, {"name": "tactic.interactive.refine_struct", "description": "`refine_struct { .. }` acts like `refine` but works only with structure instance\nliterals. It creates a goal for each missing field and tags it with the name of the\nfield so that `have_field` can be used to generically refer to the field currently\nbeing refined.\n\nAs an example, we can use `refine_struct` to automate the construction of semigroup\ninstances:\n\n```lean\nrefine_struct ( { .. } : semigroup \u03b1 ),\n-- case semigroup, mul\n-- \u03b1 : Type u,\n-- \u22a2 \u03b1 \u2192 \u03b1 \u2192 \u03b1\n\n-- case semigroup, mul_assoc\n-- \u03b1 : Type u,\n-- \u22a2 \u2200 (a b c : \u03b1), a * b * c = a * (b * c)\n```\n\n`have_field`, used after `refine_struct _`, poses `field` as a local constant\nwith the type of the field of the current goal:\n\n```lean\nrefine_struct ({ .. } : semigroup \u03b1),\n{ have_field, ... },\n{ have_field, ... },\n```\nbehaves like\n```lean\nrefine_struct ({ .. } : semigroup \u03b1),\n{ have field := @semigroup.mul, ... },\n{ have field := @semigroup.mul_assoc, ... },\n```"}, {"name": "tactic.interactive.guard_hyp_strict", "description": "`guard_hyp_strict h : t` fails if the hypothesis `h` does not have type syntactically equal\nto `t`.\nWe use this tactic for writing tests."}, {"name": "tactic.interactive.unfold_aux", "description": "Unfold auxiliary definitions associated with the current declaration."}, {"name": "tactic.interactive.revert_target_deps", "description": "Reverts all local constants on which the target depends (recursively)."}, {"name": "tactic.interactive.guard_hyp_nums", "description": "Tests that there are `n` hypotheses in the current context."}, {"name": "tactic.interactive.try_for", "description": " `try_for n { tac }` executes `tac` for `n` ticks, otherwise uses `sorry` to close the goal.\nNever fails. Useful for debugging."}, {"name": "tactic_doc.tactic.clear_", "description": "Clear all hypotheses starting with `_`, like `_match` and `_let_match`."}, {"name": "tactic.interactive.work_on_goal", "description": "`work_on_goal n { tac }` creates a block scope for the `n`-goal,\nand does not require that the goal be solved at the end\n(any remaining subgoals are inserted back into the list of goals).\n\nTypically usage might look like:\n````\nintros,\nsimp,\napply lemma_1,\nwork_on_goal 3\n{ dsimp,\n  simp },\nrefl\n````\n\nSee also `id { tac }`, which is equivalent to `work_on_goal 1 { tac }`."}, {"name": "tactic_doc.tactic.replace", "description": "Acts like `have`, but removes a hypothesis with the same name as\nthis one. For example if the state is `h : p \u22a2 goal` and `f : p \u2192 q`,\nthen after `replace h := f h` the goal will be `h : q \u22a2 goal`,\nwhere `have h := f h` would result in the state `h : p, h : q \u22a2 goal`.\nThis can be used to simulate the `specialize` and `apply at` tactics\nof Coq."}, {"name": "tactic.interactive.subst'", "description": "If the expression `q` is a local variable with type `x = t` or `t = x`, where `x` is a local\nconstant, `tactic.interactive.subst' q` substitutes `x` by `t` everywhere in the main goal and\nthen clears `q`.\nIf `q` is another local variable, then we find a local constant with type `q = t` or `t = q` and\nsubstitute `t` for `q`.\n\nLike `tactic.interactive.subst`, but fails with a nicer error message if the substituted variable is\na local definition. It is trickier to fix this in core, since `tactic.is_local_def` is in mathlib."}, {"name": "tactic.interactive.substs", "description": "Multiple `subst`. `substs x y z` is the same as `subst x, subst y, subst z`."}, {"name": "tactic_doc.tactic.clear_except", "description": "`clear_except h\u2080 h\u2081` deletes all the assumptions it can except for `h\u2080` and `h\u2081`."}, {"name": "tactic.interactive.collect_struct'", "description": ""}, {"name": "tactic_doc.tactic.rotate", "description": "`rotate` moves the first goal to the back. `rotate n` will do this `n` times.\n\nSee also `tactic.interactive.swap`, which moves the `n`th goal to the front."}, {"name": "tactic.interactive.compact_decl_aux", "description": ""}, {"name": "tactic.interactive.loc.get_local_uniq_names", "description": ""}, {"name": "tactic.interactive.inhabit", "description": "`inhabit \u03b1` tries to derive a `nonempty \u03b1` instance and then upgrades this\nto an `inhabited \u03b1` instance.\nIf the target is a `Prop`, this is done constructively;\notherwise, it uses `classical.choice`.\n\n```lean\nexample (\u03b1) [nonempty \u03b1] : \u2203 a : \u03b1, true :=\nbegin\n  inhabit \u03b1,\n  existsi default,\n  trivial\nend\n```"}, {"name": "tactic_doc.tactic.refine_struct", "description": "`refine_struct { .. }` acts like `refine` but works only with structure instance\nliterals. It creates a goal for each missing field and tags it with the name of the\nfield so that `have_field` can be used to generically refer to the field currently\nbeing refined.\n\nAs an example, we can use `refine_struct` to automate the construction of semigroup\ninstances:\n\n```lean\nrefine_struct ( { .. } : semigroup \u03b1 ),\n-- case semigroup, mul\n-- \u03b1 : Type u,\n-- \u22a2 \u03b1 \u2192 \u03b1 \u2192 \u03b1\n\n-- case semigroup, mul_assoc\n-- \u03b1 : Type u,\n-- \u22a2 \u2200 (a b c : \u03b1), a * b * c = a * (b * c)\n```\n\n`have_field`, used after `refine_struct _`, poses `field` as a local constant\nwith the type of the field of the current goal:\n\n```lean\nrefine_struct ({ .. } : semigroup \u03b1),\n{ have_field, ... },\n{ have_field, ... },\n```\nbehaves like\n```lean\nrefine_struct ({ .. } : semigroup \u03b1),\n{ have field := @semigroup.mul, ... },\n{ have field := @semigroup.mul_assoc, ... },\n```"}, {"name": "tactic.interactive.use", "description": "Similar to `existsi`. `use x` will instantiate the first term of an `\u2203` or `\u03a3` goal with `x`. It\nwill then try to close the new goal using `trivial'`, or try to simplify it by applying\n`exists_prop`. Unlike `existsi`, `x` is elaborated with respect to the expected type.\n`use` will alternatively take a list of terms `[x0, ..., xn]`.\n\n`use` will work with constructors of arbitrary inductive types.\n\nExamples:\n```lean\nexample (\u03b1 : Type) : \u2203 S : set \u03b1, S = S :=\nby use \u2205\n\nexample : \u2203 x : \u2124, x = x :=\nby use 42\n\nexample : \u2203 n > 0, n = n :=\nbegin\n  use 1,\n  -- goal is now 1 > 0 \u2227 1 = 1, whereas it would be \u2203 (H : 1 > 0), 1 = 1 after existsi 1.\n  exact \u27e8zero_lt_one, rfl\u27e9,\nend\n\nexample : \u2203 a b c : \u2124, a + b + c = 6 :=\nby use [1, 2, 3]\n\nexample : \u2203 p : \u2124 \u00d7 \u2124, p.1 = 1 :=\nby use \u27e81, 42\u27e9\n\nexample : \u03a3 x y : \u2124, (\u2124 \u00d7 \u2124) \u00d7 \u2124 :=\nby use [1, 2, 3, 4, 5]\n\ninductive foo\n| mk : \u2115 \u2192 bool \u00d7 \u2115 \u2192 \u2115 \u2192 foo\n\nexample : foo :=\nby use [100, tt, 4, 3]\n```"}, {"name": "tactic_doc.tactic.triv", "description": "Tries to solve the goal using a canonical proof of `true` or the `reflexivity` tactic.\nUnlike `trivial` or `trivial'`, does not the `contradiction` tactic."}, {"name": "tactic.interactive.success_if_fail_with_msg", "description": " `success_if_fail_with_msg { tac } msg` succeeds if the interactive tactic `tac` fails with\nerror message `msg` (for test writing purposes)."}, {"name": "tactic_doc.tactic.use", "description": "Similar to `existsi`. `use x` will instantiate the first term of an `\u2203` or `\u03a3` goal with `x`. It\nwill then try to close the new goal using `trivial'`, or try to simplify it by applying\n`exists_prop`. Unlike `existsi`, `x` is elaborated with respect to the expected type.\n`use` will alternatively take a list of terms `[x0, ..., xn]`.\n\n`use` will work with constructors of arbitrary inductive types.\n\nExamples:\n```lean\nexample (\u03b1 : Type) : \u2203 S : set \u03b1, S = S :=\nby use \u2205\n\nexample : \u2203 x : \u2124, x = x :=\nby use 42\n\nexample : \u2203 n > 0, n = n :=\nbegin\n  use 1,\n  -- goal is now 1 > 0 \u2227 1 = 1, whereas it would be \u2203 (H : 1 > 0), 1 = 1 after existsi 1.\n  exact \u27e8zero_lt_one, rfl\u27e9,\nend\n\nexample : \u2203 a b c : \u2124, a + b + c = 6 :=\nby use [1, 2, 3]\n\nexample : \u2203 p : \u2124 \u00d7 \u2124, p.1 = 1 :=\nby use \u27e81, 42\u27e9\n\nexample : \u03a3 x y : \u2124, (\u2124 \u00d7 \u2124) \u00d7 \u2124 :=\nby use [1, 2, 3, 4, 5]\n\ninductive foo\n| mk : \u2115 \u2192 bool \u00d7 \u2115 \u2192 \u2115 \u2192 foo\n\nexample : foo :=\nby use [100, tt, 4, 3]\n```"}, {"name": "tactic.interactive.trivial'", "description": "A weaker version of `trivial` that tries to solve the goal using a canonical proof of `true` or the\n`reflexivity` tactic (unfolding only `reducible` constants, so can fail faster than `trivial`),\nand otherwise tries the `contradiction` tactic."}, {"name": "tactic.interactive.guard_target'", "description": "`guard_target' t` fails if the target of the main goal is not definitionally equal to `t`.\nWe use this tactic for writing tests.\nThe difference with `guard_target` is that this uses definitional equality instead of\nalpha-equivalence."}, {"name": "tactic.interactive.replace", "description": "Acts like `have`, but removes a hypothesis with the same name as\nthis one. For example if the state is `h : p \u22a2 goal` and `f : p \u2192 q`,\nthen after `replace h := f h` the goal will be `h : q \u22a2 goal`,\nwhere `have h := f h` would result in the state `h : p, h : q \u22a2 goal`.\nThis can be used to simulate the `specialize` and `apply at` tactics\nof Coq."}, {"name": "tactic.interactive.clear_", "description": "Clear all hypotheses starting with `_`, like `_match` and `_let_match`."}, {"name": "tactic.interactive.return_cast", "description": ""}, {"name": "tactic_doc.tactic.clear_aux_decl", "description": "`clear_aux_decl` clears every `aux_decl` in the local context for the current goal.\nThis includes the induction hypothesis when using the equation compiler and\n`_let_match` and `_fun_match`.\n\nIt is useful when using a tactic such as `finish`, `simp *` or `subst` that may use these\nauxiliary declarations, and produce an error saying the recursion is not well founded.\n\n```lean\nexample (n m : \u2115) (h\u2081 : n = m) (h\u2082 : \u2203 a : \u2115, a = n \u2227 a = m) : 2 * m = 2 * n :=\nlet \u27e8a, ha\u27e9 := h\u2082 in\nbegin\n  clear_aux_decl, -- subst will fail without this line\n  subst h\u2081\nend\n\nexample (x y : \u2115) (h\u2081 : \u2203 n : \u2115, n * 1 = 2) (h\u2082 : 1 + 1 = 2 \u2192 x * 1 = y) : x = y :=\nlet \u27e8n, hn\u27e9 := h\u2081 in\nbegin\n  clear_aux_decl, -- finish produces an error without this line\n  finish\nend\n```"}, {"name": "tactic.interactive.guard_expr_strict", "description": "`guard_expr_strict t := e` fails if the expr `t` is not equal to `e`. By contrast\nto `guard_expr`, this tests strict (syntactic) equality.\nWe use this tactic for writing tests."}, {"name": "tactic.interactive.refine_recursively", "description": ""}, {"name": "tactic.interactive.list_cast_of", "description": ""}, {"name": "tactic.interactive.revert_deps", "description": " `revert_deps n\u2081 n\u2082 ...` reverts all the hypotheses that depend on one of `n\u2081, n\u2082, ...`\nIt does not revert `n\u2081, n\u2082, ...` themselves (unless they depend on another `n\u1d62`)."}, {"name": "tactic.interactive.refine_one", "description": ""}, {"name": "tactic.interactive.swap", "description": "`swap n` will move the `n`th goal to the front.\n`swap` defaults to `swap 2`, and so interchanges the first and second goals.\n\nSee also `tactic.interactive.rotate`, which moves the first `n` goals to the back."}, {"name": "tactic_doc.tactic.revert_deps", "description": " `revert_deps n\u2081 n\u2082 ...` reverts all the hypotheses that depend on one of `n\u2081, n\u2082, ...`\nIt does not revert `n\u2081, n\u2082, ...` themselves (unless they depend on another `n\u1d62`)."}, {"name": "tactic.interactive.clean", "description": "Remove identity functions from a term. These are normally\nautomatically generated with terms like `show t, from p` or\n`(p : t)` which translate to some variant on `@id t p` in\norder to retain the type."}, {"name": "tactic_doc.tactic.swap", "description": "`swap n` will move the `n`th goal to the front.\n`swap` defaults to `swap 2`, and so interchanges the first and second goals.\n\nSee also `tactic.interactive.rotate`, which moves the first `n` goals to the back."}, {"name": "tactic.interactive.guard_expr_eq'", "description": "Tests whether `t` is definitionally equal to `p`. The difference with `guard_expr_eq` is that\n this uses definitional equality instead of alpha-equivalence."}, {"name": "tactic_doc.tactic.set", "description": "`set a := t with h` is a variant of `let a := t`. It adds the hypothesis `h : a = t` to\nthe local context and replaces `t` with `a` everywhere it can.\n\n`set a := t with \u2190h` will add `h : t = a` instead.\n\n`set! a := t with h` does not do any replacing.\n\n```lean\nexample (x : \u2115) (h : x = 3)  : x + x + x = 9 :=\nbegin\n  set y := x with \u2190h_xy,\n/-\nx : \u2115,\ny : \u2115 := x,\nh_xy : x = y,\nh : y = 3\n\u22a2 y + y + y = 9\n-/\nend\n```"}, {"name": "tactic_doc.tactic.apply_rules", "description": "`apply_rules hs with attrs n` applies the list of lemmas `hs` and all lemmas tagged with an\nattribute from the list `attrs`, as well as the `assumption` tactic on the\nfirst goal and the resulting subgoals, iteratively, at most `n` times.\n`n` is optional, equal to 50 by default.\nYou can pass an `apply_cfg` option argument as `apply_rules hs n opt`.\n(A typical usage would be with `apply_rules hs n { md := reducible })`,\nwhich asks `apply_rules` to not unfold `semireducible` definitions (i.e. most)\nwhen checking if a lemma matches the goal.)\n\nFor instance:\n\n```lean\n@[user_attribute]\nmeta def mono_rules : user_attribute :=\n{ name := `mono_rules,\n  descr := \"lemmas usable to prove monotonicity\" }\n\nattribute [mono_rules] add_le_add mul_le_mul_of_nonneg_right\n\nlemma my_test {a b c d e : real} (h1 : a \u2264 b) (h2 : c \u2264 d) (h3 : 0 \u2264 e) :\na + c * e + a + c + 0 \u2264 b + d * e + b + d + e :=\n-- any of the following lines solve the goal:\nadd_le_add (add_le_add (add_le_add (add_le_add h1 (mul_le_mul_of_nonneg_right h2 h3)) h1 ) h2) h3\nby apply_rules [add_le_add, mul_le_mul_of_nonneg_right]\nby apply_rules with mono_rules\nby apply_rules [add_le_add] with mono_rules\n```"}, {"name": "tactic.interactive.match_hyp", "description": "`match_hyp h : t` fails if the hypothesis `h` does not match the type `t` (which may be a pattern).\nWe use this tactic for writing tests."}, {"name": "tactic.interactive.extract_goal", "description": "Format the current goal as a stand-alone example. Useful for testing tactics\nor creating [minimal working examples](https://leanprover-community.github.io/mwe.html).\n\n* `extract_goal`: formats the statement as an `example` declaration\n* `extract_goal my_decl`: formats the statement as a `lemma` or `def` declaration\n  called `my_decl`\n* `extract_goal with i j k:` only use local constants `i`, `j`, `k` in the declaration\n\nExamples:\n\n```lean\nexample (i j k : \u2115) (h\u2080 : i \u2264 j) (h\u2081 : j \u2264 k) : i \u2264 k :=\nbegin\n  extract_goal,\n     -- prints:\n     -- example (i j k : \u2115) (h\u2080 : i \u2264 j) (h\u2081 : j \u2264 k) : i \u2264 k :=\n     -- begin\n     --   admit,\n     -- end\n  extract_goal my_lemma\n     -- prints:\n     -- lemma my_lemma (i j k : \u2115) (h\u2080 : i \u2264 j) (h\u2081 : j \u2264 k) : i \u2264 k :=\n     -- begin\n     --   admit,\n     -- end\nend\n\nexample {i j k x y z w p q r m n : \u2115} (h\u2080 : i \u2264 j) (h\u2081 : j \u2264 k) (h\u2081 : k \u2264 p) (h\u2081 : p \u2264 q) : i \u2264 k :=\nbegin\n  extract_goal my_lemma,\n    -- prints:\n    -- lemma my_lemma {i j k x y z w p q r m n : \u2115}\n    --   (h\u2080 : i \u2264 j)\n    --   (h\u2081 : j \u2264 k)\n    --   (h\u2081 : k \u2264 p)\n    --   (h\u2081 : p \u2264 q) :\n    --   i \u2264 k :=\n    -- begin\n    --   admit,\n    -- end\n\n  extract_goal my_lemma with i j k\n    -- prints:\n    -- lemma my_lemma {p i j k : \u2115}\n    --   (h\u2080 : i \u2264 j)\n    --   (h\u2081 : j \u2264 k)\n    --   (h\u2081 : k \u2264 p) :\n    --   i \u2264 k :=\n    -- begin\n    --   admit,\n    -- end\nend\n\nexample : true :=\nbegin\n  let n := 0,\n  have m : \u2115, admit,\n  have k : fin n, admit,\n  have : n + m + k.1 = 0, extract_goal,\n    -- prints:\n    -- example (m : \u2115)  : let n : \u2115 := 0 in \u2200 (k : fin n), n + m + k.val = 0 :=\n    -- begin\n    --   intros n k,\n    --   admit,\n    -- end\nend\n```"}, {"name": "tactic.interactive.clear_value", "description": " `clear_value n\u2081 n\u2082 ...` clears the bodies of the local definitions `n\u2081, n\u2082 ...`, changing them\ninto regular hypotheses. A hypothesis `n : \u03b1 := t` is changed to `n : \u03b1`."}, {"name": "tactic.interactive.field", "description": ""}, {"name": "tactic.interactive.revert_after", "description": "`revert_after n` reverts all the hypotheses after `n`."}, {"name": "tactic.interactive.clear_except", "description": "`clear_except h\u2080 h\u2081` deletes all the assumptions it can except for `h\u2080` and `h\u2081`."}, {"name": "tactic.interactive.guard_hyp_mod_implicit", "description": "`guard_hyp_mod_implicit h : t` fails if the type of the hypothesis `h`\nis not definitionally equal to `t` modulo none transparency\n(i.e., unifying the implicit arguments modulo semireducible transparency).\nWe use this tactic for writing tests."}, {"name": "tactic.interactive.guard_hyp'", "description": "`guard_hyp' h : t` fails if the hypothesis `h` does not have type `t`.\nWe use this tactic for writing tests.\nFixes `guard_hyp` by instantiating meta variables"}, {"name": "tactic.interactive.list_cast_of_aux", "description": ""}, {"name": "tactic.interactive.get_current_field", "description": "Get the field of the current goal."}, {"name": "tactic.interactive.apply_rules", "description": "`apply_rules hs with attrs n` applies the list of lemmas `hs` and all lemmas tagged with an\nattribute from the list `attrs`, as well as the `assumption` tactic on the\nfirst goal and the resulting subgoals, iteratively, at most `n` times.\n`n` is optional, equal to 50 by default.\nYou can pass an `apply_cfg` option argument as `apply_rules hs n opt`.\n(A typical usage would be with `apply_rules hs n { md := reducible })`,\nwhich asks `apply_rules` to not unfold `semireducible` definitions (i.e. most)\nwhen checking if a lemma matches the goal.)\n\nFor instance:\n\n```lean\n@[user_attribute]\nmeta def mono_rules : user_attribute :=\n{ name := `mono_rules,\n  descr := \"lemmas usable to prove monotonicity\" }\n\nattribute [mono_rules] add_le_add mul_le_mul_of_nonneg_right\n\nlemma my_test {a b c d e : real} (h1 : a \u2264 b) (h2 : c \u2264 d) (h3 : 0 \u2264 e) :\na + c * e + a + c + 0 \u2264 b + d * e + b + d + e :=\n-- any of the following lines solve the goal:\nadd_le_add (add_le_add (add_le_add (add_le_add h1 (mul_le_mul_of_nonneg_right h2 h3)) h1 ) h2) h3\nby apply_rules [add_le_add, mul_le_mul_of_nonneg_right]\nby apply_rules with mono_rules\nby apply_rules [add_le_add] with mono_rules\n```"}, {"name": "tactic.interactive.h_generalize", "description": "`h_generalize Hx : e == x` matches on `cast _ e` in the goal and replaces it with\n`x`. It also adds `Hx : e == x` as an assumption. If `cast _ e` appears multiple\ntimes (not necessarily with the same proof), they are all replaced by `x`. `cast`\n`eq.mp`, `eq.mpr`, `eq.subst`, `eq.substr`, `eq.rec` and `eq.rec_on` are all treated\nas casts.\n\n- `h_generalize Hx : e == x with h` adds hypothesis `\u03b1 = \u03b2` with `e : \u03b1, x : \u03b2`;\n- `h_generalize Hx : e == x with _` chooses automatically chooses the name of\n  assumption `\u03b1 = \u03b2`;\n- `h_generalize! Hx : e == x` reverts `Hx`;\n- when `Hx` is omitted, assumption `Hx : e == x` is not added."}, {"name": "tactic_doc.tactic.extract_goal", "description": "Format the current goal as a stand-alone example. Useful for testing tactics\nor creating [minimal working examples](https://leanprover-community.github.io/mwe.html).\n\n* `extract_goal`: formats the statement as an `example` declaration\n* `extract_goal my_decl`: formats the statement as a `lemma` or `def` declaration\n  called `my_decl`\n* `extract_goal with i j k:` only use local constants `i`, `j`, `k` in the declaration\n\nExamples:\n\n```lean\nexample (i j k : \u2115) (h\u2080 : i \u2264 j) (h\u2081 : j \u2264 k) : i \u2264 k :=\nbegin\n  extract_goal,\n     -- prints:\n     -- example (i j k : \u2115) (h\u2080 : i \u2264 j) (h\u2081 : j \u2264 k) : i \u2264 k :=\n     -- begin\n     --   admit,\n     -- end\n  extract_goal my_lemma\n     -- prints:\n     -- lemma my_lemma (i j k : \u2115) (h\u2080 : i \u2264 j) (h\u2081 : j \u2264 k) : i \u2264 k :=\n     -- begin\n     --   admit,\n     -- end\nend\n\nexample {i j k x y z w p q r m n : \u2115} (h\u2080 : i \u2264 j) (h\u2081 : j \u2264 k) (h\u2081 : k \u2264 p) (h\u2081 : p \u2264 q) : i \u2264 k :=\nbegin\n  extract_goal my_lemma,\n    -- prints:\n    -- lemma my_lemma {i j k x y z w p q r m n : \u2115}\n    --   (h\u2080 : i \u2264 j)\n    --   (h\u2081 : j \u2264 k)\n    --   (h\u2081 : k \u2264 p)\n    --   (h\u2081 : p \u2264 q) :\n    --   i \u2264 k :=\n    -- begin\n    --   admit,\n    -- end\n\n  extract_goal my_lemma with i j k\n    -- prints:\n    -- lemma my_lemma {p i j k : \u2115}\n    --   (h\u2080 : i \u2264 j)\n    --   (h\u2081 : j \u2264 k)\n    --   (h\u2081 : k \u2264 p) :\n    --   i \u2264 k :=\n    -- begin\n    --   admit,\n    -- end\nend\n\nexample : true :=\nbegin\n  let n := 0,\n  have m : \u2115, admit,\n  have k : fin n, admit,\n  have : n + m + k.1 = 0, extract_goal,\n    -- prints:\n    -- example (m : \u2115)  : let n : \u2115 := 0 in \u2200 (k : fin n), n + m + k.val = 0 :=\n    -- begin\n    --   intros n k,\n    --   admit,\n    -- end\nend\n```"}, {"name": "tactic.interactive.source_fields", "description": ""}, {"name": "tactic.interactive.fconstructor", "description": "Similar to `constructor`, but does not reorder goals."}, {"name": "tactic.interactive.unfold_wf", "description": "Unfold `has_well_founded.r`, `sizeof` and other such definitions."}, {"name": "tactic_doc.tactic.revert_after", "description": "`revert_after n` reverts all the hypotheses after `n`."}, {"name": "tactic.interactive.classical", "description": " Make every proposition in the context decidable.\n\n`classical!` does this more aggressively, such that even if a decidable instance is already\navailable for a specific proposition, the noncomputable one will be used instead."}, {"name": "tactic_doc.tactic.unfold_coes", "description": "Unfold coercion-related definitions"}, {"name": "tactic.interactive.collect_struct", "description": ""}, {"name": "tactic_doc.tactic.change'", "description": "The logic of `change x with y at l` fails when there are dependencies.\n`change'` mimics the behavior of `change`, except in the case of `change x with y at l`.\nIn this case, it will correctly replace occurences of `x` with `y` at all possible hypotheses\nin `l`. As long as `x` and `y` are defeq, it should never fail."}, {"name": "tactic_doc.tactic.clear_value", "description": " `clear_value n\u2081 n\u2082 ...` clears the bodies of the local definitions `n\u2081, n\u2082 ...`, changing them\ninto regular hypotheses. A hypothesis `n : \u03b1 := t` is changed to `n : \u03b1`."}, {"name": "tactic.interactive.compact_decl", "description": "go from (x\u2080 : t\u2080) (x\u2081 : t\u2080) (x\u2082 : t\u2080) to (x\u2080 x\u2081 x\u2082 : t\u2080)"}, {"name": "function.surjective.monoid", "description": " A type endowed with `1` and `*` is a monoid,\nif it admits a surjective map that preserves `1` and `*` to a monoid.\nSee note [reducible non-instances]."}, {"name": "function.injective.left_cancel_monoid", "description": " A type endowed with `1` and `*` is a left cancel monoid,\nif it admits an injective map that preserves `1` and `*` to a left cancel monoid.\nSee note [reducible non-instances]."}, {"name": "function.injective.add_comm_monoid", "description": "A type endowed with `0` and `+` is an additive commutative monoid,\nif it admits an injective map that preserves `0` and `+` to an additive commutative monoid."}, {"name": "function.injective.subtraction_monoid", "description": "A type endowed with `0`, `+`, unary `-`, and binary `-` is a `subtraction_monoid`\nif it admits an injective map that preserves `0`, `+`, unary `-`, and binary `-` to\na `subtraction_monoid`.\nThis version takes custom `nsmul` and `zsmul` as `[has_smul \u2115 M\u2081]` and\n`[has_smul \u2124 M\u2081]` arguments."}, {"name": "function.injective.add_group_with_one", "description": " A type endowed with `0`, `1` and `+` is an additive group with one,\nif it admits an injective map that preserves `0`, `1` and `+` to an additive group with one.\nSee note [reducible non-instances]."}, {"name": "function.surjective.has_involutive_inv", "description": " A type has an involutive inversion if it admits a surjective map that preserves `\u207b\u00b9` to a type\nwhich has an involutive inversion."}, {"name": "function.injective.add_cancel_monoid", "description": "A type endowed with `0` and `+` is an additive left cancel monoid,\nif it admits an injective map that preserves `0` and `+` to an additive left cancel monoid."}, {"name": "function.injective.add_comm_semigroup", "description": "A type endowed with `+` is an additive commutative semigroup,\nif it admits an injective map that preserves `+` to an additive commutative semigroup."}, {"name": "function.surjective.add_monoid", "description": "A type endowed with `0` and `+` is an additive monoid,\nif it admits a surjective map that preserves `0` and `+` to an additive monoid.\nThis version takes a custom `nsmul` as a `[has_smul \u2115 M\u2082]` argument."}, {"name": "function.surjective.add_monoid_with_one", "description": " A type endowed with `0`, `1` and `+` is an additive monoid with one,\nif it admits a surjective map that preserves `0`, `1` and `*` from an additive monoid with one.\nSee note [reducible non-instances]."}, {"name": "function.injective.add_left_cancel_monoid", "description": "A type endowed with `0` and `+` is an additive left cancel monoid,\nif it admits an injective map that preserves `0` and `+` to an additive left cancel monoid."}, {"name": "function.injective.add_monoid_with_one", "description": " A type endowed with `0`, `1` and `+` is an additive monoid with one,\nif it admits an injective map that preserves `0`, `1` and `+` to an additive monoid with one.\nSee note [reducible non-instances]."}, {"name": "function.injective.has_involutive_inv", "description": " A type has an involutive inversion if it admits a surjective map that preserves `\u207b\u00b9` to a type\nwhich has an involutive inversion."}, {"name": "function.injective.division_monoid", "description": " A type endowed with `1`, `*`, `\u207b\u00b9`, and `/` is a `division_monoid`\nif it admits an injective map that preserves `1`, `*`, `\u207b\u00b9`, and `/` to a `division_monoid`."}, {"name": "function.surjective.group", "description": " A type endowed with `1`, `*` and `\u207b\u00b9` is a group,\nif it admits a surjective map that preserves `1`, `*` and `\u207b\u00b9` to a group.\nSee note [reducible non-instances]."}, {"name": "function.injective.add_monoid", "description": "A type endowed with `0` and `+` is an additive monoid,\nif it admits an injective map that preserves `0` and `+` to an additive monoid.\nThis version takes a custom `nsmul` as a `[has_smul \u2115 M\u2081]` argument."}, {"name": "function.surjective.add_group", "description": "A type endowed with `0` and `+` is an additive group,\nif it admits a surjective map that preserves `0` and `+` to an additive group."}, {"name": "function.injective.add_zero_class", "description": "A type endowed with `0` and `+` is an add_zero_class,\nif it admits an injective map that preserves `0` and `+` to an add_zero_class."}, {"name": "function.injective.add_cancel_comm_monoid", "description": "A type endowed with `0` and `+` is an additive cancel commutative monoid,\nif it admits an injective map that preserves `0` and `+` to an additive cancel commutative monoid."}, {"name": "function.surjective.comm_group", "description": " A type endowed with `1`, `*`, `\u207b\u00b9`, and `/` is a commutative group,\nif it admits a surjective map that preserves `1`, `*`, `\u207b\u00b9`, and `/` from a commutative group.\nSee note [reducible non-instances]."}, {"name": "function.surjective.add_semigroup", "description": "A type endowed with `+` is an additive semigroup,\nif it admits a surjective map that preserves `+` from an additive semigroup."}, {"name": "function.surjective.semigroup", "description": " A type endowed with `*` is a semigroup,\nif it admits a surjective map that preserves `*` from a semigroup.\nSee note [reducible non-instances]."}, {"name": "function.injective.comm_group", "description": " A type endowed with `1`, `*` and `\u207b\u00b9` is a commutative group,\nif it admits an injective map that preserves `1`, `*` and `\u207b\u00b9` to a commutative group.\nSee note [reducible non-instances]."}, {"name": "function.injective.has_involutive_neg", "description": "A type has an involutive negation if it admits a surjective map that\npreserves `\u207b\u00b9` to a type which has an involutive inversion."}, {"name": "function.injective.division_comm_monoid", "description": " A type endowed with `1`, `*`, `\u207b\u00b9`, and `/` is a `division_comm_monoid`\nif it admits an injective map that preserves `1`, `*`, `\u207b\u00b9`, and `/` to a `division_comm_monoid`.\nSee note [reducible non-instances]."}, {"name": "function.injective.right_cancel_monoid", "description": " A type endowed with `1` and `*` is a right cancel monoid,\nif it admits an injective map that preserves `1` and `*` to a right cancel monoid.\nSee note [reducible non-instances]."}, {"name": "function.injective.group", "description": " A type endowed with `1`, `*` and `\u207b\u00b9` is a group,\nif it admits an injective map that preserves `1`, `*` and `\u207b\u00b9` to a group.\nSee note [reducible non-instances]."}, {"name": "function.injective.left_cancel_semigroup", "description": " A type endowed with `*` is a left cancel semigroup,\nif it admits an injective map that preserves `*` to a left cancel semigroup.\nSee note [reducible non-instances]."}, {"name": "function.injective.semigroup", "description": " A type endowed with `*` is a semigroup,\nif it admits an injective map that preserves `*` to a semigroup.\nSee note [reducible non-instances]."}, {"name": "function.injective.subtraction_comm_monoid", "description": "A type endowed with `0`, `+`, unary `-`, and binary `-` is a `subtraction_comm_monoid`\nif it admits an injective map that preserves `0`, `+`, unary `-`, and binary `-` to\na `subtraction_comm_monoid`.\nThis version takes custom `nsmul` and `zsmul` as `[has_smul \u2115 M\u2081]` and\n`[has_smul \u2124 M\u2081]` arguments."}, {"name": "function.surjective.add_group_with_one", "description": " A type endowed with `0`, `1`, `+` is an additive group with one,\nif it admits a surjective map that preserves `0`, `1`, and `+` to an additive group with one.\nSee note [reducible non-instances]."}, {"name": "function.surjective.add_comm_group", "description": "A type endowed with `0` and `+` is an additive commutative group,\nif it admits a surjective map that preserves `0` and `+` to an additive commutative group."}, {"name": "function.injective.cancel_monoid", "description": " A type endowed with `1` and `*` is a cancel monoid,\nif it admits an injective map that preserves `1` and `*` to a cancel monoid.\nSee note [reducible non-instances]."}, {"name": "function.injective.comm_semigroup", "description": " A type endowed with `*` is a commutative semigroup,\nif it admits an injective map that preserves `*` to a commutative semigroup.\nSee note [reducible non-instances]."}, {"name": "function.injective.sub_neg_monoid", "description": "A type endowed with `0`, `+`, unary `-`, and binary `-` is a `sub_neg_monoid`\nif it admits an injective map that preserves `0`, `+`, unary `-`, and binary `-` to\na `sub_neg_monoid`.\nThis version takes custom `nsmul` and `zsmul` as `[has_smul \u2115 M\u2081]` and\n`[has_smul \u2124 M\u2081]` arguments."}, {"name": "function.surjective.div_inv_monoid", "description": " A type endowed with `1`, `*`, `\u207b\u00b9`, and `/` is a `div_inv_monoid`\nif it admits a surjective map that preserves `1`, `*`, `\u207b\u00b9`, and `/` to a `div_inv_monoid`.\nSee note [reducible non-instances]."}, {"name": "function.surjective.mul_one_class", "description": " A type endowed with `1` and `*` is a mul_one_class,\nif it admits a surjective map that preserves `1` and `*` from a mul_one_class.\nSee note [reducible non-instances]."}, {"name": "function.surjective.add_comm_monoid", "description": "A type endowed with `0` and `+` is an additive commutative monoid,\nif it admits a surjective map that preserves `0` and `+` to an additive commutative monoid."}, {"name": "function.injective.add_right_cancel_monoid", "description": "A type endowed with `0` and `+` is an additive left cancel monoid,\nif it admits an injective map that preserves `0` and `+` to an additive left cancel monoid."}, {"name": "function.injective.right_cancel_semigroup", "description": " A type endowed with `*` is a right cancel semigroup,\nif it admits an injective map that preserves `*` to a right cancel semigroup.\nSee note [reducible non-instances]."}, {"name": "function.injective.add_right_cancel_semigroup", "description": "A type endowed with `+` is an additive right cancel semigroup,\nif it admits an injective map that preserves `+` to an additive right cancel semigroup."}, {"name": "function.surjective.sub_neg_monoid", "description": "A type endowed with `0`, `+`, unary `-`, and binary `-` is a `sub_neg_monoid`\nif it admits a surjective map that preserves `0`, `+`, unary `-`, and binary `-` to\na `sub_neg_monoid`."}, {"name": "function.injective.add_comm_group", "description": "A type endowed with `0` and `+` is an additive commutative group,\nif it admits an injective map that preserves `0` and `+` to an additive commutative group."}, {"name": "function.injective.comm_monoid", "description": " A type endowed with `1` and `*` is a commutative monoid,\nif it admits an injective map that preserves `1` and `*` to a commutative monoid.\nSee note [reducible non-instances]."}, {"name": "function.injective.add_group", "description": "A type endowed with `0` and `+` is an additive group,\nif it admits an injective map that preserves `0` and `+` to an additive group."}, {"name": "function.surjective.comm_semigroup", "description": " A type endowed with `*` is a commutative semigroup,\nif it admits a surjective map that preserves `*` from a commutative semigroup.\nSee note [reducible non-instances]."}, {"name": "function.surjective.comm_monoid", "description": " A type endowed with `1` and `*` is a commutative monoid,\nif it admits a surjective map that preserves `1` and `*` from a commutative monoid.\nSee note [reducible non-instances]."}, {"name": "function.surjective.add_comm_semigroup", "description": "A type endowed with `+` is an additive commutative semigroup,\nif it admits a surjective map that preserves `+` from an additive commutative semigroup."}, {"name": "function.surjective.add_zero_class", "description": "A type endowed with `0` and `+` is an add_zero_class,\nif it admits a surjective map that preserves `0` and `+` to an add_zero_class."}, {"name": "function.surjective.has_involutive_neg", "description": "A type has an involutive negation if it admits a surjective map that\npreserves `\u207b\u00b9` to a type which has an involutive inversion."}, {"name": "function.injective.monoid", "description": " A type endowed with `1` and `*` is a monoid,\nif it admits an injective map that preserves `1` and `*` to a monoid.\nSee note [reducible non-instances]."}, {"name": "function.injective.cancel_comm_monoid", "description": " A type endowed with `1` and `*` is a cancel commutative monoid,\nif it admits an injective map that preserves `1` and `*` to a cancel commutative monoid.\nSee note [reducible non-instances]."}, {"name": "function.injective.add_left_cancel_semigroup", "description": "A type endowed with `+` is an additive left cancel semigroup,\nif it admits an injective map that preserves `+` to an additive left cancel semigroup."}, {"name": "function.injective.add_semigroup", "description": "A type endowed with `+` is an additive semigroup,\nif it admits an injective map that preserves `+` to an additive semigroup."}, {"name": "function.injective.div_inv_monoid", "description": " A type endowed with `1`, `*`, `\u207b\u00b9`, and `/` is a `div_inv_monoid`\nif it admits an injective map that preserves `1`, `*`, `\u207b\u00b9`, and `/` to a `div_inv_monoid`.\nSee note [reducible non-instances]."}, {"name": "function.injective.mul_one_class", "description": " A type endowed with `1` and `*` is a mul_one_class,\nif it admits an injective map that preserves `1` and `*` to a mul_one_class.\nSee note [reducible non-instances]."}, {"name": "tactic.exfalso", "description": ""}, {"name": "tactic.contradiction", "description": ""}, {"name": "finset.mem_attach_fin", "description": ""}, {"name": "finset.coe_fin_range", "description": ""}, {"name": "finset.fin_range_card", "description": ""}, {"name": "finset.attach_fin", "description": " Given a finset `s` of `\u2115` contained in `{0,..., n-1}`, the corresponding finset in `fin n`\nis `s.attach_fin h` where `h` is a proof that all elements of `s` are less than `n`."}, {"name": "finset.card_attach_fin", "description": ""}, {"name": "finset.mem_fin_range", "description": ""}, {"name": "finset.fin_range", "description": "`finset.fin_range n` is the finset `{0, 1, ..., n - 1}`, as a `finset (fin n)`."}, {"name": "directed.mono_comp", "description": ""}, {"name": "is_bot_or_exists_lt", "description": ""}, {"name": "order_bot.to_is_directed_ge", "description": ""}, {"name": "semilattice_inf.to_is_directed_ge", "description": ""}, {"name": "is_directed_mono", "description": ""}, {"name": "directed_on_image", "description": ""}, {"name": "monotone.directed_le", "description": ""}, {"name": "directed_on.mono", "description": ""}, {"name": "semilattice_sup.to_is_directed_le", "description": ""}, {"name": "exists_lt_of_directed_ge", "description": ""}, {"name": "order_dual.is_directed_ge", "description": ""}, {"name": "directed_id", "description": ""}, {"name": "directed.extend_bot", "description": ""}, {"name": "is_max.is_top", "description": ""}, {"name": "directed", "description": "A family of elements of \u03b1 is directed (with respect to a relation `\u227c` on \u03b1)\n if there is a member of the family `\u227c`-above any pair in the family."}, {"name": "directed_on_univ", "description": ""}, {"name": "is_top_iff_is_max", "description": ""}, {"name": "directed_id_iff", "description": ""}, {"name": "exists_le_le", "description": ""}, {"name": "exists_lt_of_directed_le", "description": ""}, {"name": "directed_of_sup", "description": "A monotone function on a sup-semilattice is directed."}, {"name": "exists_ge_ge", "description": ""}, {"name": "directed_of", "description": ""}, {"name": "is_min.is_bot", "description": ""}, {"name": "directed_comp", "description": ""}, {"name": "order_top.to_is_directed_le", "description": ""}, {"name": "directed_on", "description": "A subset of \u03b1 is directed if there is an element of the set `\u227c`-above any\n pair of elements in the set."}, {"name": "order_dual.is_directed_le", "description": ""}, {"name": "is_total.to_is_directed", "description": ""}, {"name": "is_top_or_exists_gt", "description": ""}, {"name": "is_directed", "description": " `is_directed \u03b1 r` states that for any elements `a`, `b` there exists an element `c` such that\n`r a c` and `r b c`."}, {"name": "is_directed.directed", "description": " `is_directed \u03b1 r` states that for any elements `a`, `b` there exists an element `c` such that\n`r a c` and `r b c`."}, {"name": "directed_on_univ_iff", "description": ""}, {"name": "directed_of_inf", "description": "An antitone function on an inf-semilattice is directed."}, {"name": "is_bot_iff_is_min", "description": ""}, {"name": "directed_on.directed_coe", "description": "**Alias** of the forward direction of `directed_on_iff_directed`."}, {"name": "directed_on_iff_directed", "description": ""}, {"name": "directed.mono", "description": ""}, {"name": "multiset.range_le", "description": ""}, {"name": "multiset.nodup.add_iff", "description": ""}, {"name": "multiset.nodup.erase", "description": ""}, {"name": "multiset.nodup.filter_map", "description": ""}, {"name": "multiset.count_eq_one_of_mem", "description": ""}, {"name": "multiset.nodup", "description": "`nodup s` means that `s` has no duplicates, i.e. the multiplicity of\n any element is at most 1."}, {"name": "multiset.nodup.of_cons", "description": ""}, {"name": "multiset.nodup.cons", "description": ""}, {"name": "multiset.count_eq_of_nodup", "description": ""}, {"name": "multiset.nodup.of_powerset", "description": "**Alias** of the forward direction of `multiset.nodup_powerset`."}, {"name": "multiset.nodup.powerset_len", "description": ""}, {"name": "multiset.nodup_decidable", "description": ""}, {"name": "multiset.nodup.not_mem_erase", "description": ""}, {"name": "multiset.nodup_of_le", "description": ""}, {"name": "multiset.nodup_iff_pairwise", "description": ""}, {"name": "multiset.nodup_iff_count_le_one", "description": ""}, {"name": "multiset.map_eq_map_of_bij_of_nodup", "description": ""}, {"name": "multiset.nodup_iff_ne_cons_cons", "description": ""}, {"name": "multiset.le_iff_subset", "description": ""}, {"name": "multiset.nodup.powerset", "description": "**Alias** of the reverse direction of `multiset.nodup_powerset`."}, {"name": "multiset.nodup_iff_le", "description": ""}, {"name": "multiset.nodup_powerset", "description": ""}, {"name": "multiset.not_nodup_pair", "description": ""}, {"name": "multiset.coe_nodup", "description": ""}, {"name": "multiset.nodup_cons", "description": ""}, {"name": "multiset.nodup.inter_left", "description": ""}, {"name": "multiset.nodup.erase_eq_filter", "description": ""}, {"name": "multiset.nodup.map", "description": ""}, {"name": "multiset.nodup.of_map", "description": ""}, {"name": "multiset.nodup.not_mem", "description": ""}, {"name": "multiset.nodup.pmap", "description": ""}, {"name": "multiset.nodup_range", "description": ""}, {"name": "multiset.nodup.sigma", "description": ""}, {"name": "multiset.nodup_bind", "description": ""}, {"name": "multiset.nodup_add", "description": ""}, {"name": "multiset.nodup.product", "description": ""}, {"name": "multiset.disjoint_of_nodup_add", "description": ""}, {"name": "multiset.nodup_map_iff_inj_on", "description": ""}, {"name": "multiset.pairwise.forall", "description": ""}, {"name": "multiset.nodup_zero", "description": ""}, {"name": "multiset.nodup_singleton", "description": ""}, {"name": "multiset.nodup_attach", "description": ""}, {"name": "multiset.inj_on_of_nodup_map", "description": ""}, {"name": "multiset.nodup.pairwise", "description": ""}, {"name": "multiset.nodup_union", "description": ""}, {"name": "multiset.nodup.map_on", "description": ""}, {"name": "multiset.nodup.mem_erase_iff", "description": ""}, {"name": "multiset.nodup.filter", "description": ""}, {"name": "multiset.nodup.ext", "description": ""}, {"name": "multiset.mem_sub_of_nodup", "description": ""}, {"name": "multiset.nodup.inter_right", "description": ""}, {"name": "function.injective.exists_ne", "description": " An injective function from a nontrivial type has an argument at\nwhich it does not take a given value."}, {"name": "nontrivial_iff_exists_ne", "description": ""}, {"name": "exists_pair_lt", "description": ""}, {"name": "exists_ne", "description": ""}, {"name": "tactic.nontriviality_by_assumption", "description": "Tries to generate a `nontrivial \u03b1` instance using `nontrivial_of_ne` or `nontrivial_of_lt`\nand local hypotheses."}, {"name": "not_subsingleton", "description": ""}, {"name": "nontrivial_of_ne", "description": ""}, {"name": "nontrivial_iff", "description": ""}, {"name": "nontrivial_psum_unique", "description": "An inhabited type is either nontrivial, or has a unique element."}, {"name": "nontrivial_of_lt", "description": ""}, {"name": "nontrivial_iff_lt", "description": ""}, {"name": "false_of_nontrivial_of_subsingleton", "description": ""}, {"name": "nontrivial_prod_right", "description": ""}, {"name": "decidable.exists_ne", "description": ""}, {"name": "subsingleton.le", "description": ""}, {"name": "subtype.nontrivial_iff_exists_ne", "description": ""}, {"name": "function.nontrivial", "description": ""}, {"name": "nontrivial.to_nonempty", "description": "See Note [lower instance priority]\n\nNote that since this and `nonempty_of_inhabited` are the most \"obvious\" way to find a nonempty\ninstance if no direct instance can be found, we give this a higher priority than the usual `100`."}, {"name": "exists_pair_ne", "description": ""}, {"name": "option.nontrivial", "description": ""}, {"name": "tactic.nontriviality_by_elim", "description": "Tries to generate a `nontrivial \u03b1` instance by performing case analysis on\n`subsingleton_or_nontrivial \u03b1`,\nattempting to discharge the subsingleton branch using lemmas with `@[nontriviality]` attribute,\nincluding `subsingleton.le` and `eq_iff_true_of_subsingleton`."}, {"name": "pi.nontrivial_at", "description": "A pi type is nontrivial if it's nonempty everywhere and nontrivial somewhere."}, {"name": "tactic_doc.tactic.nontriviality", "description": "Attempts to generate a `nontrivial \u03b1` hypothesis.\n\nThe tactic first looks for an instance using `apply_instance`.\n\nIf the goal is an (in)equality, the type `\u03b1` is inferred from the goal.\nOtherwise, the type needs to be specified in the tactic invocation, as `nontriviality \u03b1`.\n\nThe `nontriviality` tactic will first look for strict inequalities amongst the hypotheses,\nand use these to derive the `nontrivial` instance directly.\n\nOtherwise, it will perform a case split on `subsingleton \u03b1 \u2228 nontrivial \u03b1`, and attempt to discharge\nthe `subsingleton` goal using `simp [lemmas] with nontriviality`, where `[lemmas]` is a list of\nadditional `simp` lemmas that can be passed to `nontriviality` using the syntax\n`nontriviality \u03b1 using [lemmas]`.\n\n```lean\nexample {R : Type} [ordered_ring R] {a : R} (h : 0 < a) : 0 < a :=\nbegin\n  nontriviality, -- There is now a `nontrivial R` hypothesis available.\n  assumption,\nend\n```\n\n```lean\nexample {R : Type} [comm_ring R] {r s : R} : r * s = s * r :=\nbegin\n  nontriviality, -- There is now a `nontrivial R` hypothesis available.\n  apply mul_comm,\nend\n```\n\n```lean\nexample {R : Type} [ordered_ring R] {a : R} (h : 0 < a) : (2 : \u2115) \u2223 4 :=\nbegin\n  nontriviality R, -- there is now a `nontrivial R` hypothesis available.\n  dec_trivial\nend\n```\n\n```lean\ndef myeq {\u03b1 : Type} (a b : \u03b1) : Prop := a = b\n\nexample {\u03b1 : Type} (a b : \u03b1) (h : a = b) : myeq a b :=\nbegin\n  success_if_fail { nontriviality \u03b1 }, -- Fails\n  nontriviality \u03b1 using [myeq], -- There is now a `nontrivial \u03b1` hypothesis available\n  assumption\nend\n```"}, {"name": "sort.nontrivial", "description": ""}, {"name": "bool.nontrivial", "description": ""}, {"name": "not_nontrivial_iff_subsingleton", "description": ""}, {"name": "tactic.interactive.nontriviality", "description": "Attempts to generate a `nontrivial \u03b1` hypothesis.\n\nThe tactic first looks for an instance using `apply_instance`.\n\nIf the goal is an (in)equality, the type `\u03b1` is inferred from the goal.\nOtherwise, the type needs to be specified in the tactic invocation, as `nontriviality \u03b1`.\n\nThe `nontriviality` tactic will first look for strict inequalities amongst the hypotheses,\nand use these to derive the `nontrivial` instance directly.\n\nOtherwise, it will perform a case split on `subsingleton \u03b1 \u2228 nontrivial \u03b1`, and attempt to discharge\nthe `subsingleton` goal using `simp [lemmas] with nontriviality`, where `[lemmas]` is a list of\nadditional `simp` lemmas that can be passed to `nontriviality` using the syntax\n`nontriviality \u03b1 using [lemmas]`.\n\n```lean\nexample {R : Type} [ordered_ring R] {a : R} (h : 0 < a) : 0 < a :=\nbegin\n  nontriviality, -- There is now a `nontrivial R` hypothesis available.\n  assumption,\nend\n```\n\n```lean\nexample {R : Type} [comm_ring R] {r s : R} : r * s = s * r :=\nbegin\n  nontriviality, -- There is now a `nontrivial R` hypothesis available.\n  apply mul_comm,\nend\n```\n\n```lean\nexample {R : Type} [ordered_ring R] {a : R} (h : 0 < a) : (2 : \u2115) \u2223 4 :=\nbegin\n  nontriviality R, -- there is now a `nontrivial R` hypothesis available.\n  dec_trivial\nend\n```\n\n```lean\ndef myeq {\u03b1 : Type} (a b : \u03b1) : Prop := a = b\n\nexample {\u03b1 : Type} (a b : \u03b1) (h : a = b) : myeq a b :=\nbegin\n  success_if_fail { nontriviality \u03b1 }, -- Fails\n  nontriviality \u03b1 using [myeq], -- There is now a `nontrivial \u03b1` hypothesis available\n  assumption\nend\n```"}, {"name": "nontrivial_prod_left", "description": ""}, {"name": "simp_attr.nontriviality", "description": "Simp lemmas for `nontriviality` tactic"}, {"name": "not_nontrivial", "description": ""}, {"name": "function.injective.nontrivial", "description": "Pushforward a `nontrivial` instance along an injective function."}, {"name": "nontrivial", "description": " Predicate typeclass for expressing that a type is not reduced to a single element. In rings,\nthis is equivalent to `0 \u2260 1`. In vector spaces, this is equivalent to positive dimension."}, {"name": "nontrivial.exists_pair_ne", "description": " Predicate typeclass for expressing that a type is not reduced to a single element. In rings,\nthis is equivalent to `0 \u2260 1`. In vector spaces, this is equivalent to positive dimension."}, {"name": "subsingleton_iff", "description": ""}, {"name": "subsingleton_or_nontrivial", "description": "A type is either a subsingleton or nontrivial."}, {"name": "function.surjective.nontrivial", "description": "Pullback a `nontrivial` instance along a surjective function."}, {"name": "pi.nontrivial", "description": "As a convenience, provide an instance automatically if `(f default)` is nontrivial.\n\nIf a different index has the non-trivial type, then use `haveI := nontrivial_at that_index`."}, {"name": "list.foldr_permutations_aux2", "description": ""}, {"name": "list.mem_permutations_aux2", "description": ""}, {"name": "list.map_permutations_aux", "description": ""}, {"name": "list.map_permutations'", "description": ""}, {"name": "list.map_permutations_aux2", "description": "The `f` argument to `permutations_aux2` when `r = []` can be eliminated."}, {"name": "list.mem_foldr_permutations_aux2", "description": ""}, {"name": "list.map_map_permutations'_aux", "description": ""}, {"name": "list.permutations_aux2_snd_eq", "description": " An expository lemma to show how all of `ts`, `r`, and `f` can be eliminated from\n`permutations_aux2`.\n\n`(permutations_aux2 t [] [] ys id).2`, which appears on the RHS, is a list whose elements are\nproduced by inserting `t` into every non-terminal position of `ys` in order. As an example:\n```lean\n#eval permutations_aux2 1 [] [] [2, 3, 4] id\n-- [[1, 2, 3, 4], [2, 1, 3, 4], [2, 3, 1, 4]]\n```"}, {"name": "list.map_permutations_aux2'", "description": ""}, {"name": "list.permutations_aux2_comp_append", "description": "The `ts` argument to `permutations_aux2` can be folded into the `f` argument."}, {"name": "list.permutations_aux_append", "description": ""}, {"name": "list.mem_permutations_aux2'", "description": ""}, {"name": "list.permutations_aux2_snd_cons", "description": ""}, {"name": "list.permutations_nil", "description": ""}, {"name": "list.permutations_aux_nil", "description": ""}, {"name": "list.permutations_append", "description": ""}, {"name": "list.map_map_permutations_aux2", "description": ""}, {"name": "list.length_foldr_permutations_aux2'", "description": ""}, {"name": "list.permutations'_aux_eq_permutations_aux2", "description": ""}, {"name": "list.permutations_aux_cons", "description": ""}, {"name": "list.map_permutations", "description": ""}, {"name": "list.permutations_aux2_snd_nil", "description": ""}, {"name": "list.permutations_aux2_fst", "description": ""}, {"name": "list.length_permutations_aux2", "description": ""}, {"name": "list.length_foldr_permutations_aux2", "description": ""}, {"name": "list.permutations_aux2_append", "description": "The `r` argument to `permutations_aux2` is the same as appending."}, {"name": "ulift.up_surjective", "description": ""}, {"name": "plift.up_surjective", "description": ""}, {"name": "plift.down_surjective", "description": ""}, {"name": "plift.up_injective", "description": ""}, {"name": "ulift.down_surjective", "description": ""}, {"name": "ulift.exists", "description": ""}, {"name": "plift.decidable_eq", "description": ""}, {"name": "plift.down_bijective", "description": ""}, {"name": "plift.nonempty", "description": ""}, {"name": "ulift.down_bijective", "description": ""}, {"name": "plift.unique", "description": ""}, {"name": "ulift.up_injective", "description": ""}, {"name": "plift.exists", "description": ""}, {"name": "plift.up_inj", "description": ""}, {"name": "ulift.nonempty", "description": ""}, {"name": "plift.up_bijective", "description": ""}, {"name": "ulift.is_empty", "description": ""}, {"name": "ulift.up_inj", "description": ""}, {"name": "plift.is_empty", "description": ""}, {"name": "ulift.unique", "description": ""}, {"name": "plift.forall", "description": ""}, {"name": "ulift.forall", "description": ""}, {"name": "plift.subsingleton", "description": ""}, {"name": "ulift.up_bijective", "description": ""}, {"name": "ulift.subsingleton", "description": ""}, {"name": "ulift.decidable_eq", "description": ""}, {"name": "finset.product_union", "description": ""}, {"name": "finset.off_diag_singleton", "description": ""}, {"name": "finset.product_sdiff_diag", "description": ""}, {"name": "finset.coe_product", "description": ""}, {"name": "finset.product_val", "description": ""}, {"name": "finset.product_eq_bUnion", "description": ""}, {"name": "finset.nonempty_product", "description": ""}, {"name": "finset.filter_product", "description": ""}, {"name": "finset.singleton_product_singleton", "description": ""}, {"name": "finset.nonempty.product", "description": ""}, {"name": "finset.union_product", "description": ""}, {"name": "finset.diag_singleton", "description": ""}, {"name": "finset.diag_insert", "description": ""}, {"name": "finset.product_subset_product_left", "description": ""}, {"name": "finset.mem_off_diag", "description": ""}, {"name": "finset.diag_union_off_diag", "description": ""}, {"name": "finset.off_diag_empty", "description": ""}, {"name": "finset.product", "description": "`product s t` is the set of pairs `(a, b)` such that `a \u2208 s` and `b \u2208 t`."}, {"name": "finset.product_subset_product", "description": ""}, {"name": "finset.diag", "description": " Given a finite set `s`, the diagonal, `s.diag` is the set of pairs of the form `(a, a)` for\n`a \u2208 s`."}, {"name": "finset.product_bUnion", "description": "See also `finset.sup_product_left`."}, {"name": "finset.nonempty.snd", "description": ""}, {"name": "finset.product_subset_product_right", "description": ""}, {"name": "finset.mem_diag", "description": ""}, {"name": "finset.subset_product", "description": ""}, {"name": "finset.disjoint_diag_off_diag", "description": ""}, {"name": "finset.card_product", "description": ""}, {"name": "finset.product_eq_empty", "description": ""}, {"name": "finset.diag_union", "description": ""}, {"name": "finset.singleton_product", "description": ""}, {"name": "finset.empty_product", "description": ""}, {"name": "finset.diag_empty", "description": ""}, {"name": "finset.product_empty", "description": ""}, {"name": "finset.mk_mem_product", "description": ""}, {"name": "finset.off_diag_insert", "description": ""}, {"name": "finset.product_sdiff_off_diag", "description": ""}, {"name": "finset.off_diag_card", "description": ""}, {"name": "finset.off_diag", "description": " Given a finite set `s`, the off-diagonal, `s.off_diag` is the set of pairs `(a, b)` with `a \u2260 b`\nfor `a, b \u2208 s`."}, {"name": "finset.nonempty.fst", "description": ""}, {"name": "finset.product_eq_bUnion_right", "description": ""}, {"name": "finset.diag_card", "description": ""}, {"name": "finset.filter_product_card", "description": ""}, {"name": "finset.product_singleton", "description": ""}, {"name": "finset.off_diag_union", "description": ""}, {"name": "finset.mem_product", "description": ""}, {"name": "get_localized", "description": "Get all commands in the given locale and return them as a list of strings"}, {"name": "localized_attr", "description": ""}, {"name": "print_localized_commands", "description": "Print all commands in a given locale"}, {"name": "localized_cmd", "description": "Add a new command to a locale and execute it right now.\n The new command is added as a declaration to the environment with name `_localized_decl.<number>`.\n This declaration has attribute `_localized` and as value a name-string pair."}, {"name": "open_locale_cmd", "description": "Execute all commands in the given locale"}, {"name": "tactic_doc.command.localized notation", "description": "This consists of two user-commands which allow you to declare notation and commands localized to a\nlocale.\n\n* Declare notation which is localized to a locale using:\n```lean\nlocalized \"infix ` \u22b9 `:60 := my_add\" in my.add\n```\n\n* After this command it will be available in the same section/namespace/file, just as if you wrote\n  `local infix ` \u22b9 `:60 := my_add`\n\n* You can open it in other places. The following command will declare the notation again as local\n  notation in that section/namespace/file:\n```lean\nopen_locale my.add\n```\n\n* More generally, the following will declare all localized notation in the specified locales.\n```lean\nopen_locale locale1 locale2 ...\n```\n\n* You can also declare other localized commands, like local attributes\n```lean\nlocalized \"attribute [simp] le_refl\" in le\n```\n\n* To see all localized commands in a given locale, run:\n```lean\nrun_cmd print_localized_commands [`my.add].\n```\n\n* To see a list of all locales with localized commands, run:\n```lean\nrun_cmd do\n  m \u2190 localized_attr.get_cache,\n  tactic.trace m.keys -- change to `tactic.trace m.to_list` to list all the commands in each locale\n```\n\n* Warning: You have to give full names of all declarations used in localized notation,\n  so that the localized notation also works when the appropriate namespaces are not opened."}, {"name": "punit.decidable_eq", "description": ""}, {"name": "punit.inhabited", "description": ""}, {"name": "punit.subsingleton", "description": ""}, {"name": "punit_eq_star", "description": ""}, {"name": "punit_eq", "description": ""}, {"name": "to_mul_zero", "description": ""}, {"name": "multiplicative.right_cancel_semigroup", "description": ""}, {"name": "of_mul_div", "description": ""}, {"name": "additive.has_involutive_neg", "description": ""}, {"name": "multiplicative", "description": " If `\u03b1` carries some additive structure, then `multiplicative \u03b1` carries the corresponding\nmultiplicative structure."}, {"name": "of_add_eq_one", "description": ""}, {"name": "additive.add_zero_class", "description": ""}, {"name": "of_add_sub", "description": ""}, {"name": "multiplicative.has_div", "description": ""}, {"name": "monoid_hom.to_additive''_symm_apply_apply", "description": ""}, {"name": "additive.add_group", "description": ""}, {"name": "monoid_hom.to_additive'_apply_apply", "description": ""}, {"name": "additive.add_comm_monoid", "description": ""}, {"name": "monoid_hom.to_additive'", "description": "Reinterpret `\u03b1 \u2192* multiplicative \u03b2` as `additive \u03b1 \u2192+ \u03b2`."}, {"name": "additive.inhabited", "description": ""}, {"name": "add_monoid_hom.to_multiplicative''_symm_apply_apply", "description": ""}, {"name": "additive.has_add", "description": ""}, {"name": "multiplicative.right_cancel_monoid", "description": ""}, {"name": "additive.add_comm_semigroup", "description": ""}, {"name": "of_mul_to_mul", "description": ""}, {"name": "monoid_hom.to_additive", "description": "Reinterpret `\u03b1 \u2192* \u03b2` as `additive \u03b1 \u2192+ additive \u03b2`."}, {"name": "to_mul_add", "description": ""}, {"name": "add_monoid_hom.to_multiplicative", "description": "Reinterpret `\u03b1 \u2192+ \u03b2` as `multiplicative \u03b1 \u2192* multiplicative \u03b2`."}, {"name": "of_mul_mul", "description": ""}, {"name": "additive.nontrivial", "description": ""}, {"name": "of_mul_eq_zero", "description": ""}, {"name": "additive.add_semigroup", "description": ""}, {"name": "additive", "description": " If `\u03b1` carries some multiplicative structure, then `additive \u03b1` carries the corresponding\nadditive structure."}, {"name": "multiplicative.comm_semigroup", "description": ""}, {"name": "multiplicative.group", "description": ""}, {"name": "additive.subtraction_comm_monoid", "description": ""}, {"name": "to_add_of_add", "description": ""}, {"name": "multiplicative.has_mul", "description": ""}, {"name": "to_add_inv", "description": ""}, {"name": "multiplicative.has_one", "description": ""}, {"name": "monoid_hom.to_additive''_apply_apply", "description": ""}, {"name": "additive.subtraction_monoid", "description": ""}, {"name": "multiplicative.of_add", "description": "Reinterpret `x : \u03b1` as an element of `multiplicative \u03b1`."}, {"name": "add_monoid_hom.to_multiplicative_symm_apply_apply", "description": ""}, {"name": "multiplicative.inhabited", "description": ""}, {"name": "additive.of_mul", "description": "Reinterpret `x : \u03b1` as an element of `additive \u03b1`."}, {"name": "multiplicative.has_inv", "description": ""}, {"name": "to_mul_sub", "description": ""}, {"name": "monoid_hom.to_additive''", "description": "Reinterpret `multiplicative \u03b1 \u2192* \u03b2` as `\u03b1 \u2192+ additive \u03b2`."}, {"name": "additive.to_mul", "description": "Reinterpret `x : additive \u03b1` as an element of `\u03b1`."}, {"name": "add_monoid_hom.to_multiplicative''_apply_apply", "description": ""}, {"name": "additive.of_mul_symm_eq", "description": ""}, {"name": "add_monoid_hom.to_multiplicative_apply_apply", "description": ""}, {"name": "multiplicative.left_cancel_semigroup", "description": ""}, {"name": "multiplicative.comm_monoid", "description": ""}, {"name": "to_add_one", "description": ""}, {"name": "add_monoid_hom.to_multiplicative'_apply_apply", "description": ""}, {"name": "additive.has_zero", "description": ""}, {"name": "additive.has_sub", "description": ""}, {"name": "add_monoid_hom.to_multiplicative'_symm_apply_apply", "description": ""}, {"name": "multiplicative.comm_group", "description": ""}, {"name": "monoid_hom.to_additive_symm_apply_apply", "description": ""}, {"name": "multiplicative.mul_one_class", "description": ""}, {"name": "multiplicative.monoid", "description": ""}, {"name": "to_mul_neg", "description": ""}, {"name": "additive.add_right_cancel_monoid", "description": ""}, {"name": "additive.sub_neg_monoid", "description": ""}, {"name": "additive.add_comm_group", "description": ""}, {"name": "multiplicative.division_monoid", "description": ""}, {"name": "additive.add_monoid", "description": ""}, {"name": "multiplicative.to_add", "description": "Reinterpret `x : multiplicative \u03b1` as an element of `\u03b1`."}, {"name": "additive.has_neg", "description": ""}, {"name": "multiplicative.division_comm_monoid", "description": ""}, {"name": "add_monoid_hom.to_multiplicative'", "description": "Reinterpret `additive \u03b1 \u2192+ \u03b2` as `\u03b1 \u2192* multiplicative \u03b2`."}, {"name": "of_mul_inv", "description": ""}, {"name": "additive.has_coe_to_fun", "description": " If `\u03b1` has some multiplicative structure and coerces to a function,\nthen `additive \u03b1` should also coerce to the same function.\n\nThis allows `additive` to be used on bundled function types with a multiplicative structure, which\nis often used for composition, without affecting the behavior of the function itself."}, {"name": "multiplicative.to_add_symm_eq", "description": ""}, {"name": "multiplicative.has_coe_to_fun", "description": " If `\u03b1` has some additive structure and coerces to a function,\nthen `multiplicative \u03b1` should also coerce to the same function.\n\nThis allows `multiplicative` to be used on bundled function types with an additive structure, which\nis often used for composition, without affecting the behavior of the function itself."}, {"name": "of_add_neg", "description": ""}, {"name": "of_mul_one", "description": ""}, {"name": "multiplicative.nontrivial", "description": ""}, {"name": "monoid_hom.to_additive_apply_apply", "description": ""}, {"name": "multiplicative.left_cancel_monoid", "description": ""}, {"name": "additive.add_right_cancel_semigroup", "description": ""}, {"name": "multiplicative.div_inv_monoid", "description": ""}, {"name": "of_add_zero", "description": ""}, {"name": "to_add_div", "description": ""}, {"name": "of_add_to_add", "description": ""}, {"name": "multiplicative.semigroup", "description": ""}, {"name": "of_add_add", "description": ""}, {"name": "to_mul_of_mul", "description": ""}, {"name": "add_monoid_hom.to_multiplicative''", "description": "Reinterpret `\u03b1 \u2192+ additive \u03b2` as `multiplicative \u03b1 \u2192* \u03b2`."}, {"name": "additive.add_left_cancel_semigroup", "description": ""}, {"name": "monoid_hom.to_additive'_symm_apply_apply", "description": ""}, {"name": "additive.to_mul_symm_eq", "description": ""}, {"name": "to_add_mul", "description": ""}, {"name": "additive.add_left_cancel_monoid", "description": ""}, {"name": "multiplicative.has_involutive_inv", "description": ""}, {"name": "multiplicative.of_add_symm_eq", "description": ""}, {"name": "ring_hom.to_opposite", "description": " A ring homomorphism `f : R \u2192+* S` such that `f x` commutes with `f y` for all `x, y` defines\na ring homomorphism to `S\u1d50\u1d52\u1d56`."}, {"name": "non_unital_ring_hom.op_symm_apply_to_fun", "description": ""}, {"name": "ring_hom.op_apply_apply", "description": ""}, {"name": "ring_hom.to_opposite_apply", "description": ""}, {"name": "non_unital_ring_hom.to_opposite", "description": " A non-unital ring homomorphism `f : R \u2192\u2099+* S` such that `f x` commutes with `f y` for all `x, y`\ndefines a non-unital ring homomorphism to `S\u1d50\u1d52\u1d56`."}, {"name": "add_opposite.comm_semiring", "description": ""}, {"name": "add_opposite.semiring", "description": ""}, {"name": "mul_opposite.non_unital_ring", "description": ""}, {"name": "non_unital_ring_hom.op", "description": " A non-unital ring hom `\u03b1 \u2192\u2099+* \u03b2` can equivalently be viewed as a non-unital ring hom\n`\u03b1\u1d50\u1d52\u1d56 \u2192+* \u03b2\u1d50\u1d52\u1d56`. This is the action of the (fully faithful) `\u1d50\u1d52\u1d56`-functor on morphisms."}, {"name": "ring_hom.op", "description": " A ring hom `\u03b1 \u2192+* \u03b2` can equivalently be viewed as a ring hom `\u03b1\u1d50\u1d52\u1d56 \u2192+* \u03b2\u1d50\u1d52\u1d56`. This is the\naction of the (fully faithful) `\u1d50\u1d52\u1d56`-functor on morphisms."}, {"name": "ring_hom.from_opposite_apply", "description": ""}, {"name": "ring_hom.unop", "description": "The 'unopposite' of a ring hom `\u03b1\u1d50\u1d52\u1d56 \u2192+* \u03b2\u1d50\u1d52\u1d56`. Inverse to `ring_hom.op`."}, {"name": "mul_opposite.no_zero_divisors", "description": ""}, {"name": "mul_opposite.distrib", "description": ""}, {"name": "non_unital_ring_hom.from_opposite", "description": " A non-unital ring homomorphism `f : R \u2192\u2099* S` such that `f x` commutes with `f y` for all `x, y`\ndefines a non-unital ring homomorphism from `R\u1d50\u1d52\u1d56`."}, {"name": "mul_opposite.semiring", "description": ""}, {"name": "mul_opposite.non_unital_comm_ring", "description": ""}, {"name": "mul_opposite.non_unital_non_assoc_ring", "description": ""}, {"name": "mul_opposite.mul_zero_one_class", "description": ""}, {"name": "mul_opposite.comm_ring", "description": ""}, {"name": "mul_opposite.semigroup_with_zero", "description": ""}, {"name": "add_opposite.ring", "description": ""}, {"name": "add_opposite.non_assoc_semiring", "description": ""}, {"name": "add_opposite.non_unital_comm_semiring", "description": ""}, {"name": "mul_opposite.comm_semiring", "description": ""}, {"name": "add_opposite.mul_zero_one_class", "description": ""}, {"name": "mul_opposite.non_unital_comm_semiring", "description": ""}, {"name": "mul_opposite.ring", "description": ""}, {"name": "mul_opposite.non_assoc_ring", "description": ""}, {"name": "mul_opposite.is_domain", "description": ""}, {"name": "mul_opposite.non_assoc_semiring", "description": ""}, {"name": "non_unital_ring_hom.unop", "description": " The 'unopposite' of a non-unital ring hom `\u03b1\u1d50\u1d52\u1d56 \u2192\u2099+* \u03b2\u1d50\u1d52\u1d56`. Inverse to\n`non_unital_ring_hom.op`."}, {"name": "add_opposite.comm_ring", "description": ""}, {"name": "add_opposite.non_unital_semiring", "description": ""}, {"name": "non_unital_ring_hom.to_opposite_to_fun", "description": ""}, {"name": "ring_hom.op_symm_apply_apply", "description": ""}, {"name": "add_opposite.non_unital_non_assoc_semiring", "description": ""}, {"name": "mul_opposite.non_unital_non_assoc_semiring", "description": ""}, {"name": "add_opposite.non_assoc_ring", "description": ""}, {"name": "add_opposite.no_zero_divisors", "description": ""}, {"name": "mul_opposite.non_unital_semiring", "description": ""}, {"name": "non_unital_ring_hom.from_opposite_to_fun", "description": ""}, {"name": "mul_opposite.group_with_zero", "description": ""}, {"name": "non_unital_ring_hom.op_apply_to_fun", "description": ""}, {"name": "add_opposite.non_unital_ring", "description": ""}, {"name": "add_opposite.distrib", "description": ""}, {"name": "add_opposite.is_domain", "description": ""}, {"name": "add_opposite.monoid_with_zero", "description": ""}, {"name": "mul_opposite.mul_zero_class", "description": ""}, {"name": "add_opposite.group_with_zero", "description": ""}, {"name": "add_opposite.semigroup_with_zero", "description": ""}, {"name": "add_opposite.non_unital_non_assoc_ring", "description": ""}, {"name": "ring_hom.from_opposite", "description": " A ring homomorphism `f : R \u2192+* S` such that `f x` commutes with `f y` for all `x, y` defines\na ring homomorphism from `R\u1d50\u1d52\u1d56`."}, {"name": "add_opposite.non_unital_comm_ring", "description": ""}, {"name": "add_opposite.mul_zero_class", "description": ""}, {"name": "mul_opposite.monoid_with_zero", "description": ""}, {"name": "smt_tactic.solve1", "description": ""}, {"name": "smt_tactic.iterate_exactly", "description": "`iterate_exactly n t` : execute t n times"}, {"name": "smt_tactic.failed", "description": ""}, {"name": "smt_tactic.add_lemmas_from_facts_core", "description": ""}, {"name": "smt_tactic.definev", "description": "Add the hypothesis (h : t := v) in the current goal if v has type t."}, {"name": "smt_tactic.set_goals", "description": ""}, {"name": "smt_tactic.ematch_using", "description": "Produce new facts using heuristic lemma instantiation based on E-matching.\nThis tactic tries to match patterns from the given lemmas with terms in\nthe main goal."}, {"name": "smt_tactic.get_config", "description": ""}, {"name": "smt_tactic.trace_state", "description": ""}, {"name": "smt_tactic.ematch_core", "description": "Produce new facts using heuristic lemma instantiation based on E-matching.\nThis tactic tries to match patterns from lemmas in the main goal with terms\nin the main goal. The set of lemmas is populated with theorems\ntagged with the attribute specified at smt_config.em_attr, and lemmas\nadded using tactics such as `smt_tactic.add_lemmas`.\nThe current set of lemmas can be retrieved using the tactic `smt_tactic.get_lemmas`.\n\nRemark: the given predicate is applied to every new instance. The instance\nis only added to the state if the predicate returns tt."}, {"name": "smt_tactic.add_lemmas_from_facts", "description": ""}, {"name": "smt_tactic.add_ematch_lhs_lemma_from_decl", "description": ""}, {"name": "smt_tactic.add_ematch_lemma_from_decl", "description": ""}, {"name": "simp_attr.pre_smt", "description": ""}, {"name": "smt_tactic.seq", "description": "LCF-style AND_THEN tactic. It applies tac1, and if succeed applies tac2 to each subgoal produced by tac1"}, {"name": "using_smt", "description": ""}, {"name": "smt_tactic.intron", "description": ""}, {"name": "smt_tactic.trace", "description": ""}, {"name": "smt_tactic.write", "description": ""}, {"name": "smt_tactic", "description": ""}, {"name": "ematch_lhs", "description": ""}, {"name": "smt_tactic.swap", "description": ""}, {"name": "smt_tactic.when_tracing", "description": ""}, {"name": "smt_tactic.monad_fail", "description": ""}, {"name": "smt_state.to_format", "description": ""}, {"name": "smt_goal", "description": ""}, {"name": "smt_tactic.when", "description": ""}, {"name": "smt_tactic.slift", "description": "This lift operation will restart the SMT state.\nIt is useful for using tactics that change the set of hypotheses."}, {"name": "smt_tactic.classical", "description": ""}, {"name": "smt_tactic.pose", "description": "Add (h : t := pr) to the current goal"}, {"name": "smt_tactic.intros", "description": ""}, {"name": "smt_tactic.add_ematch_lemma_core", "description": ""}, {"name": "smt_state.has_append", "description": ""}, {"name": "smt_tactic.close", "description": "Try to close main goal by using equalities implied by the congruence\nclosure module."}, {"name": "smt_tactic.proof_for", "description": "Return a proof for e, if 'e' is a known fact in the main goal."}, {"name": "smt_tactic.add_ematch_lhs_lemma", "description": ""}, {"name": "smt_tactic.focus1", "description": ""}, {"name": "smt_tactic.mk_ematch_eqn_lemmas_for_core", "description": ""}, {"name": "smt_tactic.alternative", "description": ""}, {"name": "smt_tactic.get_facts", "description": ""}, {"name": "smt_tactic.ematch", "description": ""}, {"name": "smt_tactic.has_andthen", "description": ""}, {"name": "smt_tactic.to_expr", "description": ""}, {"name": "smt_tactic.add_ematch_eqn_lemmas_for", "description": ""}, {"name": "smt_state.mk", "description": ""}, {"name": "smt_tactic.all_goals", "description": "Apply the given tactic to all goals."}, {"name": "smt_state", "description": ""}, {"name": "smt_tactic.define", "description": "Add a new goal for t, and the hypothesis (h : t := ?M) in the current goal."}, {"name": "ematch", "description": ""}, {"name": "smt_tactic.slift_aux", "description": ""}, {"name": "smt_tactic.add_ematch_lemma", "description": ""}, {"name": "smt_tactic.get_refuted_facts", "description": ""}, {"name": "smt_tactic.assertv", "description": "Add the hypothesis (h : t) in the current goal if v has type t."}, {"name": "smt_tactic.add_lemmas", "description": ""}, {"name": "smt_tactic.fail", "description": ""}, {"name": "smt_tactic.try", "description": ""}, {"name": "smt_tactic.to_em_state", "description": ""}, {"name": "smt_tactic.monad_state", "description": ""}, {"name": "smt_tactic.note", "description": "Add (h : t) to the current goal, given a proof (pr : t)"}, {"name": "smt_config", "description": "Configuration for the smt_state object.\n\n- em_attr: is the attribute name for the hinst_lemmas\n  that are used for ematching"}, {"name": "smt_config.cc_cfg", "description": "Configuration for the smt_state object.\n\n- em_attr: is the attribute name for the hinst_lemmas\n  that are used for ematching"}, {"name": "smt_config.em_cfg", "description": "Configuration for the smt_state object.\n\n- em_attr: is the attribute name for the hinst_lemmas\n  that are used for ematching"}, {"name": "smt_config.pre_cfg", "description": "Configuration for the smt_state object.\n\n- em_attr: is the attribute name for the hinst_lemmas\n  that are used for ematching"}, {"name": "smt_config.em_attr", "description": "Configuration for the smt_state object.\n\n- em_attr: is the attribute name for the hinst_lemmas\n  that are used for ematching"}, {"name": "smt_tactic.assert", "description": "Add a new goal for t, and the hypothesis (h : t) in the current goal."}, {"name": "smt_tactic.get_lemmas", "description": ""}, {"name": "smt_tactic.has_monad_lift", "description": ""}, {"name": "smt_tactic.get_goals", "description": ""}, {"name": "smt_tactic.iterate_at_most", "description": "`iterate_at_most n t`: repeat the given tactic at most n times or until t fails"}, {"name": "smt_tactic.iterate", "description": ""}, {"name": "smt_tactic.eblast", "description": ""}, {"name": "smt_tactic.intro_lst", "description": ""}, {"name": "smt_tactic.monad", "description": ""}, {"name": "smt_tactic.read", "description": ""}, {"name": "smt_pre_config", "description": "Configuration for the smt tactic preprocessor. The preprocessor\nis applied whenever a new hypothesis is introduced.\n\n- simp_attr: is the attribute name for the simplification lemmas\n  that are used during the preprocessing step.\n\n- max_steps: it is the maximum number of steps performed by the simplifier.\n\n- zeta: if tt, then zeta reduction (i.e., unfolding let-expressions)\n  is used during preprocessing."}, {"name": "smt_pre_config.simp_attr", "description": "Configuration for the smt tactic preprocessor. The preprocessor\nis applied whenever a new hypothesis is introduced.\n\n- simp_attr: is the attribute name for the simplification lemmas\n  that are used during the preprocessing step.\n\n- max_steps: it is the maximum number of steps performed by the simplifier.\n\n- zeta: if tt, then zeta reduction (i.e., unfolding let-expressions)\n  is used during preprocessing."}, {"name": "smt_pre_config.max_steps", "description": "Configuration for the smt tactic preprocessor. The preprocessor\nis applied whenever a new hypothesis is introduced.\n\n- simp_attr: is the attribute name for the simplification lemmas\n  that are used during the preprocessing step.\n\n- max_steps: it is the maximum number of steps performed by the simplifier.\n\n- zeta: if tt, then zeta reduction (i.e., unfolding let-expressions)\n  is used during preprocessing."}, {"name": "smt_pre_config.zeta", "description": "Configuration for the smt tactic preprocessor. The preprocessor\nis applied whenever a new hypothesis is introduced.\n\n- simp_attr: is the attribute name for the simplification lemmas\n  that are used during the preprocessing step.\n\n- max_steps: it is the maximum number of steps performed by the simplifier.\n\n- zeta: if tt, then zeta reduction (i.e., unfolding let-expressions)\n  is used during preprocessing."}, {"name": "smt_tactic.to_cc_state", "description": ""}, {"name": "smt_tactic.by_contradiction", "description": ""}, {"name": "smt_tactic.by_cases", "description": ""}, {"name": "smt_tactic.induction", "description": ""}, {"name": "using_smt_with", "description": ""}, {"name": "tactic_to_smt_tactic", "description": ""}, {"name": "smt_tactic.has_coe", "description": ""}, {"name": "smt_tactic.set_lemmas", "description": ""}, {"name": "smt_tactic.destruct", "description": ""}, {"name": "smt_tactic.add_ematch_eqn_lemmas_for_core", "description": ""}, {"name": "smt_config.set_classical", "description": ""}, {"name": "smt_tactic.refutation_for", "description": "Return a refutation for e (i.e., a proof for (not e)), if 'e' has been refuted in the main goal."}, {"name": "smt_tactic.add_ematch_lemma_from_decl_core", "description": ""}, {"name": "smt_tactic.num_goals", "description": ""}, {"name": "smt_tactic.preprocess", "description": "Preprocess the given term using the same simplifications rules used when\nwe introduce a new hypothesis. The result is pair containing the resulting\nterm and a proof that it is equal to the given one."}, {"name": "smt_state.classical", "description": "Return tt iff classical excluded middle was enabled at  smt_state.mk"}, {"name": "int.cast", "description": "Canonical homomorphism from the integers to any ring(-like) structure `R`"}, {"name": "int.cast_coe_nat", "description": ""}, {"name": "add_comm_group_with_one", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.add", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.add_assoc", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.zero", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.zero_add", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.add_zero", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.nsmul", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.nsmul_zero'", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.nsmul_succ'", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.neg", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.sub", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.sub_eq_add_neg", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.zsmul", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.zsmul_zero'", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.zsmul_succ'", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.zsmul_neg'", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.add_left_neg", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.add_comm", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.int_cast", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.nat_cast", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.one", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.nat_cast_zero", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.nat_cast_succ", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.int_cast_of_nat", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_group_with_one.int_cast_neg_succ_of_nat", "description": "An `add_comm_group_with_one` is an `add_group_with_one` satisfying `a + b = b + a`."}, {"name": "int.cast_sub_nat_nat", "description": ""}, {"name": "int.cast_two", "description": ""}, {"name": "int.cast_add", "description": ""}, {"name": "int.cast_zero", "description": ""}, {"name": "int.cast_bit0", "description": ""}, {"name": "int.neg_of_nat_eq", "description": ""}, {"name": "int.cast_bit1", "description": ""}, {"name": "add_group_with_one", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.int_cast", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.add", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.add_assoc", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.zero", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.zero_add", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.add_zero", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.nsmul", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.nsmul_zero'", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.nsmul_succ'", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.neg", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.sub", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.sub_eq_add_neg", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.zsmul", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.zsmul_zero'", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.zsmul_succ'", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.zsmul_neg'", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.add_left_neg", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.nat_cast", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.one", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.nat_cast_zero", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.nat_cast_succ", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.int_cast_of_nat", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "add_group_with_one.int_cast_neg_succ_of_nat", "description": "An `add_group_with_one` is an `add_group` with a `1`.\nIt also contains data for the unique homomorphisms `\u2115 \u2192 R` and `\u2124 \u2192 R`."}, {"name": "int.cast_coe", "description": ""}, {"name": "int.cast_four", "description": ""}, {"name": "int.cast_def", "description": "Default value for `add_group_with_one.int_cast`."}, {"name": "int.coe_nat_bit0", "description": ""}, {"name": "add_group_with_one.to_add_monoid_with_one", "description": ""}, {"name": "int.cast_one", "description": ""}, {"name": "nat.cast_sub", "description": ""}, {"name": "add_group_with_one.to_add_group", "description": ""}, {"name": "add_group_with_one.to_has_int_cast", "description": ""}, {"name": "add_comm_group_with_one.to_add_group_with_one", "description": ""}, {"name": "int.cast_three", "description": ""}, {"name": "int.cast_neg", "description": ""}, {"name": "add_comm_group_with_one.to_add_comm_group", "description": ""}, {"name": "int.cast_sub", "description": ""}, {"name": "int.coe_nat_bit1", "description": ""}, {"name": "int.cast_neg_of_nat", "description": ""}, {"name": "has_int_cast", "description": "Type class for the canonical homomorphism `\u2124 \u2192 R`."}, {"name": "has_int_cast.int_cast", "description": "Type class for the canonical homomorphism `\u2124 \u2192 R`."}, {"name": "nat.cast_pred", "description": ""}, {"name": "int.cast_of_nat", "description": ""}, {"name": "int.cast_neg_succ_of_nat", "description": ""}, {"name": "function.embedding.has_coe_to_fun", "description": ""}, {"name": "function.embedding.subtype", "description": "Embedding of a `subtype`."}, {"name": "function.embedding.ext_iff", "description": ""}, {"name": "function.embedding.sigma_map_apply", "description": ""}, {"name": "function.embedding.cod_restrict_apply", "description": ""}, {"name": "function.embedding.sectr_apply", "description": ""}, {"name": "function.embedding.option_embedding_equiv_apply_fst", "description": ""}, {"name": "subtype.imp_embedding", "description": " A subtype `{x // p x}` can be injectively sent to into a subtype `{x // q x}`,\nif `p x \u2192 q x` for all `x : \u03b1`."}, {"name": "function.embedding.injective", "description": ""}, {"name": "subtype_or_equiv", "description": " A subtype `{x // p x \u2228 q x}` over a disjunction of `p q : \u03b1 \u2192 Prop` is equivalent to a sum of\nsubtypes `{x // p x} \u2295 {x // q x}` such that `\u00ac p x` is sent to the right, when\n`disjoint p q`.\n\nSee also `equiv.sum_compl`, for when `is_compl p q`."}, {"name": "function.embedding.option_map_apply", "description": ""}, {"name": "function.embedding.sectr", "description": "Fixing an element `a : \u03b1` gives an embedding `\u03b2 \u21aa \u03b1 \u00d7 \u03b2`."}, {"name": "function.embedding.cod_restrict", "description": "Restrict the codomain of an embedding."}, {"name": "equiv.refl_to_embedding", "description": ""}, {"name": "function.embedding.sectl_apply", "description": ""}, {"name": "equiv.to_embedding_apply", "description": ""}, {"name": "function.embedding.mk_coe", "description": ""}, {"name": "function.embedding.coe_subtype", "description": ""}, {"name": "function.embedding.Pi_congr_right_apply", "description": ""}, {"name": "function.embedding.coe_option_apply", "description": ""}, {"name": "function.embedding.of_is_empty", "description": "There is always an embedding from an empty type. -"}, {"name": "function.embedding.of_surjective", "description": "A right inverse `surj_inv` of a surjective function as an `embedding`."}, {"name": "function.embedding.apply_eq_iff_eq", "description": ""}, {"name": "function.embedding.sigma_mk_apply", "description": ""}, {"name": "equiv.as_embedding_range", "description": ""}, {"name": "function.embedding.option_embedding_equiv_symm_apply", "description": ""}, {"name": "equiv.coe_eq_to_embedding", "description": ""}, {"name": "function.embedding_like", "description": ""}, {"name": "function.embedding.trans", "description": "Composition of `f : \u03b1 \u21aa \u03b2` and `g : \u03b2 \u21aa \u03b3`."}, {"name": "function.embedding.trans_apply", "description": ""}, {"name": "function.embedding.some", "description": "Embedding into `option \u03b1` using `some`."}, {"name": "function.embedding.punit", "description": "Choosing an element `b : \u03b2` gives an embedding of `punit` into `\u03b2`."}, {"name": "function.embedding.coe_sum_map", "description": ""}, {"name": "equiv.embedding_congr_symm", "description": ""}, {"name": "function.embedding", "description": "`\u03b1 \u21aa \u03b2` is a bundled injective function."}, {"name": "function.embedding.to_fun", "description": "`\u03b1 \u21aa \u03b2` is a bundled injective function."}, {"name": "function.embedding.inj'", "description": "`\u03b1 \u21aa \u03b2` is a bundled injective function."}, {"name": "function.embedding.inl", "description": "The embedding of `\u03b1` into the sum `\u03b1 \u2295 \u03b2`."}, {"name": "function.embedding.swap_apply", "description": ""}, {"name": "subtype_or_left_embedding_apply_right", "description": ""}, {"name": "function.embedding.equiv_symm_to_embedding_trans_to_embedding", "description": ""}, {"name": "function.embedding.inl_apply", "description": ""}, {"name": "function.embedding.arrow_congr_right_apply", "description": ""}, {"name": "function.embedding.arrow_congr_right", "description": " An embedding `e : \u03b1 \u21aa \u03b2` defines an embedding `(\u03b3 \u2192 \u03b1) \u21aa (\u03b3 \u2192 \u03b2)` that sends each `f`\nto `e \u2218 f`."}, {"name": "function.embedding.sigma_map", "description": " If `f : \u03b1 \u21aa \u03b1'` is an embedding and `g : \u03a0 a, \u03b2 \u03b1 \u21aa \u03b2' (f \u03b1)` is a family\nof embeddings, then `sigma.map f g` is an embedding."}, {"name": "function.embedding.some_apply", "description": ""}, {"name": "subtype_or_equiv_apply", "description": ""}, {"name": "function.embedding.to_fun_eq_coe", "description": ""}, {"name": "equiv.embedding_congr_apply", "description": ""}, {"name": "function.embedding.coe_quotient_out", "description": ""}, {"name": "set.embedding_of_subset", "description": "The injection map is an embedding between subsets."}, {"name": "function.embedding.option_embedding_equiv_apply_snd_coe", "description": ""}, {"name": "function.embedding.refl", "description": "The identity map as a `function.embedding`."}, {"name": "function.embedding.pprod_map", "description": "If `e\u2081` and `e\u2082` are embeddings, then so is `\u03bb \u27e8a, b\u27e9, \u27e8e\u2081 a, e\u2082 b\u27e9 : pprod \u03b1 \u03b3 \u2192 pprod \u03b2 \u03b4`."}, {"name": "function.embedding.equiv_to_embedding_trans_symm_to_embedding", "description": ""}, {"name": "function.embedding.subtype_map", "description": "Restrict both domain and codomain of an embedding."}, {"name": "function.embedding.inr_apply", "description": ""}, {"name": "equiv.as_embedding_apply", "description": ""}, {"name": "function.embedding.congr", "description": "Transfer an embedding along a pair of equivalences."}, {"name": "function.embedding.option_elim", "description": " Given an embedding `f : \u03b1 \u21aa \u03b2` and a point outside of `set.range f`, construct an embedding\n`option \u03b1 \u21aa \u03b2`."}, {"name": "function.embedding.coe_fn_mk", "description": ""}, {"name": "function.embedding.coe_with_top", "description": "Embedding into `with_top \u03b1`."}, {"name": "subtype_or_left_embedding", "description": " A subtype `{x // p x \u2228 q x}` over a disjunction of `p q : \u03b1 \u2192 Prop` can be injectively split\ninto a sum of subtypes `{x // p x} \u2295 {x // q x}` such that `\u00ac p x` is sent to the right."}, {"name": "subtype.imp_embedding_apply_coe", "description": ""}, {"name": "function.embedding.prod_map", "description": "If `e\u2081` and `e\u2082` are embeddings, then so is `prod.map e\u2081 e\u2082 : (a, b) \u21a6 (e\u2081 a, e\u2082 b)`."}, {"name": "function.embedding.coe_injective", "description": ""}, {"name": "function.embedding.option_elim_apply", "description": ""}, {"name": "function.embedding.sectl", "description": "Fixing an element `b : \u03b2` gives an embedding `\u03b1 \u21aa \u03b1 \u00d7 \u03b2`."}, {"name": "equiv.embedding_congr", "description": " If `\u03b1\u2081 \u2243 \u03b1\u2082` and `\u03b2\u2081 \u2243 \u03b2\u2082`, then the type of embeddings `\u03b1\u2081 \u21aa \u03b2\u2081`\nis equivalent to the type of embeddings `\u03b1\u2082 \u21aa \u03b2\u2082`."}, {"name": "function.embedding.quotient_out", "description": "`quotient.out` as an embedding."}, {"name": "equiv.to_embedding", "description": " Convert an `\u03b1 \u2243 \u03b2` to `\u03b1 \u21aa \u03b2`.\n\nThis is also available as a coercion `equiv.coe_embedding`.\nThe explicit `equiv.to_embedding` version is preferred though, since the coercion can have issues\ninferring the type of the resulting embedding. For example:\n\n```lean\n-- Works:\nexample (s : finset (fin 3)) (f : equiv.perm (fin 3)) : s.map f.to_embedding = s.map f := by simp\n-- Error, `f` has type `fin 3 \u2243 fin 3` but is expected to have type `fin 3 \u21aa ?m_1 : Type ?`\nexample (s : finset (fin 3)) (f : equiv.perm (fin 3)) : s.map f = s.map f.to_embedding := by simp\n```"}, {"name": "equiv.embedding_congr_apply_trans", "description": ""}, {"name": "function.embedding.refl_apply", "description": ""}, {"name": "equiv.embedding_congr_refl", "description": ""}, {"name": "equiv.embedding_congr_trans", "description": ""}, {"name": "equiv.subtype_injective_equiv_embedding", "description": "The type of embeddings `\u03b1 \u21aa \u03b2` is equivalent to\n   the subtype of all injective functions `\u03b1 \u2192 \u03b2`."}, {"name": "subtype_or_left_embedding_apply_left", "description": ""}, {"name": "function.embedding.coe_prod_map", "description": ""}, {"name": "function.embedding.image", "description": "`set.image` as an embedding `set \u03b1 \u21aa set \u03b2`."}, {"name": "function.embedding.ext", "description": ""}, {"name": "function.embedding.option_map", "description": "A version of `option.map` for `function.embedding`s."}, {"name": "function.embedding.equiv_of_surjective", "description": "Convert a surjective `embedding` to an `equiv`"}, {"name": "function.embedding.sigma_mk", "description": "`sigma.mk` as an `function.embedding`."}, {"name": "function.embedding.can_lift", "description": ""}, {"name": "equiv.coe_embedding", "description": ""}, {"name": "function.embedding.swap_comp", "description": ""}, {"name": "function.embedding.coe_option", "description": "Embedding into `option \u03b1` using `coe`. Usually the correct synctatical form for `simp`."}, {"name": "function.embedding.coe_with_top_apply", "description": ""}, {"name": "function.embedding.inr", "description": "The embedding of `\u03b2` into the sum `\u03b1 \u2295 \u03b2`."}, {"name": "function.embedding.set_value", "description": " Change the value of an embedding `f` at one point. If the prescribed image\nis already occupied by some `f a'`, then swap the values at these two points."}, {"name": "equiv.perm.coe_embedding", "description": ""}, {"name": "function.embedding.set_value_eq", "description": ""}, {"name": "subtype_or_equiv_symm_inl", "description": ""}, {"name": "set.embedding_of_subset_apply", "description": ""}, {"name": "function.embedding.arrow_congr_left", "description": " An embedding `e : \u03b1 \u21aa \u03b2` defines an embedding `(\u03b1 \u2192 \u03b3) \u21aa (\u03b2 \u2192 \u03b3)` for any inhabited type `\u03b3`.\nThis embedding sends each `f : \u03b1 \u2192 \u03b3` to a function `g : \u03b2 \u2192 \u03b3` such that `g \u2218 e = f` and\n`g y = default` whenever `y \u2209 range e`."}, {"name": "function.embedding.sum_map", "description": "If `e\u2081` and `e\u2082` are embeddings, then so is `sum.map e\u2081 e\u2082`."}, {"name": "function.embedding.congr_apply", "description": ""}, {"name": "equiv.trans_to_embedding", "description": ""}, {"name": "function.embedding.image_apply", "description": ""}, {"name": "subtype_or_equiv_symm_inr", "description": ""}, {"name": "function.embedding.Pi_congr_right", "description": " Define an embedding `(\u03a0 a : \u03b1, \u03b2 a) \u21aa (\u03a0 a : \u03b1, \u03b3 a)` from a family of embeddings\n`e : \u03a0 a, (\u03b2 a \u21aa \u03b3 a)`. This embedding sends `f` to `\u03bb a, e a (f a)`."}, {"name": "function.embedding.option_embedding_equiv", "description": "Equivalence between embeddings of `option \u03b1` and a sigma type over the embeddings of `\u03b1`."}, {"name": "equiv.as_embedding", "description": " Given an equivalence to a subtype, produce an embedding to the elements of the corresponding\nset."}, {"name": "order_dual.no_min_order", "description": ""}, {"name": "is_top.fst", "description": ""}, {"name": "is_bot.prod_mk", "description": ""}, {"name": "nonempty_gt", "description": ""}, {"name": "is_top.mono", "description": ""}, {"name": "is_bot_of_dual_iff", "description": ""}, {"name": "prod.is_max_iff", "description": ""}, {"name": "is_max.eq_of_le", "description": ""}, {"name": "is_top_to_dual_iff", "description": ""}, {"name": "is_max.eq_of_ge", "description": ""}, {"name": "no_top_order", "description": "Order without top elements."}, {"name": "no_top_order.exists_not_le", "description": "Order without top elements."}, {"name": "is_min_of_dual_iff", "description": ""}, {"name": "no_min_order", "description": "Order without minimal elements. Sometimes called coinitial or dense."}, {"name": "no_min_order.exists_lt", "description": "Order without minimal elements. Sometimes called coinitial or dense."}, {"name": "is_max.prod_mk", "description": ""}, {"name": "is_max.not_lt", "description": ""}, {"name": "nonempty_lt", "description": ""}, {"name": "not_is_min_iff", "description": ""}, {"name": "order_dual.no_bot_order", "description": ""}, {"name": "is_min.snd", "description": ""}, {"name": "is_bot.to_dual", "description": "**Alias** of the reverse direction of `is_top_to_dual_iff`."}, {"name": "is_min_to_dual_iff", "description": ""}, {"name": "prod.is_bot_iff", "description": ""}, {"name": "is_max_iff_forall_not_lt", "description": ""}, {"name": "not_is_max", "description": ""}, {"name": "is_bot.is_min", "description": ""}, {"name": "is_max.of_dual", "description": "**Alias** of the reverse direction of `is_min_of_dual_iff`."}, {"name": "is_min.fst", "description": ""}, {"name": "is_top", "description": " `a : \u03b1` is a top element of `\u03b1` if it is greater than or equal to any other element of `\u03b1`.\nThis predicate is roughly an unbundled version of `order_bot`, except that a preorder may have\nseveral top elements. When `\u03b1` is linear, this is useful to make a case disjunction on\n`no_max_order \u03b1` within a proof."}, {"name": "is_bot.mono", "description": ""}, {"name": "subsingleton.is_min", "description": ""}, {"name": "order_dual.no_max_order", "description": ""}, {"name": "is_max.mono", "description": ""}, {"name": "is_bot.fst", "description": ""}, {"name": "is_top.prod_mk", "description": ""}, {"name": "prod.is_top_iff", "description": ""}, {"name": "is_max.fst", "description": ""}, {"name": "is_min.of_dual", "description": "**Alias** of the reverse direction of `is_max_of_dual_iff`."}, {"name": "is_min.eq_of_le", "description": ""}, {"name": "is_top.is_max", "description": ""}, {"name": "has_lt.lt.not_is_max", "description": "**Alias** of `not_is_max_of_lt`."}, {"name": "is_bot.of_dual", "description": "**Alias** of the reverse direction of `is_top_of_dual_iff`."}, {"name": "is_min.mono", "description": ""}, {"name": "is_top.of_dual", "description": "**Alias** of the reverse direction of `is_bot_of_dual_iff`."}, {"name": "is_max.to_dual", "description": "**Alias** of the reverse direction of `is_min_to_dual_iff`."}, {"name": "is_min_iff_forall_not_lt", "description": ""}, {"name": "is_min.eq_of_ge", "description": ""}, {"name": "is_max", "description": " `a` is a maximal element of `\u03b1` if no element is strictly greater than it. We spell it without\n`<` to avoid having to convert between `\u2264` and `<`. Instead, `is_max_iff_forall_not_lt` does the\nconversion."}, {"name": "is_bot_to_dual_iff", "description": ""}, {"name": "is_top.to_dual", "description": "**Alias** of the reverse direction of `is_bot_to_dual_iff`."}, {"name": "not_is_max_iff", "description": ""}, {"name": "not_is_bot", "description": ""}, {"name": "is_max_of_dual_iff", "description": ""}, {"name": "no_min_order.to_no_bot_order", "description": ""}, {"name": "is_min", "description": " `a` is a minimal element of `\u03b1` if no element is strictly less than it. We spell it without `<`\nto avoid having to convert between `\u2264` and `<`. Instead, `is_min_iff_forall_not_lt` does the\nconversion."}, {"name": "is_max_to_dual_iff", "description": ""}, {"name": "not_is_min_of_lt", "description": ""}, {"name": "not_is_min", "description": ""}, {"name": "no_bot_order", "description": "Order without bottom elements."}, {"name": "no_bot_order.exists_not_ge", "description": "Order without bottom elements."}, {"name": "is_max.snd", "description": ""}, {"name": "is_min.not_lt", "description": ""}, {"name": "no_max_order.to_no_top_order", "description": ""}, {"name": "not_is_max_of_lt", "description": ""}, {"name": "order_dual.no_top_order", "description": ""}, {"name": "not_is_top", "description": ""}, {"name": "subsingleton.is_top", "description": ""}, {"name": "is_bot", "description": " `a : \u03b1` is a bottom element of `\u03b1` if it is less than or equal to any other element of `\u03b1`.\nThis predicate is roughly an unbundled version of `order_bot`, except that a preorder may have\nseveral bottom elements. When `\u03b1` is linear, this is useful to make a case disjunction on\n`no_min_order \u03b1` within a proof."}, {"name": "subsingleton.is_max", "description": ""}, {"name": "prod.is_min_iff", "description": ""}, {"name": "is_min.to_dual", "description": "**Alias** of the reverse direction of `is_max_to_dual_iff`."}, {"name": "is_top_of_dual_iff", "description": ""}, {"name": "is_min.prod_mk", "description": ""}, {"name": "is_bot.snd", "description": ""}, {"name": "no_max_order", "description": "Order without maximal elements. Sometimes called cofinal."}, {"name": "no_max_order.exists_gt", "description": "Order without maximal elements. Sometimes called cofinal."}, {"name": "is_top.snd", "description": ""}, {"name": "has_lt.lt.not_is_min", "description": "**Alias** of `not_is_min_of_lt`."}, {"name": "subsingleton.is_bot", "description": ""}, {"name": "dlist.to_list_empty", "description": ""}, {"name": "dlist.to_list_concat", "description": ""}, {"name": "dlist.to_list_cons", "description": ""}, {"name": "dlist.of_list_to_list", "description": ""}, {"name": "dlist.concat", "description": "`O(1)` Append a single element to a dlist"}, {"name": "dlist.lazy_of_list", "description": "Convert a lazily-evaluated list to a dlist"}, {"name": "dlist.to_list_append", "description": ""}, {"name": "dlist.cons", "description": "`O(1)` Prepend a single element to a dlist"}, {"name": "dlist.empty", "description": "Create a dlist containing no elements"}, {"name": "dlist.singleton", "description": "Create dlist with a single element"}, {"name": "dlist.to_list", "description": "Convert a dlist to a list"}, {"name": "dlist.has_append", "description": ""}, {"name": "dlist.to_list_of_list", "description": ""}, {"name": "dlist.append", "description": "`O(1)` Append dlists"}, {"name": "dlist.of_list", "description": "Convert a list to a dlist"}, {"name": "dlist", "description": "A difference list is a function that, given a list, returns the original\ncontents of the difference list prepended to the given list.\n\nThis structure supports `O(1)` `append` and `concat` operations on lists, making it\nuseful for append-heavy uses such as logging and pretty printing."}, {"name": "dlist.apply", "description": "A difference list is a function that, given a list, returns the original\ncontents of the difference list prepended to the given list.\n\nThis structure supports `O(1)` `append` and `concat` operations on lists, making it\nuseful for append-heavy uses such as logging and pretty printing."}, {"name": "dlist.invariant", "description": "A difference list is a function that, given a list, returns the original\ncontents of the difference list prepended to the given list.\n\nThis structure supports `O(1)` `append` and `concat` operations on lists, making it\nuseful for append-heavy uses such as logging and pretty printing."}, {"name": "dlist.to_list_singleton", "description": ""}, {"name": "quarterround_examples.example0_quarterround", "description": "quarterround 0 0 0 0 = 0 0 0 0"}, {"name": "quarterround_examples.example2_qr1", "description": ""}, {"name": "quarterround_examples.example1_qr3", "description": ""}, {"name": "quarterround_examples.example1_qr2", "description": ""}, {"name": "quarterround_examples.example1_quarterround", "description": "example 2 -"}, {"name": "quarterround_examples.example1_qr1", "description": ""}, {"name": "quarterround_examples.example1_qr0", "description": ""}, {"name": "string.quote", "description": ""}, {"name": "string.quote_aux", "description": ""}, {"name": "repr", "description": " `repr` is similar to `to_string` except that we should have the property `eval (repr x) = x` for most sensible datatypes.\nHence, `repr \"hello\"` has the value `\"\\\"hello\\\"\"` not `\"hello\"`."}, {"name": "list.repr_aux", "description": ""}, {"name": "char.repr", "description": ""}, {"name": "nat.to_digits", "description": ""}, {"name": "nat.repr", "description": ""}, {"name": "list.repr", "description": ""}, {"name": "unsigned.has_repr", "description": ""}, {"name": "nat.digit_char", "description": ""}, {"name": "has_repr", "description": "Implement `has_repr` if the output string is valid lean code that evaluates back to the original object.\nIf you just want to view the object as a string for a trace message, use `has_to_string`.\n\n### Example:\n\n```lean\n#eval to_string \"hello world\"\n-- [Lean] \"hello world\"\n#eval repr \"hello world\"\n-- [Lean] \"\\\"hello world\\\"\"\n```\n\nReference: https://github.com/leanprover/lean/issues/1664"}, {"name": "has_repr.repr", "description": "Implement `has_repr` if the output string is valid lean code that evaluates back to the original object.\nIf you just want to view the object as a string for a trace message, use `has_to_string`.\n\n### Example:\n\n```lean\n#eval to_string \"hello world\"\n-- [Lean] \"hello world\"\n#eval repr \"hello world\"\n-- [Lean] \"\\\"hello world\\\"\"\n```\n\nReference: https://github.com/leanprover/lean/issues/1664"}, {"name": "fin.has_repr", "description": ""}, {"name": "hex_digit_repr", "description": ""}, {"name": "list.has_repr", "description": ""}, {"name": "option.has_repr", "description": ""}, {"name": "subtype.has_repr", "description": ""}, {"name": "sum.has_repr", "description": ""}, {"name": "char_to_hex", "description": ""}, {"name": "prod.has_repr", "description": ""}, {"name": "string.has_repr", "description": ""}, {"name": "char.quote_core", "description": ""}, {"name": "decidable.has_repr", "description": ""}, {"name": "unit.has_repr", "description": ""}, {"name": "bool.has_repr", "description": ""}, {"name": "nat.digit_succ", "description": ""}, {"name": "nat.has_repr", "description": ""}, {"name": "char.has_repr", "description": ""}, {"name": "sigma.has_repr", "description": ""}, {"name": "interactive.types.ident_", "description": "Parse an identifier or a '_'"}, {"name": "interactive.with_desc.reflectable", "description": ""}, {"name": "interactive.types.opt_pexpr_list", "description": ""}, {"name": "interactive.types.only_flag", "description": ""}, {"name": "interactive.types.with_ident_list", "description": ""}, {"name": "interactive.types.pexpr_list", "description": ""}, {"name": "interactive.loc.try_apply", "description": ""}, {"name": "interactive.noncomputable_modifier", "description": ""}, {"name": "interactive.noncomputable_modifier.computable", "description": ""}, {"name": "interactive.noncomputable_modifier.noncomputable", "description": ""}, {"name": "interactive.noncomputable_modifier.force_noncomputable", "description": ""}, {"name": "interactive.with_desc", "description": "Use `desc` as the interactive description of `p`."}, {"name": "interactive.types.tac_rbp", "description": "The right-binding power 2 will terminate expressions by\n   '<|>' (rbp 2), ';' (rbp 1), and ',' (rbp 0). It should be used for any (potentially)\n   trailing expression parameters."}, {"name": "interactive.types.without_ident_list", "description": ""}, {"name": "interactive.loc", "description": "A `loc` is either a 'wildcard', which means \"everywhere\", or a list of `option name`s. `none` means `target` and `some n` means `n` in the local context."}, {"name": "interactive.loc.wildcard", "description": "A `loc` is either a 'wildcard', which means \"everywhere\", or a list of `option name`s. `none` means `target` and `some n` means `n` in the local context."}, {"name": "interactive.loc.ns", "description": "A `loc` is either a 'wildcard', which means \"everywhere\", or a list of `option name`s. `none` means `target` and `some n` means `n` in the local context."}, {"name": "interactive.types.pexpr_list_or_texpr", "description": ""}, {"name": "interactive.types.texpr", "description": "A 'tactic expression', which uses right-binding power 2 so that it is terminated by\n   '<|>' (rbp 2), ';' (rbp 1), and ',' (rbp 0). It should be used for any (potentially)\n   trailing expression parameters."}, {"name": "interactive.decl_attributes.apply", "description": ""}, {"name": "interactive.decl_modifiers", "description": ""}, {"name": "interactive.decl_modifiers.is_private", "description": ""}, {"name": "interactive.decl_modifiers.is_protected", "description": ""}, {"name": "interactive.decl_modifiers.is_meta", "description": ""}, {"name": "interactive.decl_modifiers.is_mutual", "description": ""}, {"name": "interactive.decl_modifiers.is_noncomputable", "description": ""}, {"name": "interactive.decl_attributes", "description": ""}, {"name": "interactive.inductive_decl.parse", "description": "Parses and elaborates a single or multiple mutual inductive declarations (without the `inductive` keyword), depending on `is_mutual`"}, {"name": "interactive.loc.get_locals", "description": ""}, {"name": "interactive.loc.include_goal", "description": ""}, {"name": "format_macro", "description": ""}, {"name": "interactive.inductive_decl", "description": ""}, {"name": "interactive.inductive_decl.u_names", "description": ""}, {"name": "interactive.inductive_decl.params", "description": ""}, {"name": "interactive.inductive_decl.decls", "description": ""}, {"name": "interactive.parse_binders", "description": ""}, {"name": "interactive.parse_binders_core", "description": ""}, {"name": "interactive.single_inductive_decl.name", "description": ""}, {"name": "sformat_macro", "description": ""}, {"name": "interactive.loc.apply", "description": ""}, {"name": "interactive.param_desc", "description": ""}, {"name": "interactive.types.using_ident", "description": ""}, {"name": "interactive.parse", "description": "(parse p) as the parameter type of an interactive tactic will instruct the Lean parser\n   to run `p` when parsing the parameter and to pass the parsed value as an argument\n   to the tactic."}, {"name": "interactive.single_inductive_decl", "description": ""}, {"name": "interactive.single_inductive_decl.attrs", "description": ""}, {"name": "interactive.single_inductive_decl.sig", "description": ""}, {"name": "interactive.single_inductive_decl.intros", "description": ""}, {"name": "interactive.types.location", "description": ""}, {"name": "interactive.types.list_of", "description": ""}, {"name": "interactive.decl_meta_info", "description": ""}, {"name": "interactive.decl_meta_info.attrs", "description": ""}, {"name": "interactive.decl_meta_info.modifiers", "description": ""}, {"name": "interactive.decl_meta_info.doc_string", "description": ""}, {"name": "interactive.types.brackets", "description": ""}, {"name": "rowround.rowround_inv", "description": "Reverses `rowround` by doing `rowround_single_inv` to get the original matrix output"}, {"name": "rowround.rowround_is_inv", "description": "For any `rowround` output, we can get back to original values using the defined inverse."}, {"name": "rowround.rowround_inv_is_inverse_of_rowround", "description": "It is easy to see that `cat_rowround\u207b\u00b9` after `cat_rowround` produces the original object."}, {"name": "rowround.n_succ_16", "description": "A helper proposition that should be \"easy\" to prove but i don't know how yet."}, {"name": "rowround.cat_rowround", "description": ""}, {"name": "rowround.rowround_single_inv", "description": "The inverse of a single row round."}, {"name": "rowround.rowround_single", "description": "The row round of a single row. Complete `rowround` function will use 4 of this."}, {"name": "rowround.rowround", "description": "Apply `rowround_single` to get a row round matrix output"}, {"name": "rowround.rowround_is_isomorphic", "description": "Two categories are isomrphic if `f \u2218 g = id_f` and `g \u2218 f = id_g`."}, {"name": "rowround.rowroundType", "description": "A rowround structure is four `quarterroundType`s."}, {"name": "rowround.rowroundType.rowround1", "description": "A rowround structure is four `quarterroundType`s."}, {"name": "rowround.rowroundType.rowround2", "description": "A rowround structure is four `quarterroundType`s."}, {"name": "rowround.rowroundType.rowround3", "description": "A rowround structure is four `quarterroundType`s."}, {"name": "rowround.rowroundType.rowround4", "description": "A rowround structure is four `quarterroundType`s."}, {"name": "rowround.carry_diff_rowround_for_any_row_and_value", "description": "Proof that the difference is carried for any row and any value of the input matrices."}, {"name": "rowround.diff_carried_rowround", "description": "Get the difference property of `rowround` given a position `n` for a random and crafted inputs."}, {"name": "rowround.input_random", "description": "Define a random input as a 4x4 matrix."}, {"name": "rowround.cat_rowround_inv", "description": ""}, {"name": "rowround.rowround_single_is_inv", "description": "Each row is invertible."}, {"name": "rowround.rowround_difference_is_carried", "description": " Put together all the properties needed to prove that `rowround` carries the differfence for random and\ncrafted inputs."}, {"name": "rowround.rowround_is_left_invariant", "description": "`rowround` is left invariant."}, {"name": "rowround.input_crafted", "description": "Define a crafted input based on the random input as a 4x4 matrix."}, {"name": "rowround.carry_diff_rowround_for_any_row_and_value'", "description": ""}, {"name": "rowround.id_rowround", "description": "The identity of a `rowround` function given a sequence is the sequence."}, {"name": "rowround.diff_carried_prop_n", "description": ""}, {"name": "rowround.input", "description": "An input of this form should be invariant."}, {"name": "rowround.rowround'", "description": " This rowround call will sort all the elements of the input and the output to match salsa20.\nIt should be used in `doubleround`."}, {"name": "rowround.isomorphism_left", "description": "Isomorphism condition 1 : `f \u2218 g = id_f`"}, {"name": "rowround.id_rowround_inv", "description": "The identity of a `rowround_inv` function given a sequence is the sequence."}, {"name": "rowround.rowround_inv'", "description": " This rowround inverse call will sort all the elements of the input and the output to match salsa20.\nIt should be used in `doubleround`."}, {"name": "rowround.isomorphism_right", "description": "Isomorphism condition 2 : `g \u2218 f = id_g`"}, {"name": "map_nat_cast", "description": ""}, {"name": "nat.cast_with_bot", "description": ""}, {"name": "nat.cast_lt", "description": ""}, {"name": "nat.one_le_cast", "description": ""}, {"name": "with_top.add_one_le_of_lt", "description": ""}, {"name": "eq_nat_cast", "description": ""}, {"name": "ext_nat", "description": ""}, {"name": "prod.snd_nat_cast", "description": ""}, {"name": "nat.unique_ring_hom", "description": ""}, {"name": "ext_nat'", "description": ""}, {"name": "nat.cast_commute", "description": ""}, {"name": "has_dvd.dvd.nat_cast", "description": "**Alias** of `nat.coe_nat_dvd`."}, {"name": "prod.add_monoid_with_one", "description": ""}, {"name": "nat.coe_nat_dvd", "description": ""}, {"name": "nat.cast_ring_hom_nat", "description": ""}, {"name": "with_top.coe_nat", "description": ""}, {"name": "nat.cast_id", "description": ""}, {"name": "nat.cast_add_monoid_hom", "description": "`coe : \u2115 \u2192 \u03b1` as an `add_monoid_hom`."}, {"name": "pi.has_nat_cast", "description": ""}, {"name": "mul_opposite.unop_nat_cast", "description": ""}, {"name": "add_monoid_hom.ext_nat", "description": ""}, {"name": "nat.cast_max", "description": ""}, {"name": "eq_nat_cast'", "description": ""}, {"name": "mul_opposite.op_nat_cast", "description": ""}, {"name": "nat.cast_lt_one", "description": ""}, {"name": "ring_hom.eq_nat_cast'", "description": "This is primed to match `ring_hom.eq_int_cast'`."}, {"name": "nat.cast_add_one_pos", "description": ""}, {"name": "monoid_with_zero_hom.ext_nat", "description": ""}, {"name": "nat.coe_cast_add_monoid_hom", "description": ""}, {"name": "pi.nat_apply", "description": ""}, {"name": "nat.coe_cast_ring_hom", "description": ""}, {"name": "nat.commute_cast", "description": ""}, {"name": "nat.cast_ring_hom", "description": "`coe : \u2115 \u2192 \u03b1` as a `ring_hom`"}, {"name": "ext_nat''", "description": "If two `monoid_with_zero_hom`s agree on the positive naturals they are equal."}, {"name": "sum.elim_nat_cast_nat_cast", "description": ""}, {"name": "nat.mono_cast", "description": ""}, {"name": "nat.cast_pos", "description": ""}, {"name": "with_top.nat_ne_top", "description": ""}, {"name": "nat.cast_mul", "description": ""}, {"name": "nat.cast_nonneg", "description": ""}, {"name": "map_nat_cast'", "description": ""}, {"name": "nat.cast_le", "description": ""}, {"name": "prod.fst_nat_cast", "description": ""}, {"name": "with_top.top_ne_nat", "description": ""}, {"name": "nat.cast_comm", "description": ""}, {"name": "with_top.nat_induction", "description": ""}, {"name": "with_top.one_le_iff_pos", "description": ""}, {"name": "nat.abs_cast", "description": ""}, {"name": "nat.cast_min", "description": ""}, {"name": "nat.cast_le_one", "description": ""}, {"name": "pi.add_monoid_with_one", "description": ""}, {"name": "pi.coe_nat", "description": ""}, {"name": "nat.one_lt_cast", "description": ""}, {"name": "feature_search.feature_vec.has_to_string", "description": ""}, {"name": "feature_search.predictor_type.decidable_eq", "description": ""}, {"name": "feature_search.feature_vec.of_expr", "description": ""}, {"name": "feature_search.feature.repr", "description": ""}, {"name": "feature_search.feature.has_to_tactic_format", "description": ""}, {"name": "feature_search.feature_vec.union", "description": ""}, {"name": "feature_search.predictor", "description": ""}, {"name": "feature_search.feature_vec.of_thm", "description": ""}, {"name": "feature_search.feature_vec.has_to_tactic_format", "description": ""}, {"name": "feature_search.feature_stats.has_to_format", "description": ""}, {"name": "feature_search.feature.has_to_string", "description": ""}, {"name": "feature_search.predictor_type", "description": ""}, {"name": "feature_search.predictor_type.knn", "description": ""}, {"name": "feature_search.predictor_type.mepo", "description": ""}, {"name": "feature_search.predictor_type.bayes", "description": ""}, {"name": "feature_search.feature_stats.cosine_similarity", "description": ""}, {"name": "feature_search.feature_vec.of_proof", "description": ""}, {"name": "feature_search.feature_vec.has_to_format", "description": ""}, {"name": "feature_search.feature.decidable_eq", "description": ""}, {"name": "feature_search.feature_vec.to_list", "description": ""}, {"name": "feature_search.feature", "description": ""}, {"name": "feature_search.feature.const", "description": ""}, {"name": "feature_search.feature.arg", "description": ""}, {"name": "feature_search.feature_stats.dotp", "description": ""}, {"name": "feature_search.feature_cfg", "description": ""}, {"name": "feature_search.feature_cfg.ignore_tc", "description": ""}, {"name": "feature_search.feature_cfg.ignore_pi_domain", "description": ""}, {"name": "feature_search.feature_cfg.ignore_type_args", "description": ""}, {"name": "feature_search.feature_cfg.ignore_decidable", "description": ""}, {"name": "feature_search.feature_cfg.ignore_conns", "description": ""}, {"name": "feature_search.feature_stats.features", "description": ""}, {"name": "feature_search.feature_stats.of_feature_vecs", "description": ""}, {"name": "feature_search.feature_vec.of_exprs", "description": ""}, {"name": "feature_search.feature_stats.has_to_tactic_format", "description": ""}, {"name": "feature_search.feature.to_string", "description": ""}, {"name": "feature_search.feature_vec", "description": ""}, {"name": "feature_search.feature_vec.isect", "description": ""}, {"name": "feature_search.feature_stats", "description": ""}, {"name": "feature_search.feature_vec.has_repr", "description": ""}, {"name": "feature_search.predictor.predict", "description": ""}, {"name": "feature_search.feature_stats.norm", "description": ""}, {"name": "environment.mk_predictor", "description": ""}, {"name": "feature_search.feature_stats.has_to_string", "description": ""}, {"name": "feature_search.feature_vec.has_inter", "description": ""}, {"name": "feature_search.feature.has_repr", "description": ""}, {"name": "feature_search.feature_vec.has_union", "description": ""}, {"name": "feature_search.feature_stats.features_with_idf", "description": ""}, {"name": "feature_search.feature_stats.has_repr", "description": ""}, {"name": "feature_search.feature_stats.idf", "description": ""}, {"name": "feature_search.predictor_cfg", "description": ""}, {"name": "feature_search.predictor_cfg.to_feature_cfg", "description": ""}, {"name": "feature_search.predictor_cfg.type", "description": ""}, {"name": "feature_search.feature.has_to_format", "description": ""}, {"name": "category_theory.iso.op_hom", "description": ""}, {"name": "category_theory.nat_trans.remove_left_op_id", "description": ""}, {"name": "category_theory.functor.left_op_right_op_equiv_unit_iso", "description": ""}, {"name": "category_theory.op_op_equivalence_counit_iso", "description": ""}, {"name": "category_theory.nat_trans.remove_right_op", "description": "Given a natural transformation `\u03b1 : F.right_op \u27f6 G.right_op`, for `F G : C\u1d52\u1d56 \u2964 D`,\ntaking `unop` of each component gives a natural transformation `G \u27f6 F`."}, {"name": "category_theory.functor.op_unop_equiv_functor", "description": ""}, {"name": "category_theory.functor.op_unop_equiv", "description": "The equivalence of functor categories induced by `op` and `unop`."}, {"name": "category_theory.nat_trans.op_app", "description": ""}, {"name": "category_theory.functor.left_op_map", "description": ""}, {"name": "category_theory.functor.unop", "description": "Given a functor `F : C\u1d52\u1d56 \u2964 D\u1d52\u1d56` we can take the \"unopposite\" functor `F : C \u2964 D`.\nIn informal mathematics no distinction is made between these."}, {"name": "category_theory.equivalence.op_counit_iso", "description": ""}, {"name": "category_theory.iso_op_equiv_symm_apply", "description": ""}, {"name": "category_theory.functor.right_op", "description": "Another variant of the opposite of functor, turning a functor `C\u1d52\u1d56 \u2964 D` into a functor `C \u2964 D\u1d52\u1d56`.\nIn informal mathematics no distinction is made."}, {"name": "category_theory.nat_iso.remove_op_inv", "description": ""}, {"name": "category_theory.op_equiv", "description": " The equivalence between arrows of the form `A \u27f6 B` and `B.unop \u27f6 A.unop`. Useful for building\nadjunctions.\nNote that this (definitionally) gives variants\n```lean\ndef op_equiv' (A : C) (B : C\u1d52\u1d56) : (opposite.op A \u27f6 B) \u2243 (B.unop \u27f6 A) :=\nop_equiv _ _\n\ndef op_equiv'' (A : C\u1d52\u1d56) (B : C) : (A \u27f6 opposite.op B) \u2243 (B \u27f6 A.unop) :=\nop_equiv _ _\n\ndef op_equiv''' (A B : C) : (opposite.op A \u27f6 opposite.op B) \u2243 (B \u27f6 A) :=\nop_equiv _ _\n```"}, {"name": "quiver.hom.unop_op", "description": ""}, {"name": "category_theory.iso.unop_inv", "description": ""}, {"name": "category_theory.iso.unop_hom", "description": ""}, {"name": "category_theory.nat_iso.op_inv", "description": ""}, {"name": "category_theory.functor.op_unop_equiv_inverse", "description": ""}, {"name": "category_theory.functor.op.category_theory.full", "description": ""}, {"name": "category_theory.op_inv", "description": ""}, {"name": "category_theory.nat_trans.remove_right_op_app", "description": ""}, {"name": "category_theory.op_op_equivalence_functor", "description": ""}, {"name": "category_theory.functor.left_op_right_op_equiv", "description": "The equivalence of functor categories induced by `left_op` and `right_op`."}, {"name": "category_theory.nat_iso.unop_hom", "description": ""}, {"name": "category_theory.functor.op_unop_iso_inv_app", "description": ""}, {"name": "category_theory.nat_trans.op", "description": "The opposite of a natural transformation."}, {"name": "category_theory.nat_trans.unop", "description": "The \"unopposite\" of a natural transformation."}, {"name": "category_theory.nat_trans.unop_id", "description": ""}, {"name": "category_theory.functor.right_op_faithful", "description": "If F is faithful then the right_op of F is also faithful."}, {"name": "category_theory.iso.op_unop", "description": ""}, {"name": "category_theory.functor.op_inv_map", "description": ""}, {"name": "category_theory.nat_trans.left_op_app", "description": ""}, {"name": "category_theory.nat_iso.unop_inv", "description": ""}, {"name": "category_theory.nat_trans.left_op_comp", "description": ""}, {"name": "category_theory.unop_inv", "description": ""}, {"name": "category_theory.unop_id_op", "description": ""}, {"name": "category_theory.nat_iso.op", "description": " The natural isomorphism between opposite functors `G.op \u2245 F.op` induced by a natural\nisomorphism between the original functors `F \u2245 G`."}, {"name": "category_theory.functor.unop_op_iso", "description": "The isomorphism between `F.unop.op` and `F`."}, {"name": "category_theory.functor.op.category_theory.faithful", "description": ""}, {"name": "category_theory.functor.left_op", "description": "Another variant of the opposite of functor, turning a functor `C \u2964 D\u1d52\u1d56` into a functor `C\u1d52\u1d56 \u2964 D`.\nIn informal mathematics no distinction is made."}, {"name": "category_theory.functor.op_hom", "description": "Taking the opposite of a functor is functorial."}, {"name": "category_theory.iso.op", "description": "The opposite isomorphism."}, {"name": "category_theory.op_op_equivalence", "description": "The double opposite category is equivalent to the original."}, {"name": "category_theory.equivalence.op_inverse", "description": ""}, {"name": "category_theory.nat_trans.left_op", "description": "Given a natural transformation `\u03b1 : F \u27f6 G`, for `F G : C \u2964 D\u1d52\u1d56`,\ntaking `unop` of each component gives a natural transformation `G.left_op \u27f6 F.left_op`."}, {"name": "category_theory.functor.op_unop_equiv_counit_iso", "description": ""}, {"name": "category_theory.is_iso_unop", "description": ""}, {"name": "category_theory.functor.op_hom_map_app", "description": ""}, {"name": "category_theory.nat_trans.right_op_app", "description": ""}, {"name": "category_theory.equivalence.unop_inverse", "description": ""}, {"name": "category_theory.unop_unop_obj", "description": ""}, {"name": "category_theory.functor.left_op_right_op_iso_inv_app", "description": ""}, {"name": "category_theory.nat_iso.unop", "description": " The natural isomorphism between functors `G.unop \u2245 F.unop` induced by a natural isomorphism\nbetween the original functors `F \u2245 G`."}, {"name": "category_theory.functor.unop_op_iso_hom_app", "description": ""}, {"name": "category_theory.equivalence.op_functor", "description": ""}, {"name": "category_theory.nat_trans.right_op_id", "description": ""}, {"name": "category_theory.functor.op_unop_equiv_unit_iso", "description": ""}, {"name": "category_theory.is_iso_op", "description": "If `f` is an isomorphism, so is `f.op`"}, {"name": "category_theory.iso.op_inv", "description": ""}, {"name": "category_theory.iso_op_equiv", "description": "The equivalence between isomorphisms of the form `A \u2245 B` and `B.unop \u2245 A.unop`.\n\nNote this is definitionally the same as the other three variants:\n* `(opposite.op A \u2245 B) \u2243 (B.unop \u2245 A)`\n* `(A \u2245 opposite.op B) \u2243 (B \u2245 A.unop)`\n* `(opposite.op A \u2245 opposite.op B) \u2243 (B \u2245 A)`"}, {"name": "category_theory.op_comp", "description": ""}, {"name": "category_theory.equivalence.unop_functor", "description": ""}, {"name": "category_theory.nat_iso.remove_op_hom", "description": ""}, {"name": "category_theory.nat_trans.right_op_comp", "description": ""}, {"name": "category_theory.functor.left_op_right_op_equiv_inverse_obj", "description": ""}, {"name": "category_theory.functor.left_op_right_op_iso", "description": "The isomorphism between `F.left_op.right_op` and `F`."}, {"name": "category_theory.category.opposite", "description": "The opposite category.\n\nSee <https://stacks.math.columbia.edu/tag/001M>."}, {"name": "category_theory.functor.op_inv_obj", "description": ""}, {"name": "category_theory.op_equiv_symm_apply", "description": ""}, {"name": "category_theory.functor.left_op_obj", "description": ""}, {"name": "category_theory.nat_trans.remove_left_op_app", "description": ""}, {"name": "category_theory.functor.op_hom_obj", "description": ""}, {"name": "category_theory.unop_unop_map", "description": ""}, {"name": "category_theory.equivalence.op_unit_iso", "description": ""}, {"name": "category_theory.nat_trans.op_id", "description": ""}, {"name": "category_theory.nat_iso.op_hom", "description": ""}, {"name": "category_theory.is_iso_op_iff", "description": ""}, {"name": "category_theory.nat_trans.left_op_id", "description": ""}, {"name": "category_theory.nat_iso.remove_op", "description": " The natural isomorphism between functors `G \u2245 F` induced by a natural isomorphism\nbetween the opposite functors `F.op \u2245 G.op`."}, {"name": "category_theory.op_op_equivalence_inverse", "description": ""}, {"name": "category_theory.iso.unop_op", "description": ""}, {"name": "category_theory.unop_id", "description": ""}, {"name": "category_theory.functor.left_op_faithful", "description": "If F is faithful then the left_op of F is also faithful."}, {"name": "category_theory.op_op", "description": "The functor from the double-opposite of a category to the underlying category."}, {"name": "category_theory.functor.op_map", "description": ""}, {"name": "category_theory.nat_trans.remove_left_op", "description": "Given a natural transformation `\u03b1 : F.left_op \u27f6 G.left_op`, for `F G : C \u2964 D\u1d52\u1d56`,\ntaking `op` of each component gives a natural transformation `G \u27f6 F`."}, {"name": "category_theory.op_op_obj", "description": ""}, {"name": "category_theory.functor.right_op_map", "description": ""}, {"name": "category_theory.functor.unop_map", "description": ""}, {"name": "category_theory.decidable_eq_of_unop", "description": ""}, {"name": "category_theory.functor.op_unop_iso", "description": "The isomorphism between `F.op.unop` and `F`."}, {"name": "category_theory.nat_trans.remove_unop_id", "description": ""}, {"name": "category_theory.functor.op_inv", "description": "Take the \"unopposite\" of a functor is functorial."}, {"name": "category_theory.functor.op", "description": "The opposite of a functor, i.e. considering a functor `F : C \u2964 D` as a functor `C\u1d52\u1d56 \u2964 D\u1d52\u1d56`.\nIn informal mathematics no distinction is made between these."}, {"name": "category_theory.nat_trans.remove_op_id", "description": ""}, {"name": "category_theory.functor.left_op_right_op_equiv_functor_map", "description": ""}, {"name": "category_theory.nat_trans.right_op", "description": "Given a natural transformation `\u03b1 : F \u27f6 G`, for `F G : C\u1d52\u1d56 \u2964 D`,\ntaking `op` of each component gives a natural transformation `G.right_op \u27f6 F.right_op`."}, {"name": "category_theory.equivalence.unop", "description": "An equivalence between opposite categories gives an equivalence between the original categories."}, {"name": "category_theory.functor.right_op_obj", "description": ""}, {"name": "category_theory.functor.unop_op_iso_inv_app", "description": ""}, {"name": "category_theory.functor.left_op_right_op_iso_hom_app", "description": ""}, {"name": "category_theory.functor.unop_obj", "description": ""}, {"name": "category_theory.equivalence.unop_counit_iso", "description": ""}, {"name": "category_theory.nat_trans.remove_unop_app", "description": ""}, {"name": "category_theory.op_id", "description": ""}, {"name": "category_theory.functor.op_obj", "description": ""}, {"name": "quiver.hom.unop_inj", "description": ""}, {"name": "category_theory.functor.left_op_right_op_equiv_counit_iso", "description": ""}, {"name": "category_theory.nat_trans.remove_op", "description": "Given a natural transformation `\u03b1 : F.op \u27f6 G.op`,\nwe can take the \"unopposite\" of each component obtaining a natural transformation `G \u27f6 F`."}, {"name": "quiver.hom.op_unop", "description": ""}, {"name": "category_theory.functor.left_op_right_op_equiv_inverse_map", "description": ""}, {"name": "category_theory.functor.right_op_left_op_iso_hom_app", "description": ""}, {"name": "category_theory.iso.unop", "description": "The isomorphism obtained from an isomorphism in the opposite category."}, {"name": "category_theory.nat_trans.remove_right_op_id", "description": ""}, {"name": "category_theory.nat_trans.remove_unop", "description": " Given a natural transformation `\u03b1 : F.unop \u27f6 G.unop`, we can take the opposite of each\ncomponent obtaining a natural transformation `G \u27f6 F`."}, {"name": "category_theory.op_id_unop", "description": ""}, {"name": "category_theory.unop_comp", "description": ""}, {"name": "category_theory.op_op_equivalence_unit_iso", "description": ""}, {"name": "category_theory.nat_trans.unop_app", "description": ""}, {"name": "category_theory.subsingleton_of_unop", "description": ""}, {"name": "category_theory.functor.right_op_left_op_iso_inv_app", "description": ""}, {"name": "category_theory.is_iso_of_op", "description": "If `f.op` is an isomorphism `f` must be too.\n(This cannot be an instance as it would immediately loop!)"}, {"name": "category_theory.functor.op_unop_iso_hom_app", "description": ""}, {"name": "category_theory.equivalence.op", "description": "An equivalence between categories gives an equivalence between the opposite categories."}, {"name": "quiver.hom.op_inj", "description": ""}, {"name": "category_theory.unop_unop", "description": "The functor from a category to its double-opposite."}, {"name": "category_theory.op_equiv_apply", "description": ""}, {"name": "category_theory.iso_op_equiv_apply", "description": ""}, {"name": "category_theory.functor.right_op_left_op_iso", "description": "The isomorphism between `F.right_op.left_op` and `F`."}, {"name": "category_theory.functor.left_op_right_op_equiv_functor_obj", "description": ""}, {"name": "category_theory.equivalence.unop_unit_iso", "description": ""}, {"name": "category_theory.op_op_map", "description": ""}, {"name": "category_theory.is_iso_unop_iff", "description": ""}, {"name": "category_theory.nat_trans.remove_op_app", "description": ""}, {"name": "category_theory.iso.inv_hom_id_app", "description": ""}, {"name": "category_theory.nat_iso.cancel_nat_iso_inv_right", "description": ""}, {"name": "category_theory.iso.inv_hom_id_app_assoc", "description": ""}, {"name": "category_theory.iso.app_inv", "description": ""}, {"name": "category_theory.nat_iso.cancel_nat_iso_inv_right_assoc", "description": ""}, {"name": "category_theory.nat_iso.naturality_1'", "description": ""}, {"name": "category_theory.iso.hom_inv_id_app", "description": ""}, {"name": "category_theory.nat_iso.app_hom", "description": ""}, {"name": "category_theory.iso.app", "description": " The application of a natural isomorphism to an object. We put this definition in a different\nnamespace, so that we can use `\u03b1.app`"}, {"name": "category_theory.nat_iso.of_components_inv_app", "description": ""}, {"name": "category_theory.nat_iso.hom_app_is_iso", "description": ""}, {"name": "category_theory.nat_iso.cancel_nat_iso_hom_right_assoc", "description": ""}, {"name": "category_theory.nat_iso.naturality_2'_assoc", "description": ""}, {"name": "category_theory.iso.hom_inv_id_app_assoc", "description": ""}, {"name": "category_theory.nat_iso.is_iso_app_of_is_iso", "description": "The components of a natural isomorphism are isomorphisms."}, {"name": "category_theory.nat_iso.of_components", "description": "Construct a natural isomorphism between functors by giving object level isomorphisms,\nand checking naturality only in the forward direction."}, {"name": "category_theory.nat_iso.naturality_1", "description": ""}, {"name": "category_theory.nat_iso.cancel_nat_iso_inv_left", "description": ""}, {"name": "category_theory.iso.app_hom", "description": ""}, {"name": "category_theory.nat_iso.app_inv", "description": ""}, {"name": "category_theory.nat_iso.inv_app_is_iso", "description": ""}, {"name": "category_theory.nat_iso.naturality_2'", "description": ""}, {"name": "category_theory.nat_iso.cancel_nat_iso_hom_left", "description": ""}, {"name": "category_theory.nat_iso.cancel_nat_iso_hom_right", "description": ""}, {"name": "category_theory.nat_iso.hcomp", "description": "Horizontal composition of natural isomorphisms."}, {"name": "category_theory.nat_iso.is_iso_of_is_iso_app", "description": "A natural transformation is an isomorphism if all its components are isomorphisms."}, {"name": "category_theory.nat_iso.inv_map_inv_app", "description": ""}, {"name": "category_theory.nat_iso.trans_app", "description": ""}, {"name": "category_theory.nat_iso.of_components.app", "description": ""}, {"name": "category_theory.nat_iso.inv_inv_app", "description": ""}, {"name": "category_theory.nat_iso.of_components_hom_app", "description": ""}, {"name": "category_theory.nat_iso.naturality_2", "description": ""}, {"name": "category_theory.nat_iso.is_iso_inv_app", "description": ""}, {"name": "tactic.local_def_value_has_local_in_name_set", "description": "`local_def_value_has_local_in_name_set h ns` returns true iff `h` is a local\ndefinition whose value contains a local constant whose unique name appears in\n`ns`."}, {"name": "tactic.hyp_directly_depends_on_locals_inclusive", "description": "`hyp_directly_depends_on_locals_inclusive h ns` is true iff the hypothesis `h`\ndirectly depends on any of the hypotheses `hs` or `h` appears in `hs`."}, {"name": "tactic.revert_set", "description": "`revert_set hs` reverts the hypotheses `hs`, as well as any hypotheses that\ndepend on them. Returns the number of reverted hypotheses and a list containing\nthese hypotheses. The reverted hypotheses are returned in the order in which\nthey used to appear in the context and are guaranteed to store the correct type\n(see `tactic.update_type`)."}, {"name": "tactic.direct_dependencies_of_hyp", "description": "`direct_dependencies_of_hyp h` is the list of hypotheses that the hypothesis `h`\ndirectly depends on. These are the hypotheses that appear in `h`'s type or value\n(if `h` is a local definition). The dependencies are returned in no particular\norder."}, {"name": "tactic.dependencies_of_hyps", "description": "`dependencies_of_hyps hs` returns, for each `h \u2208 hs`, the dependencies of `h`.\nThe dependencies appear in no particular order in the returned lists. This is\nthe same as (but more performant than) using `tactic.dependencies_of_hyp` on\nevery `h \u2208 hs`."}, {"name": "tactic.hyps_depend_on_local_name_set_inclusive", "description": "`hyps_depend_on_local_name_set_inclusive hs ns` returns, for each `h \u2208 hs`,\nwhether `h` inclusively depends on a hypothesis whose unique name appears in\n`ns`. This is the same as (but more efficient than) calling\n`tactic.hyp_depends_on_local_name_set_inclusive` for every `h \u2208 hs`."}, {"name": "tactic.direct_dependency_name_set_of_hyp_inclusive", "description": "`direct_dependency_name_set_of_hyp_inclusive h` is the set of unique names of\nhypotheses that the hypothesis `h` directly depends on, plus `h` itself."}, {"name": "tactic.direct_dependency_name_set_of_hyp", "description": "`direct_dependency_name_set_of_hyp h` is the set of unique names of hypotheses\nthat the hypothesis `h` directly depends on. These are the hypotheses that\nappear in `h`'s type or value (if `h` is a local definition)."}, {"name": "tactic.reverse_dependencies_of_hyp_name_set_inclusive", "description": "`reverse_dependencies_of_hyp_name_set_inclusive hs` is the list of reverse\ndependencies of the hypotheses whose unique names appear in `hs`, including the\n`hs` themselves. The reverse dependencies are returned in the order in which\nthey appear in the context."}, {"name": "tactic.hyp_directly_depends_on_local_set", "description": "`hyp_directly_depends_on_local_set h hs` is true iff the hypothesis `h` directly\ndepends on any of the hypotheses `hs`."}, {"name": "tactic.dependency_set_of_hyp_inclusive'", "description": "`dependency_set_of_hyp_inclusive' cache h` is the set of dependencies of the\nhypothesis `h`, plus `h` itself. `cache` is a map from hypotheses to all their\ndependencies (including indirect dependencies). This is a performance\noptimisation, so you can give an empty cache. The tactic also returns an\nexpanded cache with hypotheses which the tactic has encountered. Note that the\ncache records exclusive, not inclusive dependencies.\n\nYou probably want to use `tactic.dependency_set_of_hyp_inclusive` or\n`tactic.dependency_sets_of_hyps_inclusive` instead of this tactic."}, {"name": "tactic.type_has_local_in_name_set", "description": "`type_has_local_in_name_set h ns` returns true iff the type of `h` contains a\nlocal constant whose unique name appears in `ns`."}, {"name": "tactic.dependency_name_sets_of_hyps_inclusive", "description": "`dependency_name_sets_of_hyps_inclusive hs` returns, for each `h \u2208 hs`, the\nunique names of the dependencies of `h`, plus the unique name of `h` itself.\nThis is the same as (but more performant than) using\n`tactic.dependency_name_set_of_hyp_inclusive` on every `h \u2208 hs`."}, {"name": "tactic.hyps_depend_on_locals_inclusive", "description": "`hyps_depend_on_locals_inclusive hs is` returns, for each `h \u2208 hs`, whether `h`\ndepends inclusively on any of the hypotheses `is`. This is the same as (but more\nefficient than) calling `tactic.hyp_depends_on_locals_inclusive` for every\n`h \u2208 hs`."}, {"name": "tactic.hyp_directly_depends_on_locals", "description": "`hyp_directly_depends_on_locals h hs` is true iff the hypothesis `h` directly\ndepends on any of the hypotheses `hs`."}, {"name": "tactic.hyps_depend_on_local_name_set", "description": "`hyps_depend_on_local_name_set hs ns` returns, for each `h \u2208 hs`, whether `h`\ndepends on a hypothesis whose unique name appears in `ns`. This is the same as\n(but more efficient than) calling `tactic.hyp_depends_on_local_name_set` for\nevery `h \u2208 hs`."}, {"name": "tactic.revert_reverse_dependencies_of_hyp_name_set", "description": "`revert_reverse_dependencies_of_hyp_name_set hs` reverts all the hypotheses that\ndepend on a hypothesis whose unique name appears in `hs`. The `hs` themselves\nare not reverted, unless they depend on each other. Returns the number of\nreverted hypotheses."}, {"name": "tactic.dependency_sets_of_hyps", "description": "`dependency_sets_of_hyps hs` returns, for each `h \u2208 hs`, the set of dependencies\nof `h`. This is the same as (but more performant than) using\n`tactic.dependency_set_of_hyp` on every `h \u2208 hs`."}, {"name": "tactic.hyps_depend_on_locals", "description": "`hyps_depend_on_locals hs is` returns, for each `h \u2208 hs`, whether `h` depends\non any of the hypotheses `is`. This is the same as (but more efficient than)\ncalling `tactic.hyp_depends_on_locals` for every `h \u2208 hs`."}, {"name": "tactic.dependency_sets_of_hyps_inclusive", "description": "`dependency_sets_of_hyps_inclusive hs` returns, for each `h \u2208 hs`, the\ndependencies of `h`, plus `h` itself. This is the same as (but more performant\nthan) using `tactic.dependency_set_of_hyp_inclusive` on every `h \u2208 hs`."}, {"name": "tactic.hyp_depends_on_local_set", "description": "`hyp_depends_on_local_set h hs` is true iff the hypothesis `h` depends on\nany of the hypotheses `hs`. If you need to check dependencies of multiple\nhypotheses, use `tactic.hyps_depend_on_local_set`."}, {"name": "tactic.hyps_depend_on_local_set_inclusive", "description": "`hyps_depend_on_local_set_inclusive hs is` returns, for each `h \u2208 hs`, whether\n`h` depends inclusively on any of the hypotheses `is`. This is the same as\n(but more efficient than) calling `tactic.hyp_depends_on_local_set_inclusive`\nfor every `h \u2208 hs`."}, {"name": "tactic.hyp_depends_on_local_name_set_inclusive'", "description": "`hyp_depends_on_local_name_set_inclusive' cache h ns` is true iff the hypothesis\n`h` inclusively depends on a hypothesis whose unique name appears in `ns`.\n`cache` must be a set of hypotheses known *not* to depend (even indirectly) on\nany of the `ns`. This is a performance optimisation, so you can give an empty\ncache. The tactic also returns an expanded cache with hypotheses which the\ntactic has encountered. Note that the cache records exclusive, not inclusive\ndependencies.\n\nYou probably want to use `tactic.hyp_depends_on_local_name_set_inclusive` or\n`tactic.hyps_depend_on_local_name_set_inclusive` instead of this tactic."}, {"name": "tactic.dependency_name_set_of_hyp", "description": "`dependency_name_set_of_hyp h` is the set of unique names of the dependencies of\nthe hypothesis `h`. If you need the dependencies of multiple hypotheses, use\n`tactic.dependency_name_sets_of_hyps`."}, {"name": "tactic.dependency_name_sets_of_hyps", "description": "`dependency_name_sets_of_hyps hs` returns, for each `h \u2208 hs`, the set of unique\nnames of the dependencies of `h`. This is the same as (but more performant than)\nusing `tactic.dependency_name_set_of_hyp` on every `h \u2208 hs`."}, {"name": "tactic.hyp_directly_depends_on_local_name_set", "description": "`hyp_directly_depends_on_local_name_set h ns` is true iff the hypothesis `h`\ndirectly depends on a hypothesis whose unique name appears in `ns`."}, {"name": "tactic.revert_reverse_dependencies_of_hyps", "description": "`revert_reverse_dependencies_of_hyp hs` reverts all the hypotheses that depend\non a hypothesis in `hs`. The `hs` themselves are not reverted, unless they\ndepend on each other. Returns the number of reverted hypotheses."}, {"name": "tactic.hyp_depends_on_local_set_inclusive", "description": "`hyp_depends_on_local_set_inclusive h hs` is true iff the hypothesis `h`\ninclusively depends on any of the hypotheses `hs`. If you need to check\ndependencies of multiple hypotheses, use\n`tactic.hyps_depend_on_local_set_inclusive`."}, {"name": "tactic.hyps_depend_on_local_set", "description": "`hyps_depend_on_local_set hs is` returns, for each `h \u2208 hs`, whether `h` depends\non any of the hypotheses `is`. This is the same as (but more efficient than)\ncalling `tactic.hyp_depends_on_local_set` for every `h \u2208 hs`."}, {"name": "tactic.revert_lst'", "description": "`revert_lst' hs` reverts the hypotheses `hs`, as well as any hypotheses that\ndepend on them. Returns the number of reverted hypotheses and a list containing\nthese hypotheses. The reverted hypotheses are returned in the order in which\nthey used to appear in the context and are guaranteed to store the correct type\n(see `tactic.update_type`).\n\nThis is a more informative version of `tactic.revert_lst`."}, {"name": "tactic.local_def_value_has_local_in_set", "description": "`local_def_value_has_local_in_set h hs` returns true iff `h` is a local\ndefinition whose value contains any of the local constants `hs`."}, {"name": "tactic.hyp_depends_on_local_name_set", "description": "`hyp_depends_on_local_name_set h ns` is true iff the hypothesis `h` depends on\nany of the hypotheses whose unique names appear in `ns`. If you need to check\ndependencies of multiple hypotheses, use `tactic.hyps_depend_on_local_name_set`."}, {"name": "tactic.dependencies_of_hyp_inclusive", "description": "`dependencies_of_hyp_inclusive h` is the list of dependencies of the hypothesis\n`h`, plus `h` itself. The dependencies are returned in no particular order. If\nyou need the dependencies of multiple hypotheses, use\n`tactic.dependencies_of_hyps_inclusive`."}, {"name": "tactic.revert_reverse_dependencies_of_hyp_set", "description": "`revert_reverse_dependencies_of_hyp_set hs` reverts all the hypotheses that\ndepend on a hypothesis in `hs`. The `hs` themselves are not reverted, unless\nthey depend on each other. Returns the number of reverted hypotheses."}, {"name": "tactic.reverse_dependencies_of_hyps_inclusive", "description": "`reverse_dependencies_of_hyps_inclusive hs` is the list of reverse dependencies\nof the hypotheses `hs`, including the `hs` themselves. The reverse dependencies\nare returned in the order in which they appear in the context."}, {"name": "tactic.direct_dependencies_of_hyp_inclusive", "description": "`direct_dependencies_of_hyp_inclusive h` is the list of hypotheses that the\nhypothesis `h` directly depends on, plus `h` itself. The dependencies are\nreturned in no particular order."}, {"name": "tactic.local_def_value_has_local_in", "description": "`local_def_value_has_local_in h hs` returns true iff `h` is a local definition\nwhose value contains any of the local constants `hs`."}, {"name": "tactic.revert_reverse_dependencies_of_hyp", "description": "`revert_reverse_dependencies_of_hyp h` reverts all the hypotheses that depend on\nthe hypothesis `h`, including the local definitions that have `h` in their\nvalue. This fixes a bug in `tactic.revert_kdependencies` that does not revert\nlocal definitions for which `h` only appears in the value. Returns the number\nof reverted hypotheses."}, {"name": "tactic.dependency_set_of_hyp_inclusive", "description": "`dependency_set_of_hyp_inclusive h` is the set of dependencies of the hypothesis\n`h`, plus `h` itself. If you need the dependencies of multiple hypotheses, use\n`tactic.dependency_sets_of_hyps_inclusive`."}, {"name": "tactic.direct_dependency_set_of_hyp_inclusive", "description": "`direct_dependency_set_of_hyp_inclusive h` is the set of hypotheses that the\nhypothesis `h` directly depends on, plus `h` itself."}, {"name": "tactic.direct_dependency_set_of_hyp", "description": "`direct_dependency_set_of_hyp h` is the set of hypotheses that the hypothesis\n`h` directly depends on. These are the hypotheses that appear in `h`'s type or\nvalue (if `h` is a local definition)."}, {"name": "tactic.type_has_local_in", "description": "`type_has_local_in h hs` returns true iff the type of `h` contains any of the\nlocal constants `hs`."}, {"name": "tactic.reverse_dependencies_of_hyps", "description": "`reverse_dependencies_of_hyps hs` is the list of reverse dependencies of the\nhypotheses `hs`, excluding the `hs` themselves. The reverse dependencies are\nreturned in the order in which they appear in the context."}, {"name": "tactic.hyp_directly_depends_on_local_name_set_inclusive", "description": "`hyp_directly_depends_on_local_name_set_inclusive h ns` is true iff the\nhypothesis `h` directly depends on a hypothesis whose unique name appears in\n`ns` or `h`'s name appears in `ns`."}, {"name": "tactic.reverse_dependencies_of_hyp_name_set", "description": "`reverse_dependencies_of_hyp_name_set hs` is the list of reverse dependencies of\nthe hypotheses whose unique names appear in `hs`, excluding the `hs` themselves.\nThe reverse dependencies are returned in the order in which they appear in the\ncontext."}, {"name": "tactic.hyp_depends_on_locals_inclusive", "description": "`hyp_depends_on_locals_inclusive h hs` is true iff the hypothesis `h`\ninclusively depends on any of the hypotheses `hs`. If you need to check\ndependencies of multiple hypotheses, use\n`tactic.hyps_depend_on_locals_inclusive`."}, {"name": "tactic.type_has_local_in_set", "description": "`type_has_local_in_set h hs` returns true iff the type of `h` contains any of\nthe local constants `hs`."}, {"name": "tactic.dependency_name_set_of_hyp_inclusive", "description": "`dependency_name_set_of_hyp_inclusive h` is the set of unique names of the\ndependencies of the hypothesis `h`, plus the unique name of `h` itself. If you\nneed the dependencies of multiple hypotheses, use\n`tactic.dependency_name_sets_of_hyps_inclusive`."}, {"name": "tactic.hyp_depends_on_local_name_set_inclusive", "description": "`hyp_depends_on_local_name_set_inclusive h ns` is true iff the hypothesis `h`\ninclusively depends on any of the hypotheses whose unique names appear in `ns`.\nIf you need to check the dependencies of multiple hypotheses, use\n`tactic.hyps_depend_on_local_name_set_inclusive`."}, {"name": "tactic.reverse_dependencies_of_hyp_set_inclusive", "description": "`reverse_dependencies_of_hyp_set_inclusive hs` is the list of reverse\ndependencies of the hypotheses `hs`, including the `hs` themselves. The\ninclusive reverse dependencies are returned in the order in which they appear in\nthe context."}, {"name": "tactic.dependency_set_of_hyp", "description": "`dependency_set_of_hyp h` is the set of dependencies of the hypothesis `h`. If\nyou need the dependencies of multiple hypotheses, use\n`tactic.dependency_sets_of_hyps`."}, {"name": "tactic.reverse_dependencies_of_hyp_set", "description": "`reverse_dependencies_of_hyp_set hs` is the list of reverse dependencies of the\nhypotheses `hs`, excluding the `hs` themselves. The reverse dependencies are\nreturned in the order in which they appear in the context."}, {"name": "tactic.hyp_directly_depends_on_local_set_inclusive", "description": "`hyp_directly_depends_on_local_set_inclusive h ns` is true iff the hypothesis `h`\ndirectly depends on any of the hypotheses `hs` or `h` appears in `hs`."}, {"name": "tactic.dependencies_of_hyps_inclusive", "description": "`dependencies_of_hyps_inclusive hs` returns, for each `h \u2208 hs`, the dependencies\nof `h`, plus `h` itself. The dependencies appear in no particular order in the\nreturned lists. This is the same as (but more performant than) using\n`tactic.dependencies_of_hyp_inclusive` on every `h \u2208 hs`."}, {"name": "tactic.hyp_depends_on_locals", "description": "`hyp_depends_on_locals h hs` is true iff the hypothesis `h` depends on any of\nthe hypotheses `hs`. If you need to check dependencies of multiple hypotheses,\nuse `tactic.hyps_depend_on_locals`."}, {"name": "tactic.dependency_set_of_hyp'", "description": "`dependency_set_of_hyp' cache h` is the set of dependencies of the hypothesis\n`h`. `cache` is a map from hypotheses to all their dependencies (including\nindirect dependencies). This is a performance optimisation, so you can give an\nempty cache. The tactic also returns an expanded cache with hypotheses which\nthe tactic has encountered.\n\nYou probably want to use `tactic.dependency_set_of_hyp` or\n`tactic.dependency_sets_of_hyps` instead of this tactic."}, {"name": "tactic.revert_name_set", "description": "`revert_name_set hs` reverts the hypotheses whose unique names appear in `hs`,\nas well as any hypotheses that depend on them. Returns the number of reverted\nhypotheses and a list containing these hypotheses. The reverted hypotheses are\nreturned in the order in which they used to appear in the context and are\nguaranteed to store the correct type (see `tactic.update_type`)."}, {"name": "tactic.dependencies_of_hyp", "description": "`dependencies_of_hyp h` is the list of dependencies of the hypothesis `h`.\nThe dependencies are returned in no particular order. If you need the\ndependencies of multiple hypotheses, use `tactic.dependencies_of_hyps`."}, {"name": "tactic.hyp_depends_on_local_name_set'", "description": "`hyp_depends_on_local_name_set' cache h ns` is true iff `h` depends on any of\nthe hypotheses whose unique names appear in `ns`. `cache` must be a set of\nhypotheses known *not* to depend (even indirectly) on any of the `ns`. This is\na performance optimisation, so you can give an empty cache. The tactic also\nreturns an expanded cache with hypotheses which the tactic has encountered.\n\nYou probably want to use `tactic.hyp_depends_on_local_name_set` or\n`tactic.hyps_depend_on_local_name_set` instead of this tactic."}, {"name": "d_array.iterate_aux", "description": ""}, {"name": "array.has_to_format", "description": ""}, {"name": "array.to_list", "description": ""}, {"name": "d_array.read", "description": "`read a i` reads the `i`th member of `a`. Has builtin VM implementation."}, {"name": "array.push_back_idx", "description": ""}, {"name": "array.decidable_eq", "description": ""}, {"name": "d_array.beq", "description": "Boolean element-wise equality check."}, {"name": "d_array.nil", "description": "The empty array."}, {"name": "array.read_mem", "description": ""}, {"name": "d_array.of_beq_aux_eq_tt", "description": ""}, {"name": "array", "description": "A non-dependent array (see `d_array`). Implemented in the VM as a persistent array."}, {"name": "array.read_write_of_ne", "description": ""}, {"name": "d_array.map\u2082", "description": ""}, {"name": "array.has_to_tactic_format", "description": ""}, {"name": "array.has_repr", "description": ""}, {"name": "array.read", "description": ""}, {"name": "d_array.rev_iterate", "description": ""}, {"name": "d_array.read_write", "description": ""}, {"name": "array.write", "description": ""}, {"name": "array.write'", "description": ""}, {"name": "array.read_write", "description": ""}, {"name": "array.pop_back_idx", "description": ""}, {"name": "array.mmap_core", "description": "Auxilliary function for monadically mapping a function over an array."}, {"name": "d_array.of_beq_aux_eq_ff", "description": ""}, {"name": "d_array.write", "description": "`write a i v` sets the `i`th member of `a` to be `v`. Has builtin VM implementation."}, {"name": "array.mem", "description": ""}, {"name": "array.ext'", "description": ""}, {"name": "array.read'", "description": ""}, {"name": "d_array.map", "description": ""}, {"name": "d_array.iterate", "description": "Fold over the elements of the given array in ascending order. Has builtin VM implementation."}, {"name": "d_array.decidable_eq", "description": ""}, {"name": "array.mmap", "description": "Monadically map a function over the array."}, {"name": "array.map\u2082", "description": ""}, {"name": "array.pop_back", "description": "Discard _last_ element in the array. Has builtin VM implementation."}, {"name": "mk_array", "description": "`mk_array n v` creates a new array of length `n` where each element is `v`. Has builtin VM implementation."}, {"name": "array.read_eq_read'", "description": ""}, {"name": "d_array.foreach", "description": "Map the array. Has builtin VM implementation."}, {"name": "d_array.of_beq_eq_tt", "description": ""}, {"name": "d_array", "description": "In the VM, d_array is implemented as a persistent array."}, {"name": "d_array.data", "description": "In the VM, d_array is implemented as a persistent array."}, {"name": "array.foreach", "description": "Map each element of the given array with an index argument."}, {"name": "d_array.ext'", "description": ""}, {"name": "d_array.ext", "description": ""}, {"name": "d_array.rev_iterate_aux", "description": ""}, {"name": "array.push_back", "description": "`push_back a v` pushes value `v` to the end of the array. Has builtin VM implementation."}, {"name": "array.rev_foldl", "description": ""}, {"name": "array.iterate", "description": "Fold array starting from 0, folder function includes an index argument."}, {"name": "d_array.of_beq_eq_ff", "description": ""}, {"name": "array.map", "description": "Map a function over the array."}, {"name": "array.has_mem", "description": ""}, {"name": "array.ext", "description": ""}, {"name": "array.write_eq_write'", "description": ""}, {"name": "d_array.read_write_of_ne", "description": ""}, {"name": "array.rev_iterate", "description": ""}, {"name": "array.rev_list", "description": ""}, {"name": "d_array.foldl", "description": ""}, {"name": "array.nil", "description": ""}, {"name": "d_array.beq_aux", "description": ""}, {"name": "array.foldl", "description": ""}, {"name": "tactic.open_n_pis_whnf", "description": "`open_n_pis_whnf e n md unfold_ginductive` instantiates the first `n` \u03a0 binders\nof `e` with fresh local constants. The leading \u03a0 binders of `e` are matched up\nto normalisation with transparency `md`. `unfold_ginductive` determines whether\nconstructors of generalised inductive types are unfolded during normalisation.\nThis is `open_pis_whnf` but restricted to `n` binders."}, {"name": "tactic.open_lambdas_whnf", "description": "`open_lambdas_whnf e md unfold_ginductive` instantiates all leading \u03bb binders of\n`e` with fresh local constants. The leading \u03bb binders of `e` are matched up to\nnormalisation with transparency `md`. `unfold_ginductive` determines whether\nconstructors of generalised inductive types are unfolded during normalisation.\nThis is `open_lambdas` up to normalisation."}, {"name": "tactic.mk_binder_replacement", "description": "`mk_binder_replacement local_or_meta b` creates an expression that can be used\nto replace the binder `b`. If `local_or_meta` is true, we create a fresh local\nconstant with `b`'s display name, `binder_info` and type; otherwise a fresh\nmetavariable with `b`'s type."}, {"name": "tactic.get_pi_binders", "description": "`get_pi_binders e` instantiates all leading \u03a0 binders of `e` with fresh local\nconstants (like `open_pis`). Returns the remainder of `e` and information about\nthe binders that were instantiated (but not the new local constants). See also\n`expr.pi_binders` (which produces open terms)."}, {"name": "tactic.open_n_pis_metas", "description": "`open_n_pis_metas e n` instantiates the first `n` \u03a0 binders of `e` with fresh\nmetavariables. Returns the metavariables and the remainder of `e`. This is\n`open_n_pis` but with metavariables instead of local constants."}, {"name": "tactic.open_n_pis", "description": "`open_n_pis e n` instantiates the first `n` \u03a0 binders of `e` with fresh local\nconstants. Returns the local constants and the remainder of `e`. Fails if\n`e` does not start with at least `n` \u03a0 binders. This is `open_pis` but limited\nto `n` binders."}, {"name": "tactic.open_n_pis_metas_whnf", "description": "`open_n_pis_metas_whnf e n md unfold_ginductive` instantiates the first `n` \u03a0\nbinders of `e` with fresh metavariables. The leading \u03a0 binders of `e` are\nmatched up to normalisation with transparency `md`. `unfold_ginductive`\ndetermines whether constructors of generalised inductive types are unfolded\nduring normalisation. This is `open_pis_metas_whnf` but restricted to `n`\nbinders."}, {"name": "tactic.get_pi_binders_nondep", "description": "`get_pi_binders_nondep e` instantiates all leading \u03a0 binders of `e` with fresh\nlocal constants (like `open_pis`). Returns the remainder of `e` and information\nabout the *nondependent* binders that were instantiated (but not the new local\nconstants). A nondependent binder is one that does not appear later in the\nexpression. Also returns the index of each returned binder (starting at 0)."}, {"name": "tactic.open_n_pis_metas'", "description": "`open_n_pis_metas' e n` instantiates the first `n` leading \u03a0 binders of `e` with\nfresh metavariables. It returns the remainder of the expression and, for each\nbinder, the corresponding metavariable, the name of the bound variable and the\nbinder's `binder_info`. Fails if `e` does not have at least `n` leading \u03a0\nbinders."}, {"name": "tactic.open_pis_whnf_dep", "description": "`open_pis_whnf_dep e` instantiates all leading \u03a0 binders of `e` with fresh local\nconstants (like `tactic.open_pis`). It returns the remainder of the expression\nand, for each binder, the corresponding local constant and whether the binder\nwas dependent."}, {"name": "tactic.open_pis_whnf", "description": "`open_pis_whnf e md unfold_ginductive` instantiates all leading \u03a0 binders of `e`\nwith fresh local constants. The leading \u03a0 binders of `e` are matched up to\nnormalisation with transparency `md`. `unfold_ginductive` determines whether\nconstructors of generalised inductive types are unfolded during normalisation.\nThis is `open_pis` up to normalisation."}, {"name": "tactic.open_n_lambdas_whnf", "description": "`open_n_lambdas_whnf e md unfold_ginductive` instantiates the first `n` \u03bb\nbinders of `e` with fresh local constants. The \u03bb binders are matched up to\nnormalisation with transparency `md`. `unfold_ginductive` determines whether\nconstructors of generalised inductive types are unfolded during normalisation.\nFails if `e` does not start with `n` \u03bb binders (after normalisation). This is\n`open_n_lambdas` up to normalisation."}, {"name": "tactic.open_pis_metas_whnf", "description": "`open_pis_metas_whnf e md unfold_ginductive` instantiates all leading \u03a0 binders\nof `e` with fresh metavariables. The leading \u03a0 binders of `e` are matched up to\nnormalisation with transparency `md`. `unfold_ginductive` determines whether\nconstructors of generalised inductive types are unfolded during normalisation.\nThis is `open_pis_metas` up to normalisation."}, {"name": "tactic.open_lambdas_metas_whnf", "description": "`open_lambdas_metas_whnf e md unfold_ginductive` instantiates all leading \u03bb\nbinders of `e` with fresh metavariables. The leading \u03bb binders of `e` are\nmatched up to normalisation with transparency `md`. `unfold_ginductive`\ndetermines whether constructors of generalised inductive types are unfolded\nduring normalisation. This is `open_lambdas_metas` up to normalisation."}, {"name": "tactic.open_pis_metas", "description": "`open_pis_metas e` instantiates all leading \u03a0 binders of `e` with fresh\nmetavariables. Returns the metavariables and the remainder of `e`. This is\n`open_pis` but with metavariables instead of local constants."}, {"name": "tactic.open_n_binders", "description": "`open_n_binders do_whnf pis_or_lambdas local_or_metas e n` is like\n`open_binders do_whnf pis_or_lambdas local_or_metas e`, but it matches exactly `n`\nleading \u03a0/\u03bb binders of `e`. If `e` does not start with at least `n` \u03a0/\u03bb binders,\n(after normalisation, if `do_whnf` is given), the tactic fails."}, {"name": "tactic.open_n_lambdas_metas_whnf", "description": "`open_n_lambdas_metas_whnf e md unfold_ginductive` instantiates the first `n` \u03bb\nbinders of `e` with fresh metavariables. The \u03bb binders are matched up to\nnormalisation with transparency `md`. `unfold_ginductive` determines whether\nconstructors of generalised inductive types are unfolded during normalisation.\nFails if `e` does not start with `n` \u03bb binders (after normalisation). This is\n`open_n_lambdas_metas` up to normalisation."}, {"name": "tactic.open_lambdas_metas", "description": "`open_lambdas_metas e` instantiates all leading \u03bb binders of `e` with fresh\nmetavariables. Returns the new metavariables and the remainder of `e`. This is\n`open_lambdas` but with metavariables instead of local constants."}, {"name": "tactic.open_n_lambdas", "description": "`open_n_lambdas e n` instantiates the first `n` \u03bb binders of `e` with fresh\nlocal constants. Returns the new local constants and the remainder of `e`. Fails\nif `e` does not start with at least `n` \u03bb binders. This is `open_lambdas` but\nrestricted to the first `n` binders."}, {"name": "tactic.get_binder", "description": "`get_binder do_whnf pi_or_lambda e` matches `e` of the form `\u03bb x, e'` or\n`\u03a0 x, e`. Returns information about the leading binder (its name, `binder_info`,\ntype and body), or `none` if `e` does not start with a binder.\n\nIf `do_whnf = some (md, unfold_ginductive)`, then `e` is weak head normalised\nwith transparency `md` before matching on it. `unfold_ginductive` controls\nwhether constructors of generalised inductive data types are unfolded during\nnormalisation.\n\nIf `pi_or_lambda` is `tt`, we match a leading \u03a0 binder; otherwise a leading \u03bb\nbinder."}, {"name": "tactic.open_pis", "description": "`open_pis e` instantiates all leading \u03a0 binders of `e` with fresh local\nconstants. Returns the local constants and the remainder of `e`. This is an\nalias for `tactic.mk_local_pis`."}, {"name": "tactic.open_binders", "description": "`open_binders` is a generalisation of functions like `open_pis`,\n`mk_meta_lambdas` etc. `open_binders do_whnf pis_or_lamdas local_or_metas e`\nproceeds as follows:\n\n- Match a leading \u03bb or \u03a0 binder using `get_binder do_whnf pis_or_lambdas`.\n  See `get_binder` for details. Return `e` unchanged (and an empty list) if\n  `e` does not start with a \u03bb/\u03a0.\n- Construct a replacement for the bound variable using\n  `mk_binder_replacement locals_or_metas`. See `mk_binder_replacement` for\n  details. Replace the bound variable with this replacement in the binder body.\n- Recurse into the binder body.\n\nReturns the constructed replacement expressions and `e` without its leading\nbinders."}, {"name": "tactic.open_n_lambdas_metas", "description": "`open_n_lambdas_metas e n` instantiates the first `n` \u03bb binders of `e` with\nfresh metavariables. Returns the new metavariables and the remainder of `e`.\nFails if `e` does not start with at least `n` \u03bb binders. This is\n`open_lambdas_metas` but restricted to the first `n` binders."}, {"name": "tactic.open_lambdas", "description": "`open_lambdas e` instantiates all leading \u03bb binders of `e` with fresh local\nconstants. Returns the new local constants and the remainder of `e`. This is\n`open_pis` but for \u03bb binders rather than \u03a0 binders."}, {"name": "rat.mk_zero", "description": ""}, {"name": "rat.pnat_denom", "description": "Denominator as `\u2115+`."}, {"name": "rat.zero_ne_one", "description": ""}, {"name": "rat.mul_one", "description": ""}, {"name": "rat.add_left_neg", "description": ""}, {"name": "rat.mk", "description": "Form the quotient `n / d` where `n d : \u2124`."}, {"name": "rat.num_denom_cases_on", "description": " Define a (dependent) function or prove `\u2200 r : \u211a, p r` by dealing with rational\nnumbers of the form `n /. d` with `0 < d` and coprime `n`, `d`."}, {"name": "rat.mk_neg_one_one", "description": ""}, {"name": "rat.mk_pnat_eq", "description": ""}, {"name": "rat.repr", "description": " String representation of a rational numbers, used in `has_repr`, `has_to_string`, and\n`has_to_format` instances."}, {"name": "rat.div_int_inj", "description": ""}, {"name": "rat.semigroup", "description": ""}, {"name": "rat.coe_nat_eq_mk", "description": ""}, {"name": "rat.forall", "description": ""}, {"name": "rat.exists", "description": ""}, {"name": "rat.has_add", "description": ""}, {"name": "rat.add_mk", "description": ""}, {"name": "rat.mul_num", "description": ""}, {"name": "rat.add_num_denom'", "description": ""}, {"name": "rat.has_zero", "description": ""}, {"name": "rat.add_left_cancel_semigroup", "description": ""}, {"name": "rat.mul_num_denom", "description": ""}, {"name": "rat.eq_iff_mul_eq_mul", "description": ""}, {"name": "rat.denom_div_cast_eq_one_iff", "description": ""}, {"name": "rat.num_neg_eq_neg_num", "description": ""}, {"name": "rat.mk_div_mk_cancel_right", "description": ""}, {"name": "rat.num_one", "description": ""}, {"name": "rat.zero_mk", "description": ""}, {"name": "rat.add_group", "description": ""}, {"name": "rat.mk_nat", "description": "Form the quotient `n / d` where `n:\u2124` and `d:\u2115`. In the case `d = 0`, we\n define `n / 0 = 0` by convention."}, {"name": "rat.add_comm_semigroup", "description": ""}, {"name": "rat.mul", "description": "Multiplication of rational numbers. Use `(*)` instead."}, {"name": "rat.nontrivial", "description": ""}, {"name": "rat.is_domain", "description": ""}, {"name": "rat.neg_def", "description": ""}, {"name": "rat.coe_int_denom", "description": ""}, {"name": "rat.mk_one_one", "description": ""}, {"name": "rat.neg", "description": "Negation of rational numbers. Use `-r` instead."}, {"name": "rat.pnat_denom_eq_iff_denom_eq", "description": ""}, {"name": "rat.add_comm_monoid", "description": ""}, {"name": "rat.num_dvd", "description": ""}, {"name": "rat.coe_int_div_eq_mk", "description": ""}, {"name": "rat.inv_def", "description": ""}, {"name": "rat.coe_pnat_denom", "description": ""}, {"name": "rat.add_comm", "description": ""}, {"name": "rat.denom_zero", "description": ""}, {"name": "rat.mul_assoc", "description": ""}, {"name": "rat.add_def", "description": ""}, {"name": "rat.inv_coe_nat_denom", "description": ""}, {"name": "rat.coe_int_div_self", "description": ""}, {"name": "rat", "description": "`rat`, or `\u211a`, is the type of rational numbers. It is defined\n as the set of pairs \u27e8n, d\u27e9 of integers such that `d` is positive and `n` and\n `d` are coprime. This representation is preferred to the quotient\n because without periodic reduction, the numerator and denominator can grow\n exponentially (for example, adding 1/2 to itself repeatedly)."}, {"name": "rat.num", "description": "`rat`, or `\u211a`, is the type of rational numbers. It is defined\n as the set of pairs \u27e8n, d\u27e9 of integers such that `d` is positive and `n` and\n `d` are coprime. This representation is preferred to the quotient\n because without periodic reduction, the numerator and denominator can grow\n exponentially (for example, adding 1/2 to itself repeatedly)."}, {"name": "rat.denom", "description": "`rat`, or `\u211a`, is the type of rational numbers. It is defined\n as the set of pairs \u27e8n, d\u27e9 of integers such that `d` is positive and `n` and\n `d` are coprime. This representation is preferred to the quotient\n because without periodic reduction, the numerator and denominator can grow\n exponentially (for example, adding 1/2 to itself repeatedly)."}, {"name": "rat.pos", "description": "`rat`, or `\u211a`, is the type of rational numbers. It is defined\n as the set of pairs \u27e8n, d\u27e9 of integers such that `d` is positive and `n` and\n `d` are coprime. This representation is preferred to the quotient\n because without periodic reduction, the numerator and denominator can grow\n exponentially (for example, adding 1/2 to itself repeatedly)."}, {"name": "rat.cop", "description": "`rat`, or `\u211a`, is the type of rational numbers. It is defined\n as the set of pairs \u27e8n, d\u27e9 of integers such that `d` is positive and `n` and\n `d` are coprime. This representation is preferred to the quotient\n because without periodic reduction, the numerator and denominator can grow\n exponentially (for example, adding 1/2 to itself repeatedly)."}, {"name": "rat.comm_ring", "description": ""}, {"name": "rat.mk_num_ne_zero_of_ne_zero", "description": ""}, {"name": "rat.ext", "description": ""}, {"name": "rat.mk_pnat_pnat_denom_eq", "description": ""}, {"name": "rat.comm_group_with_zero", "description": ""}, {"name": "rat.has_to_string", "description": ""}, {"name": "rat.add_semigroup", "description": ""}, {"name": "rat.add_denom_dvd", "description": ""}, {"name": "rat.inv", "description": "Inverse rational number. Use `r\u207b\u00b9` instead."}, {"name": "rat.mk_div_mk_cancel_left", "description": ""}, {"name": "rat.mul_def", "description": ""}, {"name": "rat.coe_int_eq_mk", "description": ""}, {"name": "rat.add_zero", "description": ""}, {"name": "rat.coe_int_num", "description": ""}, {"name": "rat.mk_zero_one", "description": ""}, {"name": "rat.of_int", "description": "Embed an integer as a rational number"}, {"name": "rat.denom_ne_zero", "description": ""}, {"name": "rat.num_div_denom", "description": ""}, {"name": "rat.num_ne_zero_of_ne_zero", "description": ""}, {"name": "rat.add", "description": "Addition of rational numbers. Use `(+)` instead."}, {"name": "rat.mul_denom_eq_num", "description": ""}, {"name": "rat.has_div", "description": ""}, {"name": "rat.inhabited", "description": ""}, {"name": "rat.denom_eq_one_iff", "description": ""}, {"name": "rat.encodable", "description": ""}, {"name": "rat.has_repr", "description": ""}, {"name": "rat.mk_ne_zero_of_ne_zero", "description": ""}, {"name": "rat.num_denom_mk", "description": ""}, {"name": "rat.has_inv", "description": ""}, {"name": "rat.div_mk_div_cancel_left", "description": ""}, {"name": "rat.lift_binop_eq", "description": ""}, {"name": "rat.substr_num_denom'", "description": ""}, {"name": "rat.coe_nat_div", "description": ""}, {"name": "rat.div_num_denom", "description": ""}, {"name": "rat.inv_coe_int_denom", "description": ""}, {"name": "rat.inv_coe_nat_num", "description": ""}, {"name": "rat.mk_pnat_num", "description": ""}, {"name": "rat.inv_def'", "description": ""}, {"name": "rat.has_mul", "description": ""}, {"name": "rat.mul_self_num", "description": ""}, {"name": "rat.mul_num_denom'", "description": ""}, {"name": "rat.mul_self_denom", "description": ""}, {"name": "rat.mk_nat_eq", "description": ""}, {"name": "rat.add_monoid", "description": ""}, {"name": "rat.zero_mk_pnat", "description": ""}, {"name": "rat.mk_denom_ne_zero_of_ne_zero", "description": ""}, {"name": "rat.of_int_eq_mk", "description": ""}, {"name": "rat.add_mul", "description": ""}, {"name": "rat.comm_semiring", "description": ""}, {"name": "rat.mk_ne_zero", "description": ""}, {"name": "rat.num_denom", "description": ""}, {"name": "rat.coe_int_inj", "description": ""}, {"name": "rat.zero_add", "description": ""}, {"name": "rat.add_assoc", "description": ""}, {"name": "rat.sub_def", "description": ""}, {"name": "rat.ext_iff", "description": ""}, {"name": "rat.exists_eq_mul_div_num_and_eq_mul_div_denom", "description": ""}, {"name": "rat.add_comm_group", "description": ""}, {"name": "rat.zero_iff_num_zero", "description": ""}, {"name": "rat.num_div_eq_of_coprime", "description": ""}, {"name": "rat.one_mul", "description": ""}, {"name": "rat.mul_denom_dvd", "description": ""}, {"name": "rat.has_one", "description": ""}, {"name": "rat.has_neg", "description": ""}, {"name": "rat.monoid", "description": ""}, {"name": "rat.mk_pnat", "description": "Form the quotient `n / d` where `n:\u2124` and `d:\u2115+` (not necessarily coprime)"}, {"name": "rat.mk_pnat_denom_dvd", "description": ""}, {"name": "rat.mk_eq", "description": ""}, {"name": "rat.has_to_format", "description": ""}, {"name": "rat.mk_eq_zero", "description": ""}, {"name": "rat.inv_coe_int_num", "description": ""}, {"name": "rat.comm_semigroup", "description": ""}, {"name": "rat.mk_mul_mk_cancel", "description": ""}, {"name": "rat.coe_nat_denom", "description": ""}, {"name": "rat.denom_neg_eq_denom", "description": ""}, {"name": "rat.num_denom_cases_on'", "description": " Define a (dependent) function or prove `\u2200 r : \u211a, p r` by dealing with rational\nnumbers of the form `n /. d` with `d \u2260 0`."}, {"name": "rat.zero_of_num_zero", "description": ""}, {"name": "rat.denom_div_eq_of_coprime", "description": ""}, {"name": "rat.mk_neg_denom", "description": ""}, {"name": "rat.coe_nat_num", "description": ""}, {"name": "rat.coe_int_div", "description": ""}, {"name": "rat.inv_mul_cancel", "description": ""}, {"name": "rat.num_denom'", "description": ""}, {"name": "rat.int.can_lift", "description": ""}, {"name": "rat.decidable_eq", "description": ""}, {"name": "rat.mk_eq_div", "description": ""}, {"name": "rat.mk_pnat_denom", "description": ""}, {"name": "rat.zero_mk_nat", "description": ""}, {"name": "rat.coe_int_num_of_denom_eq_one", "description": ""}, {"name": "rat.denom_one", "description": ""}, {"name": "rat.denom_mk", "description": ""}, {"name": "rat.coe_int_eq_of_int", "description": ""}, {"name": "rat.mul_comm", "description": ""}, {"name": "rat.semiring", "description": ""}, {"name": "rat.mul_add", "description": ""}, {"name": "rat.mul_inv_cancel", "description": ""}, {"name": "rat.mul_denom", "description": ""}, {"name": "rat.num_mk", "description": ""}, {"name": "rat.add_right_cancel_semigroup", "description": ""}, {"name": "rat.num_zero", "description": ""}, {"name": "rat.add_num_denom", "description": ""}, {"name": "rat.denom_dvd", "description": ""}, {"name": "rat.comm_monoid", "description": ""}, {"name": "rat.coe_nat_div_self", "description": ""}, {"name": "category_theory.category.comp_id", "description": ""}, {"name": "category_theory.eq_of_comp_right_eq'", "description": ""}, {"name": "category_theory.ite_comp", "description": ""}, {"name": "category_theory.comp_ite", "description": ""}, {"name": "category_theory.id_of_comp_left_id", "description": ""}, {"name": "category_theory.category_struct.id.mono", "description": ""}, {"name": "category_theory.cancel_mono_id", "description": ""}, {"name": "category_theory.mono", "description": "A morphism `f` is a monomorphism if it can be \"cancelled\" when postcomposed:\n`g \u226b f = h \u226b f` implies `g = h`.\n\nSee <https://stacks.math.columbia.edu/tag/003B>."}, {"name": "category_theory.mono.right_cancellation", "description": "A morphism `f` is a monomorphism if it can be \"cancelled\" when postcomposed:\n`g \u226b f = h \u226b f` implies `g = h`.\n\nSee <https://stacks.math.columbia.edu/tag/003B>."}, {"name": "library_note.category_theory universes", "description": "The typeclass `category C` describes morphisms associated to objects of type `C : Type u`.\n\nThe universe levels of the objects and morphisms are independent, and will often need to be\nspecified explicitly, as `category.{v} C`.\n\nTypically any concrete example will either be a `small_category`, where `v = u`,\nwhich can be introduced as\n```lean\nuniverses u\nvariables {C : Type u} [small_category C]\n```\nor a `large_category`, where `u = v+1`, which can be introduced as\n```lean\nuniverses u\nvariables {C : Type (u+1)} [large_category C]\n```\n\nIn order for the library to handle these cases uniformly,\nwe generally work with the unconstrained `category.{v u}`,\nfor which objects live in `Type u` and morphisms live in `Type v`.\n\nBecause the universe parameter `u` for the objects can be inferred from `C`\nwhen we write `category C`, while the universe parameter `v` for the morphisms\ncan not be automatically inferred, through the category theory library\nwe introduce universe parameters with morphism levels listed first,\nas in\n```lean\nuniverses v u\n```\nor\n```lean\nuniverses v\u2081 v\u2082 u\u2081 u\u2082\n```\nwhen multiple independent universes are needed.\n\nThis has the effect that we can simply write `category.{v} C`\n(that is, only specifying a single parameter) while `u` will be inferred.\n\nOften, however, it's not even necessary to include the `.{v}`.\n(Although it was in earlier versions of Lean.)\nIf it is omitted a \"free\" universe will be used."}, {"name": "category_theory.category_struct.id.epi", "description": ""}, {"name": "category_theory.mono_comp", "description": ""}, {"name": "category_theory.id_of_comp_right_id", "description": ""}, {"name": "category_theory.eq_of_comp_right_eq", "description": ""}, {"name": "category_theory.epi_of_epi_fac", "description": ""}, {"name": "category_theory.category.id_comp", "description": ""}, {"name": "category_theory.category_struct", "description": " A preliminary structure on the way to defining a category,\ncontaining the data, but none of the axioms."}, {"name": "category_theory.category_struct.to_quiver", "description": " A preliminary structure on the way to defining a category,\ncontaining the data, but none of the axioms."}, {"name": "category_theory.category_struct.id", "description": " A preliminary structure on the way to defining a category,\ncontaining the data, but none of the axioms."}, {"name": "category_theory.category_struct.comp", "description": " A preliminary structure on the way to defining a category,\ncontaining the data, but none of the axioms."}, {"name": "category_theory.eq_of_comp_left_eq'", "description": ""}, {"name": "category_theory.category", "description": "The typeclass `category C` describes morphisms associated to objects of type `C`.\nThe universe levels of the objects and morphisms are unconstrained, and will often need to be\nspecified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)\n\nSee <https://stacks.math.columbia.edu/tag/0014>."}, {"name": "category_theory.category.to_category_struct", "description": "The typeclass `category C` describes morphisms associated to objects of type `C`.\nThe universe levels of the objects and morphisms are unconstrained, and will often need to be\nspecified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)\n\nSee <https://stacks.math.columbia.edu/tag/0014>."}, {"name": "category_theory.category.id_comp'", "description": "The typeclass `category C` describes morphisms associated to objects of type `C`.\nThe universe levels of the objects and morphisms are unconstrained, and will often need to be\nspecified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)\n\nSee <https://stacks.math.columbia.edu/tag/0014>."}, {"name": "category_theory.category.comp_id'", "description": "The typeclass `category C` describes morphisms associated to objects of type `C`.\nThe universe levels of the objects and morphisms are unconstrained, and will often need to be\nspecified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)\n\nSee <https://stacks.math.columbia.edu/tag/0014>."}, {"name": "category_theory.category.assoc'", "description": "The typeclass `category C` describes morphisms associated to objects of type `C`.\nThe universe levels of the objects and morphisms are unconstrained, and will often need to be\nspecified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)\n\nSee <https://stacks.math.columbia.edu/tag/0014>."}, {"name": "category_theory.mono_of_mono_fac", "description": ""}, {"name": "category_theory.cancel_mono", "description": ""}, {"name": "category_theory.cancel_epi_id", "description": ""}, {"name": "category_theory.large_category", "description": "A `large_category` has objects in one universe level higher than the universe level of\nthe morphisms. It is useful for examples such as the category of types, or the category\nof groups, etc."}, {"name": "category_theory.cancel_epi", "description": ""}, {"name": "category_theory.ulift_category", "description": ""}, {"name": "category_theory.category.assoc", "description": ""}, {"name": "category_theory.epi_of_epi", "description": ""}, {"name": "category_theory.epi", "description": "A morphism `f` is an epimorphism if it can be \"cancelled\" when precomposed:\n`f \u226b g = f \u226b h` implies `g = h`.\n\nSee <https://stacks.math.columbia.edu/tag/003B>."}, {"name": "category_theory.epi.left_cancellation", "description": "A morphism `f` is an epimorphism if it can be \"cancelled\" when precomposed:\n`f \u226b g = f \u226b h` implies `g = h`.\n\nSee <https://stacks.math.columbia.edu/tag/003B>."}, {"name": "category_theory.mono_of_mono", "description": ""}, {"name": "category_theory.dite_comp", "description": ""}, {"name": "category_theory.eq_whisker", "description": "postcompose an equation between morphisms by another morphism"}, {"name": "category_theory.epi_comp", "description": ""}, {"name": "category_theory.whisker_eq", "description": "precompose an equation between morphisms by another morphism"}, {"name": "category_theory.eq_of_comp_left_eq", "description": ""}, {"name": "category_theory.small_category", "description": "A `small_category` has objects and morphisms in the same universe level."}, {"name": "library_note.dsimp, simp", "description": "Many proofs in the category theory library use the `dsimp, simp` pattern,\nwhich typically isn't necessary elsewhere.\n\nOne would usually hope that the same effect could be achieved simply with `simp`.\n\nThe essential issue is that composition of morphisms involves dependent types.\nWhen you have a chain of morphisms being composed, say `f : X \u27f6 Y` and `g : Y \u27f6 Z`,\nthen `simp` can operate succesfully on the morphisms\n(e.g. if `f` is the identity it can strip that off).\n\nHowever if we have an equality of objects, say `Y = Y'`,\nthen `simp` can't operate because it would break the typing of the composition operations.\nWe rarely have interesting equalities of objects\n(because that would be \"evil\" --- anything interesting should be expressed as an isomorphism\nand tracked explicitly),\nexcept of course that we have plenty of definitional equalities of objects.\n\n`dsimp` can apply these safely, even inside a composition.\n\nAfter `dsimp` has cleared up the object level, `simp` can resume work on the morphism level ---\nbut without the `dsimp` step, because `simp` looks at expressions syntactically,\nthe relevant lemmas might not fire.\n\nThere's no bound on how many times you potentially could have to switch back and forth,\nif the `simp` introduced new objects we again need to `dsimp`.\nIn practice this does occur, but only rarely, because `simp` tends to shorten chains of compositions\n(i.e. not introduce new objects at all)."}, {"name": "category_theory.comp_dite", "description": ""}, {"name": "pow_dvd_pow_of_dvd", "description": ""}, {"name": "mul_zpow_neg_one", "description": ""}, {"name": "commute.mul_zpow", "description": ""}, {"name": "commute.zpow_zpow", "description": ""}, {"name": "zsmul_sub", "description": ""}, {"name": "has_dvd.dvd.pow", "description": "**Alias** of `dvd_pow`."}, {"name": "dvd_pow", "description": ""}, {"name": "one_pow", "description": ""}, {"name": "zsmul_neg'", "description": ""}, {"name": "bit1_nsmul'", "description": ""}, {"name": "bit0_nsmul'", "description": ""}, {"name": "zpow_two", "description": ""}, {"name": "commute.zpow_left", "description": ""}, {"name": "zpow_neg_one", "description": ""}, {"name": "pow_mul'", "description": ""}, {"name": "nsmul_add", "description": ""}, {"name": "nsmul_add_comm", "description": ""}, {"name": "zsmul_add", "description": ""}, {"name": "of_add_zsmul", "description": ""}, {"name": "pow_bit0'", "description": ""}, {"name": "nsmul_add_monoid_hom_apply", "description": ""}, {"name": "zpow_group_hom_apply", "description": ""}, {"name": "neg_zsmul", "description": ""}, {"name": "pow_ite", "description": ""}, {"name": "pow_two", "description": "Note that most of the lemmas about powers of two refer to it as `sq`."}, {"name": "add_commute.zsmul_right", "description": ""}, {"name": "of_add_nsmul", "description": ""}, {"name": "two_nsmul", "description": ""}, {"name": "bit0_nsmul", "description": ""}, {"name": "dvd_pow_self", "description": ""}, {"name": "nsmul_zero_sub", "description": ""}, {"name": "pow_mul_comm", "description": ""}, {"name": "zsmul_zero", "description": ""}, {"name": "bit1_nsmul", "description": ""}, {"name": "pow_eq_pow_mod", "description": "If `x ^ n = 1`, then `x ^ m` is the same as `x ^ (m % n)`"}, {"name": "zpow_group_hom", "description": " The `n`-th power map (for an integer `n`) on a commutative group, considered as a group\nhomomorphism."}, {"name": "sub_nsmul", "description": ""}, {"name": "commute.zpow_self", "description": ""}, {"name": "zsmul_neg", "description": ""}, {"name": "pow_add", "description": ""}, {"name": "add_semiconj_by.zsmul_right", "description": ""}, {"name": "zsmul_neg_coe_of_pos", "description": ""}, {"name": "mul_pow", "description": ""}, {"name": "div_zpow", "description": ""}, {"name": "nsmul_add_monoid_hom", "description": "Multiplication by a natural `n` on a commutative additive\nmonoid, considered as a morphism of additive monoids."}, {"name": "inv_zpow", "description": ""}, {"name": "div_pow", "description": ""}, {"name": "zsmul_add_group_hom", "description": "Multiplication by an integer `n` on a commutative additive group, considered as an\nadditive group homomorphism."}, {"name": "one_zpow", "description": ""}, {"name": "mul_nsmul", "description": ""}, {"name": "pow_mul", "description": ""}, {"name": "zpow_one", "description": ""}, {"name": "inv_pow", "description": ""}, {"name": "zsmul_add_group_hom_apply", "description": ""}, {"name": "commute.zpow_right", "description": ""}, {"name": "mul_nsmul'", "description": ""}, {"name": "pow_inv_comm", "description": ""}, {"name": "pow_one", "description": ""}, {"name": "add_commute.zsmul_zsmul", "description": ""}, {"name": "pow_sub", "description": ""}, {"name": "nsmul_add_sub_nsmul", "description": ""}, {"name": "commute.zpow_zpow_self", "description": ""}, {"name": "zpow_neg_coe_of_pos", "description": ""}, {"name": "nsmul_add_comm'", "description": ""}, {"name": "semiconj_by.zpow_right", "description": ""}, {"name": "neg_one_zsmul", "description": ""}, {"name": "zpow_neg", "description": ""}, {"name": "add_commute.zsmul_self", "description": ""}, {"name": "pow_right_comm", "description": ""}, {"name": "nsmul_sub", "description": ""}, {"name": "one_zsmul", "description": ""}, {"name": "nsmul_neg_comm", "description": ""}, {"name": "mul_zpow", "description": ""}, {"name": "add_commute.zsmul_add", "description": ""}, {"name": "sub_nsmul_nsmul_add", "description": ""}, {"name": "pow_bit0", "description": ""}, {"name": "sq", "description": "**Alias** of `pow_two`."}, {"name": "nsmul_zero", "description": ""}, {"name": "neg_nsmul", "description": ""}, {"name": "add_commute.add_nsmul", "description": ""}, {"name": "pow_sub_mul_pow", "description": ""}, {"name": "add_commute.zsmul_left", "description": ""}, {"name": "nsmul_left_comm", "description": ""}, {"name": "sub_nsmul_neg", "description": ""}, {"name": "pow_mul_comm'", "description": ""}, {"name": "add_commute.zsmul_zsmul_self", "description": ""}, {"name": "commute.self_zpow", "description": ""}, {"name": "pow_bit1'", "description": ""}, {"name": "pow_boole", "description": ""}, {"name": "pow_dvd_pow", "description": ""}, {"name": "two_zsmul", "description": ""}, {"name": "nsmul_eq_mod_nsmul", "description": "If `n \u2022 x = 0`, then `m \u2022 x` is the same as `(m % n) \u2022 x`"}, {"name": "pow_monoid_hom", "description": " The `n`th power map on a commutative monoid for a natural `n`, considered as a morphism of\nmonoids."}, {"name": "one_nsmul", "description": ""}, {"name": "zsmul_zero_sub", "description": ""}, {"name": "of_mul_pow", "description": ""}, {"name": "of_mul_zpow", "description": ""}, {"name": "inv_pow_sub", "description": ""}, {"name": "pow_mul_pow_sub", "description": ""}, {"name": "add_nsmul", "description": ""}, {"name": "neg_one_zsmul_add", "description": ""}, {"name": "add_commute.self_zsmul", "description": ""}, {"name": "pow_monoid_hom_apply", "description": ""}, {"name": "pow_bit1", "description": ""}, {"name": "inv_zpow'", "description": ""}, {"name": "one_div_zpow", "description": ""}, {"name": "ite_pow", "description": ""}, {"name": "commute.mul_pow", "description": ""}, {"name": "one_div_pow", "description": ""}, {"name": "list.pairwise_of_forall", "description": ""}, {"name": "list.pairwise.imp", "description": ""}, {"name": "list.pairwise_join", "description": ""}, {"name": "list.pairwise_middle", "description": ""}, {"name": "list.pairwise_reverse", "description": ""}, {"name": "list.pairwise_and_iff", "description": ""}, {"name": "list.pairwise_pmap", "description": ""}, {"name": "list.pw_filter_nil", "description": ""}, {"name": "list.pairwise.filter_map", "description": ""}, {"name": "list.pairwise_map", "description": ""}, {"name": "list.pairwise.sublist", "description": ""}, {"name": "list.pw_filter_sublist", "description": ""}, {"name": "list.rel_of_pairwise_cons", "description": ""}, {"name": "list.pairwise_iff_nth_le", "description": ""}, {"name": "list.pairwise.iff_of_mem", "description": ""}, {"name": "list.pairwise_append", "description": ""}, {"name": "list.pairwise.forall_of_forall", "description": ""}, {"name": "list.pw_filter_map", "description": ""}, {"name": "list.pairwise.pw_filter", "description": "**Alias** of the reverse direction of `list.pw_filter_eq_self`."}, {"name": "list.pw_filter_cons_of_neg", "description": ""}, {"name": "list.pairwise.and_mem", "description": ""}, {"name": "list.pairwise.tail", "description": ""}, {"name": "list.pairwise.filter", "description": ""}, {"name": "list.pairwise_of_reflexive_of_forall_ne", "description": ""}, {"name": "list.pairwise.forall_of_forall_of_flip", "description": ""}, {"name": "list.pairwise.imp_mem", "description": ""}, {"name": "list.pairwise_pair", "description": ""}, {"name": "list.pairwise_bind", "description": ""}, {"name": "list.pairwise_filter", "description": ""}, {"name": "list.pairwise_repeat", "description": ""}, {"name": "list.pairwise.of_cons", "description": ""}, {"name": "list.pairwise_append_comm", "description": ""}, {"name": "list.pairwise.imp\u2082", "description": ""}, {"name": "list.pairwise.drop", "description": ""}, {"name": "list.pw_filter_cons_of_pos", "description": ""}, {"name": "list.pairwise.and", "description": ""}, {"name": "list.pairwise.pmap", "description": ""}, {"name": "list.pairwise_singleton", "description": ""}, {"name": "list.pairwise_sublists", "description": ""}, {"name": "list.pairwise_pw_filter", "description": ""}, {"name": "list.pairwise.iff", "description": ""}, {"name": "list.pairwise_of_reflexive_on_dupl_of_forall_ne", "description": ""}, {"name": "list.pairwise.map", "description": ""}, {"name": "list.pairwise.sublists'", "description": ""}, {"name": "list.pairwise_of_forall_mem_list", "description": ""}, {"name": "list.pairwise_iff", "description": ""}, {"name": "list.pairwise.set_pairwise", "description": ""}, {"name": "list.pairwise.forall", "description": ""}, {"name": "list.pw_filter_eq_self", "description": ""}, {"name": "list.pairwise.of_map", "description": ""}, {"name": "list.pw_filter_subset", "description": ""}, {"name": "list.pairwise_filter_map", "description": ""}, {"name": "list.forall_mem_pw_filter", "description": ""}, {"name": "list.pairwise.imp_of_mem", "description": ""}, {"name": "list.pw_filter_idempotent", "description": ""}, {"name": "traversable.id_sequence", "description": ""}, {"name": "traversable.pure_traverse", "description": ""}, {"name": "traversable.pure_transformation_apply", "description": ""}, {"name": "traversable.traverse_id", "description": ""}, {"name": "traversable.traverse_comp", "description": ""}, {"name": "traversable.traverse_map'", "description": ""}, {"name": "traversable.map_traverse", "description": ""}, {"name": "traversable.comp_sequence", "description": ""}, {"name": "traversable.naturality'", "description": ""}, {"name": "traversable.map_eq_traverse_id", "description": ""}, {"name": "traversable.naturality_pf", "description": ""}, {"name": "traversable.traverse_map", "description": ""}, {"name": "traversable.map_traverse'", "description": ""}, {"name": "traversable.traverse_eq_map_id'", "description": ""}, {"name": "traversable.pure_transformation", "description": " The natural applicative transformation from the identity functor\nto `F`, defined by `pure : \u03a0 {\u03b1}, \u03b1 \u2192 F \u03b1`."}, {"name": "id.is_comm_applicative", "description": ""}, {"name": "functor.comp.applicative_id_comp", "description": ""}, {"name": "applicative.map_seq_map", "description": ""}, {"name": "functor.add_const.is_lawful_applicative", "description": ""}, {"name": "functor.comp.is_lawful_applicative", "description": ""}, {"name": "comp.seq_mk", "description": ""}, {"name": "functor.comp.seq_assoc", "description": ""}, {"name": "functor.const.applicative", "description": ""}, {"name": "functor.comp.is_comm_applicative", "description": ""}, {"name": "functor.comp.map_pure", "description": ""}, {"name": "functor.comp.seq_pure", "description": ""}, {"name": "functor.const.is_lawful_applicative", "description": ""}, {"name": "applicative.pure_seq_eq_map'", "description": ""}, {"name": "applicative.ext", "description": ""}, {"name": "functor.comp.applicative_comp_id", "description": ""}, {"name": "functor.comp.pure_seq_eq_map", "description": ""}, {"name": "functor.add_const.applicative", "description": ""}, {"name": "level.occurs", "description": "Return tt iff the first level occurs in the second"}, {"name": "level.lt", "description": ""}, {"name": "level.lex_lt", "description": ""}, {"name": "level.has_to_format", "description": ""}, {"name": "level", "description": "A type universe term. eg `max u v`. Reflect a C++ level object. The VM replaces it with the C++ implementation."}, {"name": "level.zero", "description": "A type universe term. eg `max u v`. Reflect a C++ level object. The VM replaces it with the C++ implementation."}, {"name": "level.succ", "description": "A type universe term. eg `max u v`. Reflect a C++ level object. The VM replaces it with the C++ implementation."}, {"name": "level.max", "description": "A type universe term. eg `max u v`. Reflect a C++ level object. The VM replaces it with the C++ implementation."}, {"name": "level.imax", "description": "A type universe term. eg `max u v`. Reflect a C++ level object. The VM replaces it with the C++ implementation."}, {"name": "level.param", "description": "A type universe term. eg `max u v`. Reflect a C++ level object. The VM replaces it with the C++ implementation."}, {"name": "level.mvar", "description": "A type universe term. eg `max u v`. Reflect a C++ level object. The VM replaces it with the C++ implementation."}, {"name": "level.of_nat", "description": ""}, {"name": "level.to_format", "description": ""}, {"name": "level.to_string", "description": ""}, {"name": "level.instantiate", "description": "Replace a parameter named n with l in the first level if the list contains the pair (n, l)"}, {"name": "level.fold", "description": ""}, {"name": "level.has_decidable_eq", "description": ""}, {"name": "level.has_param", "description": ""}, {"name": "level.has_to_string", "description": ""}, {"name": "level.normalize", "description": "Return the given level expression normal form"}, {"name": "level.inhabited", "description": ""}, {"name": "level.eqv", "description": "Return tt iff lhs and rhs denote the same level.\n  The check is done by normalization."}, {"name": "category_theory.eq_to_hom.is_iso", "description": ""}, {"name": "category_theory.congr_arg_mpr_hom_right", "description": "If we (perhaps unintentionally) perform equational rewriting on\nthe target object of a morphism,\nwe can replace the resulting `_.mpr f` term by a composition with an `eq_to_hom`.\n\nIt may be advisable to introduce any necessary `eq_to_hom` morphisms manually,\nrather than relying on this lemma firing."}, {"name": "category_theory.functor.hext", "description": "Proving equality between functors using heterogeneous equality."}, {"name": "category_theory.eq_to_iso.hom", "description": ""}, {"name": "category_theory.functor.map_comp_heq'", "description": ""}, {"name": "category_theory.functor.precomp_map_heq", "description": ""}, {"name": "category_theory.eq_to_hom", "description": "An equality `X = Y` gives us a morphism `X \u27f6 Y`.\n\nIt is typically better to use this, rather than rewriting by the equality then using `\ud835\udfd9 _`\nwhich usually leads to dependent type theory hell."}, {"name": "category_theory.functor.hcongr_hom", "description": ""}, {"name": "category_theory.eq_conj_eq_to_hom", "description": ""}, {"name": "category_theory.eq_to_iso_refl", "description": ""}, {"name": "category_theory.eq_to_iso_map", "description": "See the note on `eq_to_hom_map` regarding using this as a `simp` lemma."}, {"name": "category_theory.congr_arg_mpr_hom_left", "description": "If we (perhaps unintentionally) perform equational rewriting on\nthe source object of a morphism,\nwe can replace the resulting `_.mpr f` term by a composition with an `eq_to_hom`.\n\nIt may be advisable to introduce any necessary `eq_to_hom` morphisms manually,\nrather than relying on this lemma firing."}, {"name": "category_theory.eq_to_iso.inv", "description": ""}, {"name": "category_theory.functor.postcomp_map_heq", "description": ""}, {"name": "category_theory.eq_to_hom_refl", "description": ""}, {"name": "category_theory.eq_to_hom_app", "description": ""}, {"name": "category_theory.eq_to_hom_unop", "description": ""}, {"name": "category_theory.functor.ext", "description": "Proving equality between functors. This isn't an extensionality lemma,\n because usually you don't really want to do this."}, {"name": "category_theory.functor.postcomp_map_heq'", "description": ""}, {"name": "category_theory.functor.congr_obj", "description": ""}, {"name": "category_theory.functor.map_comp_heq", "description": ""}, {"name": "category_theory.eq_to_hom_op", "description": ""}, {"name": "category_theory.dcongr_arg", "description": ""}, {"name": "category_theory.inv_eq_to_hom", "description": ""}, {"name": "category_theory.eq_to_hom_trans_assoc", "description": ""}, {"name": "category_theory.eq_to_iso", "description": "An equality `X = Y` gives us an isomorphism `X \u2245 Y`.\n\nIt is typically better to use this, rather than rewriting by the equality then using `iso.refl _`\nwhich usually leads to dependent type theory hell."}, {"name": "category_theory.functor.congr_map", "description": ""}, {"name": "category_theory.functor.congr_inv_of_congr_hom", "description": ""}, {"name": "category_theory.functor.congr_hom", "description": ""}, {"name": "category_theory.functor.conj_eq_to_hom_iff_heq", "description": "Two morphisms are conjugate via eq_to_hom if and only if they are heterogeneously equal. -"}, {"name": "category_theory.eq_to_hom_map", "description": "This is not always a good idea as a `@[simp]` lemma,\nas we lose the ability to use results that interact with `F`,\ne.g. the naturality of a natural transformation.\n\nIn some files it may be appropriate to use `local attribute [simp] eq_to_hom_map`, however."}, {"name": "category_theory.eq_to_hom_trans", "description": ""}, {"name": "category_theory.eq_to_iso_trans", "description": ""}, {"name": "category_theory.nat_trans.congr", "description": ""}, {"name": "is_valid_char_range_1", "description": ""}, {"name": "char.decidable_eq", "description": ""}, {"name": "is_valid_char_range_2", "description": ""}, {"name": "char.decidable_lt", "description": ""}, {"name": "char.has_le", "description": ""}, {"name": "char.of_nat", "description": ""}, {"name": "char.veq_of_eq", "description": ""}, {"name": "char", "description": "The `char` type represents an unicode scalar value.\n   See http://www.unicode.org/glossary/#unicode_scalar_value)."}, {"name": "char.val", "description": "The `char` type represents an unicode scalar value.\n   See http://www.unicode.org/glossary/#unicode_scalar_value)."}, {"name": "char.valid", "description": "The `char` type represents an unicode scalar value.\n   See http://www.unicode.org/glossary/#unicode_scalar_value)."}, {"name": "char.has_sizeof", "description": ""}, {"name": "char.le", "description": ""}, {"name": "char.ne_of_vne", "description": ""}, {"name": "char.to_nat", "description": ""}, {"name": "char.has_lt", "description": ""}, {"name": "char.vne_of_ne", "description": ""}, {"name": "char.inhabited", "description": ""}, {"name": "char.decidable_le", "description": ""}, {"name": "char.eq_of_veq", "description": ""}, {"name": "is_valid_char", "description": ""}, {"name": "char.lt", "description": ""}, {"name": "char.zero_lt_d800", "description": ""}, {"name": "equiv.nat_sum_nat_equiv_nat", "description": "An equivalence between `\u2115 \u2295 \u2115` and `\u2115`, by mapping `(sum.inl x)` to `2 * x` and `(sum.inr x)` to\n`2 * x + 1`."}, {"name": "equiv.nat_sum_nat_equiv_nat_symm_apply", "description": ""}, {"name": "equiv.int_equiv_nat", "description": "An equivalence between `\u2124` and `\u2115`, through `\u2124 \u2243 \u2115 \u2295 \u2115` and `\u2115 \u2295 \u2115 \u2243 \u2115`."}, {"name": "equiv.bool_prod_nat_equiv_nat", "description": "An equivalence between `bool \u00d7 \u2115` and `\u2115`, by mapping `(tt, x)` to `2 * x + 1` and `(ff, x)` to\n`2 * x`."}, {"name": "equiv.bool_prod_nat_equiv_nat_apply", "description": ""}, {"name": "equiv.bool_prod_nat_equiv_nat_symm_apply", "description": ""}, {"name": "equiv.nat_sum_nat_equiv_nat_apply", "description": ""}, {"name": "equiv.prod_equiv_of_equiv_nat", "description": "An equivalence between `\u03b1 \u00d7 \u03b1` and `\u03b1`, given that there is an equivalence between `\u03b1` and `\u2115`."}, {"name": "function.injective.coframe", "description": "Pullback an `order.coframe` along an injection."}, {"name": "order_dual.complete_distrib_lattice", "description": ""}, {"name": "pi.coframe", "description": ""}, {"name": "binfi_sup_eq", "description": ""}, {"name": "order.coframe", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.sup", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.le", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.lt", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.le_refl", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.le_trans", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.lt_iff_le_not_le", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.le_antisymm", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.le_sup_left", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.le_sup_right", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.sup_le", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.inf", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.inf_le_left", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.inf_le_right", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.le_inf", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.Sup", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.le_Sup", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.Sup_le", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.Inf", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.Inf_le", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.le_Inf", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.top", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.bot", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.le_top", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.bot_le", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "order.coframe.infi_sup_le_sup_Inf", "description": " A coframe, aka complete Brouwer algebra or complete co-Heyting algebra, is a complete lattice\nwhose `\u2294` distributes over `\u2a05`."}, {"name": "compl_Sup'", "description": ""}, {"name": "supr_inf_of_antitone", "description": ""}, {"name": "Inf_sup_eq", "description": ""}, {"name": "function.injective.frame", "description": "Pullback an `order.frame` along an injection."}, {"name": "pi.complete_boolean_algebra", "description": ""}, {"name": "coframe.to_distrib_lattice", "description": ""}, {"name": "disjoint_supr_iff", "description": ""}, {"name": "order.coframe.to_complete_lattice", "description": ""}, {"name": "inf_supr_eq", "description": ""}, {"name": "binfi_sup_binfi", "description": ""}, {"name": "function.injective.complete_boolean_algebra", "description": "Pullback a `complete_boolean_algebra` along an injection."}, {"name": "Sup_inf_eq", "description": ""}, {"name": "Sup_disjoint_iff", "description": ""}, {"name": "frame.to_distrib_lattice", "description": ""}, {"name": "sup_Inf_eq", "description": ""}, {"name": "punit.Sup_eq", "description": ""}, {"name": "Inf_sup_Inf", "description": ""}, {"name": "supr\u2082_disjoint_iff", "description": ""}, {"name": "complete_distrib_lattice.to_coframe", "description": ""}, {"name": "infi_sup_infi", "description": ""}, {"name": "Sup_inf_Sup", "description": ""}, {"name": "compl_infi", "description": ""}, {"name": "pi.frame", "description": ""}, {"name": "Prop.complete_boolean_algebra", "description": ""}, {"name": "disjoint_supr\u2082_iff", "description": ""}, {"name": "punit.Inf_eq", "description": ""}, {"name": "pi.complete_distrib_lattice", "description": ""}, {"name": "disjoint_Sup_iff", "description": ""}, {"name": "supr_disjoint_iff", "description": ""}, {"name": "complete_boolean_algebra.to_complete_distrib_lattice", "description": ""}, {"name": "order.frame.to_complete_lattice", "description": ""}, {"name": "complete_boolean_algebra", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.sup", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.le", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.lt", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.le_refl", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.le_trans", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.lt_iff_le_not_le", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.le_antisymm", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.le_sup_left", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.le_sup_right", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.sup_le", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.inf", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.inf_le_left", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.inf_le_right", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.le_inf", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.le_sup_inf", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.compl", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.sdiff", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.top", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.bot", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.inf_compl_le_bot", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.top_le_sup_compl", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.le_top", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.bot_le", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.sdiff_eq", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.Sup", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.le_Sup", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.Sup_le", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.Inf", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.Inf_le", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.le_Inf", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.inf_Sup_le_supr_inf", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.infi_sup_le_sup_Inf", "description": "A complete Boolean algebra is a completely distributive Boolean algebra."}, {"name": "complete_boolean_algebra.to_boolean_algebra", "description": ""}, {"name": "infi_sup_of_antitone", "description": ""}, {"name": "punit.complete_boolean_algebra", "description": ""}, {"name": "order_dual.coframe", "description": ""}, {"name": "infi_sup_eq", "description": ""}, {"name": "supr_inf_of_monotone", "description": ""}, {"name": "infi_sup_of_monotone", "description": ""}, {"name": "function.injective.complete_distrib_lattice", "description": "Pullback a `complete_distrib_lattice` along an injection."}, {"name": "inf_Sup_eq", "description": ""}, {"name": "compl_Inf", "description": ""}, {"name": "supr_inf_supr", "description": ""}, {"name": "order.frame", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.sup", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.le", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.lt", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.le_refl", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.le_trans", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.lt_iff_le_not_le", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.le_antisymm", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.le_sup_left", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.le_sup_right", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.sup_le", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.inf", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.inf_le_left", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.inf_le_right", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.le_inf", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.Sup", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.le_Sup", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.Sup_le", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.Inf", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.Inf_le", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.le_Inf", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.top", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.bot", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.le_top", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.bot_le", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "order.frame.inf_Sup_le_supr_inf", "description": "A frame, aka complete Heyting algebra, is a complete lattice whose `\u2293` distributes over `\u2a06`."}, {"name": "sup_infi_eq", "description": ""}, {"name": "bsupr_inf_bsupr", "description": ""}, {"name": "complete_distrib_lattice", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.sup", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.le", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.lt", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.le_refl", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.le_trans", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.lt_iff_le_not_le", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.le_antisymm", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.le_sup_left", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.le_sup_right", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.sup_le", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.inf", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.inf_le_left", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.inf_le_right", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.le_inf", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.Sup", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.le_Sup", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.Sup_le", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.Inf", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.Inf_le", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.le_Inf", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.top", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.bot", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.le_top", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.bot_le", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.inf_Sup_le_supr_inf", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "complete_distrib_lattice.infi_sup_le_sup_Inf", "description": " A completely distributive lattice is a complete lattice whose `\u2294` and `\u2293` respectively\ndistribute over `\u2a05` and `\u2a06`."}, {"name": "compl_supr", "description": ""}, {"name": "compl_Inf'", "description": ""}, {"name": "order_dual.frame", "description": ""}, {"name": "supr_inf_eq", "description": ""}, {"name": "inf_bsupr_eq", "description": ""}, {"name": "complete_distrib_lattice.to_frame", "description": ""}, {"name": "compl_Sup", "description": ""}, {"name": "sup_binfi_eq", "description": ""}, {"name": "bsupr_inf_eq", "description": ""}, {"name": "finset.coe_powerset", "description": ""}, {"name": "finset.decidable_forall_of_decidable_subsets", "description": "For predicate `p` decidable on subsets, it is decidable whether `p` holds for every subset."}, {"name": "finset.powerset_len_map", "description": ""}, {"name": "finset.not_mem_of_mem_powerset_of_not_mem", "description": ""}, {"name": "finset.powerset_len", "description": " Given an integer `n` and a finset `s`, then `powerset_len n s` is the finset of subsets of `s`\nof cardinality `n`."}, {"name": "finset.map_val_val_powerset_len", "description": ""}, {"name": "finset.powerset_len_succ_insert", "description": ""}, {"name": "finset.powerset_injective", "description": ""}, {"name": "finset.mem_powerset_self", "description": ""}, {"name": "finset.powerset_nonempty", "description": ""}, {"name": "finset.empty_mem_powerset", "description": ""}, {"name": "finset.powerset_len_nonempty", "description": ""}, {"name": "finset.powerset_mono", "description": ""}, {"name": "finset.powerset_len_eq_filter", "description": ""}, {"name": "finset.decidable_forall_of_decidable_subsets'", "description": " A version of `finset.decidable_forall_of_decidable_subsets` with a non-dependent `p`.\nTypeclass inference cannot find `hu` here, so this is not an instance."}, {"name": "finset.powerset_inj", "description": ""}, {"name": "finset.decidable_exists_of_decidable_ssubsets'", "description": " A version of `finset.decidable_exists_of_decidable_ssubsets` with a non-dependent `p`.\nTypeclass inference cannot find `hu` here, so this is not an instance."}, {"name": "finset.ssubsets", "description": "For `s` a finset, `s.ssubsets` is the finset comprising strict subsets of `s`."}, {"name": "finset.powerset_len_self", "description": ""}, {"name": "finset.powerset_len_card_add", "description": ""}, {"name": "finset.empty_mem_ssubsets", "description": ""}, {"name": "finset.decidable_forall_of_decidable_ssubsets'", "description": " A version of `finset.decidable_forall_of_decidable_ssubsets` with a non-dependent `p`.\nTypeclass inference cannot find `hu` here, so this is not an instance."}, {"name": "finset.powerset_len_empty", "description": ""}, {"name": "finset.mem_powerset", "description": ""}, {"name": "finset.powerset_empty", "description": ""}, {"name": "finset.mem_ssubsets", "description": ""}, {"name": "finset.decidable_forall_of_decidable_ssubsets", "description": "For predicate `p` decidable on ssubsets, it is decidable whether `p` holds for every ssubset."}, {"name": "finset.powerset_len_zero", "description": ""}, {"name": "finset.decidable_exists_of_decidable_subsets", "description": "For predicate `p` decidable on subsets, it is decidable whether `p` holds for any subset."}, {"name": "finset.powerset_insert", "description": ""}, {"name": "finset.powerset", "description": "When `s` is a finset, `s.powerset` is the finset of all subsets of `s` (seen as finsets)."}, {"name": "finset.powerset_eq_singleton_empty", "description": ""}, {"name": "finset.card_powerset_len", "description": "**Formula for the Number of Combinations**"}, {"name": "finset.powerset_len_sup", "description": ""}, {"name": "finset.powerset_len_mono", "description": ""}, {"name": "finset.powerset_card_bUnion", "description": ""}, {"name": "finset.decidable_exists_of_decidable_ssubsets", "description": "For predicate `p` decidable on ssubsets, it is decidable whether `p` holds for any ssubset."}, {"name": "finset.card_powerset", "description": "**Number of Subsets of a Set**"}, {"name": "finset.mem_powerset_len", "description": "**Formula for the Number of Combinations**"}, {"name": "finset.decidable_exists_of_decidable_subsets'", "description": " A version of `finset.decidable_exists_of_decidable_subsets` with a non-dependent `p`.\nTypeclass inference cannot find `hu` here, so this is not an instance."}, {"name": "operations.xor_inv", "description": ""}, {"name": "operations.rotl_inv", "description": "Inverse of the rotate operation (`rotl`)."}, {"name": "operations.double_mod", "description": ""}, {"name": "operations.xor", "description": "The salsa20 xor operation is just bitwise xor."}, {"name": "operations.modular_magic", "description": ""}, {"name": "operations.op_neq", "description": "Two operations are different if any side of the XOR is different."}, {"name": "operations.mod_neg", "description": ""}, {"name": "operations.xor_assoc", "description": ""}, {"name": "operations.mod", "description": " Bitwise modulo addition implemented as detailed in\nhttps://stackoverflow.com/a/19760152"}, {"name": "operations.operation", "description": " With the split done in `operation_rhs`, an operation is just\na XOR of 2 bitvectors."}, {"name": "operations.xor_zero", "description": ""}, {"name": "operations.operation_inverse", "description": "OP is just XOR, so each operation is its own inverse."}, {"name": "operations.neg_mod", "description": ""}, {"name": "operations.inv_of_mod_is_not_a_function", "description": ""}, {"name": "operations.mod_self", "description": ""}, {"name": "operations.operation_rhs", "description": " We split the salsa20 operations in 2 terms, one\nat each side of the XOR. This is the right hand side."}, {"name": "operations.op_eq", "description": "Two operations are equal if both sides of the XOR are equal."}, {"name": "operations.rotl", "description": " Rotate operation.\nImplements DJB's definition of '<<<' : https://github.com/alexwebr/salsa20/blob/master/salsa20.c#L6"}, {"name": "operations.zero_rotl", "description": ""}, {"name": "list.sublists_len_sublist_sublists'", "description": ""}, {"name": "list.sublists_len_aux_eq", "description": ""}, {"name": "list.sublists_aux_eq_foldr", "description": ""}, {"name": "list.length_sublists_len", "description": ""}, {"name": "list.sublists_len_succ_nil", "description": ""}, {"name": "list.mem_sublists_len_self", "description": ""}, {"name": "list.sublists_nil", "description": ""}, {"name": "list.sublists_reverse", "description": ""}, {"name": "list.sublists'_eq_sublists", "description": ""}, {"name": "list.mem_sublists_len", "description": ""}, {"name": "list.sublists_append", "description": ""}, {"name": "list.mem_sublists'", "description": ""}, {"name": "list.sublists_aux_cons_eq_sublists_aux\u2081", "description": ""}, {"name": "list.mem_sublists", "description": ""}, {"name": "list.length_of_sublists_len", "description": ""}, {"name": "list.sublists_len_sublist_of_sublist", "description": ""}, {"name": "list.sublists_aux_cons_cons", "description": ""}, {"name": "list.sublists_concat", "description": ""}, {"name": "list.sublists_aux_ne_nil", "description": ""}, {"name": "list.sublists'_cons", "description": ""}, {"name": "list.sublists_aux_eq_foldr.aux", "description": ""}, {"name": "list.sublists'_reverse", "description": ""}, {"name": "list.sublists_len_succ_cons", "description": ""}, {"name": "list.sublists_aux\u2081_eq_sublists_aux", "description": ""}, {"name": "list.sublists_aux\u2081_bind", "description": ""}, {"name": "list.sublists_singleton", "description": ""}, {"name": "list.sublists_len", "description": " The list of all sublists of a list `l` that are of length `n`. For instance, for\n`l = [0, 1, 2, 3]` and `n = 2`, one gets\n`[[2, 3], [1, 3], [1, 2], [0, 3], [0, 2], [0, 1]]`."}, {"name": "list.sublists_aux\u2081_append", "description": ""}, {"name": "list.length_sublists", "description": ""}, {"name": "list.sublists_len_aux_zero", "description": ""}, {"name": "list.map_sublists'_aux", "description": ""}, {"name": "list.sublists'_singleton", "description": ""}, {"name": "list.sublists_len_aux_append", "description": ""}, {"name": "list.map_ret_sublist_sublists", "description": ""}, {"name": "list.sublists_aux\u2081_concat", "description": ""}, {"name": "list.sublists_len_aux", "description": " Auxiliary function to construct the list of all sublists of a given length. Given an\ninteger `n`, a list `l`, a function `f` and an auxiliary list `L`, it returns the list made of\nof `f` applied to all sublists of `l` of length `n`, concatenated with `L`."}, {"name": "list.length_sublists'", "description": ""}, {"name": "list.sublists'_aux_eq_sublists'", "description": ""}, {"name": "list.sublists'_aux_append", "description": ""}, {"name": "list.sublists'_nil", "description": ""}, {"name": "list.sublists_eq_sublists'", "description": ""}, {"name": "list.sublists_aux_cons_append", "description": ""}, {"name": "list.sublists_len_zero", "description": ""}, {"name": "local_context.is_subset", "description": ""}, {"name": "local_context.has_mem", "description": ""}, {"name": "local_context.has_to_format", "description": ""}, {"name": "local_context.mk_local", "description": " Add a new local constant to the lc. The new local has an unused unique_name.\nFails when the type depends on local constants that are not present in the context."}, {"name": "local_decl", "description": ""}, {"name": "local_decl.unique_name", "description": ""}, {"name": "local_decl.pp_name", "description": ""}, {"name": "local_decl.type", "description": ""}, {"name": "local_decl.value", "description": ""}, {"name": "local_decl.bi", "description": ""}, {"name": "local_decl.idx", "description": ""}, {"name": "local_context", "description": " A local context is a list of local constant declarations.\nEach metavariable in a metavariable context holds a local_context\nto declare which locals the metavariable is allowed to depend on."}, {"name": "local_context.get_local_decl", "description": ""}, {"name": "local_context.has_decidable_eq", "description": ""}, {"name": "local_decl.to_expr", "description": ""}, {"name": "local_context.has_emptyc", "description": ""}, {"name": "local_context.has_le", "description": ""}, {"name": "local_context.to_list", "description": ""}, {"name": "local_context.decidable_rel", "description": ""}, {"name": "local_context.empty", "description": "The empty local context."}, {"name": "local_context.has_mem.mem.decidable", "description": ""}, {"name": "local_context.to_format", "description": ""}, {"name": "local_context.fold", "description": ""}, {"name": "local_context.get_local", "description": ""}, {"name": "local_context.inhabited", "description": ""}, {"name": "tactic.flat_assoc", "description": ""}, {"name": "tactic.perm_ac", "description": ""}, {"name": "old_conv", "description": ""}, {"name": "old_conv.skip", "description": ""}, {"name": "old_conv.failed", "description": ""}, {"name": "old_conv.repeat", "description": ""}, {"name": "old_conv.trace", "description": ""}, {"name": "old_conv.findp", "description": ""}, {"name": "old_conv.first", "description": ""}, {"name": "old_conv.dsimp", "description": ""}, {"name": "old_conv_result", "description": ""}, {"name": "old_conv_result.val", "description": ""}, {"name": "old_conv_result.rhs", "description": ""}, {"name": "old_conv_result.proof", "description": ""}, {"name": "old_conv.change", "description": ""}, {"name": "old_conv.apply_propext_lemmas", "description": ""}, {"name": "old_conv.apply_lemmas_core", "description": ""}, {"name": "old_conv.orelse", "description": ""}, {"name": "old_conv.to_tactic", "description": ""}, {"name": "old_conv.conversion", "description": ""}, {"name": "old_conv.apply_propext_simp_set", "description": ""}, {"name": "old_conv.apply_lemmas", "description": ""}, {"name": "old_conv.trace_lhs", "description": ""}, {"name": "old_conv.match_pattern", "description": ""}, {"name": "old_conv.funext", "description": ""}, {"name": "old_conv.find_pattern", "description": ""}, {"name": "old_conv.lhs", "description": ""}, {"name": "old_conv.alternative", "description": ""}, {"name": "old_conv.congr_core", "description": ""}, {"name": "old_conv.apply_propext_lemmas_core", "description": ""}, {"name": "old_conv.monad", "description": ""}, {"name": "old_conv.apply_simp_set", "description": ""}, {"name": "old_conv.whnf", "description": ""}, {"name": "old_conv.find", "description": ""}, {"name": "old_conv.top_down", "description": ""}, {"name": "old_conv.bind", "description": ""}, {"name": "old_conv.bottom_up", "description": ""}, {"name": "old_conv.pure", "description": ""}, {"name": "old_conv.seq", "description": ""}, {"name": "old_conv.congr", "description": ""}, {"name": "old_conv.fail", "description": ""}, {"name": "old_conv.map", "description": ""}, {"name": "old_conv.lift_tactic", "description": ""}, {"name": "old_conv.mk_match_expr", "description": ""}, {"name": "old_conv.match_expr", "description": ""}, {"name": "contravariant_mul_lt_of_covariant_mul_le", "description": ""}, {"name": "add_left_cancel_semigroup.contravariant_add_le_of_contravariant_add_lt", "description": ""}, {"name": "contravariant_swap_add_lt_of_contravariant_add_lt", "description": ""}, {"name": "covariant_add_lt_of_contravariant_add_le", "description": ""}, {"name": "antitone.covariant_of_const'", "description": "Dual of `monotone.covariant_of_const'`"}, {"name": "covariant.monotone_of_const", "description": "The partial application of a constant to a covariant operator is monotone."}, {"name": "contravariant_lt_of_contravariant_le", "description": ""}, {"name": "antitone.covariant_of_const", "description": "Dual of `monotone.covariant_of_const`"}, {"name": "contravariant_flip_mul_iff", "description": ""}, {"name": "add_right_cancel_semigroup.contravariant_swap_add_le_of_contravariant_swap_add_lt", "description": ""}, {"name": "covariant_swap_add_le_of_covariant_add_le", "description": ""}, {"name": "left_cancel_semigroup.contravariant_mul_le_of_contravariant_mul_lt", "description": ""}, {"name": "add_group.covariant_iff_contravariant", "description": ""}, {"name": "covariant_flip_mul_iff", "description": ""}, {"name": "group.covconv_swap", "description": ""}, {"name": "rel_act_of_rel_of_rel_act", "description": ""}, {"name": "group.covariant_iff_contravariant", "description": ""}, {"name": "covariant_le_of_covariant_lt", "description": ""}, {"name": "add_group.covconv_swap", "description": ""}, {"name": "contravariant_flip_add_iff", "description": ""}, {"name": "contravariant.flip", "description": ""}, {"name": "covariant_le_iff_contravariant_lt", "description": ""}, {"name": "group.covconv", "description": ""}, {"name": "right_cancel_semigroup.contravariant_swap_mul_le_of_contravariant_swap_mul_lt", "description": ""}, {"name": "act_rel_act_of_rel_of_rel", "description": ""}, {"name": "contravariant_swap_mul_lt_of_contravariant_mul_lt", "description": ""}, {"name": "covariant_flip_add_iff", "description": ""}, {"name": "monotone.covariant_of_const'", "description": " Same as `monotone.covariant_of_const`, but with the constant on the other side of\nthe operator.  E.g., `\u2200 (m : \u2115), monotone f \u2192 monotone (\u03bb n, f (n + m))`."}, {"name": "covariant_class", "description": "  Given an action `\u03bc` of a Type `M` on a Type `N` and a relation `r` on `N`, informally, the\n`covariant_class` says that \"the action `\u03bc` preserves the relation `r`.\"\n\nMore precisely, the `covariant_class` is a class taking two Types `M N`, together with an \"action\"\n`\u03bc : M \u2192 N \u2192 N` and a relation `r : N \u2192 N \u2192 Prop`.  Its unique field `elim` is the assertion that\nfor all `m \u2208 M` and all elements `n\u2081, n\u2082 \u2208 N`, if the relation `r` holds for the pair\n`(n\u2081, n\u2082)`, then, the relation `r` also holds for the pair `(\u03bc m n\u2081, \u03bc m n\u2082)`,\nobtained from `(n\u2081, n\u2082)` by acting upon it by `m`.\n\nIf `m : M` and `h : r n\u2081 n\u2082`, then `covariant_class.elim m h : r (\u03bc m n\u2081) (\u03bc m n\u2082)`."}, {"name": "covariant_class.elim", "description": "  Given an action `\u03bc` of a Type `M` on a Type `N` and a relation `r` on `N`, informally, the\n`covariant_class` says that \"the action `\u03bc` preserves the relation `r`.\"\n\nMore precisely, the `covariant_class` is a class taking two Types `M N`, together with an \"action\"\n`\u03bc : M \u2192 N \u2192 N` and a relation `r : N \u2192 N \u2192 Prop`.  Its unique field `elim` is the assertion that\nfor all `m \u2208 M` and all elements `n\u2081, n\u2082 \u2208 N`, if the relation `r` holds for the pair\n`(n\u2081, n\u2082)`, then, the relation `r` also holds for the pair `(\u03bc m n\u2081, \u03bc m n\u2082)`,\nobtained from `(n\u2081, n\u2082)` by acting upon it by `m`.\n\nIf `m : M` and `h : r n\u2081 n\u2082`, then `covariant_class.elim m h : r (\u03bc m n\u2081) (\u03bc m n\u2082)`."}, {"name": "covariant_swap_mul_lt_of_covariant_mul_lt", "description": ""}, {"name": "act_rel_of_act_rel_of_rel_act_rel", "description": ""}, {"name": "covariant", "description": " `covariant` is useful to formulate succintly statements about the interactions between an\naction of a Type on another one and a relation on the acted-upon Type.\n\nSee the `covariant_class` doc-string for its meaning."}, {"name": "covariant.flip", "description": ""}, {"name": "covariant_mul_lt_of_contravariant_mul_le", "description": ""}, {"name": "rel_act_of_act_rel_act_of_rel_act", "description": ""}, {"name": "contravariant_add_lt_of_covariant_add_le", "description": ""}, {"name": "group.covariant_swap_iff_contravariant_swap", "description": ""}, {"name": "covariant_lt_iff_contravariant_le", "description": ""}, {"name": "rel_iff_cov", "description": ""}, {"name": "add_group.covariant_swap_iff_contravariant_swap", "description": ""}, {"name": "left_cancel_semigroup.covariant_mul_lt_of_covariant_mul_le", "description": ""}, {"name": "monotone.covariant_of_const", "description": " A monotone function remains monotone when composed with the partial application\nof a covariant operator. E.g., `\u2200 (m : \u2115), monotone f \u2192 monotone (\u03bb n, f (m + n))`."}, {"name": "contravariant", "description": " `contravariant` is useful to formulate succintly statements about the interactions between an\naction of a Type on another one and a relation on the acted-upon Type.\n\nSee the `contravariant_class` doc-string for its meaning."}, {"name": "covariant_swap_add_lt_of_covariant_add_lt", "description": ""}, {"name": "add_group.covconv", "description": ""}, {"name": "contravariant_class", "description": "  Given an action `\u03bc` of a Type `M` on a Type `N` and a relation `r` on `N`, informally, the\n`contravariant_class` says that \"if the result of the action `\u03bc` on a pair satisfies the\nrelation `r`, then the initial pair satisfied the relation `r`.\"\n\nMore precisely, the `contravariant_class` is a class taking two Types `M N`, together with an\n\"action\" `\u03bc : M \u2192 N \u2192 N` and a relation `r : N \u2192 N \u2192 Prop`.  Its unique field `elim` is the\nassertion that for all `m \u2208 M` and all elements `n\u2081, n\u2082 \u2208 N`, if the relation `r` holds for the\npair `(\u03bc m n\u2081, \u03bc m n\u2082)` obtained from `(n\u2081, n\u2082)` by acting upon it by `m`, then, the relation\n`r` also holds for the pair `(n\u2081, n\u2082)`.\n\nIf `m : M` and `h : r (\u03bc m n\u2081) (\u03bc m n\u2082)`, then `contravariant_class.elim m h : r n\u2081 n\u2082`."}, {"name": "contravariant_class.elim", "description": "  Given an action `\u03bc` of a Type `M` on a Type `N` and a relation `r` on `N`, informally, the\n`contravariant_class` says that \"if the result of the action `\u03bc` on a pair satisfies the\nrelation `r`, then the initial pair satisfied the relation `r`.\"\n\nMore precisely, the `contravariant_class` is a class taking two Types `M N`, together with an\n\"action\" `\u03bc : M \u2192 N \u2192 N` and a relation `r : N \u2192 N \u2192 Prop`.  Its unique field `elim` is the\nassertion that for all `m \u2208 M` and all elements `n\u2081, n\u2082 \u2208 N`, if the relation `r` holds for the\npair `(\u03bc m n\u2081, \u03bc m n\u2082)` obtained from `(n\u2081, n\u2082)` by acting upon it by `m`, then, the relation\n`r` also holds for the pair `(n\u2081, n\u2082)`.\n\nIf `m : M` and `h : r (\u03bc m n\u2081) (\u03bc m n\u2082)`, then `contravariant_class.elim m h : r n\u2081 n\u2082`."}, {"name": "act_rel_of_rel_of_act_rel", "description": ""}, {"name": "add_left_cancel_semigroup.covariant_add_lt_of_covariant_add_le", "description": ""}, {"name": "right_cancel_semigroup.covariant_swap_mul_lt_of_covariant_swap_mul_le", "description": ""}, {"name": "act_rel_act_of_rel", "description": ""}, {"name": "contravariant_swap_mul_le_of_contravariant_mul_le", "description": ""}, {"name": "rel_of_act_rel_act", "description": ""}, {"name": "add_right_cancel_semigroup.covariant_swap_add_lt_of_covariant_swap_add_le", "description": ""}, {"name": "contravariant_swap_add_le_of_contravariant_add_le", "description": ""}, {"name": "covariant_swap_mul_le_of_covariant_mul_le", "description": ""}, {"name": "subtype.ext", "description": ""}, {"name": "subtype.restrict_def", "description": ""}, {"name": "subtype.map_involutive", "description": ""}, {"name": "subtype.map_coe", "description": ""}, {"name": "subtype.val_prop", "description": ""}, {"name": "subtype.coind_injective", "description": ""}, {"name": "subtype.equivalence", "description": ""}, {"name": "subtype.trans", "description": ""}, {"name": "subtype.heq_iff_coe_heq", "description": ""}, {"name": "subtype.coind_coe", "description": ""}, {"name": "exists_subtype_mk_eq_iff", "description": ""}, {"name": "subtype.refl", "description": ""}, {"name": "subtype.prop", "description": "A version of `x.property` or `x.2` where `p` is syntactically applied to the coercion of `x`\n instead of `x.1`. A similar result is `subtype.mem` in `data.set.basic`."}, {"name": "subtype.symm", "description": ""}, {"name": "subtype.val_injective", "description": ""}, {"name": "subtype.equiv_iff", "description": ""}, {"name": "subtype.setoid", "description": ""}, {"name": "subtype.coind_bijective", "description": ""}, {"name": "subtype.restrict_injective", "description": ""}, {"name": "subtype.coe_prop", "description": ""}, {"name": "subtype.ext_iff", "description": ""}, {"name": "subtype.coe_inj", "description": ""}, {"name": "subtype.ext_iff_val", "description": ""}, {"name": "subtype.map_comp", "description": ""}, {"name": "subtype.val_inj", "description": ""}, {"name": "subtype.mk_eq_mk", "description": ""}, {"name": "subtype.map_id", "description": ""}, {"name": "exists_eq_subtype_mk_iff", "description": ""}, {"name": "subtype.forall", "description": ""}, {"name": "subtype.heq_iff_coe_eq", "description": ""}, {"name": "subtype.coe_eq_of_eq_mk", "description": ""}, {"name": "subtype.forall'", "description": "An alternative version of `subtype.forall`. This one is useful if Lean cannot figure out `q`\n when using `subtype.forall` from right to left."}, {"name": "subtype.coind_surjective", "description": ""}, {"name": "subtype.map", "description": "Restriction of a function to a function on subtypes."}, {"name": "subtype.coe_eta", "description": ""}, {"name": "subtype.map_injective", "description": ""}, {"name": "subtype.exists", "description": ""}, {"name": "subtype.coe_mk", "description": ""}, {"name": "subtype.restrict", "description": "Restrict a (dependent) function to a subtype"}, {"name": "subtype.ext_val", "description": ""}, {"name": "subtype.has_equiv", "description": ""}, {"name": "subtype.coe_eq_iff", "description": ""}, {"name": "subtype.coe_injective", "description": ""}, {"name": "subtype.surjective_restrict", "description": ""}, {"name": "subtype.exists'", "description": "An alternative version of `subtype.exists`. This one is useful if Lean cannot figure out `q`\n when using `subtype.exists` from right to left."}, {"name": "subtype.val_eq_coe", "description": ""}, {"name": "subtype.restrict_apply", "description": ""}, {"name": "subtype.simps.coe", "description": "See Note [custom simps projection]"}, {"name": "subtype.coind", "description": "Defining a map into a subtype, this can be seen as an \"coinduction principle\" of `subtype`"}, {"name": "to_additive.ignore_args_attr", "description": "An attribute that tells `@[to_additive]` that certain arguments of this definition are not\ninvolved when using `@[to_additive]`.\nThis helps the heuristic of `@[to_additive]` by also transforming definitions if `\u2115` or another\nfixed type occurs as one of these arguments."}, {"name": "tactic_doc.attribute.to_additive", "description": "The attribute `to_additive` can be used to automatically transport theorems\nand definitions (but not inductive types and structures) from a multiplicative\ntheory to an additive theory.\n\nTo use this attribute, just write:\n\n```lean\n@[to_additive]\ntheorem mul_comm' {\u03b1} [comm_semigroup \u03b1] (x y : \u03b1) : x * y = y * x := comm_semigroup.mul_comm\n```\n\nThis code will generate a theorem named `add_comm'`. It is also\npossible to manually specify the name of the new declaration:\n\n```lean\n@[to_additive add_foo]\ntheorem foo := sorry\n```\n\nAn existing documentation string will _not_ be automatically used, so if the theorem or definition\nhas a doc string, a doc string for the additive version should be passed explicitly to\n`to_additive`.\n\n```lean\n/-- Multiplication is commutative -/\n@[to_additive \"Addition is commutative\"]\ntheorem mul_comm' {\u03b1} [comm_semigroup \u03b1] (x y : \u03b1) : x * y = y * x := comm_semigroup.mul_comm\n```\n\nThe transport tries to do the right thing in most cases using several\nheuristics described below.  However, in some cases it fails, and\nrequires manual intervention.\n\nIf the declaration to be transported has attributes which need to be\ncopied to the additive version, then `to_additive` should come last:\n\n```lean\n@[simp, to_additive] lemma mul_one' {G : Type*} [group G] (x : G) : x * 1 = x := mul_one x\n```\n\nThe following attributes are supported and should be applied correctly by `to_additive` to\nthe new additivized declaration, if they were present on the original one:\n```lean\nreducible, _refl_lemma, simp, norm_cast, instance, refl, symm, trans, elab_as_eliminator, no_rsimp,\ncontinuity, ext, ematch, measurability, alias, _ext_core, _ext_lemma_core, nolint\n```\n\nThe exception to this rule is the `simps` attribute, which should come after `to_additive`:\n\n```lean\n@[to_additive, simps]\ninstance {M N} [has_mul M] [has_mul N] : has_mul (M \u00d7 N) := \u27e8\u03bb p q, \u27e8p.1 * q.1, p.2 * q.2\u27e9\u27e9\n```\n\nAdditionally the `mono` attribute is not handled by `to_additive` and should be applied afterwards\nto both the original and additivized lemma.\n\n## Implementation notes\n\nThe transport process generally works by taking all the names of\nidentifiers appearing in the name, type, and body of a declaration and\ncreating a new declaration by mapping those names to additive versions\nusing a simple string-based dictionary and also using all declarations\nthat have previously been labeled with `to_additive`.\n\nIn the `mul_comm'` example above, `to_additive` maps:\n* `mul_comm'` to `add_comm'`,\n* `comm_semigroup` to `add_comm_semigroup`,\n* `x * y` to `x + y` and `y * x` to `y + x`, and\n* `comm_semigroup.mul_comm'` to `add_comm_semigroup.add_comm'`.\n\n### Heuristics\n\n`to_additive` uses heuristics to determine whether a particular identifier has to be\nmapped to its additive version. The basic heuristic is\n\n* Only map an identifier to its additive version if its first argument doesn't\n  contain any unapplied identifiers.\n\nExamples:\n* `@has_mul.mul \u2115 n m` (i.e. `(n * m : \u2115)`) will not change to `+`, since its\n  first argument is `\u2115`, an identifier not applied to any arguments.\n* `@has_mul.mul (\u03b1 \u00d7 \u03b2) x y` will change to `+`. It's first argument contains only the identifier\n  `prod`, but this is applied to arguments, `\u03b1` and `\u03b2`.\n* `@has_mul.mul (\u03b1 \u00d7 \u2124) x y` will not change to `+`, since its first argument contains `\u2124`.\n\nThe reasoning behind the heuristic is that the first argument is the type which is \"additivized\",\nand this usually doesn't make sense if this is on a fixed type.\n\nThere are some exceptions to this heuristic:\n\n* Identifiers that have the `@[to_additive]` attribute are ignored.\n  For example, multiplication in `\u21a5Semigroup` is replaced by addition in `\u21a5AddSemigroup`.\n* If an identifier `d` has attribute `@[to_additive_relevant_arg n]` then the argument\n  in position `n` is checked for a fixed type, instead of checking the first argument.\n  `@[to_additive]` will automatically add the attribute `@[to_additive_relevant_arg n]` to a\n  declaration when the first argument has no multiplicative type-class, but argument `n` does.\n* If an identifier has attribute `@[to_additive_ignore_args n1 n2 ...]` then all the arguments in\n  positions `n1`, `n2`, ... will not be checked for unapplied identifiers (start counting from 1).\n  For example, `cont_mdiff_map` has attribute `@[to_additive_ignore_args 21]`, which means\n  that its 21st argument `(n : with_top \u2115)` can contain `\u2115`\n  (usually in the form `has_top.top \u2115 ...`) and still be additivized.\n  So `@has_mul.mul (C^\u221e\u27eeI, N; I', G\u27ef) _ f g` will be additivized.\n\n### Troubleshooting\n\nIf `@[to_additive]` fails because the additive declaration raises a type mismatch, there are\nvarious things you can try.\nThe first thing to do is to figure out what `@[to_additive]` did wrong by looking at the type\nmismatch error.\n\n* Option 1: It additivized a declaration `d` that should remain multiplicative. Solution:\n  * Make sure the first argument of `d` is a type with a multiplicative structure. If not, can you\n    reorder the (implicit) arguments of `d` so that the first argument becomes a type with a\n    multiplicative structure (and not some indexing type)?\n    The reason is that `@[to_additive]` doesn't additivize declarations if their first argument\n    contains fixed types like `\u2115` or `\u211d`. See section Heuristics.\n    If the first argument is not the argument with a multiplicative type-class, `@[to_additive]`\n    should have automatically added the attribute `@[to_additive_relevant_arg]` to the declaration.\n    You can test this by running the following (where `d` is the full name of the declaration):\n    ```lean\n      run_cmd to_additive.relevant_arg_attr.get_param `d >>= tactic.trace\n    ```\n    The expected output is `n` where the `n`-th argument of `d` is a type (family) with a\n    multiplicative structure on it. If you get a different output (or a failure), you could add\n    the attribute `@[to_additive_relevant_arg n]` manually, where `n` is an argument with a\n    multiplicative structure.\n* Option 2: It didn't additivize a declaration that should be additivized.\n  This happened because the heuristic applied, and the first argument contains a fixed type,\n  like `\u2115` or `\u211d`. Solutions:\n  * If the fixed type has an additive counterpart (like `\u21a5Semigroup`), give it the `@[to_additive]`\n    attribute.\n  * If the fixed type occurs inside the `k`-th argument of a declaration `d`, and the\n    `k`-th argument is not connected to the multiplicative structure on `d`, consider adding\n    attribute `[to_additive_ignore_args k]` to `d`.\n  * If you want to disable the heuristic and replace all multiplicative\n    identifiers with their additive counterpart, use `@[to_additive!]`.\n* Option 3: Arguments / universe levels are incorrectly ordered in the additive version.\n  This likely only happens when the multiplicative declaration involves `pow`/`^`. Solutions:\n  * Ensure that the order of arguments of all relevant declarations are the same for the\n    multiplicative and additive version. This might mean that arguments have an \"unnatural\" order\n    (e.g. `monoid.npow n x` corresponds to `x ^ n`, but it is convenient that `monoid.npow` has this\n    argument order, since it matches `add_monoid.nsmul n x`.\n  * If this is not possible, add the `[to_additive_reorder k]` to the multiplicative declaration\n    to indicate that the `k`-th and `(k+1)`-st arguments are reordered in the additive version.\n\nIf neither of these solutions work, and `to_additive` is unable to automatically generate the\nadditive version of a declaration, manually write and prove the additive version.\nOften the proof of a lemma/theorem can just be the multiplicative version of the lemma applied to\n`multiplicative G`.\nAfterwards, apply the attribute manually:\n\n```lean\nattribute [to_additive foo_add_bar] foo_bar\n```\n\nThis will allow future uses of `to_additive` to recognize that\n`foo_bar` should be replaced with `foo_add_bar`.\n\n### Handling of hidden definitions\n\nBefore transporting the \u201cmain\u201d declaration `src`, `to_additive` first\nscans its type and value for names starting with `src`, and transports\nthem. This includes auxiliary definitions like `src._match_1`,\n`src._proof_1`.\n\nIn addition to transporting the \u201cmain\u201d declaration, `to_additive` transports\nits equational lemmas and tags them as equational lemmas for the new declaration,\nattributes present on the original equational lemmas are also transferred first (notably\n`_refl_lemma`).\n\n### Structure fields and constructors\n\nIf `src` is a structure, then `to_additive` automatically adds\nstructure fields to its mapping, and similarly for constructors of\ninductive types.\n\nFor new structures this means that `to_additive` automatically handles\ncoercions, and for old structures it does the same, if ancestry\ninformation is present in `@[ancestor]` attributes. The `ancestor`\nattribute must come before the `to_additive` attribute, and it is\nessential that the order of the base structures passed to `ancestor` matches\nbetween the multiplicative and additive versions of the structure.\n\n### Name generation\n\n* If `@[to_additive]` is called without a `name` argument, then the\n  new name is autogenerated.  First, it takes the longest prefix of\n  the source name that is already known to `to_additive`, and replaces\n  this prefix with its additive counterpart. Second, it takes the last\n  part of the name (i.e., after the last dot), and replaces common\n  name parts (\u201cmul\u201d, \u201cone\u201d, \u201cinv\u201d, \u201cprod\u201d) with their additive versions.\n\n* Namespaces can be transformed using `map_namespace`. For example:\n  ```lean\n  run_cmd to_additive.map_namespace `quotient_group `quotient_add_group\n  ```\n\n  Later uses of `to_additive` on declarations in the `quotient_group`\n  namespace will be created in the `quotient_add_group` namespaces.\n\n* If `@[to_additive]` is called with a `name` argument `new_name`\n  /without a dot/, then `to_additive` updates the prefix as described\n  above, then replaces the last part of the name with `new_name`.\n\n* If `@[to_additive]` is called with a `name` argument\n  `new_namespace.new_name` /with a dot/, then `to_additive` uses this\n  new name as is.\n\nAs a safety check, in the first case `to_additive` double checks\nthat the new name differs from the original one."}, {"name": "to_additive.target_name", "description": "Return the provided target name or autogenerate one if one was not provided."}, {"name": "to_additive.proceed_fields", "description": " Add the `aux_attr` attribute to the structure fields of `src`\nso that future uses of `to_additive` will map them to the corresponding `tgt` fields."}, {"name": "to_additive.guess_name", "description": "Autogenerate target name for `to_additive`."}, {"name": "to_additive.value_type", "description": " `value_type` is the type of the arguments that can be provided to `to_additive`.\n`to_additive.parser` parses the provided arguments:\n* `replace_all`: replace all multiplicative declarations, do not use the heuristic.\n* `trace`: output the generated additive declaration.\n* `tgt : name`: the name of the target (the additive declaration).\n* `doc`: an optional doc string.\n* if `allow_auto_name` is `ff` (default) then `@[to_additive]` will check whether the given name\n  can be auto-generated."}, {"name": "to_additive.value_type.replace_all", "description": " `value_type` is the type of the arguments that can be provided to `to_additive`.\n`to_additive.parser` parses the provided arguments:\n* `replace_all`: replace all multiplicative declarations, do not use the heuristic.\n* `trace`: output the generated additive declaration.\n* `tgt : name`: the name of the target (the additive declaration).\n* `doc`: an optional doc string.\n* if `allow_auto_name` is `ff` (default) then `@[to_additive]` will check whether the given name\n  can be auto-generated."}, {"name": "to_additive.value_type.trace", "description": " `value_type` is the type of the arguments that can be provided to `to_additive`.\n`to_additive.parser` parses the provided arguments:\n* `replace_all`: replace all multiplicative declarations, do not use the heuristic.\n* `trace`: output the generated additive declaration.\n* `tgt : name`: the name of the target (the additive declaration).\n* `doc`: an optional doc string.\n* if `allow_auto_name` is `ff` (default) then `@[to_additive]` will check whether the given name\n  can be auto-generated."}, {"name": "to_additive.value_type.tgt", "description": " `value_type` is the type of the arguments that can be provided to `to_additive`.\n`to_additive.parser` parses the provided arguments:\n* `replace_all`: replace all multiplicative declarations, do not use the heuristic.\n* `trace`: output the generated additive declaration.\n* `tgt : name`: the name of the target (the additive declaration).\n* `doc`: an optional doc string.\n* if `allow_auto_name` is `ff` (default) then `@[to_additive]` will check whether the given name\n  can be auto-generated."}, {"name": "to_additive.value_type.doc", "description": " `value_type` is the type of the arguments that can be provided to `to_additive`.\n`to_additive.parser` parses the provided arguments:\n* `replace_all`: replace all multiplicative declarations, do not use the heuristic.\n* `trace`: output the generated additive declaration.\n* `tgt : name`: the name of the target (the additive declaration).\n* `doc`: an optional doc string.\n* if `allow_auto_name` is `ff` (default) then `@[to_additive]` will check whether the given name\n  can be auto-generated."}, {"name": "to_additive.value_type.allow_auto_name", "description": " `value_type` is the type of the arguments that can be provided to `to_additive`.\n`to_additive.parser` parses the provided arguments:\n* `replace_all`: replace all multiplicative declarations, do not use the heuristic.\n* `trace`: output the generated additive declaration.\n* `tgt : name`: the name of the target (the additive declaration).\n* `doc`: an optional doc string.\n* if `allow_auto_name` is `ff` (default) then `@[to_additive]` will check whether the given name\n  can be auto-generated."}, {"name": "to_additive.parser", "description": "the parser for the arguments to `to_additive`."}, {"name": "linter.to_additive_doc", "description": " A linter that checks that multiplicative and additive lemmas have both doc strings if one of\nthem has one"}, {"name": "to_additive.value_type.has_reflect", "description": ""}, {"name": "to_additive.tr", "description": "Dictionary used by `to_additive.guess_name` to autogenerate names."}, {"name": "to_additive.map_namespace", "description": " A command that can be used to have future uses of `to_additive` change the `src` namespace\nto the `tgt` namespace.\n\nFor example:\n```lean\nrun_cmd to_additive.map_namespace `quotient_group `quotient_add_group\n```\n\nLater uses of `to_additive` on declarations in the `quotient_group` namespace will be created\nin the `quotient_add_group` namespaces."}, {"name": "to_additive.value_type.inhabited", "description": ""}, {"name": "to_additive.reorder_attr", "description": "An attribute that stores all the declarations that needs their arguments reordered when\napplying `@[to_additive]`. Currently, we only support swapping consecutive arguments.\nThe list of the natural numbers contains the positions of the first of the two arguments\nto be swapped.\nIf the first two arguments are swapped, the first two universe variables are also swapped.\nExample: `@[to_additive_reorder 1 4]` swaps the first two arguments and the arguments in\npositions 4 and 5."}, {"name": "to_additive.aux_attr", "description": " An auxiliary attribute used to store the names of the additive versions of declarations\nthat have been processed by `to_additive`."}, {"name": "to_additive.first_multiplicative_arg", "description": "Find the first argument of `nm` that has a multiplicative type-class on it.\nReturns 1 if there are no types with a multiplicative class as arguments.\nE.g. `prod.group` returns 1, and `pi.has_one` returns 2."}, {"name": "to_additive.relevant_arg_attr", "description": "An attribute that is automatically added to declarations tagged with `@[to_additive]`, if needed.\n\nThis attribute tells which argument is the type where this declaration uses the multiplicative\nstructure. If there are multiple argument, we typically tag the first one.\nIf this argument contains a fixed type, this declaration will note be additivized.\nSee the Heuristics section of `to_additive.attr` for more details.\n\nIf a declaration is not tagged, it is presumed that the first argument is relevant.\n`@[to_additive]` uses the function `to_additive.first_multiplicative_arg` to automatically tag\ndeclarations. It is ok to update it manually if the automatic tagging made an error.\n\nImplementation note: we only allow exactly 1 relevant argument, even though some declarations\n(like `prod.group`) have multiple arguments with a multiplicative structure on it.\nThe reason is that whether we additivize a declaration is an all-or-nothing decision, and if\nwe will not be able to additivize declarations that (e.g.) talk about multiplication on `\u2115 \u00d7 \u03b1`\nanyway.\n\nWarning: adding `@[to_additive_reorder]` with an equal or smaller number than the number in this\nattribute is currently not supported."}, {"name": "to_additive.attr", "description": "The attribute `to_additive` can be used to automatically transport theorems\nand definitions (but not inductive types and structures) from a multiplicative\ntheory to an additive theory.\n\nTo use this attribute, just write:\n\n```lean\n@[to_additive]\ntheorem mul_comm' {\u03b1} [comm_semigroup \u03b1] (x y : \u03b1) : x * y = y * x := comm_semigroup.mul_comm\n```\n\nThis code will generate a theorem named `add_comm'`. It is also\npossible to manually specify the name of the new declaration:\n\n```lean\n@[to_additive add_foo]\ntheorem foo := sorry\n```\n\nAn existing documentation string will _not_ be automatically used, so if the theorem or definition\nhas a doc string, a doc string for the additive version should be passed explicitly to\n`to_additive`.\n\n```lean\n/-- Multiplication is commutative -/\n@[to_additive \"Addition is commutative\"]\ntheorem mul_comm' {\u03b1} [comm_semigroup \u03b1] (x y : \u03b1) : x * y = y * x := comm_semigroup.mul_comm\n```\n\nThe transport tries to do the right thing in most cases using several\nheuristics described below.  However, in some cases it fails, and\nrequires manual intervention.\n\nIf the declaration to be transported has attributes which need to be\ncopied to the additive version, then `to_additive` should come last:\n\n```lean\n@[simp, to_additive] lemma mul_one' {G : Type*} [group G] (x : G) : x * 1 = x := mul_one x\n```\n\nThe following attributes are supported and should be applied correctly by `to_additive` to\nthe new additivized declaration, if they were present on the original one:\n```lean\nreducible, _refl_lemma, simp, norm_cast, instance, refl, symm, trans, elab_as_eliminator, no_rsimp,\ncontinuity, ext, ematch, measurability, alias, _ext_core, _ext_lemma_core, nolint\n```\n\nThe exception to this rule is the `simps` attribute, which should come after `to_additive`:\n\n```lean\n@[to_additive, simps]\ninstance {M N} [has_mul M] [has_mul N] : has_mul (M \u00d7 N) := \u27e8\u03bb p q, \u27e8p.1 * q.1, p.2 * q.2\u27e9\u27e9\n```\n\nAdditionally the `mono` attribute is not handled by `to_additive` and should be applied afterwards\nto both the original and additivized lemma.\n\n## Implementation notes\n\nThe transport process generally works by taking all the names of\nidentifiers appearing in the name, type, and body of a declaration and\ncreating a new declaration by mapping those names to additive versions\nusing a simple string-based dictionary and also using all declarations\nthat have previously been labeled with `to_additive`.\n\nIn the `mul_comm'` example above, `to_additive` maps:\n* `mul_comm'` to `add_comm'`,\n* `comm_semigroup` to `add_comm_semigroup`,\n* `x * y` to `x + y` and `y * x` to `y + x`, and\n* `comm_semigroup.mul_comm'` to `add_comm_semigroup.add_comm'`.\n\n### Heuristics\n\n`to_additive` uses heuristics to determine whether a particular identifier has to be\nmapped to its additive version. The basic heuristic is\n\n* Only map an identifier to its additive version if its first argument doesn't\n  contain any unapplied identifiers.\n\nExamples:\n* `@has_mul.mul \u2115 n m` (i.e. `(n * m : \u2115)`) will not change to `+`, since its\n  first argument is `\u2115`, an identifier not applied to any arguments.\n* `@has_mul.mul (\u03b1 \u00d7 \u03b2) x y` will change to `+`. It's first argument contains only the identifier\n  `prod`, but this is applied to arguments, `\u03b1` and `\u03b2`.\n* `@has_mul.mul (\u03b1 \u00d7 \u2124) x y` will not change to `+`, since its first argument contains `\u2124`.\n\nThe reasoning behind the heuristic is that the first argument is the type which is \"additivized\",\nand this usually doesn't make sense if this is on a fixed type.\n\nThere are some exceptions to this heuristic:\n\n* Identifiers that have the `@[to_additive]` attribute are ignored.\n  For example, multiplication in `\u21a5Semigroup` is replaced by addition in `\u21a5AddSemigroup`.\n* If an identifier `d` has attribute `@[to_additive_relevant_arg n]` then the argument\n  in position `n` is checked for a fixed type, instead of checking the first argument.\n  `@[to_additive]` will automatically add the attribute `@[to_additive_relevant_arg n]` to a\n  declaration when the first argument has no multiplicative type-class, but argument `n` does.\n* If an identifier has attribute `@[to_additive_ignore_args n1 n2 ...]` then all the arguments in\n  positions `n1`, `n2`, ... will not be checked for unapplied identifiers (start counting from 1).\n  For example, `cont_mdiff_map` has attribute `@[to_additive_ignore_args 21]`, which means\n  that its 21st argument `(n : with_top \u2115)` can contain `\u2115`\n  (usually in the form `has_top.top \u2115 ...`) and still be additivized.\n  So `@has_mul.mul (C^\u221e\u27eeI, N; I', G\u27ef) _ f g` will be additivized.\n\n### Troubleshooting\n\nIf `@[to_additive]` fails because the additive declaration raises a type mismatch, there are\nvarious things you can try.\nThe first thing to do is to figure out what `@[to_additive]` did wrong by looking at the type\nmismatch error.\n\n* Option 1: It additivized a declaration `d` that should remain multiplicative. Solution:\n  * Make sure the first argument of `d` is a type with a multiplicative structure. If not, can you\n    reorder the (implicit) arguments of `d` so that the first argument becomes a type with a\n    multiplicative structure (and not some indexing type)?\n    The reason is that `@[to_additive]` doesn't additivize declarations if their first argument\n    contains fixed types like `\u2115` or `\u211d`. See section Heuristics.\n    If the first argument is not the argument with a multiplicative type-class, `@[to_additive]`\n    should have automatically added the attribute `@[to_additive_relevant_arg]` to the declaration.\n    You can test this by running the following (where `d` is the full name of the declaration):\n    ```lean\n      run_cmd to_additive.relevant_arg_attr.get_param `d >>= tactic.trace\n    ```\n    The expected output is `n` where the `n`-th argument of `d` is a type (family) with a\n    multiplicative structure on it. If you get a different output (or a failure), you could add\n    the attribute `@[to_additive_relevant_arg n]` manually, where `n` is an argument with a\n    multiplicative structure.\n* Option 2: It didn't additivize a declaration that should be additivized.\n  This happened because the heuristic applied, and the first argument contains a fixed type,\n  like `\u2115` or `\u211d`. Solutions:\n  * If the fixed type has an additive counterpart (like `\u21a5Semigroup`), give it the `@[to_additive]`\n    attribute.\n  * If the fixed type occurs inside the `k`-th argument of a declaration `d`, and the\n    `k`-th argument is not connected to the multiplicative structure on `d`, consider adding\n    attribute `[to_additive_ignore_args k]` to `d`.\n  * If you want to disable the heuristic and replace all multiplicative\n    identifiers with their additive counterpart, use `@[to_additive!]`.\n* Option 3: Arguments / universe levels are incorrectly ordered in the additive version.\n  This likely only happens when the multiplicative declaration involves `pow`/`^`. Solutions:\n  * Ensure that the order of arguments of all relevant declarations are the same for the\n    multiplicative and additive version. This might mean that arguments have an \"unnatural\" order\n    (e.g. `monoid.npow n x` corresponds to `x ^ n`, but it is convenient that `monoid.npow` has this\n    argument order, since it matches `add_monoid.nsmul n x`.\n  * If this is not possible, add the `[to_additive_reorder k]` to the multiplicative declaration\n    to indicate that the `k`-th and `(k+1)`-st arguments are reordered in the additive version.\n\nIf neither of these solutions work, and `to_additive` is unable to automatically generate the\nadditive version of a declaration, manually write and prove the additive version.\nOften the proof of a lemma/theorem can just be the multiplicative version of the lemma applied to\n`multiplicative G`.\nAfterwards, apply the attribute manually:\n\n```lean\nattribute [to_additive foo_add_bar] foo_bar\n```\n\nThis will allow future uses of `to_additive` to recognize that\n`foo_bar` should be replaced with `foo_add_bar`.\n\n### Handling of hidden definitions\n\nBefore transporting the \u201cmain\u201d declaration `src`, `to_additive` first\nscans its type and value for names starting with `src`, and transports\nthem. This includes auxiliary definitions like `src._match_1`,\n`src._proof_1`.\n\nIn addition to transporting the \u201cmain\u201d declaration, `to_additive` transports\nits equational lemmas and tags them as equational lemmas for the new declaration,\nattributes present on the original equational lemmas are also transferred first (notably\n`_refl_lemma`).\n\n### Structure fields and constructors\n\nIf `src` is a structure, then `to_additive` automatically adds\nstructure fields to its mapping, and similarly for constructors of\ninductive types.\n\nFor new structures this means that `to_additive` automatically handles\ncoercions, and for old structures it does the same, if ancestry\ninformation is present in `@[ancestor]` attributes. The `ancestor`\nattribute must come before the `to_additive` attribute, and it is\nessential that the order of the base structures passed to `ancestor` matches\nbetween the multiplicative and additive versions of the structure.\n\n### Name generation\n\n* If `@[to_additive]` is called without a `name` argument, then the\n  new name is autogenerated.  First, it takes the longest prefix of\n  the source name that is already known to `to_additive`, and replaces\n  this prefix with its additive counterpart. Second, it takes the last\n  part of the name (i.e., after the last dot), and replaces common\n  name parts (\u201cmul\u201d, \u201cone\u201d, \u201cinv\u201d, \u201cprod\u201d) with their additive versions.\n\n* Namespaces can be transformed using `map_namespace`. For example:\n  ```lean\n  run_cmd to_additive.map_namespace `quotient_group `quotient_add_group\n  ```\n\n  Later uses of `to_additive` on declarations in the `quotient_group`\n  namespace will be created in the `quotient_add_group` namespaces.\n\n* If `@[to_additive]` is called with a `name` argument `new_name`\n  /without a dot/, then `to_additive` updates the prefix as described\n  above, then replaces the last part of the name with `new_name`.\n\n* If `@[to_additive]` is called with a `name` argument\n  `new_namespace.new_name` /with a dot/, then `to_additive` uses this\n  new name as is.\n\nAs a safety check, in the first case `to_additive` double checks\nthat the new name differs from the original one."}, {"name": "to_additive.add_comm_prefix", "description": "`add_comm_prefix x s` returns `\"comm_\" ++ s` if `x = tt` and `s` otherwise."}, {"name": "to_additive.hacky_name_reflect", "description": "Temporarily change the `has_reflect` instance for `name`."}, {"name": "punit.reflect'", "description": "Universe polymorphic version of the builtin `punit.reflect`."}, {"name": "ulift.reflect'", "description": ""}, {"name": "reflect_univ.imax", "description": ""}, {"name": "reflect_univ.zero", "description": ""}, {"name": "reflect_univ", "description": "Reflect a universe variable `u` into a `level` via typeclass search."}, {"name": "reflected.subst\u2084", "description": "Convenience helper for four consecutive `reflected.subst` applications"}, {"name": "reflect_univ.succ", "description": ""}, {"name": "list.reflect'", "description": "Universe polymorphic version of the builtin `list.reflect`."}, {"name": "tactic.interactive.reflect_name", "description": "Reflect a universe-polymorphic name, by searching for `reflected_univ` instances."}, {"name": "reflected.subst\u2082", "description": "Convenience helper for two consecutive `reflected.subst` applications"}, {"name": "reflected_univ", "description": " A typeclass to translate a universe argument into a `level`. Note that `level.mvar` and\n`level.param` are not supported.\n\nNote that the `instance_priority` linter will complain if instance of this class have the default\npriority, as it takes no arguments! Since it doesn't make any difference, we do what the linter\nasks."}, {"name": "reflected_univ.lvl", "description": " A typeclass to translate a universe argument into a `level`. Note that `level.mvar` and\n`level.param` are not supported.\n\nNote that the `instance_priority` linter will complain if instance of this class have the default\npriority, as it takes no arguments! Since it doesn't make any difference, we do what the linter\nasks."}, {"name": "reflected.subst\u2083", "description": "Convenience helper for three consecutive `reflected.subst` applications"}, {"name": "reflect_univ.max", "description": ""}, {"name": "opposite.op", "description": "The canonical map `\u03b1 \u2192 \u03b1\u1d52\u1d56`."}, {"name": "opposite.equiv_to_opposite_coe", "description": ""}, {"name": "opposite", "description": "The type of objects of the opposite of `\u03b1`; used to define the opposite category.\n\n In order to avoid confusion between `\u03b1` and its opposite type, we\n set up the type of objects `opposite \u03b1` using the following pattern,\n which will be repeated later for the morphisms.\n\n 1. Define `opposite \u03b1 := \u03b1`.\n 2. Define the isomorphisms `op : \u03b1 \u2192 opposite \u03b1`, `unop : opposite \u03b1 \u2192 \u03b1`.\n 3. Make the definition `opposite` irreducible.\n\n This has the following consequences.\n\n * `opposite \u03b1` and `\u03b1` are distinct types in the elaborator, so you\n   must use `op` and `unop` explicitly to convert between them.\n * Both `unop (op X) = X` and `op (unop X) = X` are definitional\n   equalities. Notably, every object of the opposite category is\n   definitionally of the form `op X`, which greatly simplifies the\n   definition of the structure of the opposite category, for example.\n\n (If Lean supported definitional eta equality for records, we could\n achieve the same goals using a structure with one field.)"}, {"name": "opposite.rec", "description": "A recursor for `opposite`. Use as `induction x using opposite.rec`."}, {"name": "opposite.op_unop", "description": ""}, {"name": "opposite.equiv_to_opposite", "description": "The type-level equivalence between a type and its opposite."}, {"name": "opposite.unop_inj_iff", "description": ""}, {"name": "tactic.op_induction'", "description": " A version of `induction x using opposite.rec` which finds the appropriate hypothesis\nautomatically, for use with `local attribute [tidy] op_induction'`. This is necessary because\n`induction x` is not able to deduce that `opposite.rec` should be used."}, {"name": "opposite.unop_injective", "description": ""}, {"name": "opposite.equiv_to_opposite_symm_coe", "description": ""}, {"name": "tactic.op_induction.is_opposite", "description": "Test if `e : expr` is of type `opposite \u03b1` for some `\u03b1`."}, {"name": "tactic.op_induction.find_opposite_hyp", "description": " Find the first hypothesis of type `opposite _`. Fail if no such hypothesis exist in the local\ncontext."}, {"name": "opposite.op_injective", "description": ""}, {"name": "opposite.unop_op", "description": ""}, {"name": "opposite.op_inj_iff", "description": ""}, {"name": "opposite.unop", "description": "The canonical map `\u03b1\u1d52\u1d56 \u2192 \u03b1`."}, {"name": "opposite.op_eq_iff_eq_unop", "description": ""}, {"name": "opposite.unop_eq_iff_eq_op", "description": ""}, {"name": "opposite.inhabited", "description": ""}, {"name": "option.to_list_nodup", "description": ""}, {"name": "list.nodup.not_mem_erase", "description": ""}, {"name": "list.nodup.filter", "description": ""}, {"name": "list.nodup.erase", "description": ""}, {"name": "list.nodup_iff_count_le_one", "description": ""}, {"name": "list.nodup_sublists'", "description": ""}, {"name": "list.nodup_map_iff_inj_on", "description": ""}, {"name": "list.nodup.of_sublists'", "description": "**Alias** of the forward direction of `list.nodup_sublists'`."}, {"name": "list.nodup_iff_sublist", "description": ""}, {"name": "list.nodup.of_sublists", "description": "**Alias** of the forward direction of `list.nodup_sublists`."}, {"name": "list.nodup.sublist", "description": ""}, {"name": "list.nodup.pairwise_of_set_pairwise", "description": ""}, {"name": "list.nth_le_index_of", "description": ""}, {"name": "list.nodup.of_append_left", "description": ""}, {"name": "list.nodup.insert", "description": ""}, {"name": "list.nodup_repeat", "description": ""}, {"name": "list.nodup.sublists", "description": "**Alias** of the reverse direction of `list.nodup_sublists`."}, {"name": "list.nodup.sigma", "description": ""}, {"name": "list.nodup_middle", "description": ""}, {"name": "list.not_nodup_cons_of_mem", "description": ""}, {"name": "list.nodup_singleton", "description": ""}, {"name": "list.nodup.append", "description": ""}, {"name": "list.nodup_attach", "description": ""}, {"name": "list.nodup.inter", "description": ""}, {"name": "list.nodup.mem_erase_iff", "description": ""}, {"name": "list.nodup.erase_eq_filter", "description": ""}, {"name": "list.nodup_bind", "description": ""}, {"name": "list.nodup_append", "description": ""}, {"name": "list.nodup.sublists'", "description": "**Alias** of the reverse direction of `list.nodup_sublists'`."}, {"name": "list.nodup.pairwise_of_forall_ne", "description": ""}, {"name": "list.nodup.product", "description": ""}, {"name": "list.nodup_reverse", "description": ""}, {"name": "list.nodup.map_on", "description": ""}, {"name": "list.rel_nodup", "description": ""}, {"name": "list.count_eq_one_of_mem", "description": ""}, {"name": "list.nodup.update_nth", "description": ""}, {"name": "list.nodup.union", "description": ""}, {"name": "list.nodup.nth_le_inj_iff", "description": ""}, {"name": "list.nodup.mem_diff_iff", "description": ""}, {"name": "list.nodup.of_append_right", "description": ""}, {"name": "list.nodup_iff_nth_ne_nth", "description": ""}, {"name": "list.nodup.ne_singleton_iff", "description": ""}, {"name": "list.nodup_append_comm", "description": ""}, {"name": "list.nodup.diff", "description": ""}, {"name": "list.disjoint_of_nodup_append", "description": ""}, {"name": "list.nodup.pmap", "description": ""}, {"name": "list.nodup.of_cons", "description": ""}, {"name": "list.nth_le_eq_of_ne_imp_not_nodup", "description": ""}, {"name": "list.nodup_cons", "description": ""}, {"name": "list.inj_on_of_nodup_map", "description": ""}, {"name": "list.pairwise.nodup", "description": ""}, {"name": "list.nodup.of_attach", "description": "**Alias** of the forward direction of `list.nodup_attach`."}, {"name": "list.not_nodup_pair", "description": ""}, {"name": "list.nodup.attach", "description": "**Alias** of the reverse direction of `list.nodup_attach`."}, {"name": "list.nodup.filter_map", "description": ""}, {"name": "list.nodup_nil", "description": ""}, {"name": "list.nodup_iff_nth_le_inj", "description": ""}, {"name": "list.nodup.diff_eq_filter", "description": ""}, {"name": "list.nodup.map_update", "description": ""}, {"name": "list.nodup_map_iff", "description": ""}, {"name": "list.nodup.map", "description": ""}, {"name": "list.nodup_sublists_len", "description": ""}, {"name": "list.nodup.of_map", "description": ""}, {"name": "list.nodup_sublists", "description": ""}, {"name": "list.nodup_join", "description": ""}, {"name": "list.count_eq_of_nodup", "description": ""}, {"name": "list.nodup.not_mem", "description": ""}, {"name": "list.forall_mem_ne", "description": ""}, {"name": "list.nodup.cons", "description": ""}, {"name": "list.nodup.concat", "description": ""}, {"name": "tactic.interactive.dsimp_result", "description": "`dsimp_result { tac }`\nattempts to run a tactic block `tac`,\nintercepts any results the tactic block would have assigned to the goals,\nand runs `dsimp` on those results\nbefore assigning the simplified values to the original goals.\n\nYou can use the usual interactive syntax for `dsimp`, e.g.\n`dsimp_result only [a, b, c] with attr { tac }`."}, {"name": "tactic.interactive.simp_result", "description": "`simp_result { tac }`\nattempts to run a tactic block `tac`,\nintercepts any results the tactic block would have assigned to the goals,\nand runs `simp` on those results\nbefore assigning the simplified values to the original goals.\n\nYou can use the usual interactive syntax for `simp`, e.g.\n`simp_result only [a, b, c] with attr { tac }`."}, {"name": "tactic.intercept_result", "description": "`intercept_result m t`\nattempts to run a tactic `t`,\nintercepts any results `t` assigns to the goals,\nand runs `m : expr \u2192 tactic expr` on each of the expressions\nbefore assigning the returned values to the original goals.\n\nBecause `intercept_result` uses `unsafe.type_context.assign` rather than `unify`,\nif the tactic `m` does something unreasonable\nyou may produce terms that don't typecheck,\npossibly with mysterious error messages.\nBe careful!"}, {"name": "tactic.simp_result", "description": "`simp_result t`\nattempts to run a tactic `t`,\nintercepts any results `t` assigns to the goals,\nand runs `simp` on those results\nbefore assigning the simplified values to the original goals."}, {"name": "tactic_doc.tactic.simp_result", "description": "`simp_result { tac }`\nattempts to run a tactic block `tac`,\nintercepts any results the tactic block would have assigned to the goals,\nand runs `simp` on those results\nbefore assigning the simplified values to the original goals.\n\nYou can use the usual interactive syntax for `simp`, e.g.\n`simp_result only [a, b, c] with attr { tac }`.\n\n`dsimp_result { tac }` works similarly, internally using `dsimp`\n(and so only simplifiying along definitional lemmas)."}, {"name": "tactic.dsimp_result", "description": "`dsimp_result t`\nattempts to run a tactic `t`,\nintercepts any results it assigns to the goals,\nand runs `dsimp` on those results\nbefore assigning the simplified values to the original goals."}, {"name": "pexpr.get_uninst_pis", "description": ""}, {"name": "expr.get_pis", "description": ""}, {"name": "find_cmd", "description": "The `find` command from `tactic.find` allows to find definitions lemmas using\npattern matching on the type. For instance:\n\n```lean\nimport tactic.find\n\nrun_cmd tactic.skip\n\n#find _ + _ = _ + _\n#find (_ : \u2115) + _ = _ + _\n#find \u2115 \u2192 \u2115\n```\n\nThe tactic `library_search` is an alternate way to find lemmas in the library."}, {"name": "tactic_doc.command.#find", "description": "The `find` command from `tactic.find` allows to find definitions lemmas using\npattern matching on the type. For instance:\n\n```lean\nimport tactic.find\n\nrun_cmd tactic.skip\n\n#find _ + _ = _ + _\n#find (_ : \u2115) + _ = _ + _\n#find \u2115 \u2192 \u2115\n```\n\nThe tactic `library_search` is an alternate way to find lemmas in the library."}, {"name": "category_theory.nat_trans.naturality_app", "description": ""}, {"name": "category_theory.nat_trans.hcomp_id_app", "description": ""}, {"name": "category_theory.map_hom_inv_app", "description": ""}, {"name": "category_theory.nat_trans.app_naturality", "description": ""}, {"name": "category_theory.nat_trans.hcomp", "description": "`hcomp \u03b1 \u03b2` is the horizontal composition of natural transformations."}, {"name": "category_theory.nat_trans.vcomp_app'", "description": ""}, {"name": "category_theory.nat_trans.vcomp_eq_comp", "description": ""}, {"name": "category_theory.nat_trans.comp_app", "description": ""}, {"name": "category_theory.nat_trans.hcomp_app", "description": ""}, {"name": "category_theory.functor.flip_obj_map", "description": ""}, {"name": "category_theory.functor.flip_map_app", "description": ""}, {"name": "category_theory.functor.flip", "description": "Flip the arguments of a bifunctor. See also `currying.lean`."}, {"name": "category_theory.nat_trans.id_hcomp_app", "description": ""}, {"name": "category_theory.nat_trans.exchange", "description": ""}, {"name": "category_theory.nat_trans.epi_app_of_epi", "description": "A natural transformation is an epimorphism if each component is."}, {"name": "category_theory.functor.category", "description": "`functor.category C D` gives the category structure on functors and natural transformations\nbetween categories `C` and `D`.\n\nNotice that if `C` and `D` are both small categories at the same universe level,\nthis is another small category at that level.\nHowever if `C` and `D` are both large categories at the same universe level,\nthis is a small category at the next higher level."}, {"name": "category_theory.functor.flip_obj_obj", "description": ""}, {"name": "category_theory.map_hom_inv_app_assoc", "description": ""}, {"name": "category_theory.nat_trans.congr_app", "description": ""}, {"name": "category_theory.nat_trans.id_app", "description": ""}, {"name": "category_theory.map_inv_hom_app", "description": ""}, {"name": "category_theory.map_inv_hom_app_assoc", "description": ""}, {"name": "category_theory.nat_trans.mono_app_of_mono", "description": "A natural transformation is a monomorphism if each component is."}, {"name": "equiv.option_congr_injective", "description": ""}, {"name": "equiv.option_congr", "description": "A universe-polymorphic version of `equiv_functor.map_equiv option e`."}, {"name": "equiv.option_symm_apply_none_iff", "description": ""}, {"name": "equiv.some_remove_none_iff", "description": ""}, {"name": "equiv.remove_none_none", "description": ""}, {"name": "equiv.remove_none_option_congr", "description": ""}, {"name": "equiv.remove_none_some", "description": ""}, {"name": "equiv.option_congr_eq_equiv_function_map_equiv", "description": " When `\u03b1` and `\u03b2` are in the same universe, this is the same as the result of\n`equiv_functor.map_equiv`."}, {"name": "equiv.option_congr_refl", "description": ""}, {"name": "equiv.option_congr_symm", "description": ""}, {"name": "equiv.remove_none", "description": " Given an equivalence between two `option` types, eliminate `none` from that equivalence by\nmapping `e.symm none` to `e none`."}, {"name": "equiv.option_congr_trans", "description": ""}, {"name": "equiv.option_congr_apply", "description": ""}, {"name": "equiv.remove_none_symm", "description": ""}, {"name": "nat.bitwise_zero", "description": ""}, {"name": "nat.bit_zero", "description": ""}, {"name": "nat.bodd", "description": ""}, {"name": "nat.test_bit", "description": ""}, {"name": "nat.shiftl'_add", "description": ""}, {"name": "nat.lxor_bit", "description": ""}, {"name": "nat.test_bit_ldiff", "description": ""}, {"name": "nat.bodd_div2", "description": ""}, {"name": "nat.test_bit_bitwise", "description": ""}, {"name": "nat.bodd_add_div2", "description": ""}, {"name": "nat.bodd_add", "description": ""}, {"name": "nat.shiftl_sub", "description": ""}, {"name": "nat.div2", "description": ""}, {"name": "nat.test_bit_lor", "description": ""}, {"name": "nat.bit0_val", "description": ""}, {"name": "nat.bodd_succ", "description": ""}, {"name": "nat.ldiff_bit", "description": ""}, {"name": "nat.binary_rec_eq", "description": ""}, {"name": "nat.lor_bit", "description": ""}, {"name": "nat.mod_two_of_bodd", "description": ""}, {"name": "nat.binary_rec_zero", "description": ""}, {"name": "nat.bodd_one", "description": ""}, {"name": "nat.bitwise_zero_left", "description": ""}, {"name": "nat.bitwise", "description": ""}, {"name": "nat.bit", "description": ""}, {"name": "nat.shiftl'_sub", "description": ""}, {"name": "nat.bodd_mul", "description": ""}, {"name": "nat.div2_zero", "description": ""}, {"name": "nat.bodd_zero", "description": ""}, {"name": "nat.bit_decomp", "description": ""}, {"name": "nat.bit_cases_on", "description": ""}, {"name": "nat.bitwise_swap", "description": ""}, {"name": "nat.bitwise_zero_right", "description": ""}, {"name": "nat.shiftr_add", "description": ""}, {"name": "nat.size", "description": ""}, {"name": "nat.lor", "description": ""}, {"name": "nat.bitwise_bit", "description": ""}, {"name": "nat.bitwise_bit_aux", "description": ""}, {"name": "nat.shiftl", "description": ""}, {"name": "nat.land", "description": ""}, {"name": "nat.test_bit_lxor", "description": ""}, {"name": "nat.land_bit", "description": ""}, {"name": "nat.div2_val", "description": ""}, {"name": "nat.bit1_val", "description": ""}, {"name": "nat.bodd_bit", "description": ""}, {"name": "nat.shiftl_succ", "description": ""}, {"name": "nat.lxor", "description": ""}, {"name": "nat.test_bit_succ", "description": ""}, {"name": "nat.ldiff", "description": ""}, {"name": "nat.div2_bit", "description": ""}, {"name": "nat.bit_val", "description": ""}, {"name": "nat.shiftl_add", "description": ""}, {"name": "nat.test_bit_zero", "description": ""}, {"name": "nat.test_bit_land", "description": ""}, {"name": "nat.div2_succ", "description": ""}, {"name": "nat.binary_rec", "description": ""}, {"name": "nat.shiftl_zero", "description": ""}, {"name": "nat.div2_two", "description": ""}, {"name": "nat.bits", "description": ""}, {"name": "nat.shiftr", "description": ""}, {"name": "nat.shiftl'", "description": ""}, {"name": "nat.div2_one", "description": ""}, {"name": "nat.bodd_two", "description": ""}, {"name": "tactic.interactive.case_tag.repr", "description": ""}, {"name": "tactic.interactive.case_tag.match_result.combine", "description": "The 'minimum' of two match results:\n\n- If any of the arguments is `no_match`, the result is `no_match`.\n- Otherwise, if any of the arguments is `fuzzy_match`, the result is `fuzzy_match`.\n- Otherwise (iff both arguments are `exact_match`), the result is `exact_match`."}, {"name": "tactic.interactive.case_tag.has_to_format", "description": ""}, {"name": "tactic.interactive.case_tag.has_repr", "description": ""}, {"name": "tactic.interactive.case_tag.to_string", "description": ""}, {"name": "tactic.interactive.case_tag.match_result", "description": "Indicates the result of matching a list of names against the names of a case\ntag. See `match_tag`."}, {"name": "tactic.interactive.case_tag.match_result.exact_match", "description": "Indicates the result of matching a list of names against the names of a case\ntag. See `match_tag`."}, {"name": "tactic.interactive.case_tag.match_result.fuzzy_match", "description": "Indicates the result of matching a list of names against the names of a case\ntag. See `match_tag`."}, {"name": "tactic.interactive.case_tag.match_result.no_match", "description": "Indicates the result of matching a list of names against the names of a case\ntag. See `match_tag`."}, {"name": "tactic.interactive.case_tag.to_format", "description": ""}, {"name": "tactic.interactive.case_tag.case_names", "description": "The constructor names associated with a case tag."}, {"name": "tactic.interactive.case_tag.parse", "description": "Parses a case tag from the list of names produced by `render`."}, {"name": "tactic.interactive.case_tag", "description": "A case tag carries the following information:\n\n1. A list of names identifying the case ('case names'). This is usually a list\n   of constructor names, one for each case split that was performed. For\n   example, the sequence of tactics `cases n; cases xs`, where `n` is a natural\n   number and `xs` is a list, will generate four cases tagged as follows:\n\n   ```lean\n   nat.zero, list.nil\n   nat.zero, list.cons\n   nat.succ, list.nil\n   nat.succ, list.cons\n   ```\n\n   Note: In the case tag, the case names are stored in reverse order. Thus, the\n   case names of the first case tag would be `list.nil, nat.zero`. This is\n   because when printing a goal tag (as part of a goal state), Lean prints all\n   non-internal names in reverse order.\n\n2. Information about the arguments introduced by the cases-like tactic.\n   Different tactics work slightly different in this regard:\n\n   1. The `with_cases` tactic generates goals where the target quantifies over\n      any added hypotheses. For example, `with_cases { cases xs }`, where `xs`\n      is a `list \u03b1`, will generate a target of the form `\u03b1 \u2192 list \u03b1 \u2192 ...` in\n      the `cons` case, where the two arguments correspond to the two arguments\n      of the `cons` constructor. Goals of this form are tagged with a `pi` case\n      tag (since the target is a pi type). In addition to the case names, it\n      contains a natural number, `num_arguments`, which specifies how many of\n      the arguments that the target quantifies over were introduced by\n      `with_cases`.\n\n      For example, given `n : \u2115` and `xs : list \u03b1`, the fourth goal generated by\n      `with_cases { cases n; induction xs }` has this form:\n\n      ```lean\n      ...\n      \u22a2 \u2115 \u2192 \u03b1 \u2192 \u2200 (xs' : list \u03b1), P xs' \u2192 ...\n      ```\n\n      The corresponding case tag is\n\n      ```lean\n      pi [`list.cons, `nat.succ] 4\n      ```\n\n      since the first four arguments of the target were introduced by\n      `with_cases {...}`.\n\n   2. The `cases` and `induction` tactics do not add arguments to the target,\n      but rather introduce them as hypotheses in the local context. Goals of\n      this form are tagged with a `hyps` case tag. In addition to the case\n      names, it contains a list of *unique* names of the hypotheses that were\n      introduced.\n\n      For example, given `xs : list \u03b1`, the second goal generated by\n      `induction xs` has this form:\n\n      ```lean\n      ...\n      x : \u03b1\n      xs' : list \u03b1\n      ih_xs' : P xs'\n      \u22a2 ...\n      ```\n\n      The corresponding goal tag is\n\n      ```lean\n      hyps [`list.cons] [`<x>, `<xs'>, `<ih_xs'>]\n      ```\n\n      where ````<h>``` denotes the unique name of a hypothesis `h`.\n\n      Note: Many tactics do not preserve the unique names of hypotheses\n      (particularly those tactics that use `revert`). Therefore, a `hyps` case\n      tag is only guaranteed to be valid directly after it was generated."}, {"name": "tactic.interactive.case_tag.pi", "description": "A case tag carries the following information:\n\n1. A list of names identifying the case ('case names'). This is usually a list\n   of constructor names, one for each case split that was performed. For\n   example, the sequence of tactics `cases n; cases xs`, where `n` is a natural\n   number and `xs` is a list, will generate four cases tagged as follows:\n\n   ```lean\n   nat.zero, list.nil\n   nat.zero, list.cons\n   nat.succ, list.nil\n   nat.succ, list.cons\n   ```\n\n   Note: In the case tag, the case names are stored in reverse order. Thus, the\n   case names of the first case tag would be `list.nil, nat.zero`. This is\n   because when printing a goal tag (as part of a goal state), Lean prints all\n   non-internal names in reverse order.\n\n2. Information about the arguments introduced by the cases-like tactic.\n   Different tactics work slightly different in this regard:\n\n   1. The `with_cases` tactic generates goals where the target quantifies over\n      any added hypotheses. For example, `with_cases { cases xs }`, where `xs`\n      is a `list \u03b1`, will generate a target of the form `\u03b1 \u2192 list \u03b1 \u2192 ...` in\n      the `cons` case, where the two arguments correspond to the two arguments\n      of the `cons` constructor. Goals of this form are tagged with a `pi` case\n      tag (since the target is a pi type). In addition to the case names, it\n      contains a natural number, `num_arguments`, which specifies how many of\n      the arguments that the target quantifies over were introduced by\n      `with_cases`.\n\n      For example, given `n : \u2115` and `xs : list \u03b1`, the fourth goal generated by\n      `with_cases { cases n; induction xs }` has this form:\n\n      ```lean\n      ...\n      \u22a2 \u2115 \u2192 \u03b1 \u2192 \u2200 (xs' : list \u03b1), P xs' \u2192 ...\n      ```\n\n      The corresponding case tag is\n\n      ```lean\n      pi [`list.cons, `nat.succ] 4\n      ```\n\n      since the first four arguments of the target were introduced by\n      `with_cases {...}`.\n\n   2. The `cases` and `induction` tactics do not add arguments to the target,\n      but rather introduce them as hypotheses in the local context. Goals of\n      this form are tagged with a `hyps` case tag. In addition to the case\n      names, it contains a list of *unique* names of the hypotheses that were\n      introduced.\n\n      For example, given `xs : list \u03b1`, the second goal generated by\n      `induction xs` has this form:\n\n      ```lean\n      ...\n      x : \u03b1\n      xs' : list \u03b1\n      ih_xs' : P xs'\n      \u22a2 ...\n      ```\n\n      The corresponding goal tag is\n\n      ```lean\n      hyps [`list.cons] [`<x>, `<xs'>, `<ih_xs'>]\n      ```\n\n      where ````<h>``` denotes the unique name of a hypothesis `h`.\n\n      Note: Many tactics do not preserve the unique names of hypotheses\n      (particularly those tactics that use `revert`). Therefore, a `hyps` case\n      tag is only guaranteed to be valid directly after it was generated."}, {"name": "tactic.interactive.case_tag.hyps", "description": "A case tag carries the following information:\n\n1. A list of names identifying the case ('case names'). This is usually a list\n   of constructor names, one for each case split that was performed. For\n   example, the sequence of tactics `cases n; cases xs`, where `n` is a natural\n   number and `xs` is a list, will generate four cases tagged as follows:\n\n   ```lean\n   nat.zero, list.nil\n   nat.zero, list.cons\n   nat.succ, list.nil\n   nat.succ, list.cons\n   ```\n\n   Note: In the case tag, the case names are stored in reverse order. Thus, the\n   case names of the first case tag would be `list.nil, nat.zero`. This is\n   because when printing a goal tag (as part of a goal state), Lean prints all\n   non-internal names in reverse order.\n\n2. Information about the arguments introduced by the cases-like tactic.\n   Different tactics work slightly different in this regard:\n\n   1. The `with_cases` tactic generates goals where the target quantifies over\n      any added hypotheses. For example, `with_cases { cases xs }`, where `xs`\n      is a `list \u03b1`, will generate a target of the form `\u03b1 \u2192 list \u03b1 \u2192 ...` in\n      the `cons` case, where the two arguments correspond to the two arguments\n      of the `cons` constructor. Goals of this form are tagged with a `pi` case\n      tag (since the target is a pi type). In addition to the case names, it\n      contains a natural number, `num_arguments`, which specifies how many of\n      the arguments that the target quantifies over were introduced by\n      `with_cases`.\n\n      For example, given `n : \u2115` and `xs : list \u03b1`, the fourth goal generated by\n      `with_cases { cases n; induction xs }` has this form:\n\n      ```lean\n      ...\n      \u22a2 \u2115 \u2192 \u03b1 \u2192 \u2200 (xs' : list \u03b1), P xs' \u2192 ...\n      ```\n\n      The corresponding case tag is\n\n      ```lean\n      pi [`list.cons, `nat.succ] 4\n      ```\n\n      since the first four arguments of the target were introduced by\n      `with_cases {...}`.\n\n   2. The `cases` and `induction` tactics do not add arguments to the target,\n      but rather introduce them as hypotheses in the local context. Goals of\n      this form are tagged with a `hyps` case tag. In addition to the case\n      names, it contains a list of *unique* names of the hypotheses that were\n      introduced.\n\n      For example, given `xs : list \u03b1`, the second goal generated by\n      `induction xs` has this form:\n\n      ```lean\n      ...\n      x : \u03b1\n      xs' : list \u03b1\n      ih_xs' : P xs'\n      \u22a2 ...\n      ```\n\n      The corresponding goal tag is\n\n      ```lean\n      hyps [`list.cons] [`<x>, `<xs'>, `<ih_xs'>]\n      ```\n\n      where ````<h>``` denotes the unique name of a hypothesis `h`.\n\n      Note: Many tactics do not preserve the unique names of hypotheses\n      (particularly those tactics that use `revert`). Therefore, a `hyps` case\n      tag is only guaranteed to be valid directly after it was generated."}, {"name": "tactic.interactive.case_tag.from_tag_hyps", "description": "Creates a `hyps` case tag from an input tag `in_tag`. The `names` of the\nresulting tag are the non-internal names in `in_tag` (in the order in which they\nappear in `in_tag`). `arguments` is the list of unique hypothesis names of the\nresulting tag."}, {"name": "tactic.interactive.case_tag.match_tag", "description": "Match the `names` of a case tag against a user-supplied list of names `ns`. For\nthis purpose, we consider the `names` in reverse order, i.e. in the order in\nwhich they are displayed to the user. The matching then uses the following\nrules:\n\n- If `ns` is exactly the same sequence of names as `names`, this is an exact\n  match.\n- If `ns` is a *suffix* of `names`, this is a fuzzy match. Additionally, each of\n  the names in `ns` may be a suffix of the corresponding name in `names`.\n- Otherwise, we have no match.\n\nThus, the tag\n```lean\nnat.zero, list.nil\n```\nis matched by any of these tags:\n```lean\nnat.zero, list.nil (exact match)\nnat.zero, nil      (fuzzy match)\nzero, nil          (fuzzy match)\nnil                (fuzzy match)\n```"}, {"name": "tactic.interactive.case_tag.from_tag_pi", "description": "Creates a `pi` case tag from an input tag `in_tag`. The `names` of the resulting\ntag are the non-internal names in `in_tag` (in the order in which they appear in\n`in_tag`). `num_arguments` is the number of arguments of the resulting tag."}, {"name": "tactic.interactive.case_tag.render", "description": "Renders a case tag to a goal tag (i.e. a list of names), according to the\nfollowing schema:\n\n- A `pi` tag with names `N\u2080 ... N\u2099` and number of arguments `a` is rendered as\n  ```lean\n  [`_case.pi.a, N\u2080, ..., N\u2099]\n  ```\n- A `hyps` tag with names `N\u2080 ... N\u2099` and argument names `A\u2080 ... A\u2098` is rendered\n  as\n  ```lean\n  [`_case.hyps, A\u2080._arg, ..., A\u2098._arg, N\u2080, ..., N\u2099]\n  ```"}, {"name": "tactic.interactive.case_tag.has_to_string", "description": ""}, {"name": "prod.decidable_eq", "description": ""}, {"name": "prod.mk.eta", "description": ""}, {"name": "prod.inhabited", "description": ""}, {"name": "prod.map", "description": ""}, {"name": "tactic.unify_equations.unify_cyclic", "description": "Given `equ : t = u` with `t, u : I` and `I.sizeof t \u2260 I.sizeof u`, we solve the\ngoal by contradiction."}, {"name": "tactic.unify_equations.add_add_one_ne", "description": ""}, {"name": "tactic.unify_equations.orelse_step", "description": "`orelse_step s t` first runs the unification step `s`. If this was successful\n(i.e. `s` simplified or solved the goal), it returns the result of `s`.\nOtherwise, it runs `t` and returns its result."}, {"name": "tactic.unify_equations.get_sizeof", "description": "For `type = I x\u2081 ... x\u2099`, where `I` is an inductive type, `get_sizeof type`\nreturns the constant `I.sizeof`. Fails if `type` is not of this form or if no\nsuch constant exists."}, {"name": "tactic.unify_equations.match_n_plus_m", "description": "`match_n_plus_m n e` matches `e` of the form `nat.succ (... (nat.succ e')...)`.\nIt returns `n` plus the number of `succ` constructors and `e'`. The matching is\nperformed up to normalisation with transparency `md`."}, {"name": "tactic.unify_equations.contradict_n_eq_n_plus_m", "description": "Given `equ : n + m = n` or `equ : n = n + m` with `n` and `m` natural numbers\nand `m` a nonzero literal, this tactic produces a proof of `false`. More\nprecisely, the two sides of the equation must be of the form\n`nat.succ (... (nat.succ e)...)` with different numbers of `nat.succ`\nconstructors. Matching is performed with transparency `md`."}, {"name": "tactic.unify_equations.unification_step", "description": "A unification step is a tactic that attempts to simplify a given equation and\nreturns a `unification_step_result`. The inputs are:\n\n- `equ`, the equation being processed. Must be a local constant.\n- `lhs_type` and `rhs_type`, the types of equ's LHS and RHS. For homogeneous\n  equations, these are defeq.\n- `lhs` and `rhs`, `equ`'s LHS and RHS.\n- `lhs_whnf` and `rhs_whnf`, `equ`'s LHS and RHS in WHNF.\n- `u`, `equ`'s level.\n\nSo `equ : @eq.{u} lhs_type lhs rhs` or `equ : @heq.{u} lhs_type lhs rhs_type rhs`."}, {"name": "tactic.unify_equations.unify_defeq", "description": "For `equ : t = u`, if `t` and `u` are defeq, we delete `equ`."}, {"name": "tactic_doc.tactic.unify_equations", "description": "`unify_equations eq\u2081 ... eq\u2099` performs a form of first-order unification on the\nhypotheses `eq\u1d62`. The `eq\u1d62` must be homogeneous or heterogeneous equations.\nUnification means that the equations are simplified using various facts about\nconstructors. For instance, consider this goal:\n\n```lean\nP : \u2200 n, fin n \u2192 Prop\nn m : \u2115\nf : fin n\ng : fin m\nh\u2081 : n + 1 = m + 1\nh\u2082 : f == g\nh\u2083 : P n f\n\u22a2 P m g\n```\n\nAfter `unify_equations h\u2081 h\u2082`, we get\n\n```lean\nP : \u2200 n, fin n \u2192 Prop\nn : \u2115\nf : fin n\nh\u2083 : P n f\n\u22a2 P n f\n```\n\nIn the example, `unify_equations` uses the fact that every constructor is\ninjective to conclude `n = m` from `h\u2081`. Then it replaces every `m` with `n` and\nmoves on to `h\u2082`. The types of `f` and `g` are now equal, so the heterogeneous\nequation turns into a homogeneous one and `g` is replaced by `f`. Note that the\nequations are processed from left to right, so `unify_equations h\u2082 h\u2081` would not\nsimplify as much.\n\nIn general, `unify_equations` uses the following steps on each equation until\nnone of them applies any more:\n\n- Constructor injectivity: if `nat.succ n = nat.succ m` then `n = m`.\n- Substitution: if `x = e` for some hypothesis `x`, then `x` is replaced by `e`\n  everywhere.\n- No-confusion: `nat.succ n = nat.zero` is a contradiction. If we have such an\n  equation, the goal is solved immediately.\n- Cycle elimination: `n = nat.succ n` is a contradiction.\n- Redundancy: if `t = u` but `t` and `u` are already definitionally equal, then\n  this equation is removed.\n- Downgrading of heterogeneous equations: if `t == u` but `t` and `u` have the\n  same type (up to definitional equality), then the equation is replaced by\n  `t = u`."}, {"name": "tactic.unify_equation_once", "description": "If `equ` is the display name of a local constant with type `t = u` or `t == u`,\nthen `unify_equation_once equ` simplifies it once using\n`unify_equations.unify_homogeneous` or `unify_equations.unify_heterogeneous`.\n\nOtherwise it fails."}, {"name": "tactic.unify_equations.unify_homogeneous", "description": "For `equ : t = u`, try the following methods in order: `unify_defeq`,\n`unify_var`, `unify_constructor_headed`, `unify_cyclic`. If any of them is\nsuccessful, stop and return its result. If none is successful, fail."}, {"name": "tactic.unify_equations.unification_step_result", "description": "The result of a unification step:\n\n- `simplified hs` means that the step succeeded and produced some new (simpler)\n  equations `hs`. `hs` can be empty.\n- `goal_solved` means that the step succeeded and solved the goal (by deriving a\n  contradiction from the given equation).\n- `not_simplified` means that the step failed to simplify the equation."}, {"name": "tactic.unify_equations.unification_step_result.simplified", "description": "The result of a unification step:\n\n- `simplified hs` means that the step succeeded and produced some new (simpler)\n  equations `hs`. `hs` can be empty.\n- `goal_solved` means that the step succeeded and solved the goal (by deriving a\n  contradiction from the given equation).\n- `not_simplified` means that the step failed to simplify the equation."}, {"name": "tactic.unify_equations.unification_step_result.not_simplified", "description": "The result of a unification step:\n\n- `simplified hs` means that the step succeeded and produced some new (simpler)\n  equations `hs`. `hs` can be empty.\n- `goal_solved` means that the step succeeded and solved the goal (by deriving a\n  contradiction from the given equation).\n- `not_simplified` means that the step failed to simplify the equation."}, {"name": "tactic.unify_equations.unification_step_result.goal_solved", "description": "The result of a unification step:\n\n- `simplified hs` means that the step succeeded and produced some new (simpler)\n  equations `hs`. `hs` can be empty.\n- `goal_solved` means that the step succeeded and solved the goal (by deriving a\n  contradiction from the given equation).\n- `not_simplified` means that the step failed to simplify the equation."}, {"name": "tactic.unify_equations.unify_heterogeneous", "description": "For `equ : t == u` with `t : T` and `u : U`, if `T` and `U` are defeq,\nwe replace `equ` with `equ : t = u`."}, {"name": "tactic.unify_equations.unify_var", "description": "For `equ : x = t` or `equ : t = x`, where `x` is a local constant, we\nsubstitute `x` with `t` in the goal."}, {"name": "tactic.unify_equations.unify_constructor_headed", "description": "Given `equ : C x\u2081 ... x\u2099 = D y\u2081 ... y\u2098` with `C` and `D` constructors of the\nsame datatype `I`:\n\n- If `C \u2260 D`, we solve the goal by contradiction using the no-confusion rule.\n- If `C = D`, we clear `equ` and add equations `x\u2081 = y\u2081`, ..., `x\u2099 = y\u2099`."}, {"name": "tactic.interactive.unify_equations", "description": "`unify_equations eq\u2081 ... eq\u2099` performs a form of first-order unification on the\nhypotheses `eq\u1d62`. The `eq\u1d62` must be homogeneous or heterogeneous equations.\nUnification means that the equations are simplified using various facts about\nconstructors. For instance, consider this goal:\n\n```lean\nP : \u2200 n, fin n \u2192 Prop\nn m : \u2115\nf : fin n\ng : fin m\nh\u2081 : n + 1 = m + 1\nh\u2082 : f == g\nh\u2083 : P n f\n\u22a2 P m g\n```\n\nAfter `unify_equations h\u2081 h\u2082`, we get\n\n```lean\nP : \u2200 n, fin n \u2192 Prop\nn : \u2115\nf : fin n\nh\u2083 : P n f\n\u22a2 P n f\n```\n\nIn the example, `unify_equations` uses the fact that every constructor is\ninjective to conclude `n = m` from `h\u2081`. Then it replaces every `m` with `n` and\nmoves on to `h\u2082`. The types of `f` and `g` are now equal, so the heterogeneous\nequation turns into a homogeneous one and `g` is replaced by `f`. Note that the\nequations are processed from left to right, so `unify_equations h\u2082 h\u2081` would not\nsimplify as much.\n\nIn general, `unify_equations` uses the following steps on each equation until\nnone of them applies any more:\n\n- Constructor injectivity: if `nat.succ n = nat.succ m` then `n = m`.\n- Substitution: if `x = e` for some hypothesis `x`, then `x` is replaced by `e`\n  everywhere.\n- No-confusion: `nat.succ n = nat.zero` is a contradiction. If we have such an\n  equation, the goal is solved immediately.\n- Cycle elimination: `n = nat.succ n` is a contradiction.\n- Redundancy: if `t = u` but `t` and `u` are already definitionally equal, then\n  this equation is removed.\n- Downgrading of heterogeneous equations: if `t == u` but `t` and `u` have the\n  same type (up to definitional equality), then the equation is replaced by\n  `t = u`."}, {"name": "tactic.unify_equations", "description": "Given a list of display names of local hypotheses that are (homogeneous or\nheterogeneous) equations, `unify_equations` performs first-order unification on\neach hypothesis in order. See `tactic.interactive.unify_equations` for an\nexample and an explanation of what unification does.\n\nReturns true iff the goal has been solved during the unification process.\n\nNote: you must make sure that the input names are unique in the context."}, {"name": "tactic.mllist.m_of_list", "description": "Convert a `list` of values inside the monad into an `mllist`."}, {"name": "tactic.mllist.empty", "description": "Compute, inside the monad, whether an `mllist` is empty."}, {"name": "tactic.mllist.head", "description": "Return the head of a monadic lazy list, as a value in the monad."}, {"name": "tactic.mllist.force", "description": "Extract a list inside the monad from an `mllist`."}, {"name": "tactic.mllist.enum_from", "description": "Enumerate the elements of a monadic lazy list, starting at a specified offset."}, {"name": "tactic.mllist.map", "description": "Apply a function to every element of an `mllist`."}, {"name": "tactic.mllist.enum", "description": "Enumerate the elements of a monadic lazy list."}, {"name": "tactic.mllist.filter", "description": "Filter a `mllist`."}, {"name": "tactic.mllist.fix", "description": "Construct an `mllist` recursively."}, {"name": "tactic.mllist.squash", "description": "Lift a monadic lazy list inside the monad to a monadic lazy list."}, {"name": "tactic.mllist.range", "description": "The infinite monadic lazy list of natural numbers."}, {"name": "tactic.mllist.concat", "description": "Add one element to the end of a monadic lazy list."}, {"name": "tactic.mllist.of_list", "description": "Convert a `list` to an `mllist`."}, {"name": "tactic.mllist.fixl_with", "description": " Repeatedly apply a function `f : \u03b1 \u2192 m (\u03b1 \u00d7 list \u03b2)` to an initial `a : \u03b1`,\naccumulating the elements of the resulting `list \u03b2` as a single monadic lazy list.\n\n(This variant allows starting with a specified `list \u03b2` of elements, as well. )"}, {"name": "tactic.mllist.bind_", "description": " Apply a function returning a monadic lazy list to each element of a monadic lazy list,\njoining the results."}, {"name": "tactic.mllist", "description": "A monadic lazy list, controlled by an arbitrary monad."}, {"name": "tactic.mllist.nil", "description": "A monadic lazy list, controlled by an arbitrary monad."}, {"name": "tactic.mllist.cons", "description": "A monadic lazy list, controlled by an arbitrary monad."}, {"name": "tactic.mllist.uncons", "description": " Deconstruct an `mllist`, returning inside the monad an optional pair `\u03b1 \u00d7 mllist m \u03b1`\nrepresenting the head and tail of the list."}, {"name": "tactic.mllist.mmap", "description": "Apply a function which returns values in the monad to every element of an `mllist`."}, {"name": "tactic.mllist.filter_map", "description": "Filter and transform a `mllist` using an `option` valued function."}, {"name": "tactic.mllist.monad_lift", "description": "Convert any value in the monad to the singleton monadic lazy list."}, {"name": "tactic.mllist.join", "description": "Join a monadic lazy list of monadic lazy lists into a single monadic lazy list."}, {"name": "tactic.mllist.mfirst", "description": " Apply a function returning values inside the monad to a monadic lazy list,\nreturning only the first successful result."}, {"name": "tactic.mllist.take", "description": "Take the first `n` elements, as a list inside the monad."}, {"name": "tactic.mllist.mfilter", "description": " Filter a `mllist` using a function which returns values in the (alternative) monad.\nWhenever the function \"succeeds\", we accept the element, and reject otherwise."}, {"name": "tactic.mllist.append", "description": "Concatenate two monadic lazty lists."}, {"name": "tactic.mllist.mfilter_map", "description": " Filter and transform a `mllist` using a function that returns values inside the monad.\nWe discard elements where the function fails."}, {"name": "tactic.mllist.fixl", "description": " Repeatedly apply a function `f : \u03b1 \u2192 m (\u03b1 \u00d7 list \u03b2)` to an initial `a : \u03b1`,\naccumulating the elements of the resulting `list \u03b2` as a single monadic lazy list."}, {"name": "auto_param_eq", "description": ""}, {"name": "name.has_append", "description": ""}, {"name": "name.has_lt", "description": ""}, {"name": "name.inhabited", "description": ""}, {"name": "mk_simple_name", "description": ""}, {"name": "name.is_suffix_of", "description": ""}, {"name": "name.append", "description": ""}, {"name": "name.components", "description": ""}, {"name": "string_to_name", "description": ""}, {"name": "name.replace_prefix", "description": ""}, {"name": "name", "description": "Reflect a C++ name object. The VM replaces it with the C++ implementation."}, {"name": "name.anonymous", "description": "Reflect a C++ name object. The VM replaces it with the C++ implementation."}, {"name": "name.mk_string", "description": "Reflect a C++ name object. The VM replaces it with the C++ implementation."}, {"name": "name.mk_numeral", "description": "Reflect a C++ name object. The VM replaces it with the C++ implementation."}, {"name": "name.lex_cmp", "description": ""}, {"name": "name.to_string", "description": ""}, {"name": "name.is_internal", "description": ""}, {"name": "name.has_decidable_eq", "description": ""}, {"name": "name.repr", "description": ""}, {"name": "name.lt.decidable_rel", "description": ""}, {"name": "name.has_repr", "description": ""}, {"name": "name.append_after", "description": "`name.append_after n i` return a name of the form n_i"}, {"name": "name.has_to_string", "description": ""}, {"name": "name.is_prefix_of", "description": ""}, {"name": "name.lt", "description": ""}, {"name": "name.get_prefix", "description": ""}, {"name": "name.to_string_with_sep", "description": ""}, {"name": "name.update_prefix", "description": ""}, {"name": "mk_num_name", "description": ""}, {"name": "auto_param", "description": "Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses\n   the tactic declaration names tac_name to synthesize the argument.\n   Like opt_param, this gadget only affects elaboration.\n   For example, the tactic will *not* be invoked during type class resolution."}, {"name": "name.cmp", "description": ""}, {"name": "mk_str_name", "description": ""}, {"name": "infer_type_cmd", "description": ""}, {"name": "hole_command", "description": "The front-end (e.g., Emacs, VS Code) can invoke commands for holes `{! ... !}` in\na declaration. A command is a tactic that takes zero or more pre-terms in the\nhole, and returns a list of pair (s, descr) where 's' is a substitution and 'descr' is\na short explanation for the substitution.\nEach string 's' represents a different way to fill the hole.\nThe front-end is responsible for replacing the hole with the string/alternative selected by the user.\n\nThis infra-structure can be use to implement auto-fill and/or refine commands.\n\nAn action may return an empty list. This is useful for actions that just return\ninformation such as: the type of an expression, its normal form, etc."}, {"name": "hole_command.name", "description": "The front-end (e.g., Emacs, VS Code) can invoke commands for holes `{! ... !}` in\na declaration. A command is a tactic that takes zero or more pre-terms in the\nhole, and returns a list of pair (s, descr) where 's' is a substitution and 'descr' is\na short explanation for the substitution.\nEach string 's' represents a different way to fill the hole.\nThe front-end is responsible for replacing the hole with the string/alternative selected by the user.\n\nThis infra-structure can be use to implement auto-fill and/or refine commands.\n\nAn action may return an empty list. This is useful for actions that just return\ninformation such as: the type of an expression, its normal form, etc."}, {"name": "hole_command.descr", "description": "The front-end (e.g., Emacs, VS Code) can invoke commands for holes `{! ... !}` in\na declaration. A command is a tactic that takes zero or more pre-terms in the\nhole, and returns a list of pair (s, descr) where 's' is a substitution and 'descr' is\na short explanation for the substitution.\nEach string 's' represents a different way to fill the hole.\nThe front-end is responsible for replacing the hole with the string/alternative selected by the user.\n\nThis infra-structure can be use to implement auto-fill and/or refine commands.\n\nAn action may return an empty list. This is useful for actions that just return\ninformation such as: the type of an expression, its normal form, etc."}, {"name": "hole_command.action", "description": "The front-end (e.g., Emacs, VS Code) can invoke commands for holes `{! ... !}` in\na declaration. A command is a tactic that takes zero or more pre-terms in the\nhole, and returns a list of pair (s, descr) where 's' is a substitution and 'descr' is\na short explanation for the substitution.\nEach string 's' represents a different way to fill the hole.\nThe front-end is responsible for replacing the hole with the string/alternative selected by the user.\n\nThis infra-structure can be use to implement auto-fill and/or refine commands.\n\nAn action may return an empty list. This is useful for actions that just return\ninformation such as: the type of an expression, its normal form, etc."}, {"name": "use_cmd", "description": ""}, {"name": "show_goal_cmd", "description": ""}, {"name": "add_units.coe_map_neg", "description": ""}, {"name": "is_add_unit.sub_self", "description": ""}, {"name": "is_unit.eq_inv_mul_iff_mul_eq", "description": ""}, {"name": "add_units.lift_right_neg_add", "description": ""}, {"name": "is_unit.div_left_inj", "description": ""}, {"name": "is_add_unit.neg_add_eq_zero", "description": ""}, {"name": "is_unit.mul_div_mul_right", "description": ""}, {"name": "is_unit.div_eq_of_eq_mul", "description": ""}, {"name": "is_unit.inv", "description": ""}, {"name": "is_unit.mul_inv_eq_iff_eq_mul", "description": ""}, {"name": "is_unit.div_div_cancel", "description": ""}, {"name": "is_unit.mul_div_cancel_left", "description": ""}, {"name": "is_add_unit.neg_add_cancel_left", "description": ""}, {"name": "is_unit.one_div_mul_cancel", "description": ""}, {"name": "units.lift_right", "description": " If a map `g : M \u2192 N\u02e3` agrees with a homomorphism `f : M \u2192* N`, then\nthis map is a monoid homomorphism too."}, {"name": "is_add_unit.neg_add_eq_iff_eq_add", "description": ""}, {"name": "is_unit.mul_div_cancel", "description": ""}, {"name": "units.coe_map", "description": ""}, {"name": "is_unit.div_eq_one_iff_eq", "description": ""}, {"name": "add_monoid_hom.to_hom_add_units", "description": "If `f` is a homomorphism from an additive group `G` to an additive monoid `M`,\nthen its image lies in the `add_units` of `M`,\nand `f.to_hom_units` is the corresponding homomorphism from `G` to `add_units M`."}, {"name": "is_unit.div_mul_cancel", "description": ""}, {"name": "units.coe_inv", "description": ""}, {"name": "is_add_unit.sub", "description": ""}, {"name": "is_add_unit.zero_sub_add_cancel", "description": ""}, {"name": "is_unit.mul_lift_right_inv", "description": ""}, {"name": "is_unit.coe_inv_unit'", "description": ""}, {"name": "is_unit.mul_one_div_cancel", "description": ""}, {"name": "is_unit.lift_right_inv_mul", "description": ""}, {"name": "units.map_id", "description": ""}, {"name": "is_add_unit.lift_right_neg_add", "description": ""}, {"name": "units.lift_right_inv_mul", "description": ""}, {"name": "is_unit.inv_mul_cancel", "description": ""}, {"name": "units.coe_hom_apply", "description": ""}, {"name": "is_unit.div", "description": ""}, {"name": "is_unit.lift_right", "description": " If a homomorphism `f : M \u2192* N` sends each element to an `is_unit`, then it can be lifted\nto `f : M \u2192* N\u02e3`. See also `units.lift_right` for a computable version."}, {"name": "is_add_unit.lift_right", "description": "If a homomorphism `f : M \u2192+ N` sends each element to an `is_add_unit`, then it can be\nlifted to `f : M \u2192+ add_units N`. See also `add_units.lift_right` for a computable version."}, {"name": "is_add_unit.eq_sub_iff", "description": ""}, {"name": "is_add_unit.sub_add_cancel", "description": ""}, {"name": "is_unit.inv_mul_eq_iff_eq_mul", "description": ""}, {"name": "add_units.coe_hom_apply", "description": ""}, {"name": "is_unit.div_eq_div_iff", "description": ""}, {"name": "is_unit.eq_mul_inv_iff_mul_eq", "description": ""}, {"name": "is_add_unit.add_eq_zero_iff_eq_neg", "description": ""}, {"name": "add_units.map_id", "description": ""}, {"name": "divp_eq_div", "description": ""}, {"name": "units.coe_zpow", "description": ""}, {"name": "add_units.coe_lift_right", "description": ""}, {"name": "is_add_unit.sub_eq_zero_iff_eq", "description": ""}, {"name": "add_units.coe_sub", "description": ""}, {"name": "is_unit.div_mul_left", "description": ""}, {"name": "is_unit.coe_lift_right", "description": ""}, {"name": "add_units.add_lift_right_neg", "description": ""}, {"name": "add_units.coe_zsmul", "description": ""}, {"name": "is_add_unit.neg", "description": ""}, {"name": "is_add_unit.add_neg_eq_iff_eq_add", "description": ""}, {"name": "is_add_unit.add_sub_add_right", "description": ""}, {"name": "is_add_unit.add_neg_cancel_left", "description": ""}, {"name": "units.coe_hom", "description": "Coercion `M\u02e3 \u2192 M` as a monoid homomorphism."}, {"name": "units.map", "description": "The group homomorphism on units induced by a `monoid_hom`."}, {"name": "is_add_unit.add_sub_cancel", "description": ""}, {"name": "is_unit.eq_div_of_mul_eq", "description": ""}, {"name": "add_units.coe_neg", "description": ""}, {"name": "is_unit.coe_unit'", "description": ""}, {"name": "units.coe_map_inv", "description": ""}, {"name": "is_add_unit.add_eq_add_of_sub_eq_sub", "description": ""}, {"name": "is_add_unit.add_sub_cancel'", "description": ""}, {"name": "is_unit.mul_eq_one_iff_eq_inv", "description": ""}, {"name": "is_add_unit.eq_neg_add_iff_add_eq", "description": ""}, {"name": "is_unit.eq_div_iff", "description": ""}, {"name": "add_units.coe_map", "description": ""}, {"name": "is_unit.inv_mul_cancel_right", "description": ""}, {"name": "is_unit.mul_inv_eq_one", "description": ""}, {"name": "is_unit.mul_inv_cancel_right", "description": ""}, {"name": "is_unit.mul_div_mul_left", "description": ""}, {"name": "is_unit.map", "description": ""}, {"name": "is_add_unit.coe_neg_add_unit'", "description": ""}, {"name": "is_add_unit.add_add_sub", "description": ""}, {"name": "is_add_unit.neg_add_cancel", "description": ""}, {"name": "is_add_unit.neg_add_cancel_right", "description": ""}, {"name": "is_add_unit.add_neg_cancel", "description": ""}, {"name": "is_unit.mul_inv_cancel", "description": ""}, {"name": "is_add_unit.coe_lift_right", "description": ""}, {"name": "is_add_unit.sub_eq_iff", "description": ""}, {"name": "is_add_unit.add_neg_cancel_right", "description": ""}, {"name": "monoid_hom.coe_to_hom_units", "description": ""}, {"name": "is_add_unit.eq_sub_of_add_eq", "description": ""}, {"name": "is_add_unit.add_sub_cancel_left", "description": ""}, {"name": "is_add_unit.add_unit'", "description": "The element of the additive group of additive units, corresponding to an element of\nan additive monoid which is an additive unit. As opposed to `is_add_unit.add_unit`, the negation is\ncomputable and comes from the negation on `\u03b1`. This is useful to transfer properties of negation in\n`add_units \u03b1` to `\u03b1`. See also `to_add_units`."}, {"name": "add_units.map_comp", "description": ""}, {"name": "is_add_unit.sub_add_left", "description": ""}, {"name": "is_unit.div_eq_iff", "description": ""}, {"name": "is_add_unit.add_neg_eq_zero", "description": ""}, {"name": "units.mul_lift_right_inv", "description": ""}, {"name": "is_add_unit.sub_eq_sub_iff", "description": ""}, {"name": "add_units.coe_nsmul", "description": ""}, {"name": "units.map_comp", "description": ""}, {"name": "units.coe_div", "description": ""}, {"name": "is_unit.mul_inv_cancel_left", "description": ""}, {"name": "is_add_unit.add_lift_right_neg", "description": ""}, {"name": "monoid_hom.to_hom_units", "description": " If `f` is a homomorphism from a group `G` to a monoid `M`,\nthen its image lies in the units of `M`,\nand `f.to_hom_units` is the corresponding monoid homomorphism from `G` to `M\u02e3`."}, {"name": "units.coe_lift_right", "description": ""}, {"name": "is_add_unit.sub_left_inj", "description": ""}, {"name": "add_units.lift_right", "description": "If a map `g : M \u2192 add_units N` agrees with a homomorphism `f : M \u2192+ N`, then this map\nis an add_monoid homomorphism too."}, {"name": "is_unit.mul_div_cancel'", "description": ""}, {"name": "is_unit.inv_mul_cancel_left", "description": ""}, {"name": "is_add_unit.add_zero_sub_cancel", "description": ""}, {"name": "is_unit.mul_eq_one_iff_inv_eq", "description": ""}, {"name": "is_add_unit.map", "description": ""}, {"name": "add_units.map", "description": "The `add_group` homomorphism on `add_unit`s induced by an `add_monoid_hom`."}, {"name": "is_unit.div_mul_right", "description": ""}, {"name": "is_unit.div_self", "description": ""}, {"name": "is_unit.unit'", "description": " The element of the group of units, corresponding to an element of a monoid which is a unit. As\nopposed to `is_unit.unit`, the inverse is computable and comes from the inversion on `\u03b1`. This is\nuseful to transfer properties of inversion in `units \u03b1` to `\u03b1`. See also `to_units`."}, {"name": "is_add_unit.add_sub_add_left", "description": ""}, {"name": "is_add_unit.sub_add_right", "description": ""}, {"name": "is_unit.mul_eq_mul_of_div_eq_div", "description": ""}, {"name": "units.coe_pow", "description": ""}, {"name": "is_add_unit.coe_add_unit'", "description": ""}, {"name": "is_add_unit.eq_add_neg_iff_add_eq", "description": ""}, {"name": "is_add_unit.sub_sub_cancel", "description": ""}, {"name": "is_add_unit.sub_eq_of_eq_add", "description": ""}, {"name": "is_add_unit.add_eq_zero_iff_neg_eq", "description": ""}, {"name": "is_unit.inv_mul_eq_one", "description": ""}, {"name": "is_unit.mul_mul_div", "description": ""}, {"name": "add_units.coe_hom", "description": "Coercion `add_units M \u2192 M` as an add_monoid homomorphism."}, {"name": "fin.insert_nth_div", "description": ""}, {"name": "fin.insert_nth_apply_above", "description": ""}, {"name": "fin.eq_insert_nth_iff", "description": ""}, {"name": "fin.cons_update", "description": "Updating a tuple and adding an element at the beginning commute."}, {"name": "fin.insert_nth_apply_succ_above", "description": ""}, {"name": "fin.mem_find_iff", "description": ""}, {"name": "fin.snoc_last", "description": ""}, {"name": "fin.le_cons", "description": ""}, {"name": "fin.insert_nth_last", "description": ""}, {"name": "fin.tail_update_zero", "description": "Updating the first element of a tuple does not change the tail."}, {"name": "fin.preimage_insert_nth_Icc_of_not_mem", "description": ""}, {"name": "fin.succ_above_cases", "description": " Define a function on `fin (n + 1)` from a value on `i : fin (n + 1)` and values on each\n`fin.succ_above i j`, `j : fin n`. This version is elaborated as eliminator and works for\npropositions, see also `fin.insert_nth` for a version without an `@[elab_as_eliminator]`\nattribute."}, {"name": "fin.insert_nth_sub_same", "description": ""}, {"name": "fin.forall_fin_succ_pi", "description": ""}, {"name": "fin.find_eq_none_iff", "description": "`find p` returns `none` if and only if `p i` never holds."}, {"name": "fin.le_insert_nth_iff", "description": ""}, {"name": "fin.cons_right_injective", "description": ""}, {"name": "fin.snoc_update", "description": "Updating a tuple and adding an element at the end commute."}, {"name": "fin.init_def", "description": ""}, {"name": "fin.cons_self_tail", "description": "Concatenating the first element of a tuple with its tail gives back the original tuple"}, {"name": "fin.comp_snoc", "description": ""}, {"name": "fin.exists_fin_zero_pi", "description": ""}, {"name": "fin.forall_fin_zero_pi", "description": ""}, {"name": "fin.fin_append_apply_zero", "description": ""}, {"name": "fin.insert_nth_binop", "description": ""}, {"name": "fin.find_spec", "description": "If `find p = some i`, then `p i` holds"}, {"name": "fin.insert_nth_add", "description": ""}, {"name": "fin.init_update_last", "description": "Updating the last element of a tuple does not change the beginning."}, {"name": "fin.init_update_cast_succ", "description": "Updating an element and taking the beginning commute."}, {"name": "fin.tail_def", "description": ""}, {"name": "fin.nat_find_mem_find", "description": ""}, {"name": "fin.cons_induction_cons", "description": ""}, {"name": "fin.cons_eq_cons", "description": ""}, {"name": "fin.cons_induction", "description": "Recurse on an `n+1`-tuple by splitting it into a single element and an `n`-tuple."}, {"name": "fin.tail", "description": "The tail of an `n+1` tuple, i.e., its last `n` entries."}, {"name": "fin.cons_zero", "description": ""}, {"name": "fin.succ_above_cases_eq_insert_nth", "description": ""}, {"name": "fin.find_min'", "description": ""}, {"name": "fin.tuple0_le", "description": ""}, {"name": "fin.snoc", "description": " Adding an element at the end of an `n`-tuple, to get an `n+1`-tuple. The name `snoc` comes from\n`cons` (i.e., adding an element to the left of a tuple) read in reverse order."}, {"name": "fin.find", "description": " `find p` returns the first index `n` where `p n` is satisfied, and `none` if it is never\nsatisfied."}, {"name": "fin.comp_cons", "description": ""}, {"name": "fin.insert_nth_zero", "description": ""}, {"name": "fin.range_cons", "description": ""}, {"name": "fin.cons_le_cons", "description": ""}, {"name": "fin.insert_nth", "description": " Insert an element into a tuple at a given position. For `i = 0` see `fin.cons`,\nfor `i = fin.last n` see `fin.snoc`. See also `fin.succ_above_cases` for a version elaborated\nas an eliminator."}, {"name": "fin.insert_nth_last'", "description": ""}, {"name": "fin.forall_iff_succ_above", "description": ""}, {"name": "fin.find_eq_some_iff", "description": ""}, {"name": "fin.cons_succ", "description": ""}, {"name": "fin.init_snoc", "description": ""}, {"name": "fin.insert_nth_comp_succ_above", "description": ""}, {"name": "fin.preimage_insert_nth_Icc_of_mem", "description": ""}, {"name": "fin.exists_fin_succ_pi", "description": ""}, {"name": "fin.insert_nth_eq_iff", "description": ""}, {"name": "fin.sigma_eq_of_eq_comp_cast", "description": " To show two sigma pairs of tuples agree, it to show the second elements are related via\n`fin.cast`."}, {"name": "fin.tail_update_succ", "description": "Updating a nonzero element and taking the tail commute."}, {"name": "fin.is_some_find_iff", "description": "`find p` does not return `none` if and only if `p i` holds at some index `i`."}, {"name": "fin.find_min", "description": " If `find p` returns `some i`, then `p j` does not hold for `j < i`, i.e., `i` is minimal among\nthe indices where `p` holds."}, {"name": "fin.update_cons_zero", "description": " Adding an element at the beginning of a tuple and then updating it amounts to adding it\ndirectly."}, {"name": "fin.insert_nth_apply_same", "description": ""}, {"name": "fin.mem_find_of_unique", "description": ""}, {"name": "fin.pi_lex_lt_cons_cons", "description": ""}, {"name": "fin.snoc_comp_cast_succ", "description": ""}, {"name": "fin.comp_init", "description": ""}, {"name": "fin.cons_left_injective", "description": ""}, {"name": "fin.insert_nth_mul", "description": ""}, {"name": "fin.append", "description": " `fin.append ho u v` appends two vectors of lengths `m` and `n` to produce\none of length `o = m + n`.  `ho` provides control of definitional equality\nfor the vector length."}, {"name": "fin.sigma_eq_iff_eq_comp_cast", "description": "`fin.sigma_eq_of_eq_comp_cast` as an `iff`."}, {"name": "fin.tail_init_eq_init_tail", "description": " `tail` and `init` commute. We state this lemma in a non-dependent setting, as otherwise it\nwould involve a cast to convince Lean that the two types are equal, making it harder to use."}, {"name": "fin.insert_nth_zero'", "description": ""}, {"name": "fin.tail_cons", "description": ""}, {"name": "fin.comp_tail", "description": ""}, {"name": "fin.init", "description": "The beginning of an `n+1` tuple, i.e., its first `n` entries"}, {"name": "fin.insert_nth_sub", "description": ""}, {"name": "fin.update_snoc_last", "description": " Adding an element at the beginning of a tuple and then updating it amounts to adding it\ndirectly."}, {"name": "fin.snoc_cast_succ", "description": ""}, {"name": "fin.cons_injective2", "description": "As a binary function, `fin.cons` is injective."}, {"name": "fin.snoc_cast_add", "description": ""}, {"name": "fin.insert_nth_apply_below", "description": ""}, {"name": "fin.cons", "description": "Adding an element at the beginning of an `n`-tuple, to get an `n+1`-tuple."}, {"name": "fin.insert_nth_mem_Icc", "description": ""}, {"name": "fin.cons_snoc_eq_snoc_cons", "description": " `cons` and `snoc` commute. We state this lemma in a non-dependent setting, as otherwise it\nwould involve a cast to convince Lean that the two types are equal, making it harder to use."}, {"name": "fin.cons_le", "description": ""}, {"name": "fin.insert_nth_le_iff", "description": ""}, {"name": "fin.snoc_init_self", "description": "Concatenating the first element of a tuple with its tail gives back the original tuple"}, {"name": "fin.snoc_comp_nat_add", "description": ""}, {"name": "fin.insert_nth_zero_right", "description": ""}, {"name": "fin.snoc_comp_cast_add", "description": ""}, {"name": "tactic.apply_cfg.inhabited", "description": ""}, {"name": "tactic_doc_entry.inhabited", "description": ""}, {"name": "interactive.loc.inhabited", "description": ""}, {"name": "pos.inhabited", "description": ""}, {"name": "smt_pre_config.inhabited", "description": ""}, {"name": "reducibility_hints.inhabited", "description": ""}, {"name": "environment.projection_info.inhabited", "description": ""}, {"name": "rbmap.inhabited", "description": ""}, {"name": "tactic.unfold_proj_config.inhabited", "description": ""}, {"name": "bin_tree.inhabited", "description": ""}, {"name": "vm_decl_kind.inhabited", "description": ""}, {"name": "rsimp.config.inhabited", "description": ""}, {"name": "ulift.inhabited", "description": ""}, {"name": "tactic.simp_config.inhabited", "description": ""}, {"name": "tactic.transparency.inhabited", "description": ""}, {"name": "tactic.rewrite_cfg.inhabited", "description": ""}, {"name": "tactic.new_goals.inhabited", "description": ""}, {"name": "rbnode.inhabited", "description": ""}, {"name": "unsigned.inhabited", "description": ""}, {"name": "format.color.inhabited", "description": ""}, {"name": "tactic.delta_config.inhabited", "description": ""}, {"name": "subsingleton_info.inhabited", "description": ""}, {"name": "rbnode.color.inhabited", "description": ""}, {"name": "tactic.dsimp_config.inhabited", "description": ""}, {"name": "smt_config.inhabited", "description": ""}, {"name": "congr_arg_kind.inhabited", "description": ""}, {"name": "unification_constraint.inhabited", "description": ""}, {"name": "unification_hint.inhabited", "description": ""}, {"name": "pprod.inhabited", "description": ""}, {"name": "fun_info.inhabited", "description": ""}, {"name": "tactic.dunfold_config.inhabited", "description": ""}, {"name": "cc_config.inhabited", "description": ""}, {"name": "string.iterator.inhabited", "description": ""}, {"name": "doc_category.inhabited", "description": ""}, {"name": "ematch_config.inhabited", "description": ""}, {"name": "tactic.inhabited_instance", "description": "Tries to derive an `inhabited` instance for inductives and structures.\n\nFor example:\n```lean\n@[derive inhabited]\nstructure foo :=\n(a : \u2115 := 42)\n(b : list \u2115)\n```\nHere, `@[derive inhabited]` adds the instance `foo.inhabited`, which is defined as\n`\u27e8\u27e842, default\u27e9\u27e9`.  For inductives, the default value is the first constructor.\n\nIf the structure/inductive has a type parameter `\u03b1`, then the generated instance will have an\nargument `inhabited \u03b1`, even if it is not used.  (This is due to the implementation using\n`instance_derive_handler`.)"}, {"name": "rbtree.inhabited", "description": ""}, {"name": "param_info.inhabited", "description": ""}, {"name": "plift.inhabited", "description": ""}, {"name": "string_imp.inhabited", "description": ""}, {"name": "ordering.inhabited", "description": ""}, {"name": "tactic.unfold_config.inhabited", "description": ""}, {"name": "tactic.simp_intros_config.inhabited", "description": ""}, {"name": "string.iterator_imp.inhabited", "description": ""}, {"name": "vm_obj_kind.inhabited", "description": ""}, {"name": "add_commute.neg_add_cancel", "description": ""}, {"name": "neg_add_cancel_comm_assoc", "description": ""}, {"name": "commute.right_comm", "description": ""}, {"name": "commute.units_inv_left", "description": ""}, {"name": "add_commute.neg_neg", "description": ""}, {"name": "mul_inv_cancel_comm_assoc", "description": ""}, {"name": "add_commute.neg_left", "description": ""}, {"name": "add_commute.refl", "description": "Any element commutes with itself."}, {"name": "add_commute", "description": "Two elements additively commute if `a + b = b + a`"}, {"name": "commute.units_coe_iff", "description": ""}, {"name": "commute.semiconj_by", "description": ""}, {"name": "commute.one_left", "description": ""}, {"name": "commute.self_pow", "description": ""}, {"name": "commute", "description": "Two elements commute if `a * b = b * a`."}, {"name": "add_commute.nsmul_right", "description": ""}, {"name": "add_commute.self_nsmul", "description": ""}, {"name": "commute.all", "description": ""}, {"name": "commute.mul_left", "description": "If both `a` and `b` commute with `c`, then their product commutes with `c`."}, {"name": "add_commute.is_add_unit_add_iff", "description": ""}, {"name": "add_commute.neg_neg_iff", "description": ""}, {"name": "add_commute.all", "description": ""}, {"name": "add_commute.add_units_coe_iff", "description": ""}, {"name": "inv_mul_cancel_comm_assoc", "description": ""}, {"name": "add_commute.add_units_neg_left_iff", "description": ""}, {"name": "commute.inv_mul_cancel", "description": ""}, {"name": "add_commute.add_units_coe", "description": ""}, {"name": "add_commute.neg_right", "description": ""}, {"name": "add_commute.nsmul_nsmul", "description": ""}, {"name": "add_commute.add_left", "description": "If both `a` and `b` commute with `c`, then their product commutes with `c`."}, {"name": "inv_mul_cancel_comm", "description": ""}, {"name": "add_commute.symm", "description": "If `a` commutes with `b`, then `b` commutes with `a`."}, {"name": "commute.one_right", "description": ""}, {"name": "neg_add_cancel_comm", "description": ""}, {"name": "commute.inv_inv", "description": ""}, {"name": "commute.inv_right_iff", "description": ""}, {"name": "add_commute.add_units_neg_right", "description": ""}, {"name": "commute.mul_inv_cancel", "description": ""}, {"name": "commute.refl", "description": "Any element commutes with itself."}, {"name": "commute.pow_self", "description": ""}, {"name": "commute.units_inv_left_iff", "description": ""}, {"name": "commute.inv_left_iff", "description": ""}, {"name": "add_commute.nsmul_nsmul_self", "description": ""}, {"name": "commute.eq", "description": "Equality behind `commute a b`; useful for rewriting."}, {"name": "add_commute.add_units_neg_left", "description": ""}, {"name": "commute.mul_right", "description": "If `a` commutes with both `b` and `c`, then it commutes with their product."}, {"name": "add_commute.add_units_of_coe", "description": ""}, {"name": "is_add_unit_add_self_iff", "description": ""}, {"name": "pow_succ'", "description": ""}, {"name": "add_commute.add_units_neg_right_iff", "description": ""}, {"name": "add_commute.left_comm", "description": ""}, {"name": "commute.pow_left", "description": ""}, {"name": "commute.inv_mul_cancel_assoc", "description": ""}, {"name": "add_commute.neg_add_cancel_assoc", "description": ""}, {"name": "add_commute.semiconj_by", "description": ""}, {"name": "commute.is_unit_mul_iff", "description": ""}, {"name": "commute.inv_right", "description": ""}, {"name": "commute.units_coe", "description": ""}, {"name": "commute.pow_pow", "description": ""}, {"name": "succ_nsmul'", "description": ""}, {"name": "add_commute.neg_left_iff", "description": ""}, {"name": "add_commute.eq", "description": "Equality behind `add_commute a b`; useful for rewriting."}, {"name": "mul_inv_cancel_comm", "description": ""}, {"name": "commute.units_inv_right", "description": ""}, {"name": "commute.mul_inv_cancel_assoc", "description": ""}, {"name": "add_commute.nsmul_self", "description": ""}, {"name": "commute.symm", "description": "If `a` commutes with `b`, then `b` commutes with `a`."}, {"name": "commute.inv_left", "description": ""}, {"name": "commute.units_inv_right_iff", "description": ""}, {"name": "add_commute.add_right", "description": "If `a` commutes with both `b` and `c`, then it commutes with their sum."}, {"name": "add_commute.add_neg_cancel", "description": ""}, {"name": "is_unit_mul_self_iff", "description": ""}, {"name": "commute.units_of_coe", "description": ""}, {"name": "add_commute.symm_iff", "description": ""}, {"name": "add_commute.neg_right_iff", "description": ""}, {"name": "commute.inv_inv_iff", "description": ""}, {"name": "add_commute.nsmul_left", "description": ""}, {"name": "commute.left_comm", "description": ""}, {"name": "add_neg_cancel_comm_assoc", "description": ""}, {"name": "add_commute.add_neg_cancel_assoc", "description": ""}, {"name": "add_neg_cancel_comm", "description": ""}, {"name": "commute.pow_pow_self", "description": ""}, {"name": "add_commute.zero_left", "description": ""}, {"name": "commute.symm_iff", "description": ""}, {"name": "commute.pow_right", "description": ""}, {"name": "add_commute.right_comm", "description": ""}, {"name": "add_commute.zero_right", "description": ""}, {"name": "list.nth_le_of_fn", "description": ""}, {"name": "list.of_fn_mul'", "description": "This breaks a list of `m*n` items into `n` groups each containing `m` elements."}, {"name": "list.last_of_fn_succ", "description": ""}, {"name": "list.forall_mem_of_fn_iff", "description": ""}, {"name": "list.of_fn_injective", "description": "Note we can only state this when the two functions are indexed by defeq `n`."}, {"name": "list.of_fn_rec_of_fn", "description": ""}, {"name": "list.equiv_sigma_tuple", "description": "Lists are equivalent to the sigma type of tuples of a given length."}, {"name": "list.map_of_fn", "description": ""}, {"name": "list.last_of_fn", "description": ""}, {"name": "list.length_of_fn", "description": "The length of a list converted from a function is the size of the domain."}, {"name": "list.nth_le_of_fn'", "description": ""}, {"name": "list.equiv_sigma_tuple_apply_snd", "description": ""}, {"name": "list.forall_iff_forall_tuple", "description": ""}, {"name": "list.array_eq_of_fn", "description": "Arrays converted to lists are the same as `of_fn` on the indexing function of the array."}, {"name": "list.of_fn_zero", "description": "`of_fn` on an empty domain is the empty list."}, {"name": "list.of_fn_succ'", "description": ""}, {"name": "list.of_fn_add", "description": "Note this matches the convention of `list.of_fn_succ'`, putting the `fin m` elements first."}, {"name": "list.length_of_fn_aux", "description": ""}, {"name": "list.of_fn_inj'", "description": "`fin.sigma_eq_iff_eq_comp_cast` may be useful to work with the RHS of this expression."}, {"name": "list.of_fn_succ", "description": ""}, {"name": "list.of_fn_congr", "description": ""}, {"name": "list.nth_of_fn_aux", "description": ""}, {"name": "list.of_fn_const", "description": ""}, {"name": "list.nth_of_fn", "description": "The `n`th element of a list"}, {"name": "list.of_fn_rec", "description": " A recursor for lists that expands a list into a function mapping to its elements.\n\nThis can be used with `induction l using list.of_fn_rec`."}, {"name": "list.of_fn_eq_nil_iff", "description": ""}, {"name": "list.exists_iff_exists_tuple", "description": ""}, {"name": "list.mem_of_fn", "description": ""}, {"name": "list.equiv_sigma_tuple_apply_fst", "description": ""}, {"name": "list.of_fn_inj", "description": "A special case of `list.of_fn_inj'` for when the two functions are indexed by defeq `n`."}, {"name": "list.of_fn_mul", "description": "This breaks a list of `m*n` items into `m` groups each containing `n` elements."}, {"name": "list.of_fn_nth_le", "description": ""}, {"name": "list.equiv_sigma_tuple_symm_apply", "description": ""}, {"name": "add_monoid_with_one.to_has_nat_cast", "description": ""}, {"name": "nat.cast_coe", "description": ""}, {"name": "nat.bin_cast_eq", "description": ""}, {"name": "add_monoid_with_one.unary", "description": "`add_monoid_with_one` implementation using unary recursion."}, {"name": "nat.cast_add_one", "description": ""}, {"name": "add_monoid_with_one", "description": "An `add_monoid_with_one` is an `add_monoid` with a `1`.\nIt also contains data for the unique homomorphism `\u2115 \u2192 R`."}, {"name": "add_monoid_with_one.nat_cast", "description": "An `add_monoid_with_one` is an `add_monoid` with a `1`.\nIt also contains data for the unique homomorphism `\u2115 \u2192 R`."}, {"name": "add_monoid_with_one.add", "description": "An `add_monoid_with_one` is an `add_monoid` with a `1`.\nIt also contains data for the unique homomorphism `\u2115 \u2192 R`."}, {"name": "add_monoid_with_one.add_assoc", "description": "An `add_monoid_with_one` is an `add_monoid` with a `1`.\nIt also contains data for the unique homomorphism `\u2115 \u2192 R`."}, {"name": "add_monoid_with_one.zero", "description": "An `add_monoid_with_one` is an `add_monoid` with a `1`.\nIt also contains data for the unique homomorphism `\u2115 \u2192 R`."}, {"name": "add_monoid_with_one.zero_add", "description": "An `add_monoid_with_one` is an `add_monoid` with a `1`.\nIt also contains data for the unique homomorphism `\u2115 \u2192 R`."}, {"name": "add_monoid_with_one.add_zero", "description": "An `add_monoid_with_one` is an `add_monoid` with a `1`.\nIt also contains data for the unique homomorphism `\u2115 \u2192 R`."}, {"name": "add_monoid_with_one.nsmul", "description": "An `add_monoid_with_one` is an `add_monoid` with a `1`.\nIt also contains data for the unique homomorphism `\u2115 \u2192 R`."}, {"name": "add_monoid_with_one.nsmul_zero'", "description": "An `add_monoid_with_one` is an `add_monoid` with a `1`.\nIt also contains data for the unique homomorphism `\u2115 \u2192 R`."}, {"name": "add_monoid_with_one.nsmul_succ'", "description": "An `add_monoid_with_one` is an `add_monoid` with a `1`.\nIt also contains data for the unique homomorphism `\u2115 \u2192 R`."}, {"name": "add_monoid_with_one.one", "description": "An `add_monoid_with_one` is an `add_monoid` with a `1`.\nIt also contains data for the unique homomorphism `\u2115 \u2192 R`."}, {"name": "add_monoid_with_one.nat_cast_zero", "description": "An `add_monoid_with_one` is an `add_monoid` with a `1`.\nIt also contains data for the unique homomorphism `\u2115 \u2192 R`."}, {"name": "add_monoid_with_one.nat_cast_succ", "description": "An `add_monoid_with_one` is an `add_monoid` with a `1`.\nIt also contains data for the unique homomorphism `\u2115 \u2192 R`."}, {"name": "nat.cast_bit0", "description": ""}, {"name": "nat.cast_zero", "description": ""}, {"name": "add_monoid_with_one.to_has_one", "description": ""}, {"name": "nat.cast_bit1", "description": ""}, {"name": "add_monoid_with_one.binary", "description": "`add_monoid_with_one` implementation using binary recursion."}, {"name": "nat.cast_succ", "description": ""}, {"name": "nat.cast_two", "description": ""}, {"name": "nat.cast_add", "description": ""}, {"name": "nat.cast_one", "description": ""}, {"name": "nat.cast", "description": "Canonical homomorphism from `\u2115` to a additive monoid `R` with a `1`."}, {"name": "add_comm_monoid_with_one.to_add_comm_monoid", "description": ""}, {"name": "add_monoid_with_one.to_add_monoid", "description": ""}, {"name": "library_note.coercion into rings", "description": "Coercions such as `nat.cast_coe` that go from a concrete structure such as\n`\u2115` to an arbitrary ring `R` should be set up as follows:\n```lean\n@[priority 900] instance : has_coe_t \u2115 R := \u27e8...\u27e9\n```\n\nIt needs to be `has_coe_t` instead of `has_coe` because otherwise type-class\ninference would loop when constructing the transitive coercion `\u2115 \u2192 \u2115 \u2192 \u2115 \u2192 ...`.\nThe reduced priority is necessary so that it doesn't conflict with instances\nsuch as `has_coe_t R (option R)`.\n\nFor this to work, we reduce the priority of the `coe_base` and `coe_trans`\ninstances because we want the instances for `has_coe_t` to be tried in the\nfollowing order:\n\n 1. `has_coe_t` instances declared in mathlib (such as `has_coe_t R (with_top R)`, etc.)\n 2. `coe_base`, which contains instances such as `has_coe (fin n) n`\n 3. `nat.cast_coe : has_coe_t \u2115 R` etc.\n 4. `coe_trans`\n\nIf `coe_trans` is tried first, then `nat.cast_coe` doesn't get a chance to apply."}, {"name": "nat.cast_ite", "description": ""}, {"name": "nat.unary_cast", "description": "The numeral `((0+1)+\u22ef)+1`."}, {"name": "add_comm_monoid_with_one", "description": "An `add_comm_monoid_with_one` is an `add_monoid_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_monoid_with_one.nat_cast", "description": "An `add_comm_monoid_with_one` is an `add_monoid_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_monoid_with_one.add", "description": "An `add_comm_monoid_with_one` is an `add_monoid_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_monoid_with_one.add_assoc", "description": "An `add_comm_monoid_with_one` is an `add_monoid_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_monoid_with_one.zero", "description": "An `add_comm_monoid_with_one` is an `add_monoid_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_monoid_with_one.zero_add", "description": "An `add_comm_monoid_with_one` is an `add_monoid_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_monoid_with_one.add_zero", "description": "An `add_comm_monoid_with_one` is an `add_monoid_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_monoid_with_one.nsmul", "description": "An `add_comm_monoid_with_one` is an `add_monoid_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_monoid_with_one.nsmul_zero'", "description": "An `add_comm_monoid_with_one` is an `add_monoid_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_monoid_with_one.nsmul_succ'", "description": "An `add_comm_monoid_with_one` is an `add_monoid_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_monoid_with_one.one", "description": "An `add_comm_monoid_with_one` is an `add_monoid_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_monoid_with_one.nat_cast_zero", "description": "An `add_comm_monoid_with_one` is an `add_monoid_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_monoid_with_one.nat_cast_succ", "description": "An `add_comm_monoid_with_one` is an `add_monoid_with_one` satisfying `a + b = b + a`."}, {"name": "add_comm_monoid_with_one.add_comm", "description": "An `add_comm_monoid_with_one` is an `add_monoid_with_one` satisfying `a + b = b + a`."}, {"name": "nat.bin_cast", "description": "Computationally friendlier cast than `nat.unary_cast`, using binary representation."}, {"name": "has_nat_cast", "description": "Type class for the canonical homomorphism `\u2115 \u2192 R`."}, {"name": "has_nat_cast.nat_cast", "description": "Type class for the canonical homomorphism `\u2115 \u2192 R`."}, {"name": "add_comm_monoid_with_one.to_add_monoid_with_one", "description": ""}, {"name": "list.join_filter_empty_eq_ff", "description": ""}, {"name": "list.drop_sum_join", "description": " In a join, dropping all the elements up to an index which is the sum of the lengths of the\nfirst `i` sublists, is the same as taking the join after dropping the first `i` sublists."}, {"name": "list.join_filter_ne_nil", "description": ""}, {"name": "list.drop_take_succ_join_eq_nth_le", "description": " In a join of sublists, taking the slice between the indices `A` and `B - 1` gives back the\noriginal sublist of index `i` if `A` is the sum of the lenghts of sublists of index `< i`, and\n`B` is the sum of the lengths of sublists of index `\u2264 i`."}, {"name": "list.drop_take_succ_eq_cons_nth_le", "description": " Taking only the first `i+1` elements in a list, and then dropping the first `i` ones, one is\nleft with a list of length `1` made of the `i`-th element of the original list."}, {"name": "list.join_append", "description": ""}, {"name": "list.join_nil", "description": ""}, {"name": "list.length_join", "description": ""}, {"name": "list.take_sum_join", "description": " In a join, taking the first elements up to an index which is the sum of the lengths of the\nfirst `i` sublists, is the same as taking the join of the first `i` sublists."}, {"name": "list.join_join", "description": ""}, {"name": "list.join_eq_nil", "description": ""}, {"name": "list.length_bind", "description": ""}, {"name": "list.eq_iff_join_eq", "description": " Two lists of sublists are equal iff their joins coincide, as well as the lengths of the\nsublists."}, {"name": "list.join_concat", "description": ""}, {"name": "list.nth_le_join", "description": " The `n`-th element in a join of sublists is the `j`-th element of the `i`th sublist,\nwhere `n` can be obtained in terms of `i` and `j` by adding the lengths of all the sublists\nof index `< i`, and adding `j`."}, {"name": "list.bind_eq_nil", "description": ""}, {"name": "list.sum_take_map_length_lt1", "description": "Auxiliary lemma to control elements in a join."}, {"name": "list.sum_take_map_length_lt2", "description": "Auxiliary lemma to control elements in a join."}, {"name": "functor.map_const_rev", "description": ""}, {"name": "functor", "description": ""}, {"name": "functor.map", "description": ""}, {"name": "functor.map_const", "description": ""}, {"name": "unsigned.has_mod", "description": ""}, {"name": "unsigned.has_le", "description": ""}, {"name": "unsigned.has_zero", "description": ""}, {"name": "unsigned.of_nat", "description": ""}, {"name": "unsigned.has_lt", "description": ""}, {"name": "unsigned.has_mul", "description": ""}, {"name": "unsigned.has_one", "description": ""}, {"name": "unsigned.has_div", "description": ""}, {"name": "unsigned.has_add", "description": ""}, {"name": "unsigned.has_sub", "description": ""}, {"name": "explicit_vars_of_iff", "description": "This function works as follows:\n1. Call `unravel_explicits_of_pi` to obtain the names, complements of de-Bruijn indexes and the\nremaining non-Pi expression;\n2. Check if the remaining non-Pi expression is an iff, already obtaining the respective left and\nright expressions if this is the case. Returns `none` otherwise;\n3. Filter the explicit variables that appear on the left *and* right side of the iff;\n4. If no variable satisfies the condition above, return `none`;\n5. Return a message mentioning the variables that do, otherwise."}, {"name": "find_unused_have_suffices_macros", "description": "Return a list of unused have and suffices terms in an expression"}, {"name": "linter.explicit_vars_of_iff", "description": "A linter for checking if variables appearing on both sides of an iff are explicit. Ideally, such\nvariables should be implicit instead."}, {"name": "has_unused_haves_suffices", "description": "Checks whether a declaration contains term mode have statements that have no effect on the resulting\nterm."}, {"name": "linter.unused_arguments", "description": "A linter object for checking for unused arguments. This is in the default linter set."}, {"name": "check_type", "description": "Checks whether the statement of a declaration is well-typed."}, {"name": "bad_params", "description": "The good parameters are the parameters that occur somewhere in the `rb_set` as a singleton or\n(recursively) with only other good parameters.\nAll other parameters in the `rb_set` are bad."}, {"name": "linter.dup_namespace", "description": "A linter for checking whether a declaration has a namespace twice consecutively in its name."}, {"name": "linter.unused_haves_suffices", "description": " A linter for checking that declarations don't have unused term mode have statements. We do not\ntag this as `@[linter]` so that it is not in the default linter set as it is slow and an uncommon\nproblem."}, {"name": "linter.syn_taut", "description": "A linter for checking that declarations aren't syntactic tautologies."}, {"name": "expr.has_zero_var", "description": "Check if an expression contains `var 0` by folding over the expression and matching the binder depth"}, {"name": "linter.check_univs", "description": "A linter for checking that there are no bad `max u v` universe levels."}, {"name": "linter.ge_or_gt", "description": "A linter for checking whether illegal constants (\u2265, >) appear in a declaration's type."}, {"name": "unprintable_interactive", "description": "Ensures that every interactive tactic has arguments for which `interactive.param_desc` succeeds.\nThis is used to generate the parser documentation that appears in hovers on interactive tactics."}, {"name": "expr.univ_params_grouped", "description": "`univ_params_grouped e` computes for each `level` `u` of `e` the parameters that occur in `u`,\nand returns the corresponding set of lists of parameters.\nIn pseudo-mathematical form, this returns `{ { p : parameter | p \u2208 u } | (u : level) \u2208 e }`\nWe use `list name` instead of `name_set`, since `name_set` does not have an order.\nIt will ignore `nm\u2080._proof_i` declarations."}, {"name": "check_unused_arguments", "description": " Check which arguments of a declaration are not used.\nPrints a list of natural numbers corresponding to which arguments are not used (e.g.\n  this outputs [1, 4] if the first and fourth arguments are unused).\nChecks both the type and the value of `d` for whether the argument is used\n(in rare cases an argument is used in the type but not in the value).\nWe return [] if the declaration was automatically generated.\nWe print arguments that are larger than the arity of the type of the declaration\n(without unfolding definitions)."}, {"name": "linter.doc_blame_thm", "description": "A linter for checking theorem doc strings. This is not in the default linter set."}, {"name": "linter.unprintable_interactive", "description": "A linter for checking that interactive tactics have parser documentation."}, {"name": "linter.check_type", "description": "A linter for missing checking whether statements of declarations are well-typed."}, {"name": "unravel_explicits_of_pi", "description": "Recursively consumes a Pi expression while accumulating names and the complement of de-Bruijn\nindexes of explicit variables, ultimately obtaining the remaining non-Pi expression as well."}, {"name": "linter.doc_blame", "description": "A linter for checking definition doc strings"}, {"name": "unused_have_of_decl", "description": "Return a list of unused have and suffices terms in a declaration"}, {"name": "syn_taut", "description": "Checks whether a lemma is a declaration of the form `\u2200 a b ... z, e\u2081 = e\u2082`\nwhere `e\u2081` and `e\u2082` are identical exprs.\nWe call declarations of this form syntactic tautologies.\nSuch lemmas are (mostly) useless and sometimes introduced unintentionally when proving basic facts\nwith rfl when elaboration results in a different term than the user intended."}, {"name": "library_note.nolint_ge", "description": "Currently, the linter forbids the use of `>` and `\u2265` in definitions and\nstatements, as they cause problems in rewrites.\nThey are still allowed in statements such as `bounded (\u2265)` or `\u2200 \u03b5 > 0` or `\u2a06 n \u2265 m`,\nand the linter allows that.\nIf you write a pattern where you bind two or more variables, like `\u2203 n m > 0`, the linter will\nflag this as illegal, but it is also allowed. In this case, add the line\n```lean\n@[nolint ge_or_gt] -- see Note [nolint_ge]\n```"}, {"name": "check_univs", "description": "Checks whether all universe levels `u` in the type of `d` are \"good\".\nThis means that `u` either occurs in a `level` of `d` by itself, or (recursively)\nwith only other good levels.\nWhen this fails, usually this means that there is a level `max u v`, where neither `u` nor `v`\noccur by themselves in a level. It is ok if *one* of `u` or `v` never occurs alone. For example,\n`(\u03b1 : Type u) (\u03b2 : Type (max u v))` is a occasionally useful method of saying that `\u03b2` lives in\na higher universe level than `\u03b1`."}, {"name": "linter.def_lemma", "description": " A linter for checking whether the correct declaration constructor (definition or theorem)\nhas been used."}, {"name": "tactic.interactive.rsimp", "description": ""}, {"name": "rsimp.rsimplify_goal", "description": ""}, {"name": "no_rsimp", "description": ""}, {"name": "mk_hinst_lemma_attr_from_simp_attr", "description": "Create a rsimp attribute named `attr_name`, the attribute declaration is named `attr_decl_name`.\n   The cached hinst_lemmas structure is built using the lemmas marked with simp attribute `simp_attr_name`,\n   but *not* marked with `ex_attr_name`.\n\n   We say `ex_attr_name` is the \"exception set\". It is useful for excluding lemmas in `simp_attr_name`\n   which are not good or redundant for ematching."}, {"name": "rsimp_attr", "description": ""}, {"name": "rsimp.explicit_size", "description": "Return the size of term by considering only explicit arguments."}, {"name": "rsimp.rsimplify_at", "description": ""}, {"name": "rsimp.to_repr_map", "description": ""}, {"name": "rsimp.collect_implied_eqs", "description": ""}, {"name": "rsimp.repr_map", "description": ""}, {"name": "rsimp.choose", "description": "Choose smallest element (with respect to explicit_size) in `e`s equivalence class."}, {"name": "rsimp.rsimplify", "description": ""}, {"name": "tactic.rsimp", "description": ""}, {"name": "tactic.rsimp_at", "description": ""}, {"name": "rsimp.is_value_like", "description": ""}, {"name": "tactic.id_tag.rsimp", "description": ""}, {"name": "rsimp.config", "description": ""}, {"name": "rsimp.config.attr_name", "description": ""}, {"name": "rsimp.config.max_rounds", "description": ""}, {"name": "rsimp.mk_repr_map", "description": ""}, {"name": "extensional_attribute", "description": "Tag lemmas of the form:\n\n```lean\n@[ext]\nlemma my_collection.ext (a b : my_collection)\n  (h : \u2200 x, a.lookup x = b.lookup y) :\n  a = b := ...\n```\n\nThe attribute indexes extensionality lemma using the type of the\nobjects (i.e. `my_collection`) which it gets from the statement of\nthe lemma.  In some cases, the same lemma can be used to state the\nextensionality of multiple types that are definitionally equivalent.\n\n```lean\nattribute [ext thunk, ext stream] funext\n```\n\nAlso, the following:\n\n```lean\n@[ext]\nlemma my_collection.ext (a b : my_collection)\n  (h : \u2200 x, a.lookup x = b.lookup y) :\n  a = b := ...\n```\n\nis equivalent to\n\n```lean\n@[ext my_collection]\nlemma my_collection.ext (a b : my_collection)\n  (h : \u2200 x, a.lookup x = b.lookup y) :\n  a = b := ...\n```\n\nThis allows us specify type synonyms along with the type\nthat is referred to in the lemma statement.\n\n```lean\n@[ext, ext my_type_synonym]\nlemma my_collection.ext (a b : my_collection)\n  (h : \u2200 x, a.lookup x = b.lookup y) :\n  a = b := ...\n```\n\nThe `ext` attribute can be applied to a structure to generate its extensionality lemmas:\n\n```lean\n@[ext]\nstructure foo (\u03b1 : Type*) :=\n(x y : \u2115)\n(z : {z // z < x})\n(k : \u03b1)\n(h : x < y)\n```\n\nwill generate:\n\n```lean\n@[ext] lemma foo.ext : \u2200 {\u03b1 : Type u_1} (x y : foo \u03b1),\nx.x = y.x \u2192 x.y = y.y \u2192 x.z == y.z \u2192 x.k = y.k \u2192 x = y\nlemma foo.ext_iff : \u2200 {\u03b1 : Type u_1} (x y : foo \u03b1),\nx = y \u2194 x.x = y.x \u2227 x.y = y.y \u2227 x.z == y.z \u2227 x.k = y.k\n```"}, {"name": "tactic_doc.tactic.ext1 / ext", "description": "* `ext1 id` selects and apply one extensionality lemma (with\n  attribute `ext`), using `id`, if provided, to name a\n  local constant introduced by the lemma. If `id` is omitted, the\n  local constant is named automatically, as per `intro`.\n\n* `ext` applies as many extensionality lemmas as possible;\n* `ext ids`, with `ids` a list of identifiers, finds extensionality lemmas\n  and applies them until it runs out of identifiers in `ids` to name\n  the local constants.\n* `ext` can also be given an `rcases` pattern in place of an identifier.\n  This will destruct the introduced local constant.\n- Placing a `?` after `ext`/`ext1` (e.g. `ext? i \u27e8a,b\u27e9 : 3`) will display\n  a sequence of tactic applications that can replace the call to `ext`/`ext1`.\n- `set_option trace.ext true` will trace every attempted lemma application,\n  along with the time it takes for the application to succeed or fail.\n  This is useful for debugging slow `ext` calls.\n\nWhen trying to prove:\n\n```lean\n\u03b1 \u03b2 : Type,\nf g : \u03b1 \u2192 set \u03b2\n\u22a2 f = g\n```\n\napplying `ext x y` yields:\n\n```lean\n\u03b1 \u03b2 : Type,\nf g : \u03b1 \u2192 set \u03b2,\nx : \u03b1,\ny : \u03b2\n\u22a2 y \u2208 f x \u2194 y \u2208 g x\n```\nby applying functional extensionality and set extensionality.\n\nWhen trying to prove:\n\n```lean\n\u03b1 \u03b2 \u03b3 : Type\nf g : \u03b1 \u00d7 \u03b2 \u2192 \u03b3\n\u22a2 f = g\n```\n\napplying `ext \u27e8a, b\u27e9` yields:\n\n```lean\n\u03b1 \u03b2 \u03b3 : Type,\nf g : \u03b1 \u00d7 \u03b2 \u2192 \u03b3,\na : \u03b1,\nb : \u03b2\n\u22a2 f (a, b) = g (a, b)\n```\n\nby applying functional extensionality and destructing the introduced pair.\n\nIn the previous example, applying `ext? \u27e8a,b\u27e9` will produce the trace message:\n\n```lean\nTry this: apply funext, rintro \u27e8a, b\u27e9\n```\n\nA maximum depth can be provided with `ext x y z : 3`."}, {"name": "tactic.try_intros", "description": "Try to introduce as many arguments as possible, using the given patterns to destruct the\n introduced variables. Returns the unused patterns."}, {"name": "tactic.ext_core", "description": "Apply multiple extensionality lemmas, destructing the arguments using the given patterns."}, {"name": "has_zero.ext_iff", "description": ""}, {"name": "library_note.user attribute parameters", "description": "For performance reasons, it is inadvisable to use `user_attribute.get_param`.\nThe parameter is stored as a reflected expression.  When calling `get_param`,\nthe stored parameter is evaluated using `eval_expr`, which first compiles the\nexpression into VM bytecode. The unevaluated expression is available using\n`user_attribute.get_param_untyped`.\n\nIn particular, `user_attribute.get_param` MUST NEVER BE USED in the\nimplementation of an attribute cache. This is because calling `eval_expr`\ndisables the attribute cache.\n\nThere are several possible workarounds:\n 1. Set a different attribute depending on the parameter.\n 2. Use your own evaluation function instead of `eval_expr`, such as e.g. `expr.to_nat`.\n 3. Write your own `has_reflect Param` instance (using a more efficient serialization format).\n   The `user_attribute` code unfortunately checks whether the expression has the correct type,\n   but you can use `` `(id %%e : Param) `` to pretend that your expression `e` has type `Param`."}, {"name": "punit.ext", "description": ""}, {"name": "tactic.ext", "description": "Apply multiple extensionality lemmas, destructing the arguments using the given patterns.\n `ext ps (some n)` applies at most `n` extensionality lemmas. Returns the unused patterns."}, {"name": "unit.ext", "description": ""}, {"name": "plift.ext", "description": ""}, {"name": "tactic.interactive.ext1", "description": "`ext1 id` selects and apply one extensionality lemma (with attribute\n`ext`), using `id`, if provided, to name a local constant\nintroduced by the lemma. If `id` is omitted, the local constant is\nnamed automatically, as per `intro`. Placing a `?` after `ext1`\n (e.g. `ext1? i \u27e8a,b\u27e9 : 3`) will display a sequence of tactic\napplications that can replace the call to `ext1`."}, {"name": "add_ext_lemma", "description": " Marks `lem` as an extensionality lemma corresponding to type constructor `constr`;\nif `persistent` is true then this is a global attribute, else local."}, {"name": "ulift.ext_iff", "description": ""}, {"name": "tactic_doc.attribute.ext", "description": "Tag lemmas of the form:\n\n```lean\n@[ext]\nlemma my_collection.ext (a b : my_collection)\n  (h : \u2200 x, a.lookup x = b.lookup y) :\n  a = b := ...\n```\n\nThe attribute indexes extensionality lemma using the type of the\nobjects (i.e. `my_collection`) which it gets from the statement of\nthe lemma.  In some cases, the same lemma can be used to state the\nextensionality of multiple types that are definitionally equivalent.\n\n```lean\nattribute [ext thunk, ext stream] funext\n```\n\nAlso, the following:\n\n```lean\n@[ext]\nlemma my_collection.ext (a b : my_collection)\n  (h : \u2200 x, a.lookup x = b.lookup y) :\n  a = b := ...\n```\n\nis equivalent to\n\n```lean\n@[ext my_collection]\nlemma my_collection.ext (a b : my_collection)\n  (h : \u2200 x, a.lookup x = b.lookup y) :\n  a = b := ...\n```\n\nThis allows us specify type synonyms along with the type\nthat is referred to in the lemma statement.\n\n```lean\n@[ext, ext my_type_synonym]\nlemma my_collection.ext (a b : my_collection)\n  (h : \u2200 x, a.lookup x = b.lookup y) :\n  a = b := ...\n```\n\nThe `ext` attribute can be applied to a structure to generate its extensionality lemmas:\n\n```lean\n@[ext]\nstructure foo (\u03b1 : Type*) :=\n(x y : \u2115)\n(z : {z // z < x})\n(k : \u03b1)\n(h : x < y)\n```\n\nwill generate:\n\n```lean\n@[ext] lemma foo.ext : \u2200 {\u03b1 : Type u_1} (x y : foo \u03b1),\nx.x = y.x \u2192 x.y = y.y \u2192 x.z == y.z \u2192 x.k = y.k \u2192 x = y\nlemma foo.ext_iff : \u2200 {\u03b1 : Type u_1} (x y : foo \u03b1),\nx = y \u2194 x.x = y.x \u2227 x.y = y.y \u2227 x.z == y.z \u2227 x.k = y.k\n```"}, {"name": "get_ext_subject", "description": ""}, {"name": "tactic.interactive.ext", "description": "- `ext` applies as many extensionality lemmas as possible;\n- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them\n  until it runs out of identifiers in `ids` to name the local constants.\n- `ext` can also be given an `rcases` pattern in place of an identifier.\n  This will destruct the introduced local constant.\n- Placing a `?` after `ext` (e.g. `ext? i \u27e8a,b\u27e9 : 3`) will display\n  a sequence of tactic applications that can replace the call to `ext`.\n- `set_option trace.ext true` will trace every attempted lemma application,\n  along with the time it takes for the application to succeed or fail.\n  This is useful for debugging slow `ext` calls.\n\nWhen trying to prove:\n\n```lean\n\u03b1 \u03b2 : Type,\nf g : \u03b1 \u2192 set \u03b2\n\u22a2 f = g\n```\n\napplying `ext x y` yields:\n\n```lean\n\u03b1 \u03b2 : Type,\nf g : \u03b1 \u2192 set \u03b2,\nx : \u03b1,\ny : \u03b2\n\u22a2 y \u2208 f x \u2194 y \u2208 f x\n```\n\nby applying functional extensionality and set extensionality.\n\nWhen trying to prove:\n\n```lean\n\u03b1 \u03b2 \u03b3 : Type\nf g : \u03b1 \u00d7 \u03b2 \u2192 \u03b3\n\u22a2 f = g\n```\n\napplying `ext \u27e8a, b\u27e9` yields:\n\n```lean\n\u03b1 \u03b2 \u03b3 : Type,\nf g : \u03b1 \u00d7 \u03b2 \u2192 \u03b3,\na : \u03b1,\nb : \u03b2\n\u22a2 f (a, b) = g (a, b)\n```\n\nby applying functional extensionality and destructing the introduced pair.\n\nIn the previous example, applying `ext? \u27e8a,b\u27e9` will produce the trace message:\n\n```lean\nTry this: apply funext, rintro \u27e8a, b\u27e9\n```\n\nA maximum depth can be provided with `ext x y z : 3`."}, {"name": "get_ext_lemma_names", "description": "Returns the extensionality lemmas in the environment, as a list of lemma names."}, {"name": "tactic.ext1", "description": "Apply one extensionality lemma, and destruct the arguments using the given patterns.\n Returns the unused patterns."}, {"name": "get_ext_lemmas", "description": "Returns the extensionality lemmas in the environment, as a map from structure\nname to lemma name."}, {"name": "library_note.partially-applied ext lemmas", "description": "When possible, `ext` lemmas are stated without a full set of arguments. As an example, for bundled\nhoms `f`, `g`, and `of`, `f.comp of = g.comp of \u2192 f = g` is a better `ext` lemma than\n`(\u2200 x, f (of x) = g (of x)) \u2192 f = g`, as the former allows a second type-specific extensionality\nlemmas to be applied to `f.comp of = g.comp of`.\nIf the domain of `of` is `\u2115` or `\u2124` and `of` is a `ring_hom`, such a lemma could then make the goal\n`f (of 1) = g (of 1)`.\n\nFor bundled morphisms, there is a `ext` lemma that always applies of the form\n`(\u2200 x, \u21d1f x = \u21d1g x) \u2192 f = g`. When adding type-specific `ext` lemmas like the one above, we want\nthese to be tried first. This happens automatically since the type-specific lemmas are inevitably\ndefined later."}, {"name": "saturate_fun", "description": ""}, {"name": "equiv_type_constr", "description": ""}, {"name": "derive_struct_ext_lemma", "description": "`derive_struct_ext_lemma n` generates two extensionality lemmas based on\nthe equality of all non-propositional projections.\n\nOn the following:\n\n```lean\n@[ext]\nstructure foo (\u03b1 : Type*) :=\n(x y : \u2115)\n(z : {z // z < x})\n(k : \u03b1)\n(h : x < y)\n```\n\n`derive_struct_lemma` generates:\n\n```lean\nlemma foo.ext : \u2200 {\u03b1 : Type u_1} (x y : foo \u03b1),\n  x.x = y.x \u2192 x.y = y.y \u2192 x.z == y.z \u2192 x.k = y.k \u2192 x = y\nlemma foo.ext_iff : \u2200 {\u03b1 : Type u_1} (x y : foo \u03b1),\n  x = y \u2194 x.x = y.x \u2227 x.y = y.y \u2227 x.z == y.z \u2227 x.k = y.k\n```"}, {"name": "tactic.ext1_core", "description": "Apply one extensionality lemma, and destruct the arguments using the patterns\n in the ext_state."}, {"name": "tactic.ext_state", "description": "Helper structure for `ext` and `ext1`. `lemmas` keeps track of extensionality lemmas\n applied so far."}, {"name": "tactic.ext_state.patts", "description": "Helper structure for `ext` and `ext1`. `lemmas` keeps track of extensionality lemmas\n applied so far."}, {"name": "tactic.ext_state.trace_msg", "description": "Helper structure for `ext` and `ext1`. `lemmas` keeps track of extensionality lemmas\n applied so far."}, {"name": "tactic.ext_state.fuel", "description": "Helper structure for `ext` and `ext1`. `lemmas` keeps track of extensionality lemmas\n applied so far."}, {"name": "has_zero.ext", "description": ""}, {"name": "ulift.ext", "description": ""}, {"name": "bitvec.to_fin_val", "description": ""}, {"name": "bitvec.of_fin", "description": "convert `fin` to `bitvec`"}, {"name": "bitvec.to_fin", "description": "convert `bitvec` to `fin`"}, {"name": "bitvec.of_fin_val", "description": ""}, {"name": "bitvec.to_nat_eq_foldr_reverse", "description": ""}, {"name": "bitvec.to_nat_lt", "description": ""}, {"name": "bitvec.of_nat_to_nat", "description": ""}, {"name": "bitvec.to_fin_le_to_fin_of_le", "description": ""}, {"name": "bitvec.preorder", "description": ""}, {"name": "bitvec.of_fin_le_of_fin_of_le", "description": ""}, {"name": "bitvec.add_lsb_div_two", "description": ""}, {"name": "bitvec.to_fin_of_fin", "description": ""}, {"name": "bitvec.of_fin_to_fin", "description": ""}, {"name": "bitvec.to_bool_add_lsb_mod_two", "description": ""}, {"name": "bitvec.add_lsb_eq_twice_add_one", "description": ""}, {"name": "tactic.rewrite_core", "description": "Rewrite the expression `e` using `h`.\n   The unification is performed using the transparency mode in `cfg`.\n   If `cfg.approx` is `tt`, then fallback to first-order unification, \n   and approximate context during unification.\n   `cfg.new_goals` specifies which unassigned metavariables become new goals, \n   and their order.\n   If `cfg.instances` is `tt`, then use type class resolution to instantiate \n   unassigned meta-variables.\n   The fields `cfg.auto_param` and `cfg.opt_param` are ignored by this tactic \n   (See `tactic.rewrite`).\n   It a triple `(new_e, prf, metas)` where `prf : e = new_e`, and `metas` \n   is a list of all introduced meta variables,\n   even the assigned ones.\n\n   TODO(Leo): improve documentation and explain symm/occs"}, {"name": "tactic.rewrite", "description": ""}, {"name": "tactic.rewrite_hyp", "description": ""}, {"name": "tactic.rewrite_cfg", "description": "Configuration options for the `rewrite` tactic."}, {"name": "tactic.rewrite_cfg.to_apply_cfg", "description": "Configuration options for the `rewrite` tactic."}, {"name": "tactic.rewrite_cfg.symm", "description": "Configuration options for the `rewrite` tactic."}, {"name": "tactic.rewrite_cfg.occs", "description": "Configuration options for the `rewrite` tactic."}, {"name": "tactic.rewrite_target", "description": ""}, {"name": "tactic.id_tag.rw", "description": ""}, {"name": "prefunctor.id", "description": "The identity morphism between quivers."}, {"name": "quiver.opposite", "description": "`V\u1d52\u1d56` reverses the direction of all arrows of `V`."}, {"name": "quiver.hom.unop", "description": "Given an arrow in `V\u1d52\u1d56`, we can take the \"unopposite\" back in `V`."}, {"name": "prefunctor.comp", "description": "Composition of morphisms between quivers."}, {"name": "quiver.empty", "description": "A type synonym for a quiver with no arrows."}, {"name": "quiver.empty_quiver", "description": ""}, {"name": "prefunctor", "description": "A morphism of quivers. As we will later have categorical functors extend this structure,\nwe call it a `prefunctor`."}, {"name": "prefunctor.obj", "description": "A morphism of quivers. As we will later have categorical functors extend this structure,\nwe call it a `prefunctor`."}, {"name": "prefunctor.map", "description": "A morphism of quivers. As we will later have categorical functors extend this structure,\nwe call it a `prefunctor`."}, {"name": "quiver.empty_arrow", "description": ""}, {"name": "prefunctor.id_map", "description": ""}, {"name": "quiver.hom.op", "description": "The opposite of an arrow in `V`."}, {"name": "prefunctor.comp_obj", "description": ""}, {"name": "quiver", "description": "A quiver `G` on a type `V` of vertices assigns to every pair `a b : V` of vertices\na type `a \u27f6 b` of arrows from `a` to `b`.\n\nFor graphs with no repeated edges, one can use `quiver.{0} V`, which ensures\n`a \u27f6 b : Prop`. For multigraphs, one can use `quiver.{v+1} V`, which ensures\n`a \u27f6 b : Type v`.\n\nBecause `category` will later extend this class, we call the field `hom`.\nExcept when constructing instances, you should rarely see this, and use the `\u27f6` notation instead."}, {"name": "quiver.hom", "description": "A quiver `G` on a type `V` of vertices assigns to every pair `a b : V` of vertices\na type `a \u27f6 b` of arrows from `a` to `b`.\n\nFor graphs with no repeated edges, one can use `quiver.{0} V`, which ensures\n`a \u27f6 b : Prop`. For multigraphs, one can use `quiver.{v+1} V`, which ensures\n`a \u27f6 b : Type v`.\n\nBecause `category` will later extend this class, we call the field `hom`.\nExcept when constructing instances, you should rarely see this, and use the `\u27f6` notation instead."}, {"name": "prefunctor.inhabited", "description": ""}, {"name": "prefunctor.id_obj", "description": ""}, {"name": "prefunctor.comp_map", "description": ""}, {"name": "columnround.diff_carried_columnround", "description": "Get the difference property of `columnround` given a position `n` for a random and crafted inputs."}, {"name": "columnround.cat_columnround_inv", "description": ""}, {"name": "columnround.id_columnround", "description": "The identity of a `columnround` function given a sequence is the sequence."}, {"name": "columnround.columnroundType", "description": "A columnround structure is four `quarterroundType`s."}, {"name": "columnround.columnroundType.columnround1", "description": "A columnround structure is four `quarterroundType`s."}, {"name": "columnround.columnroundType.columnround2", "description": "A columnround structure is four `quarterroundType`s."}, {"name": "columnround.columnroundType.columnround3", "description": "A columnround structure is four `quarterroundType`s."}, {"name": "columnround.columnroundType.columnround4", "description": "A columnround structure is four `quarterroundType`s."}, {"name": "columnround.columnround", "description": "Without ordering for inputs, a `columnround` is exactly the same as a `rowround`."}, {"name": "columnround.input", "description": "An input of this form should be invariant."}, {"name": "columnround.columnround_is_isomorphic", "description": "Two categories are isomrphic if `f \u2218 g = id_f` and `g \u2218 f = id_g`."}, {"name": "columnround.isomorphism_left", "description": "Isomorphism condition 1 : `f \u2218 g = id_f`"}, {"name": "columnround.carry_diff_columnround_for_any_row_and_value'", "description": "This is the same lemma as `carry_diff_columnround_for_any_row_and_value` but using the sorted salsa20 matrix\nfrom the `columnround'` function."}, {"name": "columnround.columnround_inv_is_inverse_of_rowround", "description": "It is easy to see that `cat_columnround\u207b\u00b9` after `cat_columnround` produces the original object."}, {"name": "columnround.columnround_difference_is_carried", "description": " Put together all the properties needed to prove that `columnround` carries the differfence for random and\ncrafted inputs."}, {"name": "columnround.columnround'", "description": " This columnround call will sort all the elements of the input and the output to match salsa20.\n-- It should be used in `doubleround`."}, {"name": "columnround.columnround_inv", "description": "Without ordering for inputs, a `columnround_inv` is exactly the same as a `rowround_inv`."}, {"name": "columnround.isomorphism_right", "description": "Isomorphism condition 2 : `g \u2218 f = id_g`"}, {"name": "columnround.columnround_is_left_invariant", "description": "`columnround` is left invariant."}, {"name": "columnround.columnround_inv'", "description": " This columnround inverse call will sort all the elements of the input and the output to match salsa20.\nIt should be used in `doubleround`."}, {"name": "columnround.cat_columnround", "description": ""}, {"name": "columnround.carry_diff_columnround_for_any_row_and_value", "description": "Proof that the difference is carried for any row and any value of the input matrices."}, {"name": "columnround.columnround_is_inv", "description": "For any `columnround` output, we can get back to original values using the defined inverse."}, {"name": "columnround.id_columnround_inv", "description": "The identity of a `columnround_inv` function given a sequence is the sequence."}, {"name": "tactic.mk_constructor_arg_names", "description": "Return a list of names of the form [p.i, ..., p.{i+n}] where n is\n  the number of fields of the constructor c"}, {"name": "tactic.mk_brec_on_rec_value", "description": "Construct brec_on \"recursive value\". F_name is the name of the brec_on \"dictionary\".\n  Type of the F_name hypothesis should be of the form (below (C ...)) where C is a constructor.\n  The result is the \"recursive value\" for the (i+1)-th recursive value of the constructor C."}, {"name": "tactic.constructor_num_fields", "description": ""}, {"name": "tactic.is_type_app_of", "description": "Return tt iff e's type is of the form `(I_name ...)`"}, {"name": "tactic.mk_constructors_arg_names", "description": "Given an inductive datatype I with k constructors and where constructor i has n_i fields,\n  return the list [[p.1, ..., p.n_1], [p.{n_1 + 1}, ..., p.{n_1 + n_2}], ..., [..., p.{n_1 + ... + n_k}]]"}, {"name": "tactic.mk_constructor_fresh_names", "description": ""}, {"name": "tactic.mk_constructors_fresh_names", "description": ""}, {"name": "category_theory.section_", "description": "The chosen section of a split epimorphism.\n(Note that `section` is a reserved keyword, so we append an underscore.)"}, {"name": "category_theory.is_iso_of_mono_of_split_epi", "description": "A split epi which is mono is an iso."}, {"name": "category_theory.is_iso.of_mono_retraction", "description": "Every split mono whose retraction is mono is an iso."}, {"name": "category_theory.retraction", "description": "The chosen retraction of a split monomorphism."}, {"name": "category_theory.split_epi.id", "description": ""}, {"name": "category_theory.op_mono_of_epi", "description": ""}, {"name": "category_theory.section_split_mono", "description": "The section of a split epimorphism is itself a split monomorphism."}, {"name": "category_theory.functor.map.split_mono", "description": "Split monomorphisms are also absolute monomorphisms."}, {"name": "category_theory.op_epi_of_mono", "description": ""}, {"name": "category_theory.split_mono.of_iso", "description": "Every iso is a split mono."}, {"name": "category_theory.split_epi_of_epi", "description": "In a category in which every epimorphism is split, every epimorphism splits. This is not an\n   instance because it would create an instance loop."}, {"name": "category_theory.split_mono", "description": "A split monomorphism is a morphism `f : X \u27f6 Y` admitting a retraction `retraction f : Y \u27f6 X`\nsuch that `f \u226b retraction f = \ud835\udfd9 X`.\n\nEvery split monomorphism is a monomorphism."}, {"name": "category_theory.split_mono.retraction", "description": "A split monomorphism is a morphism `f : X \u27f6 Y` admitting a retraction `retraction f : Y \u27f6 X`\nsuch that `f \u226b retraction f = \ud835\udfd9 X`.\n\nEvery split monomorphism is a monomorphism."}, {"name": "category_theory.split_mono.id'", "description": "A split monomorphism is a morphism `f : X \u27f6 Y` admitting a retraction `retraction f : Y \u27f6 X`\nsuch that `f \u226b retraction f = \ud835\udfd9 X`.\n\nEvery split monomorphism is a monomorphism."}, {"name": "category_theory.split_mono.id", "description": ""}, {"name": "category_theory.retraction_split_epi", "description": "The retraction of a split monomorphism is itself a split epimorphism."}, {"name": "category_theory.split_epi", "description": "A split epimorphism is a morphism `f : X \u27f6 Y` admitting a section `section_ f : Y \u27f6 X`\nsuch that `section_ f \u226b f = \ud835\udfd9 Y`.\n(Note that `section` is a reserved keyword, so we append an underscore.)\n\nEvery split epimorphism is an epimorphism."}, {"name": "category_theory.split_epi.section_", "description": "A split epimorphism is a morphism `f : X \u27f6 Y` admitting a section `section_ f : Y \u27f6 X`\nsuch that `section_ f \u226b f = \ud835\udfd9 Y`.\n(Note that `section` is a reserved keyword, so we append an underscore.)\n\nEvery split epimorphism is an epimorphism."}, {"name": "category_theory.split_epi.id'", "description": "A split epimorphism is a morphism `f : X \u27f6 Y` admitting a section `section_ f : Y \u27f6 X`\nsuch that `section_ f \u226b f = \ud835\udfd9 Y`.\n(Note that `section` is a reserved keyword, so we append an underscore.)\n\nEvery split epimorphism is an epimorphism."}, {"name": "category_theory.functor.map.split_epi", "description": "Split epimorphisms are also absolute epimorphisms."}, {"name": "category_theory.is_iso_of_epi_of_split_mono", "description": "A split mono which is epi is an iso."}, {"name": "category_theory.split_epi.of_iso", "description": "Every iso is a split epi."}, {"name": "category_theory.split_mono_of_mono", "description": "In a category in which every monomorphism is split, every monomorphism splits. This is not an\n   instance because it would create an instance loop."}, {"name": "category_theory.groupoid.of_trunc_split_mono", "description": "A category where every morphism has a `trunc` retraction is computably a groupoid."}, {"name": "category_theory.unop_epi_of_mono", "description": ""}, {"name": "category_theory.split_mono.mono", "description": "Every split mono is a mono."}, {"name": "category_theory.unop_mono_of_epi", "description": ""}, {"name": "category_theory.split_epi.id_assoc", "description": ""}, {"name": "category_theory.split_epi.epi", "description": "Every split epi is an epi."}, {"name": "category_theory.split_mono.id_assoc", "description": ""}, {"name": "category_theory.split_epi_category", "description": "A split epi category is a category in which every epimorphism is split."}, {"name": "category_theory.split_epi_category.split_epi_of_epi", "description": "A split epi category is a category in which every epimorphism is split."}, {"name": "category_theory.split_mono_category", "description": "A split mono category is a category in which every monomorphism is split."}, {"name": "category_theory.split_mono_category.split_mono_of_mono", "description": "A split mono category is a category in which every monomorphism is split."}, {"name": "category_theory.is_iso.of_epi_section", "description": "Every split epi whose section is epi is an iso."}, {"name": "bit1_eq_one", "description": ""}, {"name": "sub_half", "description": ""}, {"name": "ring_hom.injective_nat", "description": ""}, {"name": "zero_eq_bit0", "description": ""}, {"name": "neg_eq_self_iff", "description": ""}, {"name": "with_top.char_zero", "description": ""}, {"name": "bit1_injective", "description": ""}, {"name": "half_sub", "description": ""}, {"name": "bit0_eq_bit0", "description": ""}, {"name": "nat.cast_pow_eq_one", "description": ""}, {"name": "nat.cast_div_char_zero", "description": ""}, {"name": "nat.cast_embedding_apply", "description": ""}, {"name": "two_ne_zero'", "description": ""}, {"name": "nat.cast_embedding", "description": "`nat.cast` as an embedding into monoids of characteristic `0`."}, {"name": "bit1_eq_bit1", "description": ""}, {"name": "char_zero.infinite", "description": ""}, {"name": "half_add_self", "description": ""}, {"name": "ring_hom.char_zero_iff", "description": ""}, {"name": "ring_hom.char_zero", "description": ""}, {"name": "bit0_eq_zero", "description": ""}, {"name": "nat_mul_inj", "description": ""}, {"name": "add_halves'", "description": ""}, {"name": "add_self_eq_zero", "description": ""}, {"name": "nat_mul_inj'", "description": ""}, {"name": "bit0_injective", "description": ""}, {"name": "eq_neg_self_iff", "description": ""}, {"name": "one_eq_bit1", "description": ""}, {"name": "rbnode.balance1_node", "description": ""}, {"name": "mk_rbtree", "description": ""}, {"name": "rbnode.mem", "description": ""}, {"name": "rbtree.mem", "description": ""}, {"name": "rbtree.max", "description": ""}, {"name": "rbtree.empty", "description": ""}, {"name": "rbtree.has_repr", "description": ""}, {"name": "rbtree.depth", "description": ""}, {"name": "rbnode.max", "description": ""}, {"name": "rbtree.fold", "description": ""}, {"name": "rbtree.rev_fold", "description": ""}, {"name": "rbnode.balance2_node", "description": ""}, {"name": "rbnode.color.decidable_eq", "description": ""}, {"name": "rbnode", "description": ""}, {"name": "rbnode.leaf", "description": ""}, {"name": "rbnode.red_node", "description": ""}, {"name": "rbnode.black_node", "description": ""}, {"name": "rbtree.insert", "description": ""}, {"name": "rbtree.to_list", "description": ""}, {"name": "rbnode.find", "description": ""}, {"name": "rbtree.mem_exact", "description": ""}, {"name": "rbnode.well_formed", "description": ""}, {"name": "rbnode.well_formed.leaf_wff", "description": ""}, {"name": "rbnode.well_formed.insert_wff", "description": ""}, {"name": "rbnode.min", "description": ""}, {"name": "rbnode.rev_fold", "description": ""}, {"name": "rbnode.color", "description": ""}, {"name": "rbnode.color.red", "description": ""}, {"name": "rbnode.color.black", "description": ""}, {"name": "rbnode.balance2", "description": ""}, {"name": "rbtree.from_list", "description": ""}, {"name": "rbtree_of", "description": ""}, {"name": "rbnode.depth", "description": ""}, {"name": "rbnode.balance1", "description": ""}, {"name": "rbnode.mk_insert_result", "description": ""}, {"name": "rbtree.has_mem", "description": ""}, {"name": "rbnode.insert", "description": ""}, {"name": "rbnode.ins", "description": ""}, {"name": "rbnode.mem_exact", "description": ""}, {"name": "rbtree.find", "description": ""}, {"name": "rbnode.fold", "description": ""}, {"name": "rbtree.min", "description": ""}, {"name": "rbnode.get_color", "description": ""}, {"name": "rbtree.contains", "description": ""}, {"name": "rbtree", "description": ""}, {"name": "columnround_examples.output2", "description": "Output for example 2"}, {"name": "columnround_examples.input1", "description": "Input for example 1 -"}, {"name": "columnround_examples.input2", "description": ""}, {"name": "columnround_examples.output1", "description": "Output for example 1 -"}, {"name": "tactic.explode.core", "description": ""}, {"name": "tactic.explode.entries.inhabited", "description": ""}, {"name": "tactic.explode.args", "description": ""}, {"name": "tactic.explode.status", "description": ""}, {"name": "tactic.explode.status.reg", "description": ""}, {"name": "tactic.explode.status.intro", "description": ""}, {"name": "tactic.explode.status.lam", "description": ""}, {"name": "tactic.explode.status.sintro", "description": ""}, {"name": "tactic.explode.entries.size", "description": ""}, {"name": "tactic.explode.entries.has_to_tactic_format", "description": ""}, {"name": "tactic.explode.append_dep", "description": ""}, {"name": "tactic.explode.thm", "description": "A type to distinguish introduction or elimination rules represented as\nstrings from theorems referred to by their names."}, {"name": "tactic.explode.thm.expr", "description": "A type to distinguish introduction or elimination rules represented as\nstrings from theorems referred to by their names."}, {"name": "tactic.explode.thm.name", "description": "A type to distinguish introduction or elimination rules represented as\nstrings from theorems referred to by their names."}, {"name": "tactic.explode.thm.string", "description": "A type to distinguish introduction or elimination rules represented as\nstrings from theorems referred to by their names."}, {"name": "tactic.explode.may_be_proof", "description": ""}, {"name": "tactic.explode", "description": ""}, {"name": "tactic.explode.entries.head", "description": ""}, {"name": "tactic.explode.entries.find", "description": ""}, {"name": "tactic_doc.command.#explode / #explode_widget", "description": "`#explode decl_name` displays a proof term in a line-by-line format somewhat akin to a Fitch-style\nproof or the Metamath proof style.\n`#explode_widget decl_name` renders a widget that displays an `#explode` proof.\n\n`#explode iff_true_intro` produces\n\n```lean\niff_true_intro : \u2200 {a : Prop}, a \u2192 (a \u2194 true)\n0\u2502   \u2502 a         \u251c Prop\n1\u2502   \u2502 h         \u251c a\n2\u2502   \u2502 hl        \u2502 \u250c a\n3\u2502   \u2502 trivial   \u2502 \u2502 true\n4\u25022,3\u2502 \u2200I        \u2502 a \u2192 true\n5\u2502   \u2502 hr        \u2502 \u250c true\n6\u25025,1\u2502 \u2200I        \u2502 true \u2192 a\n7\u25024,6\u2502 iff.intro \u2502 a \u2194 true\n8\u25021,7\u2502 \u2200I        \u2502 a \u2192 (a \u2194 true)\n9\u25020,8\u2502 \u2200I        \u2502 \u2200 {a : Prop}, a \u2192 (a \u2194 true)\n```\n\nIn more detail:\n\nThe output of `#explode` is a Fitch-style proof in a four-column diagram modeled after Metamath\nproof displays like [this](http://us.metamath.org/mpeuni/ru.html). The headers of the columns are\n\"Step\", \"Hyp\", \"Ref\", \"Type\" (or \"Expression\" in the case of Metamath):\n* Step: An increasing sequence of numbers to number each step in the proof, used in the Hyp field.\n* Hyp: The direct children of the current step. Most theorems are implications like `A -> B -> C`,\n  and so on the step proving `C` the Hyp field will refer to the steps that prove `A` and `B`.\n* Ref: The name of the theorem being applied. This is well-defined in Metamath, but in Lean there\n  are some special steps that may have long names because the structure of proof terms doesn't\n  exactly match this mold.\n  * If the theorem is `foo (x y : Z) : A x -> B y -> C x y`:\n    * the Ref field will contain `foo`,\n    * `x` and `y` will be suppressed, because term construction is not interesting, and\n    * the Hyp field will reference steps proving `A x` and `B y`. This corresponds to a proof term\n      like `@foo x y pA pB` where `pA` and `pB` are subproofs.\n  * If the head of the proof term is a local constant or lambda, then in this case the Ref will\n    say `\u2200E` for forall-elimination. This happens when you have for example `h : A -> B` and\n    `ha : A` and prove `b` by `h ha`; we reinterpret this as if it said `\u2200E h ha` where `\u2200E` is\n    (n-ary) modus ponens.\n  * If the proof term is a lambda, we will also use `\u2200I` for forall-introduction, referencing the\n    body of the lambda. The indentation level will increase, and a bracket will surround the proof\n    of the body of the lambda, starting at a proof step labeled with the name of the lambda variable\n    and its type, and ending with the `\u2200I` step. Metamath doesn't have steps like this, but the\n    style is based on Fitch proofs in first-order logic.\n* Type: This contains the type of the proof term, the theorem being proven at the current step.\n  This proof layout differs from `#print` in using lots of intermediate step displays so that you\n  can follow along and don't have to see term construction steps because they are implicitly in the\n  intermediate step displays.\n\nAlso, it is common for a Lean theorem to begin with a sequence of lambdas introducing local\nconstants of the theorem. In order to minimize the indentation level, the `\u2200I` steps at the end of\nthe proof will be introduced in a group and the indentation will stay fixed. (The indentation\nbrackets are only needed in order to delimit the scope of assumptions, and these assumptions\nhave global scope anyway so detailed tracking is not necessary.)"}, {"name": "tactic.explode.pad_right", "description": ""}, {"name": "tactic.explode_expr", "description": ""}, {"name": "tactic.explode.thm.to_string", "description": "Turn a thm into a string."}, {"name": "tactic.explode.format_aux", "description": ""}, {"name": "tactic.explode.entry", "description": ""}, {"name": "tactic.explode.entry.expr", "description": ""}, {"name": "tactic.explode.entry.line", "description": ""}, {"name": "tactic.explode.entry.depth", "description": ""}, {"name": "tactic.explode.entry.status", "description": ""}, {"name": "tactic.explode.entry.thm", "description": ""}, {"name": "tactic.explode.entry.deps", "description": ""}, {"name": "tactic.explode.status.inhabited", "description": ""}, {"name": "tactic.explode.entries", "description": ""}, {"name": "tactic.explode.entries.s", "description": ""}, {"name": "tactic.explode.entries.l", "description": ""}, {"name": "tactic.explode.entries.add", "description": ""}, {"name": "tactic.explode_cmd", "description": "`#explode decl_name` displays a proof term in a line-by-line format somewhat akin to a Fitch-style\nproof or the Metamath proof style.\n`#explode_widget decl_name` renders a widget that displays an `#explode` proof.\n\n`#explode iff_true_intro` produces\n\n```lean\niff_true_intro : \u2200 {a : Prop}, a \u2192 (a \u2194 true)\n0\u2502   \u2502 a         \u251c Prop\n1\u2502   \u2502 h         \u251c a\n2\u2502   \u2502 hl        \u2502 \u250c a\n3\u2502   \u2502 trivial   \u2502 \u2502 true\n4\u25022,3\u2502 \u2200I        \u2502 a \u2192 true\n5\u2502   \u2502 hr        \u2502 \u250c true\n6\u25025,1\u2502 \u2200I        \u2502 true \u2192 a\n7\u25024,6\u2502 iff.intro \u2502 a \u2194 true\n8\u25021,7\u2502 \u2200I        \u2502 a \u2192 (a \u2194 true)\n9\u25020,8\u2502 \u2200I        \u2502 \u2200 {a : Prop}, a \u2192 (a \u2194 true)\n```\n\nIn more detail:\n\nThe output of `#explode` is a Fitch-style proof in a four-column diagram modeled after Metamath\nproof displays like [this](http://us.metamath.org/mpeuni/ru.html). The headers of the columns are\n\"Step\", \"Hyp\", \"Ref\", \"Type\" (or \"Expression\" in the case of Metamath):\n* Step: An increasing sequence of numbers to number each step in the proof, used in the Hyp field.\n* Hyp: The direct children of the current step. Most theorems are implications like `A -> B -> C`,\n  and so on the step proving `C` the Hyp field will refer to the steps that prove `A` and `B`.\n* Ref: The name of the theorem being applied. This is well-defined in Metamath, but in Lean there\n  are some special steps that may have long names because the structure of proof terms doesn't\n  exactly match this mold.\n  * If the theorem is `foo (x y : Z) : A x -> B y -> C x y`:\n    * the Ref field will contain `foo`,\n    * `x` and `y` will be suppressed, because term construction is not interesting, and\n    * the Hyp field will reference steps proving `A x` and `B y`. This corresponds to a proof term\n      like `@foo x y pA pB` where `pA` and `pB` are subproofs.\n  * If the head of the proof term is a local constant or lambda, then in this case the Ref will\n    say `\u2200E` for forall-elimination. This happens when you have for example `h : A -> B` and\n    `ha : A` and prove `b` by `h ha`; we reinterpret this as if it said `\u2200E h ha` where `\u2200E` is\n    (n-ary) modus ponens.\n  * If the proof term is a lambda, we will also use `\u2200I` for forall-introduction, referencing the\n    body of the lambda. The indentation level will increase, and a bracket will surround the proof\n    of the body of the lambda, starting at a proof step labeled with the name of the lambda variable\n    and its type, and ending with the `\u2200I` step. Metamath doesn't have steps like this, but the\n    style is based on Fitch proofs in first-order logic.\n* Type: This contains the type of the proof term, the theorem being proven at the current step.\n  This proof layout differs from `#print` in using lots of intermediate step displays so that you\n  can follow along and don't have to see term construction steps because they are implicitly in the\n  intermediate step displays.\n\nAlso, it is common for a Lean theorem to begin with a sequence of lambdas introducing local\nconstants of the theorem. In order to minimize the indentation level, the `\u2200I` steps at the end of\nthe proof will be introduced in a group and the indentation will stay fixed. (The indentation\nbrackets are only needed in order to delimit the scope of assumptions, and these assumptions\nhave global scope anyway so detailed tracking is not necessary.)"}, {"name": "auto.do_subst", "description": "carries out a subst if there is one, fails otherwise"}, {"name": "tactic.interactive.finish", "description": "`finish [h1,...,hn] using [e1,...,en]` negates the goal, normalizes hypotheses\n(by splitting conjunctions, eliminating existentials, pushing negations inwards,\nand calling `simp` with the supplied lemmas `h1,...,hn`), and then tries `contradiction`.\n\nIf this fails, it will create an SMT state and repeatedly use `ematch`\n(using `ematch` lemmas in the environment, universally quantified assumptions,\nand the supplied lemmas `e1,...,en`) and congruence closure.\n\n`finish` is complete for propositional logic.\n\nEither of the supplied simp lemmas or the supplied ematch lemmas are optional.\n\n`finish` will fail if it does not close the goal."}, {"name": "auto.do_substs", "description": ""}, {"name": "auto.not_implies_eq", "description": ""}, {"name": "auto.not_not_eq", "description": ""}, {"name": "auto.eelims", "description": "eliminate all existential quantifiers, fails if there aren't any"}, {"name": "auto.add_conjuncts", "description": "Assumes `pr` is a proof of `t`. Adds the consequences of `t` to the context\nand returns `tt` if anything nontrivial has been added."}, {"name": "auto.auto_config.inhabited", "description": ""}, {"name": "auto.whnf_reducible", "description": ""}, {"name": "auto.case_some_hyp", "description": ""}, {"name": "auto.not_forall_eq", "description": ""}, {"name": "auto.preprocess_goal", "description": ""}, {"name": "auto.common_normalize_lemma_names", "description": ""}, {"name": "auto.mk_hinst_lemmas", "description": "The terminal tactic, used to try to finish off goals:\n- Call the contradiction tactic.\n- Open an SMT state, and use ematching and congruence closure, with all the universal\n  statements in the context.\n\nTODO(Jeremy): allow users to specify attribute for ematching lemmas?"}, {"name": "tactic.interactive.clarify", "description": "`clarify [h1,...,hn] using [e1,...,en]` negates the goal, normalizes hypotheses\n(by splitting conjunctions, eliminating existentials, pushing negations inwards,\nand calling `simp` with the supplied lemmas `h1,...,hn`), and then tries `contradiction`.\n\nIf this fails, it will create an SMT state and repeatedly use `ematch`\n(using `ematch` lemmas in the environment, universally quantified assumptions,\nand the supplied lemmas `e1,...,en`) and congruence closure.\n\n`clarify` is complete for propositional logic.\n\nEither of the supplied simp lemmas or the supplied ematch lemmas are optional.\n\n`clarify` will fail if it produces more than one goal."}, {"name": "auto.case_option", "description": ""}, {"name": "auto.case_option.force", "description": ""}, {"name": "auto.case_option.at_most_one", "description": ""}, {"name": "auto.case_option.accept", "description": ""}, {"name": "auto.not_exists_eq", "description": ""}, {"name": "tactic.interactive.safe", "description": "`safe [h1,...,hn] using [e1,...,en]` negates the goal, normalizes hypotheses\n(by splitting conjunctions, eliminating existentials, pushing negations inwards,\nand calling `simp` with the supplied lemmas `h1,...,hn`), and then tries `contradiction`.\n\nIf this fails, it will create an SMT state and repeatedly use `ematch`\n(using `ematch` lemmas in the environment, universally quantified assumptions,\nand the supplied lemmas `e1,...,en`) and congruence closure.\n\n`safe` is complete for propositional logic.\n\nEither of the supplied simp lemmas or the supplied ematch lemmas are optional.\n\n`safe` ignores the number of goals it produces, and should never fail."}, {"name": "auto.normalize_negations", "description": ""}, {"name": "auto.normalize_hyps", "description": ""}, {"name": "auto.not_and_eq", "description": ""}, {"name": "auto.add_simps", "description": ""}, {"name": "auto.done", "description": "`done` first attempts to close the goal using `contradiction`. If this fails, it creates an\nSMT state and will repeatedly use `ematch` (using `ematch` lemmas in the environment,\nuniversally quantified assumptions, and the supplied lemmas `ps`) and congruence closure."}, {"name": "auto.classical.implies_iff_not_or", "description": ""}, {"name": "auto.split_hyp", "description": "return `tt` if any progress is made"}, {"name": "auto.classical_normalize_lemma_names", "description": ""}, {"name": "auto.normalize_hyp", "description": ""}, {"name": "auto.split_hyps", "description": "fail if no progress is made"}, {"name": "tactic.interactive.revert_all", "description": ""}, {"name": "auto.eelim", "description": "eliminate an existential quantifier if there is one"}, {"name": "auto.case_option.inhabited", "description": ""}, {"name": "auto.preprocess_hyps", "description": "Eagerly apply all the preprocessing rules"}, {"name": "auto.auto_config", "description": "Configuration information for the auto tactics.\n* `(use_simp := tt)`: call the simplifier\n* `(max_ematch_rounds := 20)`: for the \"done\" tactic"}, {"name": "auto.auto_config.use_simp", "description": "Configuration information for the auto tactics.\n* `(use_simp := tt)`: call the simplifier\n* `(max_ematch_rounds := 20)`: for the \"done\" tactic"}, {"name": "auto.auto_config.max_ematch_rounds", "description": "Configuration information for the auto tactics.\n* `(use_simp := tt)`: call the simplifier\n* `(max_ematch_rounds := 20)`: for the \"done\" tactic"}, {"name": "auto.case_option.decidable_eq", "description": ""}, {"name": "auto.auto_config.decidable_eq", "description": ""}, {"name": "auto.safe_core", "description": "`safe_core s ps cfg opt` negates the goal, normalizes hypotheses\n(by splitting conjunctions, eliminating existentials, pushing negations inwards,\nand calling `simp` with the supplied lemmas `s`), and then tries `contradiction`.\n\nIf this fails, it will create an SMT state and repeatedly use `ematch`\n(using `ematch` lemmas in the environment, universally quantified assumptions,\nand the supplied lemmas `ps`) and congruence closure.\n\n`safe_core` is complete for propositional logic. Depending on the form of `opt`\nit will:\n\n- (if `opt` is `case_option.force`) fail if it does not close the goal,\n- (if `opt` is `case_option.at_most_one`) fail if it produces more than one goal, and\n- (if `opt` is `case_option.accept`) ignore the number of goals it produces."}, {"name": "auto.clarify", "description": "`clarify` is `safe_core`, but with the `(opt : case_option)`\nparameter fixed at `case_option.at_most_one`."}, {"name": "auto.finish", "description": "`finish` is `safe_core`, but with the `(opt : case_option)`\nparameter fixed at `case_option.force`."}, {"name": "tactic_doc.tactic.finish / clarify / safe", "description": "These tactics do straightforward things: they call the simplifier, split conjunctive assumptions,\neliminate existential quantifiers on the left, and look for contradictions. They rely on ematching\nand congruence closure to try to finish off a goal at the end.\n\nThe procedures *do* split on disjunctions and recreate the smt state for each terminal call, so\nthey are only meant to be used on small, straightforward problems.\n\n* `finish`:  solves the goal or fails\n* `clarify`: makes as much progress as possible while not leaving more than one goal\n* `safe`:    splits freely, finishes off whatever subgoals it can, and leaves the rest\n\nAll accept an optional list of simplifier rules, typically definitions that should be expanded.\n(The equations and identities should not refer to the local context.) All also accept an optional\nlist of `ematch` lemmas, which must be preceded by `using`."}, {"name": "auto.split_hyps_aux", "description": "return `tt` if any progress is made"}, {"name": "auto.not_or_eq", "description": ""}, {"name": "auto.safe", "description": "`safe` is `safe_core`, but with the `(opt : case_option)`\nparameter fixed at `case_option.accept`."}, {"name": "auto.by_contradiction_trick", "description": ""}, {"name": "auto.case_hyp", "description": ""}, {"name": "auto.case_some_hyp_aux", "description": ""}, {"name": "nat.succ_le_succ_sqrt'", "description": ""}, {"name": "nat.sqrt_eq", "description": ""}, {"name": "nat.sqrt_le_self", "description": ""}, {"name": "nat.sqrt_le_sqrt", "description": ""}, {"name": "nat.sqrt_lt_self", "description": ""}, {"name": "nat.sqrt_le'", "description": ""}, {"name": "nat.lt_succ_sqrt'", "description": ""}, {"name": "nat.exists_mul_self", "description": ""}, {"name": "nat.sqrt_one", "description": ""}, {"name": "nat.eq_sqrt'", "description": ""}, {"name": "nat.sqrt_mul_sqrt_lt_succ'", "description": ""}, {"name": "nat.sqrt_aux_dec", "description": ""}, {"name": "nat.sqrt_mul_sqrt_lt_succ", "description": ""}, {"name": "nat.lt_succ_sqrt", "description": ""}, {"name": "nat.sqrt_pos", "description": ""}, {"name": "nat.not_exists_sq'", "description": ""}, {"name": "nat.sqrt_le_add", "description": ""}, {"name": "nat.sqrt_aux_1", "description": ""}, {"name": "nat.sqrt_aux", "description": " Auxiliary function for `nat.sqrt`. See e.g.\n<https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Binary_numeral_system_(base_2)>"}, {"name": "nat.sqrt_aux_0", "description": ""}, {"name": "nat.sqrt_succ_le_succ_sqrt", "description": ""}, {"name": "nat.sqrt", "description": "`sqrt n` is the square root of a natural number `n`. If `n` is not a\n perfect square, it returns the largest `k:\u2115` such that `k*k \u2264 n`."}, {"name": "nat.eq_sqrt", "description": ""}, {"name": "nat.sqrt_add_eq'", "description": ""}, {"name": "nat.sqrt_lt'", "description": ""}, {"name": "nat.succ_le_succ_sqrt", "description": ""}, {"name": "nat.le_sqrt", "description": ""}, {"name": "nat.exists_mul_self'", "description": ""}, {"name": "nat.sqrt_aux_2", "description": ""}, {"name": "nat.sqrt_lt", "description": ""}, {"name": "nat.sqrt_zero", "description": ""}, {"name": "nat.sqrt_eq_zero", "description": ""}, {"name": "nat.le_three_of_sqrt_eq_one", "description": ""}, {"name": "nat.sqrt_add_eq", "description": ""}, {"name": "nat.sqrt_eq'", "description": ""}, {"name": "nat.not_exists_sq", "description": "There are no perfect squares strictly between m\u00b2 and (m+1)\u00b2"}, {"name": "nat.sqrt_le", "description": ""}, {"name": "nat.le_sqrt'", "description": ""}, {"name": "print_warning", "description": "Formats a linter warning as `#check` command with comment."}, {"name": "tactic_doc.hole_command.Lint", "description": "Invoking the hole command `lint` (\"Find common mistakes in current file\") will print text that\nindicates mistakes made in the file above the command. It is equivalent to copying and pasting the\noutput of `#lint`. On large files, it may take some time before the output appears."}, {"name": "print_workflow_command", "description": "Prints a workflow command to emit an error understood by github in an actions workflow.\nThis enables CI to tag the parts of the file where linting failed with annotations, and makes it\neasier for mathlib contributors to see what needs fixing.\nSee https://docs.github.com/en/actions/learn-github-actions/workflow-commands-for-github-actions#setting-an-error-message"}, {"name": "lint_cmd", "description": " The command `#lint` at the bottom of a file will warn you about some common mistakes\nin that file. Usage: `#lint`, `#lint linter_1 linter_2`, `#lint only linter_1 linter_2`.\n`#lint-` will suppress the output if all checks pass.\n`#lint+` will enable verbose output.\n\nUse the command `#list_linters` to see all available linters."}, {"name": "sort_results", "description": "Sorts a map with declaration keys as names by line number."}, {"name": "lint", "description": "Return the message printed by `#lint` and a `name_set` containing all declarations that fail."}, {"name": "lint_project", "description": " Returns the linter message by running the linter on all declarations in project `proj_name` in\nfolder `proj_folder`. It also returns a `name_set` containing all declarations that fail.\n\nTo add a linter command for your own project, write\n```lean\nopen lean.parser lean tactic interactive\n@[user_command] meta def lint_my_project_cmd (_ : parse $ tk \"#lint_my_project\") : parser unit :=\ndo str \u2190 get_project_dir n k, lint_cmd_aux (@lint_project str \"my project\")\n```\nHere `n` is the name of any declaration in the project (like `` `lint_my_project_cmd`` and `k` is\nthe number of characters in the filename of `n` *after* the `src/` directory\n(so e.g. the number of characters in `tactic/lint/frontend.lean`).\nWarning: the linter will not work in the file where `n` is declared."}, {"name": "lint_all_cmd", "description": " The command `#lint_all` checks all imported files for certain mistakes.\nUsage: `#lint_all`, `#lint_all linter_1 linter_2`, `#lint_all only linter_1 linter_2`.\n`#lint_all-` will suppress the output if all checks pass.\n`lint_all+` will enable verbose output.\n\nUse the command `#list_linters` to see all available linters."}, {"name": "format_linter_results", "description": "Formats the linter results as Lean code with comments and `#check` commands."}, {"name": "lint_verbosity", "description": "Verbosity for the linter output.\n* `low`: only print failing checks, print nothing on success.\n* `medium`: only print failing checks, print confirmation on success.\n* `high`: print output of every check."}, {"name": "lint_verbosity.low", "description": "Verbosity for the linter output.\n* `low`: only print failing checks, print nothing on success.\n* `medium`: only print failing checks, print confirmation on success.\n* `high`: print output of every check."}, {"name": "lint_verbosity.medium", "description": "Verbosity for the linter output.\n* `low`: only print failing checks, print nothing on success.\n* `medium`: only print failing checks, print confirmation on success.\n* `high`: print output of every check."}, {"name": "lint_verbosity.high", "description": "Verbosity for the linter output.\n* `low`: only print failing checks, print nothing on success.\n* `medium`: only print failing checks, print confirmation on success.\n* `high`: print output of every check."}, {"name": "lint_cmd_aux", "description": "The common denominator of `lint_cmd`, `lint_mathlib_cmd`, `lint_all_cmd`"}, {"name": "lint_project_decls", "description": "Returns the declarations in the folder `proj_folder`."}, {"name": "lint_verbosity.inhabited", "description": ""}, {"name": "lint_hole_cmd", "description": "Invoking the hole command `lint` (\"Find common mistakes in current file\") will print text that\nindicates mistakes made in the file above the command. It is equivalent to copying and pasting the\noutput of `#lint`. On large files, it may take some time before the output appears."}, {"name": "escape_workflow_command", "description": "Escape characters that may not be used in a workflow commands, following\nhttps://github.com/actions/toolkit/blob/7257597d731b34d14090db516d9ea53439300e98/packages/core/src/command.ts#L92-L105"}, {"name": "parse_verbosity", "description": "Parses a \"-\" or \"+\", returning `lint_verbosity.low` or `lint_verbosity.high` respectively,\nor returns `none`."}, {"name": "lint_verbosity.decidable_eq", "description": ""}, {"name": "list_linters", "description": "The command `#list_linters` prints a list of all available linters."}, {"name": "lint_aux", "description": " The common denominator of `#lint[|mathlib|all]`.\nThe different commands have different configurations for `l`,\n`group_by_filename` and `where_desc`.\nIf `slow` is false, doesn't do the checks that take a lot of time.\nIf `verbose` is false, it will suppress messages from passing checks.\nBy setting `checks` you can customize which checks are performed.\n\nReturns a `name_set` containing the names of all declarations that fail any check in `check`,\nand a `format` object describing the failures."}, {"name": "grouped_by_filename", "description": "Formats a map of linter warnings grouped by filename with `-- filename` comments.\nThe first `drop_fn_chars` characters are stripped from the filename."}, {"name": "get_checks", "description": " `get_checks slow extra use_only` produces a list of linters.\n`extras` is a list of names that should resolve to declarations with type `linter`.\nIf `use_only` is true, it only uses the linters in `extra`.\nOtherwise, it uses all linters in the environment tagged with `@[linter]`.\nIf `slow` is false, it only uses the fast default tests."}, {"name": "parse_lint_additions", "description": " Parses an optional `only`, followed by a sequence of zero or more identifiers.\nPrepends `linter.` to each of these identifiers."}, {"name": "lint_all", "description": " Return the message printed by `#lint_all` and a `name_set` containing all declarations\nthat fail."}, {"name": "lint_mathlib_cmd", "description": " The command `#lint_mathlib` checks all of mathlib for certain mistakes.\nUsage: `#lint_mathlib`, `#lint_mathlib linter_1 linter_2`, `#lint_mathlib only linter_1 linter_2`.\n`#lint_mathlib-` will suppress the output if all checks pass.\n`lint_mathlib+` will enable verbose output.\n\nUse the command `#list_linters` to see all available linters."}, {"name": "print_warnings", "description": "Formats a map of linter warnings using `print_warning`, sorted by line number."}, {"name": "lint_core", "description": "`lint_core all_decls non_auto_decls checks` applies the linters `checks` to the list of\ndeclarations.\nIf `auto_decls` is false for a linter (default) the linter is applied to `non_auto_decls`.\nIf `auto_decls` is true, then it is applied to `all_decls`.\nThe resulting list has one element for each linter, containing the linter as\nwell as a map from declaration name to warning."}, {"name": "old_conv.interactive.trace_state", "description": ""}, {"name": "conv.interactive.conv", "description": " The `conv` tactic provides a `conv` within a `conv`. It allows the user to return to a\nprevious state of the outer conv block to continue editing an expression without having to\nstart a new conv block."}, {"name": "old_conv.execute", "description": ""}, {"name": "old_conv.istep", "description": ""}, {"name": "conv.interactive.guard_target", "description": "`guard_target t` fails if the target of the conv goal is not `t`.\nWe use this tactic for writing tests."}, {"name": "old_conv.interactive.find", "description": ""}, {"name": "old_conv.interactive.whnf", "description": ""}, {"name": "old_conv.save_info", "description": ""}, {"name": "tactic.interactive.find", "description": ""}, {"name": "conv.replace_lhs", "description": ""}, {"name": "tactic.interactive.conv_rhs", "description": ""}, {"name": "conv.interactive.erw", "description": ""}, {"name": "old_conv.step", "description": ""}, {"name": "old_conv.interactive.dsimp", "description": ""}, {"name": "tactic.interactive.conv_lhs", "description": ""}, {"name": "old_conv.interactive.change", "description": ""}, {"name": "conv.discharge_eq_lhs", "description": ""}, {"name": "old_conv.interactive.itactic", "description": ""}, {"name": "tactic.interactive.old_conv", "description": ""}, {"name": "unique.inhabited", "description": ""}, {"name": "inhabited_fin_one_add", "description": ""}, {"name": "unique.forall_iff", "description": ""}, {"name": "unique", "description": " `unique \u03b1` expresses that `\u03b1` is a type with a unique term `default`.\n\nThis is implemented as a type, rather than a `Prop`-valued predicate,\nfor good definitional properties of the default term."}, {"name": "unique.to_inhabited", "description": " `unique \u03b1` expresses that `\u03b1` is a type with a unique term `default`.\n\nThis is implemented as a type, rather than a `Prop`-valued predicate,\nfor good definitional properties of the default term."}, {"name": "unique.uniq", "description": " `unique \u03b1` expresses that `\u03b1` is a type with a unique term `default`.\n\nThis is implemented as a type, rather than a `Prop`-valued predicate,\nfor good definitional properties of the default term."}, {"name": "fin.default_eq_zero", "description": ""}, {"name": "eq_const_of_unique", "description": ""}, {"name": "pi.unique_of_is_empty", "description": "There is a unique function on an empty domain."}, {"name": "unique.subsingleton", "description": ""}, {"name": "pi.default_def", "description": ""}, {"name": "true.unique", "description": ""}, {"name": "unique.default_eq", "description": ""}, {"name": "unique.eq_default", "description": ""}, {"name": "pi.default_apply", "description": ""}, {"name": "punit.unique", "description": ""}, {"name": "fin.eq_zero", "description": ""}, {"name": "unique.subtype_eq'", "description": ""}, {"name": "unique_iff_subsingleton_and_nonempty", "description": ""}, {"name": "option.unique", "description": ""}, {"name": "pi.unique", "description": ""}, {"name": "function.injective.subsingleton", "description": " If the codomain of an injective function is a subsingleton, then the domain\nis a subsingleton as well."}, {"name": "option.subsingleton_iff_is_empty", "description": "`option \u03b1` is a `subsingleton` if and only if `\u03b1` is empty."}, {"name": "unique_of_subsingleton", "description": " Given an explicit `a : \u03b1` with `[subsingleton \u03b1]`, we can construct\na `[unique \u03b1]` instance. This is a def because the typeclass search cannot\narbitrarily invent the `a : \u03b1` term. Nevertheless, these instances are all\nequivalent by `unique.subsingleton.unique`.\n\nSee note [reducible non-instances]."}, {"name": "function.surjective.subsingleton", "description": " If the domain of a surjective function is a subsingleton, then the codomain is a subsingleton as\nwell."}, {"name": "fin.unique", "description": ""}, {"name": "unique.mk'", "description": " Construct `unique` from `inhabited` and `subsingleton`. Making this an instance would create\na loop in the class inheritance graph."}, {"name": "punit.default_eq_star", "description": ""}, {"name": "unique_iff_exists_unique", "description": ""}, {"name": "unique_subtype_iff_exists_unique", "description": ""}, {"name": "function.surjective.unique", "description": " If the domain of a surjective function is a singleton,\nthen the codomain is a singleton as well."}, {"name": "unique.bijective", "description": ""}, {"name": "unique_prop", "description": "Every provable proposition is unique, as all proofs are equal."}, {"name": "unique.ext_iff", "description": ""}, {"name": "unique.subsingleton_unique'", "description": ""}, {"name": "unique.exists_iff", "description": ""}, {"name": "unique.subsingleton_unique", "description": ""}, {"name": "unique.ext", "description": ""}, {"name": "function.surjective.unique_of_surjective_const", "description": "If a constant function is surjective, then the codomain is a singleton."}, {"name": "fin.inhabited", "description": ""}, {"name": "heq_const_of_unique", "description": ""}, {"name": "function.injective.unique", "description": "If `\u03b1` is inhabited and admits an injective map to a subsingleton type, then `\u03b1` is `unique`."}, {"name": "unique.subtype_eq", "description": ""}, {"name": "category_theory.groupoid.of_is_iso", "description": "A category where every morphism `is_iso` is a groupoid."}, {"name": "category_theory.groupoid.inv_comp", "description": ""}, {"name": "category_theory.induced_category.groupoid", "description": ""}, {"name": "category_theory.groupoid.of_hom_unique", "description": "A category with a unique morphism between any two objects is a groupoid"}, {"name": "category_theory.groupoid_prod", "description": ""}, {"name": "category_theory.groupoid_pi", "description": ""}, {"name": "category_theory.groupoid", "description": "A `groupoid` is a category such that all morphisms are isomorphisms."}, {"name": "category_theory.groupoid.to_category", "description": "A `groupoid` is a category such that all morphisms are isomorphisms."}, {"name": "category_theory.groupoid.inv", "description": "A `groupoid` is a category such that all morphisms are isomorphisms."}, {"name": "category_theory.groupoid.inv_comp'", "description": "A `groupoid` is a category such that all morphisms are isomorphisms."}, {"name": "category_theory.groupoid.comp_inv'", "description": "A `groupoid` is a category such that all morphisms are isomorphisms."}, {"name": "category_theory.groupoid.comp_inv", "description": ""}, {"name": "category_theory.groupoid.iso_equiv_hom", "description": "In a groupoid, isomorphisms are equivalent to morphisms."}, {"name": "category_theory.is_iso.of_groupoid", "description": ""}, {"name": "category_theory.large_groupoid", "description": "A `large_groupoid` is a groupoid\nwhere the objects live in `Type (u+1)` while the morphisms live in `Type u`."}, {"name": "category_theory.small_groupoid", "description": "A `small_groupoid` is a groupoid\nwhere the objects and morphisms live in the same universe."}, {"name": "function.commute.id_right", "description": ""}, {"name": "function.semiconj.id_right", "description": ""}, {"name": "function.semiconj\u2082.comp_eq", "description": ""}, {"name": "function.semiconj.id_left", "description": ""}, {"name": "function.semiconj.eq", "description": ""}, {"name": "function.semiconj.option_map", "description": ""}, {"name": "function.commute.refl", "description": ""}, {"name": "function.semiconj", "description": " We say that `f : \u03b1 \u2192 \u03b2` semiconjugates `ga : \u03b1 \u2192 \u03b1` to `gb : \u03b2 \u2192 \u03b2` if `f \u2218 ga = gb \u2218 f`.\nWe use `\u2200 x, f (ga x) = gb (f x)` as the definition, so given `h : function.semiconj f ga gb` and\n`a : \u03b1`, we have `h a : f (ga a) = gb (f a)` and `h.comp_eq : f \u2218 ga = gb \u2218 f`."}, {"name": "function.semiconj.comp_left", "description": ""}, {"name": "function.commute.id_left", "description": ""}, {"name": "function.commute.option_map", "description": ""}, {"name": "function.semiconj\u2082.is_associative_left", "description": ""}, {"name": "function.semiconj.comp_eq", "description": ""}, {"name": "function.semiconj\u2082.is_idempotent_right", "description": ""}, {"name": "function.commute.comp_left", "description": ""}, {"name": "function.semiconj\u2082.eq", "description": ""}, {"name": "function.semiconj\u2082.id_left", "description": ""}, {"name": "function.semiconj\u2082.comp", "description": ""}, {"name": "function.commute", "description": " Two maps `f g : \u03b1 \u2192 \u03b1` commute if `f (g x) = g (f x)` for all `x : \u03b1`.\nGiven `h : function.commute f g` and `a : \u03b1`, we have `h a : f (g a) = g (f a)` and\n`h.comp_eq : f \u2218 g = g \u2218 f`."}, {"name": "function.commute.comp_right", "description": ""}, {"name": "function.semiconj.inverses_right", "description": ""}, {"name": "function.semiconj.commute", "description": ""}, {"name": "function.semiconj\u2082.is_idempotent_left", "description": ""}, {"name": "function.semiconj\u2082", "description": " A map `f` semiconjugates a binary operation `ga` to a binary operation `gb` if\nfor all `x`, `y` we have `f (ga x y) = gb (f x) (f y)`. E.g., a `monoid_hom`\nsemiconjugates `(*)` to `(*)`."}, {"name": "function.commute.symm", "description": ""}, {"name": "function.semiconj.comp_right", "description": ""}, {"name": "function.semiconj\u2082.is_associative_right", "description": ""}, {"name": "category_theory.functor.id_map", "description": ""}, {"name": "category_theory.functor.id_obj", "description": ""}, {"name": "category_theory.functor.map_dite", "description": ""}, {"name": "category_theory.functor.to_prefunctor", "description": "The prefunctor between the underlying quivers."}, {"name": "category_theory.functor", "description": "`functor C D` represents a functor between categories `C` and `D`.\n\nTo apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.\n\nThe axiom `map_id` expresses preservation of identities, and\n`map_comp` expresses functoriality.\n\nSee <https://stacks.math.columbia.edu/tag/001B>."}, {"name": "category_theory.functor.obj", "description": "`functor C D` represents a functor between categories `C` and `D`.\n\nTo apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.\n\nThe axiom `map_id` expresses preservation of identities, and\n`map_comp` expresses functoriality.\n\nSee <https://stacks.math.columbia.edu/tag/001B>."}, {"name": "category_theory.functor.map", "description": "`functor C D` represents a functor between categories `C` and `D`.\n\nTo apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.\n\nThe axiom `map_id` expresses preservation of identities, and\n`map_comp` expresses functoriality.\n\nSee <https://stacks.math.columbia.edu/tag/001B>."}, {"name": "category_theory.functor.map_id'", "description": "`functor C D` represents a functor between categories `C` and `D`.\n\nTo apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.\n\nThe axiom `map_id` expresses preservation of identities, and\n`map_comp` expresses functoriality.\n\nSee <https://stacks.math.columbia.edu/tag/001B>."}, {"name": "category_theory.functor.map_comp'", "description": "`functor C D` represents a functor between categories `C` and `D`.\n\nTo apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.\n\nThe axiom `map_id` expresses preservation of identities, and\n`map_comp` expresses functoriality.\n\nSee <https://stacks.math.columbia.edu/tag/001B>."}, {"name": "category_theory.functor.comp_map", "description": ""}, {"name": "category_theory.functor.comp_id", "description": ""}, {"name": "category_theory.functor.id", "description": "`\ud835\udfed C` is the identity functor on a category `C`."}, {"name": "category_theory.functor.id_comp", "description": ""}, {"name": "category_theory.functor.map_comp_assoc", "description": ""}, {"name": "category_theory.functor.inhabited", "description": ""}, {"name": "category_theory.functor.comp", "description": "`F \u22d9 G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`)."}, {"name": "category_theory.functor.map_comp", "description": ""}, {"name": "category_theory.functor.comp_obj", "description": ""}, {"name": "category_theory.functor.map_id", "description": ""}, {"name": "tactic.generalizes_intro", "description": "Like `generalizes'`, but also introduces the generalized constants and their\nassociated equations into the context."}, {"name": "tactic.generalizes.step1", "description": "Input:\n\n- Target expression `e`.\n- List of expressions `j\u1d62` to be generalised, along with a name for the local\n  const that will replace them. The `j\u1d62` must be in dependency order:\n  `[n, fin n]` is okay but `[fin n, n]` is not.\n\nOutput:\n\n- List of new local constants `k\u1d62`, one for each `j\u1d62`.\n- `e` with the `j\u1d62` replaced by the `k\u1d62`, i.e. `e[j\u1d62 := k\u1d62]...[j\u2080 := k\u2080]`.\n\nNote that the substitution also affects the types of the `k\u1d62`: If `j\u1d62 : J\u1d62` then\n`k\u1d62 : J\u1d62[j\u1d62\u208b\u2081 := k\u1d62\u208b\u2081]...[j\u2080 := k\u2080]`.\n\nThe transparency `md` and the boolean `unify` are passed to `kabstract` when we\nabstract over occurrences of the `j\u1d62` in `e`."}, {"name": "tactic_doc.tactic.generalizes", "description": "Generalizes the target over multiple expressions. For example, given the goal\n\n    P : \u2200 n, fin n \u2192 Prop\n    n : \u2115\n    f : fin n\n    \u22a2 P (nat.succ n) (fin.succ f)\n\nyou can use `generalizes [n'_eq : nat.succ n = n', f'_eq : fin.succ f == f']` to\nget\n\n    P : \u2200 n, fin n \u2192 Prop\n    n : \u2115\n    f : fin n\n    n' : \u2115\n    n'_eq : n' = nat.succ n\n    f' : fin n'\n    f'_eq : f' == fin.succ f\n    \u22a2 P n' f'\n\nThe expressions must be given in dependency order, so\n`[f'_eq : fin.succ f == f', n'_eq : nat.succ n = n']` would fail since the type\nof `fin.succ f` is `nat.succ n`.\n\nYou can choose to omit some or all of the generated equations. For the above\nexample, `generalizes [nat.succ n = n', fin.succ f == f']` gets you\n\n    P : \u2200 n, fin n \u2192 Prop\n    n : \u2115\n    f : fin n\n    n' : \u2115\n    f' : fin n'\n    \u22a2 P n' f'\n\nAfter generalization, the target type may no longer type check. `generalizes`\nwill then raise an error."}, {"name": "tactic.generalizes'", "description": "Generalizes the target over each of the expressions in `args`. Given\n`args = [(a\u2081, h\u2081, arg\u2081), ...]`, this changes the target to\n\n    \u2200 (a\u2081 : T\u2081) ... (h\u2081 : a\u2081 = arg\u2081) ..., U\n\nwhere `U` is the current target with every occurrence of `arg\u1d62` replaced by\n`a\u1d62`. A similar effect can be achieved by using `generalize` once for each of\nthe `args`, but if there are dependencies between the `args`, this may fail to\nperform some generalizations.\n\nThe replacement is performed using keyed matching/unification with transparency\n`md`. `unify` determines whether matching or unification is used. See\n`kabstract`.\n\nThe `args` must be given in dependency order, so `[n, fin n]` is okay but\n`[fin n, n]` will result in an error.\n\nAfter generalizing the `args`, the target type may no longer type check.\n`generalizes'` will then raise an error."}, {"name": "tactic.generalizes.step2", "description": "Input: for each equation that should be generated: the equation name, the\nargument `j\u1d62` and the corresponding local constant `k\u1d62` from step 1.\n\nOutput: for each element of the input list a new local constant of type\n`j\u1d62 = k\u1d62` or `j\u1d62 == k\u1d62` and a proof of `j\u1d62 = j\u1d62` or `j\u1d62 == j\u1d62`.\n\nThe transparency `md` is used when determining whether the type of `j\u1d62` is defeq\nto the type of `k\u1d62` (and thus whether to generate a homogeneous or heterogeneous\nequation)."}, {"name": "tactic.generalizes.step3", "description": "Input: The `j\u1d62`; the local constants `k\u1d62` from step 1; the equations and their\nproofs from step 2.\n\nThis step is the first one that changes the goal (and also the last one\noverall). It asserts the generalized goal, then derives the current goal from\nit. This leaves us with the generalized goal."}, {"name": "tactic.interactive.generalizes", "description": "Generalizes the target over multiple expressions. For example, given the goal\n\n    P : \u2200 n, fin n \u2192 Prop\n    n : \u2115\n    f : fin n\n    \u22a2 P (nat.succ n) (fin.succ f)\n\nyou can use `generalizes [n'_eq : nat.succ n = n', f'_eq : fin.succ f == f']` to\nget\n\n    P : \u2200 n, fin n \u2192 Prop\n    n : \u2115\n    f : fin n\n    n' : \u2115\n    n'_eq : n' = nat.succ n\n    f' : fin n'\n    f'_eq : f' == fin.succ f\n    \u22a2 P n' f'\n\nThe expressions must be given in dependency order, so\n`[f'_eq : fin.succ f == f', n'_eq : nat.succ n = n']` would fail since the type\nof `fin.succ f` is `nat.succ n`.\n\nYou can choose to omit some or all of the generated equations. For the above\nexample, `generalizes [nat.succ n = n', fin.succ f == f']` gets you\n\n    P : \u2200 n, fin n \u2192 Prop\n    n : \u2115\n    f : fin n\n    n' : \u2115\n    f' : fin n'\n    \u22a2 P n' f'\n\nAfter generalization, the target type may no longer type check. `generalizes`\nwill then raise an error."}, {"name": "hinst_lemma.id", "description": ""}, {"name": "ematch_state.internalize", "description": ""}, {"name": "hinst_lemma.mk", "description": ""}, {"name": "hinst_lemma.has_to_tactic_format", "description": ""}, {"name": "mk_hinst_singleton", "description": ""}, {"name": "ematch_config", "description": ""}, {"name": "ematch_config.max_instances", "description": ""}, {"name": "ematch_config.max_generation", "description": ""}, {"name": "hinst_lemma.pp", "description": ""}, {"name": "tactic.ematch_all_core", "description": ""}, {"name": "hinst_lemma", "description": "Heuristic instantiation lemma"}, {"name": "merge_hinst_lemma_attrs", "description": ""}, {"name": "mk_hinst_lemma_attrs_core", "description": ""}, {"name": "hinst_lemmas.fold", "description": ""}, {"name": "hinst_lemma.mk_from_decl", "description": ""}, {"name": "tactic.ematch_core", "description": ""}, {"name": "ematch_state.mk", "description": ""}, {"name": "tactic.ematch_all", "description": ""}, {"name": "hinst_lemmas", "description": ""}, {"name": "tactic.ematch", "description": ""}, {"name": "hinst_lemmas.pp", "description": ""}, {"name": "get_hinst_lemmas_for_attr", "description": ""}, {"name": "to_hinst_lemmas_core", "description": ""}, {"name": "hinst_lemmas.has_to_tactic_format", "description": ""}, {"name": "ematch_state", "description": ""}, {"name": "mk_hinst_lemma_attr_set", "description": "Create a new \"cached\" attribute (attr_name : user_attribute hinst_lemmas).\nIt also creates \"cached\" attributes for each attr_names and simp_attr_names if they have not been defined\nyet. Moreover, the hinst_lemmas for attr_name will be the union of the lemmas tagged with\n    attr_name, attrs_name, and simp_attr_names.\nFor the ones in simp_attr_names, we use the left-hand-side of the conclusion as the pattern."}, {"name": "hinst_lemma.mk_from_decl_core", "description": ""}, {"name": "mk_hinst_lemma_attr_core", "description": ""}, {"name": "hinst_lemmas.add", "description": ""}, {"name": "hinst_lemmas.merge", "description": ""}, {"name": "hinst_lemma.mk_core", "description": "`mk_core m e as_simp`, m is used to decide which definitions will be unfolded in patterns.\n  If as_simp is tt, then this tactic will try to use the left-hand-side of the conclusion\n  as a pattern."}, {"name": "hinst_lemmas.mk", "description": ""}, {"name": "monad_reader_trans", "description": ""}, {"name": "monad_reader", "description": "An implementation of [MonadReader](https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader).\n   It does not contain `local` because this function cannot be lifted using `monad_lift`.\n   Instead, the `monad_reader_adapter` class provides the more general `adapt_reader` function.\n\n   Note: This class can be seen as a simplification of the more \"principled\" definition\n   ```lean\n   class monad_reader (\u03c1 : out_param (Type u)) (n : Type u \u2192 Type u) :=\n   (lift {\u03b1 : Type u} : (\u2200 {m : Type u \u2192 Type u} [monad m], reader_t \u03c1 m \u03b1) \u2192 n \u03b1)\n   ```"}, {"name": "monad_reader.read", "description": "An implementation of [MonadReader](https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader).\n   It does not contain `local` because this function cannot be lifted using `monad_lift`.\n   Instead, the `monad_reader_adapter` class provides the more general `adapt_reader` function.\n\n   Note: This class can be seen as a simplification of the more \"principled\" definition\n   ```lean\n   class monad_reader (\u03c1 : out_param (Type u)) (n : Type u \u2192 Type u) :=\n   (lift {\u03b1 : Type u} : (\u2200 {m : Type u \u2192 Type u} [monad m], reader_t \u03c1 m \u03b1) \u2192 n \u03b1)\n   ```"}, {"name": "monad_reader_adapter", "description": "Adapt a monad stack, changing the type of its top-most environment.\n\n   This class is comparable to [Control.Lens.Magnify](https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Zoom.html#t:Magnify), but does not use lenses (why would it), and is derived automatically for any transformer implementing `monad_functor`.\n\n   Note: This class can be seen as a simplification of the more \"principled\" definition\n   ```lean\n   class monad_reader_functor (\u03c1 \u03c1' : out_param (Type u)) (n n' : Type u \u2192 Type u) :=\n   (map {\u03b1 : Type u} : (\u2200 {m : Type u \u2192 Type u} [monad m], reader_t \u03c1 m \u03b1 \u2192 reader_t \u03c1' m \u03b1) \u2192 n \u03b1 \u2192 n' \u03b1)\n   ```"}, {"name": "monad_reader_adapter.adapt_reader", "description": "Adapt a monad stack, changing the type of its top-most environment.\n\n   This class is comparable to [Control.Lens.Magnify](https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Zoom.html#t:Magnify), but does not use lenses (why would it), and is derived automatically for any transformer implementing `monad_functor`.\n\n   Note: This class can be seen as a simplification of the more \"principled\" definition\n   ```lean\n   class monad_reader_functor (\u03c1 \u03c1' : out_param (Type u)) (n n' : Type u \u2192 Type u) :=\n   (map {\u03b1 : Type u} : (\u2200 {m : Type u \u2192 Type u} [monad m], reader_t \u03c1 m \u03b1 \u2192 reader_t \u03c1' m \u03b1) \u2192 n \u03b1 \u2192 n' \u03b1)\n   ```"}, {"name": "monad_reader_adapter_trans", "description": ""}, {"name": "reader_t.monad_except", "description": ""}, {"name": "reader_t.adapt", "description": ""}, {"name": "reader", "description": ""}, {"name": "reader_t.monad_reader_adapter", "description": ""}, {"name": "reader_t.read", "description": ""}, {"name": "reader_t.monad_reader", "description": ""}, {"name": "reader_t.bind", "description": ""}, {"name": "reader_t.has_monad_lift", "description": ""}, {"name": "reader_t.lift", "description": ""}, {"name": "reader_t.monad_functor", "description": ""}, {"name": "reader_t.monad_map", "description": ""}, {"name": "reader_t.orelse", "description": ""}, {"name": "reader_t.pure", "description": ""}, {"name": "reader_t.alternative", "description": ""}, {"name": "reader_t.failure", "description": ""}, {"name": "reader_t", "description": "An implementation of [ReaderT](https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#t:ReaderT)"}, {"name": "reader_t.run", "description": "An implementation of [ReaderT](https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#t:ReaderT)"}, {"name": "reader_t.monad", "description": ""}, {"name": "reader_t.monad_run", "description": ""}, {"name": "multiset.pi", "description": "`pi m t` constructs the Cartesian product over `t` indexed by `m`."}, {"name": "multiset.pi.cons_same", "description": ""}, {"name": "multiset.pi.cons_ne", "description": ""}, {"name": "multiset.pi_zero", "description": ""}, {"name": "multiset.pi.cons", "description": " Given `\u03b4 : \u03b1 \u2192 Type*`, a multiset `m` and a term `a`, as well as a term `b : \u03b4 a` and a\nfunction `f` such that `f a' : \u03b4 a'` for all `a'` in `m`, `pi.cons m a b f` is a function `g` such\nthat `g a'' : \u03b4 a''` for all `a''` in `a ::\u2098 m`."}, {"name": "multiset.pi_cons", "description": ""}, {"name": "multiset.pi_cons_injective", "description": ""}, {"name": "multiset.pi.cons_ext", "description": ""}, {"name": "multiset.pi.cons_swap", "description": ""}, {"name": "multiset.pi.empty", "description": " Given `\u03b4 : \u03b1 \u2192 Type*`, `pi.empty \u03b4` is the trivial dependent function out of the empty\nmultiset."}, {"name": "multiset.nodup.pi", "description": ""}, {"name": "multiset.mem_pi", "description": ""}, {"name": "multiset.card_pi", "description": ""}, {"name": "bnot", "description": "Boolean NOT"}, {"name": "bxor", "description": "Boolean XOR"}, {"name": "bor", "description": "Boolean OR"}, {"name": "band", "description": "Boolean AND"}, {"name": "cond", "description": "`cond b x y` is `x` if `b = tt` and `y` otherwise."}, {"name": "tactic.using_new_ref", "description": "Create a new reference `r` with initial value `a`, execute `t r`, and then delete `r`."}, {"name": "tactic.read_ref", "description": "Read the value stored in the given reference."}, {"name": "tactic.ref", "description": "A `ref` performs the role of a mutable variable within a tactic."}, {"name": "tactic.write_ref", "description": "Update the value stored in the given reference."}, {"name": "eqv_gen.is_equivalence", "description": ""}, {"name": "quotient", "description": ""}, {"name": "quot.exact", "description": ""}, {"name": "quotient.rec_on_subsingleton\u2082", "description": ""}, {"name": "quotient.ind\u2082", "description": ""}, {"name": "quotient.hrec_on", "description": ""}, {"name": "quotient.induction_on\u2083", "description": ""}, {"name": "quotient.decidable_eq", "description": ""}, {"name": "quotient.mk", "description": ""}, {"name": "quot.hrec_on", "description": ""}, {"name": "quotient.lift_on\u2082", "description": ""}, {"name": "quotient.exact", "description": ""}, {"name": "quot.lift_beta", "description": ""}, {"name": "quotient.sound", "description": ""}, {"name": "quot.lift_on", "description": ""}, {"name": "quot.ind_beta", "description": ""}, {"name": "quot.exists_rep", "description": ""}, {"name": "quot.rec_on_subsingleton", "description": ""}, {"name": "quotient.induction_on", "description": ""}, {"name": "quot.rec", "description": ""}, {"name": "iff_subst", "description": ""}, {"name": "quotient.ind", "description": ""}, {"name": "quotient.lift_on", "description": ""}, {"name": "quot.indep", "description": ""}, {"name": "quotient.lift", "description": ""}, {"name": "quot.rec_on", "description": ""}, {"name": "eqv_gen.setoid", "description": ""}, {"name": "quotient.rec_on", "description": ""}, {"name": "quotient.exists_rep", "description": ""}, {"name": "quot.eqv_gen_sound", "description": ""}, {"name": "quot.sound", "description": ""}, {"name": "quot.lift_indep_pr1", "description": ""}, {"name": "quotient.induction_on\u2082", "description": ""}, {"name": "eqv_gen", "description": ""}, {"name": "eqv_gen.rel", "description": ""}, {"name": "eqv_gen.refl", "description": ""}, {"name": "eqv_gen.symm", "description": ""}, {"name": "eqv_gen.trans", "description": ""}, {"name": "quotient.rec", "description": ""}, {"name": "quotient.rec_on_subsingleton", "description": ""}, {"name": "quotient.lift\u2082", "description": ""}, {"name": "quot.indep_coherent", "description": ""}, {"name": "quot.induction_on", "description": ""}, {"name": "tactic.injections_with", "description": "Simplifies equations in the context using injectivity of constructors. For\neach equation `h : C x\u2081 ... x\u2099 = D y\u2081 ... y\u2098` in the context, where `C` and `D`\nare constructors of the same data type, `injections_with` does the following:\n\n- If `C = D`, it adds equations `x\u2081 = y\u2081`, ..., `x\u2099 = y\u2099`.\n- If `C \u2260 D`, it solves the goal by contradiction.\n\nSee `injection_with` for details, including information about `base` and\n`offset`.\n\n`injections_with` also recurses into the new equations `x\u1d62 = y\u1d62`. If it has to\nrecurse more than five times, it fails."}, {"name": "tactic.injection_with", "description": ""}, {"name": "tactic.injection", "description": "Simplify the equation `h` using injectivity of constructors. See\n`injection_with`. Returns the hypotheses that were added to the context, or an\nempty list if the goal was solved by contradiction."}, {"name": "options.get_nat", "description": ""}, {"name": "options.mk", "description": ""}, {"name": "options.set_bool", "description": ""}, {"name": "options.get_string", "description": ""}, {"name": "options.join", "description": ""}, {"name": "options.set_nat", "description": ""}, {"name": "options", "description": ""}, {"name": "options.fold", "description": ""}, {"name": "options.size", "description": ""}, {"name": "options.get_bool", "description": ""}, {"name": "options.has_add", "description": ""}, {"name": "options.set_string", "description": ""}, {"name": "options.contains", "description": ""}, {"name": "options.inhabited", "description": ""}, {"name": "options.has_decidable_eq", "description": ""}, {"name": "int.nat_abs_bit1_nonneg_step", "description": ""}, {"name": "int.neg_ne_of_pos", "description": ""}, {"name": "int.zero_ne_neg_of_ne", "description": ""}, {"name": "int.ne_of_nat_ne_nonneg_case", "description": ""}, {"name": "int.zero_nonneg", "description": ""}, {"name": "int.neg_ne_zero_of_ne", "description": ""}, {"name": "int.one_pos", "description": ""}, {"name": "int.zero_le_of_nat", "description": ""}, {"name": "int.nat_abs_add_neg", "description": ""}, {"name": "int.nat_abs_add_nonneg", "description": ""}, {"name": "int.nat_abs_bit0_step", "description": ""}, {"name": "int.of_nat_nat_abs_eq_of_nonneg", "description": ""}, {"name": "int.ne_neg_of_ne", "description": ""}, {"name": "int.bit1_pos", "description": ""}, {"name": "int.bit1_nonneg", "description": ""}, {"name": "int.one_nonneg", "description": ""}, {"name": "int.nat_abs_bit0", "description": ""}, {"name": "int.nonneg_of_pos", "description": ""}, {"name": "int.nat_abs_of_nat_core", "description": ""}, {"name": "int.bit0_pos", "description": ""}, {"name": "int.ne_of_nat_abs_ne_nat_abs_of_nonneg", "description": ""}, {"name": "int.nat_abs_bit1_nonneg", "description": ""}, {"name": "int.nat_abs_of_neg_succ_of_nat", "description": ""}, {"name": "int.ne_neg_of_pos", "description": ""}, {"name": "int.bit0_nonneg", "description": ""}, {"name": "int.neg_succ_of_nat_lt_zero", "description": ""}, {"name": "core.core", "description": "Do addition modulo 2^32 of the reduced input and the doubleround of the reduced input."}, {"name": "core.Z'", "description": "Z\u2032 = Z + 2\u00b3\u00b9"}, {"name": "core.doubleround_10_is_isomorphic", "description": " Two morphism `doubleround_10` and `doubleround_10\u207b\u00b9` are isomorphic if:\n- `doubleround_10 \u2218 doubleround_10\u207b\u00b9 = \ud835\udfd9 doubleround_10`, and\n- `doubleround_10\u207b\u00b9 \u2218 doubleround_10 = \ud835\udfd9 doubleround_10\u207b\u00b9`."}, {"name": "core.id_core", "description": "The identity of a `core` morphism given a sequence is the sequence."}, {"name": "core.core_of_zero", "description": "`core` of zero is always zero."}, {"name": "core.known_collissions", "description": "As stated in https://www.ecrypt.eu.org/stream/papersdir/2008/011.pdf there are known collissions in salsa20 core\nin the form of salsa20(x) = salsa20 (x + \u0394), where \u0394 = (0x80000000, ...).\n\nThis is also Theorem 7 of https://www.iacr.org/archive/fse2008/50860470/50860470.pdf"}, {"name": "core.doubleround_10_is_left_invariant", "description": "`doubleround_10` is left invariant."}, {"name": "core.id_core_inv", "description": "The identity of a `core\u207b\u00b9` morphism given a sequence is the sequence."}, {"name": "core.output", "description": "An hypotetical collission output of the `core` function where the inputs are:\n \n Z \u2212Z Z \u2212Z\n \u2212Z Z \u2212Z Z\n Z \u2212Z Z \u2212Z\n \u2212Z Z \u2212Z Z\n\n or\n\n Z' \u2212Z' Z' \u2212Z'\n \u2212Z' Z' \u2212Z' Z'\n Z' \u2212Z' Z' \u2212Z'\n \u2212Z' Z' \u2212Z' Z'\n\n Where Z and Z' are of the form of the definitions above.\n\n Note : This type of input is not allowed in Salsa20. \n When expansion matrix us used, diagonal constants are added that mitigates this problem.\n\n https://www.ecrypt.eu.org/stream/papersdir/2008/011.pdf\n\n However, at the `core` function level, wthout the constants added, this inputs are possible."}, {"name": "core.salsa20_core_linear_transformation", "description": ""}, {"name": "core.collision", "description": "Two different specially crafted inputs produces the same output."}, {"name": "core.Z", "description": "Z < 2\u00b3\u00b9"}, {"name": "core.doubleround_10_inv", "description": "Inverse of `doubleround_10`."}, {"name": "core.differences_cancel", "description": "The specially crafted input based in some random input produces the same result as the original input. \n\n### TODO:\n\nProve:\n\n- `quarterrround` conserves the difference. \u2713\n- `rowround` conserves the difference.\n- `columnround` conserves the difference.\n- `doubleround` conserves the difference.\n- `doubleround`_10 conserves the difference.\n- `mod_matrix` cancel the difference.\n\nhttps://crypto.stackexchange.com/questions/26437/collision-or-second-preimage-for-the-chacha-core\nhttps://www.iacr.org/archive/fse2008/50860470/50860470.pdf"}, {"name": "core.Delta", "description": "A matrix consisting of all 2\u00b3\u00b9 (0x80000000) bit vectors."}, {"name": "core.isomorphism_right", "description": "Isomorphism condition 2 : `doubleround_10 \u2218 doubleround_10\u207b\u00b9 = \ud835\udfd9 doubleround_10\u207b\u00b9`"}, {"name": "core.doubleround_10", "description": "Apply double round 10 times to a reduced input."}, {"name": "core.Zero", "description": "A matrix where all its elements are zero."}, {"name": "core.id_doubleround_10_inv", "description": "The identity of a `doubleround\u207b\u00b9` morphism given a sequence is the sequence."}, {"name": "core.id_doubleround_10", "description": "The identity of a `doubleround_10` morphism given a sequence is the sequence."}, {"name": "core.hash", "description": "Do the hash."}, {"name": "core.isomorphism_left", "description": "Isomorphism condition 1 : `doubleround_10\u207b\u00b9 \u2218 doubleround_10 = \ud835\udfd9 doubleround_10`"}, {"name": "core.core_of_delta", "description": "`core` of delta is always zero."}, {"name": "core.Input", "description": "A random input matrix."}, {"name": "core.no_isomorphism_core", "description": " No isomrphism exists as none of the conditions apply :\n- `core\u207b\u00b9 \u2218 core = \ud835\udfd9 core` = false\n- `core \u2218 core\u207b\u00b9 = \ud835\udfd9 core` = false"}, {"name": "tactic.elide.unelide", "description": ""}, {"name": "tactic.elide.replace", "description": ""}, {"name": "tactic.interactive.elide", "description": " The `elide n (at ...)` tactic hides all subterms of the target goal or hypotheses\nbeyond depth `n` by replacing them with `hidden`, which is a variant\non the identity function. (Tactics should still mostly be able to see\nthrough the abbreviation, but if you want to unhide the term you can use\n`unelide`.)"}, {"name": "tactic_doc.tactic.elide / unelide", "description": "The `elide n (at ...)` tactic hides all subterms of the target goal or hypotheses\nbeyond depth `n` by replacing them with `hidden`, which is a variant\non the identity function. (Tactics should still mostly be able to see\nthrough the abbreviation, but if you want to unhide the term you can use\n`unelide`.)\n\nThe `unelide (at ...)` tactic removes all `hidden` subterms in the target\ntypes (usually added by `elide`)."}, {"name": "tactic.interactive.unelide", "description": " The `unelide (at ...)` tactic removes all `hidden` subterms in the target\ntypes (usually added by `elide`)."}, {"name": "utils.columnround_input", "description": "Prepare the `columnround` matrix input.\n\nAny `columnround` input matrix is in the form:\n\n(x\u2080, x\u2081, x\u2082, x\u2083)\n(x\u2084, x\u2085, x\u2086, x\u2087)\n(x\u2088, x\u2089, x\u2081\u2080, x\u2081\u2081)\n(x\u2081\u2082, x\u2081\u2083, x\u2081\u2084, x\u2081\u2085)\n\nBut we need this to be converted to:\n\n(x\u2080, x\u2084, x\u2088, x\u2081\u2082)\n(x\u2085, x\u2089, x\u2081\u2083, x\u2081)\n(x\u2081\u2080, x\u2081\u2084, x\u2082, x\u2086)\n(x\u2081\u2085, x\u2083, x\u2087, x\u2081\u2081)"}, {"name": "utils.list_to_matrix", "description": "Convert a list of bitvectors into a `matrixType`. Will panic if list size is < 16"}, {"name": "utils.mod_matrix_double", "description": "The MOD sum of two equal matrices X is 2 times X."}, {"name": "utils.xor_matrix", "description": "We define the xor of a matrix to be the xor of each individual bitvector of matrix A and matrix B."}, {"name": "utils.matrix_to_list", "description": "Convert a `matrixType` to a `list` as lists are easy to work sometimes than prods."}, {"name": "utils.columnround_output_is_inv_of_input", "description": "The `columnround_output` function is the inverse of the `columnround_input` function."}, {"name": "utils.matrix_distribute_two", "description": "Distribute 2 * Matrix."}, {"name": "utils.columnround_output", "description": "Prepare the `columnround` matrix output.\n\nAny `columnround` output matrix is in the form:\n\n(y\u2080, y\u2084, y\u2088, y\u2081\u2082)\n(y\u2085, y\u2089, y\u2081\u2083, y\u2081)\n(y\u2081\u2080, y\u2081\u2084, y\u2082, y\u2086)\n(y\u2081\u2085, y\u2083, y\u2087, y\u2081\u2081)\n\nBut we need this to be converted to:\n\n(y\u2080, y\u2081, y\u2082, y\u2083)\n(y\u2084, y\u2085, y\u2086, y\u2087)\n(y\u2088, y\u2089, y\u2081\u2080, y\u2081\u2081)\n(y\u2081\u2082, y\u2081\u2083, y\u2081\u2084, y\u2081\u2085)"}, {"name": "utils.reduce", "description": "Reduce the 64 bytes sequence to a 16 bytes one by using little endian."}, {"name": "utils.rowround_input", "description": "Prepare the `rowround` matrix input.\n\nAny `rowround` input matrix is in the form:\n\n(y\u2080, y\u2081, y\u2082, y\u2083)\n(y\u2084, y\u2085, y\u2086, y\u2087)\n(y\u2088, y\u2089, y\u2081\u2080, y\u2081\u2081)\n(y\u2081\u2082, y\u2081\u2083, y\u2081\u2084, y\u2081\u2085)\n\nBut we need this to be converted to:\n\n(y\u2080, y\u2081, y\u2082, y\u2083)\n(y\u2085, y\u2086, y\u2087, y\u2084)\n(y\u2081\u2080, y\u2081\u2081, y\u2088, y\u2089)\n(y\u2081\u2085, y\u2081\u2082, y\u2081\u2083, y\u2081\u2084)"}, {"name": "utils.rowround_output_is_inv_of_input", "description": "The `rowround_output` function is the inverse of the `rowround_input` function."}, {"name": "utils.aument", "description": "Aument a given 16 bytes sequence to a 64 bytes one using `littleenedian_inv`."}, {"name": "utils.mod_matrix", "description": "Modular 2^32 addition of 4x4 matrices by doing A\u1d62\u2c7c + B\u1d62\u2c7c\n\nThe `MOD` operation (modulo 2^32 addition) is the key to make the salsa20 hash function irreversible.\nEverything is reversible except for this addition."}, {"name": "utils.inv_of_mod_matrix_is_not_a_function", "description": "The inverse of a `mod_matrix` operation is not a function."}, {"name": "utils.rowround_output", "description": "Prepare the `rowround` matrix output.\n\nAny `rowround` output matrix is of the form:\n\n(z\u2080, z\u2081, z\u2082, z\u2083)\n(z\u2085, z\u2086, z\u2087, z\u2084)\n(z\u2081\u2080, z\u2081\u2081, z\u2088, z\u2089)\n(z\u2081\u2085, z\u2081\u2082, z\u2081\u2083, z\u2081\u2084)  \n\nBut we need this to be converted to:\n\n(z\u2080, z\u2081, z\u2082, z\u2083)\n(z\u2084, z\u2085, z\u2086, z\u2087)\n(z\u2088, z\u2089, z\u2081\u2080, z\u2081\u2081)\n(z\u2081\u2082, z\u2081\u2083, z\u2081\u2084, z\u2081\u2085)"}, {"name": "scope_trace", "description": "This function has a native implementation that displays in the given position all trace messages used in f.\n  The arguments line and col are filled by the elaborator."}, {"name": "try_for", "description": "This function has a native implementation where\nthe thunk is interrupted if it takes more than 'max' \"heartbeats\" to compute it.\nThe heartbeat is approx. the maximum number of memory allocations (in thousands) performed by 'f ()'.\nThis is a deterministic way of interrupting long running tasks."}, {"name": "trace", "description": "This function has a native implementation that displays the given string in the regular output stream."}, {"name": "trace_call_stack", "description": "This function has a native implementation that shows the VM call stack."}, {"name": "unchecked_cast", "description": ""}, {"name": "undefined_core", "description": "Throws an exception when it is evaluated."}, {"name": "try_for_time", "description": "This function has a native implementation where\nthe thunk is interrupted if it takes more than `max` milliseconds to compute it.\nThis is useful due to the variance in the number of heartbeats used by tactics."}, {"name": "trace_val", "description": ""}, {"name": "id_tag", "description": "For tactics to tag the proofs they construct.\nThe tag is `unit` but is intended to be encoded by a constant, e.g.\ndef tagged_proof.ring : unit := ()"}, {"name": "timeit", "description": "This function has a native implementation that tracks time."}, {"name": "undefined", "description": ""}, {"name": "imp_congr_ctx_eq", "description": ""}, {"name": "propext", "description": ""}, {"name": "eq_false_intro", "description": ""}, {"name": "forall_congr_eq", "description": ""}, {"name": "imp_congr_eq", "description": ""}, {"name": "eq_true_intro", "description": ""}, {"name": "iff.to_eq", "description": ""}, {"name": "eq_true", "description": ""}, {"name": "iff_eq_eq", "description": ""}, {"name": "eq_false", "description": ""}, {"name": "multiset.mem_powerset_aux", "description": ""}, {"name": "multiset.powerset_len_le_powerset", "description": ""}, {"name": "multiset.powerset_aux'", "description": " Helper function for the powerset of a multiset. Given a list `l`, returns a list\nof sublists of `l` (using `sublists'`), as multisets."}, {"name": "multiset.powerset_len_aux_nil", "description": ""}, {"name": "multiset.mem_powerset_len", "description": ""}, {"name": "multiset.powerset_len_card_add", "description": ""}, {"name": "multiset.powerset_len_aux_cons", "description": ""}, {"name": "multiset.revzip_powerset_aux'", "description": ""}, {"name": "multiset.powerset_len_coe'", "description": ""}, {"name": "multiset.powerset_aux'_nil", "description": ""}, {"name": "multiset.powerset_coe", "description": ""}, {"name": "multiset.revzip_powerset_aux_lemma", "description": ""}, {"name": "multiset.powerset_coe'", "description": ""}, {"name": "multiset.powerset_len_aux", "description": " Helper function for `powerset_len`. Given a list `l`, `powerset_len_aux n l` is the list\nof sublists of length `n`, as multisets."}, {"name": "multiset.powerset_aux_eq_map_coe", "description": ""}, {"name": "multiset.powerset_len_aux_perm", "description": ""}, {"name": "multiset.powerset_aux'_perm", "description": ""}, {"name": "multiset.mem_powerset", "description": ""}, {"name": "multiset.powerset_len_zero_right", "description": ""}, {"name": "multiset.powerset_len_aux_eq_map_coe", "description": ""}, {"name": "multiset.powerset_aux_perm_powerset_aux'", "description": ""}, {"name": "multiset.map_single_le_powerset", "description": ""}, {"name": "multiset.powerset_len", "description": "`powerset_len n s` is the multiset of all submultisets of `s` of length `n`."}, {"name": "multiset.powerset_aux", "description": " A helper function for the powerset of a multiset. Given a list `l`, returns a list\nof sublists of `l` (using `sublists_aux`), as multisets."}, {"name": "multiset.powerset_cons", "description": ""}, {"name": "multiset.powerset_len_coe", "description": ""}, {"name": "multiset.card_powerset_len", "description": ""}, {"name": "multiset.powerset_len_cons", "description": ""}, {"name": "multiset.revzip_powerset_aux_perm_aux'", "description": ""}, {"name": "multiset.powerset_len_empty", "description": ""}, {"name": "multiset.powerset_aux_perm", "description": ""}, {"name": "multiset.powerset", "description": "The power set of a multiset."}, {"name": "multiset.mem_powerset_len_aux", "description": ""}, {"name": "multiset.powerset_len_mono", "description": ""}, {"name": "multiset.powerset_zero", "description": ""}, {"name": "multiset.revzip_powerset_aux_perm", "description": ""}, {"name": "multiset.powerset_len_map", "description": ""}, {"name": "multiset.powerset_len_zero_left", "description": ""}, {"name": "multiset.revzip_powerset_aux", "description": ""}, {"name": "multiset.powerset_aux'_cons", "description": ""}, {"name": "multiset.card_powerset", "description": ""}, {"name": "multiset.powerset_len_aux_zero", "description": ""}, {"name": "option_t.ext", "description": ""}, {"name": "state_t.run_bind", "description": ""}, {"name": "option_t.run_pure", "description": ""}, {"name": "except_t.ext", "description": ""}, {"name": "except_t.run_pure", "description": ""}, {"name": "bind_pure", "description": ""}, {"name": "reader_t.run_read", "description": ""}, {"name": "state_t.run_map", "description": ""}, {"name": "is_lawful_functor", "description": ""}, {"name": "is_lawful_functor.map_const_eq", "description": ""}, {"name": "is_lawful_functor.id_map", "description": ""}, {"name": "is_lawful_functor.comp_map", "description": ""}, {"name": "reader_t.run_map", "description": ""}, {"name": "id.bind_eq", "description": ""}, {"name": "reader_t.run_pure", "description": ""}, {"name": "state_t.run_monad_map", "description": ""}, {"name": "option_t.run_map", "description": ""}, {"name": "state_t.run_adapt", "description": ""}, {"name": "option_t.run_monad_map", "description": ""}, {"name": "reader_t.is_lawful_monad", "description": ""}, {"name": "id.map_eq", "description": ""}, {"name": "except_t.run_map", "description": ""}, {"name": "state_t.run_monad_lift", "description": ""}, {"name": "state_t.run_get", "description": ""}, {"name": "except_t.run_monad_lift", "description": ""}, {"name": "bind_ext_congr", "description": ""}, {"name": "control_laws_tac", "description": ""}, {"name": "option_t.run_bind", "description": ""}, {"name": "id.is_lawful_monad", "description": ""}, {"name": "reader_t.run_monad_lift", "description": ""}, {"name": "state_t.ext", "description": ""}, {"name": "except_t.run_monad_map", "description": ""}, {"name": "map_ext_congr", "description": ""}, {"name": "state_t.run_put", "description": ""}, {"name": "pure_id_seq", "description": ""}, {"name": "reader_t.run_bind", "description": ""}, {"name": "except_t.is_lawful_monad", "description": ""}, {"name": "except_t.run_bind", "description": ""}, {"name": "reader_t.run_monad_map", "description": ""}, {"name": "id.pure_eq", "description": ""}, {"name": "is_lawful_monad", "description": ""}, {"name": "is_lawful_monad.to_is_lawful_applicative", "description": ""}, {"name": "is_lawful_monad.bind_pure_comp_eq_map", "description": ""}, {"name": "is_lawful_monad.bind_map_eq_seq", "description": ""}, {"name": "is_lawful_monad.pure_bind", "description": ""}, {"name": "is_lawful_monad.bind_assoc", "description": ""}, {"name": "reader_t.ext", "description": ""}, {"name": "option_t.is_lawful_monad", "description": ""}, {"name": "option_t.run_monad_lift", "description": ""}, {"name": "state_t.is_lawful_monad", "description": ""}, {"name": "state_t.run_pure", "description": ""}, {"name": "is_lawful_applicative", "description": ""}, {"name": "is_lawful_applicative.to_is_lawful_functor", "description": ""}, {"name": "is_lawful_applicative.seq_left_eq", "description": ""}, {"name": "is_lawful_applicative.seq_right_eq", "description": ""}, {"name": "is_lawful_applicative.pure_seq_eq_map", "description": ""}, {"name": "is_lawful_applicative.map_pure", "description": ""}, {"name": "is_lawful_applicative.seq_pure", "description": ""}, {"name": "is_lawful_applicative.seq_assoc", "description": ""}, {"name": "finset.erase_none_insert_none", "description": ""}, {"name": "option.mem_to_finset", "description": ""}, {"name": "option.card_to_finset", "description": ""}, {"name": "finset.map_some_erase_none", "description": ""}, {"name": "option.to_finset_none", "description": ""}, {"name": "finset.mem_insert_none", "description": ""}, {"name": "finset.image_some_erase_none", "description": ""}, {"name": "finset.card_insert_none", "description": ""}, {"name": "option.to_finset_some", "description": ""}, {"name": "finset.insert_none", "description": " Given a finset on `\u03b1`, lift it to being a finset on `option \u03b1`\nusing `option.some` and then insert `option.none`."}, {"name": "option.to_finset", "description": "Construct an empty or singleton finset from an `option`"}, {"name": "finset.erase_none_inter", "description": ""}, {"name": "finset.erase_none_union", "description": ""}, {"name": "finset.erase_none_empty", "description": ""}, {"name": "finset.mem_erase_none", "description": ""}, {"name": "finset.erase_none_image_some", "description": ""}, {"name": "finset.erase_none_eq_bUnion", "description": ""}, {"name": "finset.insert_none_erase_none", "description": ""}, {"name": "finset.some_mem_insert_none", "description": ""}, {"name": "finset.coe_erase_none", "description": ""}, {"name": "finset.erase_none_map_some", "description": ""}, {"name": "finset.erase_none", "description": " Given `s : finset (option \u03b1)`, `s.erase_none : finset \u03b1` is the set of `x : \u03b1` such that\n`some x \u2208 s`."}, {"name": "finset.erase_none_none", "description": ""}, {"name": "tactic_doc.tactic.solve_by_elim", "description": "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `max_depth` recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs back-tracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congr_fun` and `congr_arg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h\u2081, h\u2082, ..., h\u1d63]` also applies the named lemmas.\n* `solve_by_elim with attr\u2081 ... attr\u1d63` also applies all lemmas tagged with the specified attributes.\n* `solve_by_elim only [h\u2081, h\u2082, ..., h\u1d63]` does not include the local context,\n  `rfl`, `trivial`, `congr_fun`, or `congr_arg` unless they are explicitly included.\n* `solve_by_elim [-id_1, ... -id_n]` uses the default assumptions, removing the specified ones.\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n\noptional arguments passed via a configuration argument as `solve_by_elim { ... }`\n- max_depth: number of attempts at discharging generated sub-goals\n- discharger: a subsidiary tactic to try at each step when no lemmas apply\n  (e.g. `cc` may be helpful).\n- pre_apply: a subsidiary tactic to run at each step before applying lemmas (e.g. `intros`).\n- accept: a subsidiary tactic `list expr \u2192 tactic unit` that at each step,\n    before any lemmas are applied, is passed the original proof terms\n    as reported by `get_goals` when `solve_by_elim` started\n    (but which may by now have been partially solved by previous `apply` steps).\n    If the `accept` tactic fails,\n    `solve_by_elim` will abort searching the current branch and backtrack.\n    This may be used to filter results, either at every step of the search,\n    or filtering complete results\n    (by testing for the absence of metavariables, and then the filtering condition)."}, {"name": "tactic.solve_by_elim.basic_opt", "description": "Configuration options for `solve_by_elim`.\n\n* `accept : list expr \u2192 tactic unit` determines whether the current branch should be explored.\n   At each step, before the lemmas are applied,\n   `accept` is passed the proof terms for the original goals,\n   as reported by `get_goals` when `solve_by_elim` started.\n   These proof terms may be metavariables (if no progress has been made on that goal)\n   or may contain metavariables at some leaf nodes\n   (if the goal has been partially solved by previous `apply` steps).\n   If the `accept` tactic fails `solve_by_elim` aborts searching this branch and backtracks.\n   By default `accept := \u03bb _, skip` always succeeds.\n   (There is an example usage in `tests/solve_by_elim.lean`.)\n* `pre_apply : tactic unit` specifies an additional tactic to run before each round of `apply`.\n* `discharger : tactic unit` specifies an additional tactic to apply on subgoals\n  for which no lemma applies.\n  If that tactic succeeds, `solve_by_elim` will continue applying lemmas on resulting goals."}, {"name": "tactic.solve_by_elim.basic_opt.to_apply_any_opt", "description": "Configuration options for `solve_by_elim`.\n\n* `accept : list expr \u2192 tactic unit` determines whether the current branch should be explored.\n   At each step, before the lemmas are applied,\n   `accept` is passed the proof terms for the original goals,\n   as reported by `get_goals` when `solve_by_elim` started.\n   These proof terms may be metavariables (if no progress has been made on that goal)\n   or may contain metavariables at some leaf nodes\n   (if the goal has been partially solved by previous `apply` steps).\n   If the `accept` tactic fails `solve_by_elim` aborts searching this branch and backtracks.\n   By default `accept := \u03bb _, skip` always succeeds.\n   (There is an example usage in `tests/solve_by_elim.lean`.)\n* `pre_apply : tactic unit` specifies an additional tactic to run before each round of `apply`.\n* `discharger : tactic unit` specifies an additional tactic to apply on subgoals\n  for which no lemma applies.\n  If that tactic succeeds, `solve_by_elim` will continue applying lemmas on resulting goals."}, {"name": "tactic.solve_by_elim.basic_opt.accept", "description": "Configuration options for `solve_by_elim`.\n\n* `accept : list expr \u2192 tactic unit` determines whether the current branch should be explored.\n   At each step, before the lemmas are applied,\n   `accept` is passed the proof terms for the original goals,\n   as reported by `get_goals` when `solve_by_elim` started.\n   These proof terms may be metavariables (if no progress has been made on that goal)\n   or may contain metavariables at some leaf nodes\n   (if the goal has been partially solved by previous `apply` steps).\n   If the `accept` tactic fails `solve_by_elim` aborts searching this branch and backtracks.\n   By default `accept := \u03bb _, skip` always succeeds.\n   (There is an example usage in `tests/solve_by_elim.lean`.)\n* `pre_apply : tactic unit` specifies an additional tactic to run before each round of `apply`.\n* `discharger : tactic unit` specifies an additional tactic to apply on subgoals\n  for which no lemma applies.\n  If that tactic succeeds, `solve_by_elim` will continue applying lemmas on resulting goals."}, {"name": "tactic.solve_by_elim.basic_opt.pre_apply", "description": "Configuration options for `solve_by_elim`.\n\n* `accept : list expr \u2192 tactic unit` determines whether the current branch should be explored.\n   At each step, before the lemmas are applied,\n   `accept` is passed the proof terms for the original goals,\n   as reported by `get_goals` when `solve_by_elim` started.\n   These proof terms may be metavariables (if no progress has been made on that goal)\n   or may contain metavariables at some leaf nodes\n   (if the goal has been partially solved by previous `apply` steps).\n   If the `accept` tactic fails `solve_by_elim` aborts searching this branch and backtracks.\n   By default `accept := \u03bb _, skip` always succeeds.\n   (There is an example usage in `tests/solve_by_elim.lean`.)\n* `pre_apply : tactic unit` specifies an additional tactic to run before each round of `apply`.\n* `discharger : tactic unit` specifies an additional tactic to apply on subgoals\n  for which no lemma applies.\n  If that tactic succeeds, `solve_by_elim` will continue applying lemmas on resulting goals."}, {"name": "tactic.solve_by_elim.basic_opt.discharger", "description": "Configuration options for `solve_by_elim`.\n\n* `accept : list expr \u2192 tactic unit` determines whether the current branch should be explored.\n   At each step, before the lemmas are applied,\n   `accept` is passed the proof terms for the original goals,\n   as reported by `get_goals` when `solve_by_elim` started.\n   These proof terms may be metavariables (if no progress has been made on that goal)\n   or may contain metavariables at some leaf nodes\n   (if the goal has been partially solved by previous `apply` steps).\n   If the `accept` tactic fails `solve_by_elim` aborts searching this branch and backtracks.\n   By default `accept := \u03bb _, skip` always succeeds.\n   (There is an example usage in `tests/solve_by_elim.lean`.)\n* `pre_apply : tactic unit` specifies an additional tactic to run before each round of `apply`.\n* `discharger : tactic unit` specifies an additional tactic to apply on subgoals\n  for which no lemma applies.\n  If that tactic succeeds, `solve_by_elim` will continue applying lemmas on resulting goals."}, {"name": "tactic.solve_by_elim.basic_opt.max_depth", "description": "Configuration options for `solve_by_elim`.\n\n* `accept : list expr \u2192 tactic unit` determines whether the current branch should be explored.\n   At each step, before the lemmas are applied,\n   `accept` is passed the proof terms for the original goals,\n   as reported by `get_goals` when `solve_by_elim` started.\n   These proof terms may be metavariables (if no progress has been made on that goal)\n   or may contain metavariables at some leaf nodes\n   (if the goal has been partially solved by previous `apply` steps).\n   If the `accept` tactic fails `solve_by_elim` aborts searching this branch and backtracks.\n   By default `accept := \u03bb _, skip` always succeeds.\n   (There is an example usage in `tests/solve_by_elim.lean`.)\n* `pre_apply : tactic unit` specifies an additional tactic to run before each round of `apply`.\n* `discharger : tactic unit` specifies an additional tactic to apply on subgoals\n  for which no lemma applies.\n  If that tactic succeeds, `solve_by_elim` will continue applying lemmas on resulting goals."}, {"name": "tactic.interactive.solve_by_elim", "description": "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `max_depth` recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs back-tracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congr_fun` and `congr_arg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h\u2081, h\u2082, ..., h\u1d63]` also applies the named lemmas.\n* `solve_by_elim with attr\u2081 ... attr\u1d63` also applies all lemmas tagged with the specified attributes.\n* `solve_by_elim only [h\u2081, h\u2082, ..., h\u1d63]` does not include the local context,\n  `rfl`, `trivial`, `congr_fun`, or `congr_arg` unless they are explicitly included.\n* `solve_by_elim [-id_1, ... -id_n]` uses the default assumptions, removing the specified ones.\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n\noptional arguments passed via a configuration argument as `solve_by_elim { ... }`\n- max_depth: number of attempts at discharging generated sub-goals\n- discharger: a subsidiary tactic to try at each step when no lemmas apply\n  (e.g. `cc` may be helpful).\n- pre_apply: a subsidiary tactic to run at each step before applying lemmas (e.g. `intros`).\n- accept: a subsidiary tactic `list expr \u2192 tactic unit` that at each step,\n    before any lemmas are applied, is passed the original proof terms\n    as reported by `get_goals` when `solve_by_elim` started\n    (but which may by now have been partially solved by previous `apply` steps).\n    If the `accept` tactic fails,\n    `solve_by_elim` will abort searching the current branch and backtrack.\n    This may be used to filter results, either at every step of the search,\n    or filtering complete results\n    (by testing for the absence of metavariables, and then the filtering condition)."}, {"name": "tactic.interactive.apply_assumption", "description": "`apply_assumption` looks for an assumption of the form `... \u2192 \u2200 _, ... \u2192 head`\nwhere `head` matches the current goal.\n\nIf this fails, `apply_assumption` will call `symmetry` and try again.\n\nIf this also fails, `apply_assumption` will call `exfalso` and try again,\nso that if there is an assumption of the form `P \u2192 \u00ac Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nOptional arguments:\n- `lemmas`: a list of expressions to apply, instead of the local constants\n- `tac`: a tactic to run on each subgoal after applying an assumption; if\n  this tactic fails, the corresponding assumption will be rejected and\n  the next one will be attempted."}, {"name": "tactic.solve_by_elim.solve_by_elim_trace", "description": "A helper function for trace messages, prepending '....' depending on the current search depth."}, {"name": "tactic.solve_by_elim.mk_assumption_set", "description": "`mk_assumption_set` builds a collection of lemmas for use in\nthe backtracking search in `solve_by_elim`.\n\n* By default, it includes all local hypotheses, along with `rfl`, `trivial`, `congr_fun` and\n  `congr_arg`.\n* The flag `no_dflt` removes these.\n* The argument `hs` is a list of `simp_arg_type`s,\n  and can be used to add, or remove, lemmas or expressions from the set.\n* The argument `attr : list name` adds all lemmas tagged with one of a specified list of attributes.\n\n`mk_assumption_set` returns not a `list expr`, but a `list (tactic expr) \u00d7 tactic (list expr)`.\nThere are two separate problems that need to be solved.\n\n### Relevant local hypotheses\n\n`solve_by_elim*` works with multiple goals,\nand we need to use separate sets of local hypotheses for each goal.\nThe second component of the returned value provides these local hypotheses.\n(Essentially using `local_context`, along with some filtering to remove hypotheses\nthat have been explicitly removed via `only` or `[-h]`.)\n\n### Stuck metavariables\n\nLemmas with implicit arguments would be filled in with metavariables if we created the\n`expr` objects immediately, so instead we return thunks that generate the expressions\non demand. This is the first component, with type `list (tactic expr)`.\n\nAs an example, we have `def rfl : \u2200 {\u03b1 : Sort u} {a : \u03b1}, a = a`, which on elaboration will become\n`@rfl ?m_1 ?m_2`.\n\nBecause `solve_by_elim` works by repeated application of lemmas against subgoals,\nthe first time such a lemma is successfully applied,\nthose metavariables will be unified, and thereafter have fixed values.\nThis would make it impossible to apply the lemma\na second time with different values of the metavariables.\n\nSee https://github.com/leanprover-community/mathlib/issues/2269\n\nAs an optimisation, after we build the list of `tactic expr`s, we actually run them, and replace any\nthat do not in fact produce metavariables with a simple `return` tactic."}, {"name": "tactic.solve_by_elim.trace_hooks", "description": "A helper function to generate the tactic that print trace messages.\nThis function exists to ensure the target is pretty printed only as necessary."}, {"name": "tactic.solve_by_elim.solve_by_elim_aux", "description": "The internal implementation of `solve_by_elim`, with a limiting counter."}, {"name": "tactic.solve_by_elim", "description": "`solve_by_elim` repeatedly tries `apply`ing a lemma\nfrom the list of assumptions (passed via the `opt` argument),\nrecursively operating on any generated subgoals, backtracking as necessary.\n\n`solve_by_elim` succeeds only if it discharges the goal.\n(By default, `solve_by_elim` focuses on the first goal, and only attempts to solve that.\nWith the option `backtrack_all_goals := tt`,\nit attempts to solve all goals, and only succeeds if it does so.\nWith `backtrack_all_goals := tt`, `solve_by_elim` will backtrack a solution it has found for\none goal if it then can't discharge other goals.)\n\nIf passed an empty list of assumptions, `solve_by_elim` builds a default set\nas per the interactive tactic, using the `local_context` along with\n`rfl`, `trivial`, `congr_arg`, and `congr_fun`.\n\nTo pass a particular list of assumptions, use the `lemmas` field\nin the configuration argument. This expects an\n`option (list expr)`. In certain situations it may be necessary to instead use the\n`lemma_thunks` field, which expects a `option (list (tactic expr))`.\nThis allows for regenerating metavariables\nfor each application, which might otherwise get stuck.\n\nSee also the simpler tactic `apply_rules`, which does not perform backtracking."}, {"name": "tactic.solve_by_elim.opt.get_lemma_thunks", "description": "If no lemmas have been specified, generate the default set\n(local hypotheses, along with `rfl`, `trivial`, `congr_arg`, and `congr_fun`)."}, {"name": "tactic.solve_by_elim.opt", "description": "Arguments for `solve_by_elim`:\n* By default `solve_by_elim` operates only on the first goal,\n  but with `backtrack_all_goals := true`, it operates on all goals at once,\n  backtracking across goals as needed,\n  and only succeeds if it discharges all goals.\n* `lemmas` specifies the list of lemmas to use in the backtracking search.\n  If `none`, `solve_by_elim` uses the local hypotheses,\n  along with `rfl`, `trivial`, `congr_arg`, and `congr_fun`.\n* `lemma_thunks` provides the lemmas as a list of `tactic expr`,\n  which are used to regenerate the `expr` objects to avoid binding metavariables.\n  It should not usually be specified by the user.\n  (If both `lemmas` and `lemma_thunks` are specified, only `lemma_thunks` is used.)\n* `ctx_thunk` is for internal use only: it returns the local hypotheses which will be used.\n* `max_depth` bounds the depth of the search."}, {"name": "tactic.solve_by_elim.opt.to_basic_opt", "description": "Arguments for `solve_by_elim`:\n* By default `solve_by_elim` operates only on the first goal,\n  but with `backtrack_all_goals := true`, it operates on all goals at once,\n  backtracking across goals as needed,\n  and only succeeds if it discharges all goals.\n* `lemmas` specifies the list of lemmas to use in the backtracking search.\n  If `none`, `solve_by_elim` uses the local hypotheses,\n  along with `rfl`, `trivial`, `congr_arg`, and `congr_fun`.\n* `lemma_thunks` provides the lemmas as a list of `tactic expr`,\n  which are used to regenerate the `expr` objects to avoid binding metavariables.\n  It should not usually be specified by the user.\n  (If both `lemmas` and `lemma_thunks` are specified, only `lemma_thunks` is used.)\n* `ctx_thunk` is for internal use only: it returns the local hypotheses which will be used.\n* `max_depth` bounds the depth of the search."}, {"name": "tactic.solve_by_elim.opt.backtrack_all_goals", "description": "Arguments for `solve_by_elim`:\n* By default `solve_by_elim` operates only on the first goal,\n  but with `backtrack_all_goals := true`, it operates on all goals at once,\n  backtracking across goals as needed,\n  and only succeeds if it discharges all goals.\n* `lemmas` specifies the list of lemmas to use in the backtracking search.\n  If `none`, `solve_by_elim` uses the local hypotheses,\n  along with `rfl`, `trivial`, `congr_arg`, and `congr_fun`.\n* `lemma_thunks` provides the lemmas as a list of `tactic expr`,\n  which are used to regenerate the `expr` objects to avoid binding metavariables.\n  It should not usually be specified by the user.\n  (If both `lemmas` and `lemma_thunks` are specified, only `lemma_thunks` is used.)\n* `ctx_thunk` is for internal use only: it returns the local hypotheses which will be used.\n* `max_depth` bounds the depth of the search."}, {"name": "tactic.solve_by_elim.opt.lemmas", "description": "Arguments for `solve_by_elim`:\n* By default `solve_by_elim` operates only on the first goal,\n  but with `backtrack_all_goals := true`, it operates on all goals at once,\n  backtracking across goals as needed,\n  and only succeeds if it discharges all goals.\n* `lemmas` specifies the list of lemmas to use in the backtracking search.\n  If `none`, `solve_by_elim` uses the local hypotheses,\n  along with `rfl`, `trivial`, `congr_arg`, and `congr_fun`.\n* `lemma_thunks` provides the lemmas as a list of `tactic expr`,\n  which are used to regenerate the `expr` objects to avoid binding metavariables.\n  It should not usually be specified by the user.\n  (If both `lemmas` and `lemma_thunks` are specified, only `lemma_thunks` is used.)\n* `ctx_thunk` is for internal use only: it returns the local hypotheses which will be used.\n* `max_depth` bounds the depth of the search."}, {"name": "tactic.solve_by_elim.opt.lemma_thunks", "description": "Arguments for `solve_by_elim`:\n* By default `solve_by_elim` operates only on the first goal,\n  but with `backtrack_all_goals := true`, it operates on all goals at once,\n  backtracking across goals as needed,\n  and only succeeds if it discharges all goals.\n* `lemmas` specifies the list of lemmas to use in the backtracking search.\n  If `none`, `solve_by_elim` uses the local hypotheses,\n  along with `rfl`, `trivial`, `congr_arg`, and `congr_fun`.\n* `lemma_thunks` provides the lemmas as a list of `tactic expr`,\n  which are used to regenerate the `expr` objects to avoid binding metavariables.\n  It should not usually be specified by the user.\n  (If both `lemmas` and `lemma_thunks` are specified, only `lemma_thunks` is used.)\n* `ctx_thunk` is for internal use only: it returns the local hypotheses which will be used.\n* `max_depth` bounds the depth of the search."}, {"name": "tactic.solve_by_elim.opt.ctx_thunk", "description": "Arguments for `solve_by_elim`:\n* By default `solve_by_elim` operates only on the first goal,\n  but with `backtrack_all_goals := true`, it operates on all goals at once,\n  backtracking across goals as needed,\n  and only succeeds if it discharges all goals.\n* `lemmas` specifies the list of lemmas to use in the backtracking search.\n  If `none`, `solve_by_elim` uses the local hypotheses,\n  along with `rfl`, `trivial`, `congr_arg`, and `congr_fun`.\n* `lemma_thunks` provides the lemmas as a list of `tactic expr`,\n  which are used to regenerate the `expr` objects to avoid binding metavariables.\n  It should not usually be specified by the user.\n  (If both `lemmas` and `lemma_thunks` are specified, only `lemma_thunks` is used.)\n* `ctx_thunk` is for internal use only: it returns the local hypotheses which will be used.\n* `max_depth` bounds the depth of the search."}, {"name": "tactic.solve_by_elim.on_success", "description": "A helper function to generate trace messages on successful applications."}, {"name": "tactic_doc.tactic.apply_assumption", "description": "`apply_assumption` looks for an assumption of the form `... \u2192 \u2200 _, ... \u2192 head`\nwhere `head` matches the current goal.\n\nIf this fails, `apply_assumption` will call `symmetry` and try again.\n\nIf this also fails, `apply_assumption` will call `exfalso` and try again,\nso that if there is an assumption of the form `P \u2192 \u00ac Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nOptional arguments:\n- `lemmas`: a list of expressions to apply, instead of the local constants\n- `tac`: a tactic to run on each subgoal after applying an assumption; if\n  this tactic fails, the corresponding assumption will be rejected and\n  the next one will be attempted."}, {"name": "tactic.solve_by_elim.on_failure", "description": "A helper function to generate trace messages on unsuccessful applications."}, {"name": "is_empty.forall_iff", "description": ""}, {"name": "is_empty.exists_iff", "description": ""}, {"name": "is_empty_prod", "description": ""}, {"name": "function.is_empty", "description": ""}, {"name": "is_empty.subsingleton", "description": ""}, {"name": "fin.is_empty", "description": ""}, {"name": "is_empty_sum", "description": ""}, {"name": "is_empty_elim", "description": "Eliminate out of a type that `is_empty` (without using projection notation)."}, {"name": "empty.is_empty", "description": ""}, {"name": "not_is_empty_iff", "description": ""}, {"name": "sigma.is_empty_left", "description": ""}, {"name": "is_empty_or_nonempty", "description": ""}, {"name": "sum.is_empty", "description": ""}, {"name": "function.extend_of_empty", "description": ""}, {"name": "is_empty_pprod", "description": ""}, {"name": "pempty.is_empty", "description": ""}, {"name": "not_nonempty_iff", "description": ""}, {"name": "pprod.is_empty_right", "description": ""}, {"name": "not_is_empty_of_nonempty", "description": ""}, {"name": "well_founded_of_empty", "description": ""}, {"name": "is_empty_pi", "description": ""}, {"name": "pi.is_empty", "description": ""}, {"name": "prod.is_empty_left", "description": ""}, {"name": "subtype.is_empty_of_false", "description": "subtypes by an all-false predicate are false."}, {"name": "subtype.is_empty", "description": "subtypes of an empty type are empty"}, {"name": "psum.is_empty", "description": ""}, {"name": "subtype.is_empty_false", "description": "subtypes by false are false."}, {"name": "is_empty", "description": "`is_empty \u03b1` expresses that `\u03b1` is empty."}, {"name": "is_empty.false", "description": "`is_empty \u03b1` expresses that `\u03b1` is empty."}, {"name": "is_empty.elim", "description": "Eliminate out of a type that `is_empty` (using projection notation)."}, {"name": "is_empty.prop_iff", "description": ""}, {"name": "is_empty_subtype", "description": ""}, {"name": "is_empty_ulift", "description": ""}, {"name": "is_empty.elim'", "description": "Non-dependent version of `is_empty.elim`. Helpful if the elaborator cannot elaborate `h.elim a`\n correctly."}, {"name": "pprod.is_empty_left", "description": ""}, {"name": "is_empty_sigma", "description": ""}, {"name": "is_empty_iff", "description": ""}, {"name": "is_empty_plift", "description": ""}, {"name": "is_empty_Prop", "description": ""}, {"name": "is_empty_psigma", "description": ""}, {"name": "prod.is_empty_right", "description": ""}, {"name": "false.is_empty", "description": ""}, {"name": "is_empty_psum", "description": ""}, {"name": "option.is_lawful_monad", "description": ""}, {"name": "option.eq_of_eq_some", "description": ""}, {"name": "option.eq_some_of_is_some", "description": ""}, {"name": "option.eq_none_of_is_none", "description": ""}, {"name": "sigma.has_to_string", "description": ""}, {"name": "char.has_to_string", "description": ""}, {"name": "subtype.has_to_string", "description": ""}, {"name": "string.has_to_string", "description": ""}, {"name": "unsigned.has_to_string", "description": ""}, {"name": "list.to_string", "description": ""}, {"name": "nat.has_to_string", "description": ""}, {"name": "sum.has_to_string", "description": ""}, {"name": "has_to_string", "description": " Convert the object into a string for tracing/display purposes.\nSimilar to Haskell's `show`.\nSee also `has_repr`, which is used to output a string which is a valid lean code.\nSee also `has_to_format` and `has_to_tactic_format`, `format` has additional support for colours and pretty printing multilines."}, {"name": "has_to_string.to_string", "description": " Convert the object into a string for tracing/display purposes.\nSimilar to Haskell's `show`.\nSee also `has_repr`, which is used to output a string which is a valid lean code.\nSee also `has_to_format` and `has_to_tactic_format`, `format` has additional support for colours and pretty printing multilines."}, {"name": "to_string", "description": ""}, {"name": "bool.has_to_string", "description": ""}, {"name": "decidable.has_to_string", "description": ""}, {"name": "prod.has_to_string", "description": ""}, {"name": "list.to_string_aux", "description": ""}, {"name": "unit.has_to_string", "description": ""}, {"name": "option.has_to_string", "description": ""}, {"name": "fin.has_to_string", "description": ""}, {"name": "list.has_to_string", "description": ""}, {"name": "interaction_monad", "description": ""}, {"name": "interaction_monad.orelse'", "description": ""}, {"name": "interaction_monad.fail", "description": ""}, {"name": "interaction_monad.result_to_string", "description": ""}, {"name": "interaction_monad.result", "description": ""}, {"name": "interaction_monad.result.success", "description": ""}, {"name": "interaction_monad.result.exception", "description": ""}, {"name": "interaction_monad_return", "description": ""}, {"name": "interaction_monad_seq", "description": ""}, {"name": "interaction_monad.mk_exception", "description": ""}, {"name": "interaction_monad.monad", "description": ""}, {"name": "interaction_monad.failed", "description": ""}, {"name": "interaction_monad_fmap", "description": ""}, {"name": "interaction_monad_orelse", "description": ""}, {"name": "interaction_monad.result.clamp_pos", "description": ""}, {"name": "interaction_monad.bracket", "description": ""}, {"name": "interaction_monad.result_has_string", "description": ""}, {"name": "interaction_monad_bind", "description": ""}, {"name": "interaction_monad.monad_fail", "description": ""}, {"name": "interaction_monad.silent_fail", "description": ""}, {"name": "should_be_linted", "description": " `should_be_linted linter decl` returns true if `decl` should be checked\nusing `linter`, i.e., if there is no `nolint` attribute."}, {"name": "nolint_attr", "description": "Defines the user attribute `nolint` for skipping `#lint`"}, {"name": "tactic_doc.attribute.nolint", "description": "Defines the user attribute `nolint` for skipping `#lint`"}, {"name": "tactic_doc.attribute.linter", "description": " Defines the user attribute `linter` for adding a linter to the default set.\nLinters should be defined in the `linter` namespace.\nA linter `linter.my_new_linter` is referred to as `my_new_linter` (without the `linter` namespace)\nwhen used in `#lint`."}, {"name": "linter_attr", "description": " Defines the user attribute `linter` for adding a linter to the default set.\nLinters should be defined in the `linter` namespace.\nA linter `linter.my_new_linter` is referred to as `my_new_linter` (without the `linter` namespace)\nwhen used in `#lint`."}, {"name": "linter", "description": "A linting test for the `#lint` command.\n\n`test` defines a test to perform on every declaration. It should never fail. Returning `none`\nsignifies a passing test. Returning `some msg` reports a failing test with error `msg`.\n\n`no_errors_found` is the message printed when all tests are negative, and `errors_found` is printed\nwhen at least one test is positive.\n\nIf `is_fast` is false, this test will be omitted from `#lint-`.\n\nIf `auto_decls` is true, this test will also be executed on automatically generated declarations."}, {"name": "linter.test", "description": "A linting test for the `#lint` command.\n\n`test` defines a test to perform on every declaration. It should never fail. Returning `none`\nsignifies a passing test. Returning `some msg` reports a failing test with error `msg`.\n\n`no_errors_found` is the message printed when all tests are negative, and `errors_found` is printed\nwhen at least one test is positive.\n\nIf `is_fast` is false, this test will be omitted from `#lint-`.\n\nIf `auto_decls` is true, this test will also be executed on automatically generated declarations."}, {"name": "linter.no_errors_found", "description": "A linting test for the `#lint` command.\n\n`test` defines a test to perform on every declaration. It should never fail. Returning `none`\nsignifies a passing test. Returning `some msg` reports a failing test with error `msg`.\n\n`no_errors_found` is the message printed when all tests are negative, and `errors_found` is printed\nwhen at least one test is positive.\n\nIf `is_fast` is false, this test will be omitted from `#lint-`.\n\nIf `auto_decls` is true, this test will also be executed on automatically generated declarations."}, {"name": "linter.errors_found", "description": "A linting test for the `#lint` command.\n\n`test` defines a test to perform on every declaration. It should never fail. Returning `none`\nsignifies a passing test. Returning `some msg` reports a failing test with error `msg`.\n\n`no_errors_found` is the message printed when all tests are negative, and `errors_found` is printed\nwhen at least one test is positive.\n\nIf `is_fast` is false, this test will be omitted from `#lint-`.\n\nIf `auto_decls` is true, this test will also be executed on automatically generated declarations."}, {"name": "linter.is_fast", "description": "A linting test for the `#lint` command.\n\n`test` defines a test to perform on every declaration. It should never fail. Returning `none`\nsignifies a passing test. Returning `some msg` reports a failing test with error `msg`.\n\n`no_errors_found` is the message printed when all tests are negative, and `errors_found` is printed\nwhen at least one test is positive.\n\nIf `is_fast` is false, this test will be omitted from `#lint-`.\n\nIf `auto_decls` is true, this test will also be executed on automatically generated declarations."}, {"name": "linter.auto_decls", "description": "A linting test for the `#lint` command.\n\n`test` defines a test to perform on every declaration. It should never fail. Returning `none`\nsignifies a passing test. Returning `some msg` reports a failing test with error `msg`.\n\n`no_errors_found` is the message printed when all tests are negative, and `errors_found` is printed\nwhen at least one test is positive.\n\nIf `is_fast` is false, this test will be omitted from `#lint-`.\n\nIf `auto_decls` is true, this test will also be executed on automatically generated declarations."}, {"name": "get_linters", "description": " Takes a list of names that resolve to declarations of type `linter`,\nand produces a list of linters."}, {"name": "pi_subtype.can_lift'", "description": ""}, {"name": "pi.can_lift", "description": "Enable automatic handling of pi types in `can_lift`."}, {"name": "can_lift_attr", "description": "A user attribute used internally by the `lift` tactic.\nThis should not be applied by hand."}, {"name": "tactic.to_texpr", "description": "Parses a token \"to\" followed by a trailing `pexpr`."}, {"name": "tactic.interactive.lift", "description": "Lift an expression to another type.\n* Usage: `'lift' expr 'to' expr ('using' expr)? ('with' id (id id?)?)?`.\n* If `n : \u2124` and `hn : n \u2265 0` then the tactic `lift n to \u2115 using hn` creates a new\n  constant of type `\u2115`, also named `n` and replaces all occurrences of the old variable `(n : \u2124)`\n  with `\u2191n` (where `n` in the new variable). It will remove `n` and `hn` from the context.\n  + So for example the tactic `lift n to \u2115 using hn` transforms the goal\n    `n : \u2124, hn : n \u2265 0, h : P n \u22a2 n = 3` to `n : \u2115, h : P \u2191n \u22a2 \u2191n = 3`\n    (here `P` is some term of type `\u2124 \u2192 Prop`).\n* The argument `using hn` is optional, the tactic `lift n to \u2115` does the same, but also creates a\n  new subgoal that `n \u2265 0` (where `n` is the old variable).\n  + So for example the tactic `lift n to \u2115` transforms the goal\n    `n : \u2124, h : P n \u22a2 n = 3` to two goals\n    `n : \u2115, h : P \u2191n \u22a2 \u2191n = 3` and `n : \u2124, h : P n \u22a2 n \u2265 0`.\n* You can also use `lift n to \u2115 using e` where `e` is any expression of type `n \u2265 0`.\n* Use `lift n to \u2115 with k` to specify the name of the new variable.\n* Use `lift n to \u2115 with k hk` to also specify the name of the equality `\u2191k = n`. In this case, `n`\n  will remain in the context. You can use `rfl` for the name of `hk` to substitute `n` away\n  (i.e. the default behavior).\n* You can also use `lift e to \u2115 with k hk` where `e` is any expression of type `\u2124`.\n  In this case, the `hk` will always stay in the context, but it will be used to rewrite `e` in\n  all hypotheses and the target.\n  + So for example the tactic `lift n + 3 to \u2115 using hn with k hk` transforms the goal\n    `n : \u2124, hn : n + 3 \u2265 0, h : P (n + 3) \u22a2 n + 3 = 2 * n` to the goal\n    `n : \u2124, k : \u2115, hk : \u2191k = n + 3, h : P \u2191k \u22a2 \u2191k = 2 * n`.\n* The tactic `lift n to \u2115 using h` will remove `h` from the context. If you want to keep it,\n  specify it again as the third argument to `with`, like this: `lift n to \u2115 using h with n rfl h`.\n* More generally, this can lift an expression from `\u03b1` to `\u03b2` assuming that there is an instance\n  of `can_lift \u03b1 \u03b2`. In this case the proof obligation is specified by `can_lift.cond`.\n* Given an instance `can_lift \u03b2 \u03b3`, it can also lift `\u03b1 \u2192 \u03b2` to `\u03b1 \u2192 \u03b3`; more generally, given\n  `\u03b2 : \u03a0 a : \u03b1, Type*`, `\u03b3 : \u03a0 a : \u03b1, Type*`, and `[\u03a0 a : \u03b1, can_lift (\u03b2 a) (\u03b3 a)]`, it\n  automatically generates an instance `can_lift (\u03a0 a, \u03b2 a) (\u03a0 a, \u03b3 a)`.\n\n`lift` is in some sense dual to the `zify` tactic. `lift (z : \u2124) to \u2115` will change the type of an\ninteger `z` (in the supertype) to `\u2115` (the subtype), given a proof that `z \u2265 0`;\npropositions concerning `z` will still be over `\u2124`. `zify` changes propositions about `\u2115` (the\nsubtype) to propositions about `\u2124` (the supertype), without changing the type of any variable."}, {"name": "subtype.exists_pi_extension", "description": ""}, {"name": "can_lift", "description": "A class specifying that you can lift elements from `\u03b1` to `\u03b2` assuming `cond` is true.\n Used by the tactic `lift`."}, {"name": "can_lift.coe", "description": "A class specifying that you can lift elements from `\u03b1` to `\u03b2` assuming `cond` is true.\n Used by the tactic `lift`."}, {"name": "can_lift.cond", "description": "A class specifying that you can lift elements from `\u03b1` to `\u03b2` assuming `cond` is true.\n Used by the tactic `lift`."}, {"name": "can_lift.prf", "description": "A class specifying that you can lift elements from `\u03b1` to `\u03b2` assuming `cond` is true.\n Used by the tactic `lift`."}, {"name": "tactic.lift", "description": "Lift the expression `p` to the type `t`, with proof obligation given by `h`.\n The list `n` is used for the two newly generated names, and to specify whether `h` should\n remain in the local context. See the doc string of `tactic.interactive.lift` for more information."}, {"name": "subtype.can_lift", "description": ""}, {"name": "pi_subtype.can_lift", "description": ""}, {"name": "tactic_doc.tactic.lift", "description": "Lift an expression to another type.\n* Usage: `'lift' expr 'to' expr ('using' expr)? ('with' id (id id?)?)?`.\n* If `n : \u2124` and `hn : n \u2265 0` then the tactic `lift n to \u2115 using hn` creates a new\n  constant of type `\u2115`, also named `n` and replaces all occurrences of the old variable `(n : \u2124)`\n  with `\u2191n` (where `n` in the new variable). It will remove `n` and `hn` from the context.\n  + So for example the tactic `lift n to \u2115 using hn` transforms the goal\n    `n : \u2124, hn : n \u2265 0, h : P n \u22a2 n = 3` to `n : \u2115, h : P \u2191n \u22a2 \u2191n = 3`\n    (here `P` is some term of type `\u2124 \u2192 Prop`).\n* The argument `using hn` is optional, the tactic `lift n to \u2115` does the same, but also creates a\n  new subgoal that `n \u2265 0` (where `n` is the old variable).\n  + So for example the tactic `lift n to \u2115` transforms the goal\n    `n : \u2124, h : P n \u22a2 n = 3` to two goals\n    `n : \u2115, h : P \u2191n \u22a2 \u2191n = 3` and `n : \u2124, h : P n \u22a2 n \u2265 0`.\n* You can also use `lift n to \u2115 using e` where `e` is any expression of type `n \u2265 0`.\n* Use `lift n to \u2115 with k` to specify the name of the new variable.\n* Use `lift n to \u2115 with k hk` to also specify the name of the equality `\u2191k = n`. In this case, `n`\n  will remain in the context. You can use `rfl` for the name of `hk` to substitute `n` away\n  (i.e. the default behavior).\n* You can also use `lift e to \u2115 with k hk` where `e` is any expression of type `\u2124`.\n  In this case, the `hk` will always stay in the context, but it will be used to rewrite `e` in\n  all hypotheses and the target.\n  + So for example the tactic `lift n + 3 to \u2115 using hn with k hk` transforms the goal\n    `n : \u2124, hn : n + 3 \u2265 0, h : P (n + 3) \u22a2 n + 3 = 2 * n` to the goal\n    `n : \u2124, k : \u2115, hk : \u2191k = n + 3, h : P \u2191k \u22a2 \u2191k = 2 * n`.\n* The tactic `lift n to \u2115 using h` will remove `h` from the context. If you want to keep it,\n  specify it again as the third argument to `with`, like this: `lift n to \u2115 using h with n rfl h`.\n* More generally, this can lift an expression from `\u03b1` to `\u03b2` assuming that there is an instance\n  of `can_lift \u03b1 \u03b2`. In this case the proof obligation is specified by `can_lift.cond`.\n* Given an instance `can_lift \u03b2 \u03b3`, it can also lift `\u03b1 \u2192 \u03b2` to `\u03b1 \u2192 \u03b3`; more generally, given\n  `\u03b2 : \u03a0 a : \u03b1, Type*`, `\u03b3 : \u03a0 a : \u03b1, Type*`, and `[\u03a0 a : \u03b1, can_lift (\u03b2 a) (\u03b3 a)]`, it\n  automatically generates an instance `can_lift (\u03a0 a, \u03b2 a) (\u03a0 a, \u03b3 a)`.\n\n`lift` is in some sense dual to the `zify` tactic. `lift (z : \u2124) to \u2115` will change the type of an\ninteger `z` (in the supertype) to `\u2115` (the subtype), given a proof that `z \u2265 0`;\npropositions concerning `z` will still be over `\u2124`. `zify` changes propositions about `\u2115` (the\nsubtype) to propositions about `\u2124` (the supertype), without changing the type of any variable."}, {"name": "tactic.using_texpr", "description": "Parses an optional token \"using\" followed by a trailing `pexpr`."}, {"name": "nat.can_lift", "description": ""}, {"name": "tactic.get_lift_prf", "description": "Construct the proof of `cond x` in the lift tactic.\n*  `e` is the expression being lifted and `h` is the specified proof of `can_lift.cond e`.\n*  `old_tp` and `new_tp` are the arguments to `can_lift` and `inst` is the `can_lift`-instance.\n*  `s` and `to_unfold` contain the information of the simp set used to simplify.\n\nIf the proof was specified, we check whether it has the correct type.\nIf it doesn't have the correct type, we display an error message\n(but first call dsimp on the expression in the message).\n\nIf the proof was not specified, we create assert it as a local constant.\n(The name of this local constant doesn't matter, since `lift` will remove it from the context.)"}, {"name": "prod.id_prod", "description": ""}, {"name": "prod.lex.is_trans", "description": ""}, {"name": "prod.swap_injective", "description": ""}, {"name": "prod.forall", "description": ""}, {"name": "function.left_inverse.prod_map", "description": ""}, {"name": "prod.lex.decidable", "description": ""}, {"name": "prod.lex.refl_left", "description": ""}, {"name": "prod.map_snd'", "description": ""}, {"name": "prod.map_fst'", "description": ""}, {"name": "prod.lex.refl_right", "description": ""}, {"name": "function.bijective.prod_map", "description": ""}, {"name": "prod.is_refl_left", "description": ""}, {"name": "prod.swap_surjective", "description": ""}, {"name": "function.right_inverse.prod_map", "description": ""}, {"name": "prod.swap_swap", "description": ""}, {"name": "prod.map_fst", "description": ""}, {"name": "prod.map_id", "description": ""}, {"name": "prod.mk.inj_right", "description": ""}, {"name": "prod.snd_eq_iff", "description": ""}, {"name": "prod.lex.is_antisymm", "description": ""}, {"name": "prod.fst_comp_mk", "description": ""}, {"name": "prod.fst_surjective", "description": ""}, {"name": "prod.mk.inj_iff", "description": ""}, {"name": "prod.eq_iff_fst_eq_snd_eq", "description": ""}, {"name": "prod.swap_swap_eq", "description": ""}, {"name": "prod.lex.trans", "description": ""}, {"name": "prod.exists'", "description": ""}, {"name": "prod.fst_swap", "description": ""}, {"name": "prod.forall'", "description": ""}, {"name": "prod_map", "description": ""}, {"name": "prod.swap_left_inverse", "description": ""}, {"name": "prod.snd_injective", "description": ""}, {"name": "prod.swap_inj", "description": ""}, {"name": "prod.ext", "description": ""}, {"name": "prod.map_snd", "description": ""}, {"name": "prod.snd_surjective", "description": ""}, {"name": "prod.is_total_left", "description": ""}, {"name": "function.surjective.prod_map", "description": ""}, {"name": "prod.snd_swap", "description": ""}, {"name": "prod.is_refl_right", "description": ""}, {"name": "prod.ext_iff", "description": ""}, {"name": "prod.swap_prod_mk", "description": ""}, {"name": "function.injective.prod_map", "description": ""}, {"name": "prod.map_map", "description": "Composing a `prod.map` with another `prod.map` is equal to\na single `prod.map` of composed functions, fully applied."}, {"name": "prod.swap", "description": "Swap the factors of a product. `swap (a, b) = (b, a)`"}, {"name": "prod.lex_def", "description": ""}, {"name": "prod.map_def", "description": ""}, {"name": "prod.mk.inj_left", "description": ""}, {"name": "prod.map_mk", "description": ""}, {"name": "prod.is_total_right", "description": ""}, {"name": "prod.map_comp_map", "description": "Composing a `prod.map` with another `prod.map` is equal to\na single `prod.map` of composed functions."}, {"name": "prod.swap_bijective", "description": ""}, {"name": "prod.fst_injective", "description": ""}, {"name": "prod.swap_right_inverse", "description": ""}, {"name": "prod.snd_comp_mk", "description": ""}, {"name": "prod.exists", "description": ""}, {"name": "prod.fst_eq_iff", "description": ""}, {"name": "function.involutive.prod_map", "description": ""}, {"name": "has_monad_lift_t_trans", "description": ""}, {"name": "monad_lift_refl", "description": ""}, {"name": "monad_map_refl", "description": ""}, {"name": "monad_functor_t_trans", "description": ""}, {"name": "has_monad_lift", "description": "A function for lifting a computation from an inner monad to an outer monad.\n   Like [MonadTrans](https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Class.html),\n   but `n` does not have to be a monad transformer.\n   Alternatively, an implementation of [MonadLayer](https://hackage.haskell.org/package/layers-0.1/docs/Control-Monad-Layer.html#t:MonadLayer) without `layerInvmap` (so far)."}, {"name": "has_monad_lift.monad_lift", "description": "A function for lifting a computation from an inner monad to an outer monad.\n   Like [MonadTrans](https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Class.html),\n   but `n` does not have to be a monad transformer.\n   Alternatively, an implementation of [MonadLayer](https://hackage.haskell.org/package/layers-0.1/docs/Control-Monad-Layer.html#t:MonadLayer) without `layerInvmap` (so far)."}, {"name": "has_monad_lift_to_has_coe", "description": "A coercion that may reduce the need for explicit lifting.\n   Because of [limitations of the current coercion resolution](https://github.com/leanprover/lean/issues/1402), this definition is not marked as a global instance and should be marked locally instead."}, {"name": "monad_functor", "description": "A functor in the category of monads. Can be used to lift monad-transforming functions.\n   Based on pipes' [MFunctor](https://hackage.haskell.org/package/pipes-2.4.0/docs/Control-MFunctor.html),\n   but not restricted to monad transformers.\n   Alternatively, an implementation of [MonadTransFunctor](http://duairc.netsoc.ie/layers-docs/Control-Monad-Layer.html#t:MonadTransFunctor)."}, {"name": "monad_functor.monad_map", "description": "A functor in the category of monads. Can be used to lift monad-transforming functions.\n   Based on pipes' [MFunctor](https://hackage.haskell.org/package/pipes-2.4.0/docs/Control-MFunctor.html),\n   but not restricted to monad transformers.\n   Alternatively, an implementation of [MonadTransFunctor](http://duairc.netsoc.ie/layers-docs/Control-Monad-Layer.html#t:MonadTransFunctor)."}, {"name": "monad_functor_t", "description": "The reflexive-transitive closure of `monad_functor`.\n   `monad_map` is used to transitively lift monad morphisms such as `state_t.zoom`.\n   A generalization of [MonadLiftFunctor](http://duairc.netsoc.ie/layers-docs/Control-Monad-Layer.html#t:MonadLiftFunctor), which can only lift endomorphisms (i.e. m = m', n = n')."}, {"name": "monad_functor_t.monad_map", "description": "The reflexive-transitive closure of `monad_functor`.\n   `monad_map` is used to transitively lift monad morphisms such as `state_t.zoom`.\n   A generalization of [MonadLiftFunctor](http://duairc.netsoc.ie/layers-docs/Control-Monad-Layer.html#t:MonadLiftFunctor), which can only lift endomorphisms (i.e. m = m', n = n')."}, {"name": "has_monad_lift_t_refl", "description": ""}, {"name": "monad_functor_t_refl", "description": ""}, {"name": "has_monad_lift_t", "description": "The reflexive-transitive closure of `has_monad_lift`.\n   `monad_lift` is used to transitively lift monadic computations such as `state_t.get` or `state_t.put s`.\n   Corresponds to [MonadLift](https://hackage.haskell.org/package/layers-0.1/docs/Control-Monad-Layer.html#t:MonadLift)."}, {"name": "has_monad_lift_t.monad_lift", "description": "The reflexive-transitive closure of `has_monad_lift`.\n   `monad_lift` is used to transitively lift monadic computations such as `state_t.get` or `state_t.put s`.\n   Corresponds to [MonadLift](https://hackage.haskell.org/package/layers-0.1/docs/Control-Monad-Layer.html#t:MonadLift)."}, {"name": "monad_run", "description": "Run a monad stack to completion.\n   `run` should be the composition of the transformers' individual `run` functions.\n   This class mostly saves some typing when using highly nested monad stacks:\n   ```lean\n   @[reducible] def my_monad := reader_t my_cfg $ state_t my_state $ except_t my_err id\n   -- def my_monad.run {\u03b1 : Type} (x : my_monad \u03b1) (cfg : my_cfg) (st : my_state) := ((x.run cfg).run st).run\n   def my_monad.run {\u03b1 : Type} (x : my_monad \u03b1) := monad_run.run x\n   ```"}, {"name": "monad_run.run", "description": "Run a monad stack to completion.\n   `run` should be the composition of the transformers' individual `run` functions.\n   This class mostly saves some typing when using highly nested monad stacks:\n   ```lean\n   @[reducible] def my_monad := reader_t my_cfg $ state_t my_state $ except_t my_err id\n   -- def my_monad.run {\u03b1 : Type} (x : my_monad \u03b1) (cfg : my_cfg) (st : my_state) := ((x.run cfg).run st).run\n   def my_monad.run {\u03b1 : Type} (x : my_monad \u03b1) := monad_run.run x\n   ```"}, {"name": "nat.lcm", "description": ""}, {"name": "nat.gcd_succ", "description": ""}, {"name": "nat.gcd_zero_left", "description": ""}, {"name": "nat.coprime", "description": ""}, {"name": "nat.gcd.induction", "description": ""}, {"name": "nat.gcd_one_left", "description": ""}, {"name": "nat.gcd", "description": ""}, {"name": "nat.gcd_zero_right", "description": ""}, {"name": "nat.gcd_rec", "description": ""}, {"name": "nat.gcd_self", "description": ""}, {"name": "nat.gcd_def", "description": ""}, {"name": "nat.not_succ_le_zero", "description": ""}, {"name": "nat.succ_eq_add_one", "description": ""}, {"name": "nat.sub", "description": ""}, {"name": "nat.le_of_succ_le_succ", "description": ""}, {"name": "nat.pred_le", "description": ""}, {"name": "nat.not_lt_zero", "description": ""}, {"name": "nat.zero_le", "description": ""}, {"name": "nat.has_mul", "description": ""}, {"name": "nat.lt_irrefl", "description": ""}, {"name": "nat.le_succ", "description": ""}, {"name": "nat.nat_zero_eq_zero", "description": ""}, {"name": "nat.le_trans", "description": ""}, {"name": "nat.succ_sub_succ_eq_sub", "description": ""}, {"name": "nat.zero_lt_succ", "description": ""}, {"name": "nat.add_succ", "description": ""}, {"name": "nat.has_dvd", "description": ""}, {"name": "nat.has_lt", "description": ""}, {"name": "nat.pred_le_pred", "description": ""}, {"name": "nat.succ_pos", "description": ""}, {"name": "nat.decidable_lt", "description": ""}, {"name": "nat.less_than_or_equal", "description": ""}, {"name": "nat.less_than_or_equal.refl", "description": ""}, {"name": "nat.less_than_or_equal.step", "description": ""}, {"name": "nat.mul", "description": ""}, {"name": "nat.le", "description": ""}, {"name": "nat.inhabited", "description": ""}, {"name": "nat.decidable_eq", "description": ""}, {"name": "nat.decidable_le", "description": ""}, {"name": "nat.succ_add", "description": ""}, {"name": "nat.add_zero", "description": ""}, {"name": "nat.has_le", "description": ""}, {"name": "nat.lt", "description": ""}, {"name": "nat.bit0_succ_eq", "description": ""}, {"name": "nat.eq_or_lt_of_le", "description": ""}, {"name": "nat.pred_lt", "description": ""}, {"name": "nat.zero_lt_bit1", "description": ""}, {"name": "nat.not_succ_le_self", "description": ""}, {"name": "nat.add_one", "description": ""}, {"name": "nat.lt_succ_of_le", "description": ""}, {"name": "nat.succ_le_succ", "description": ""}, {"name": "nat.repeat", "description": ""}, {"name": "nat.bit1_ne_zero", "description": ""}, {"name": "nat.le_refl", "description": ""}, {"name": "nat.sub_le", "description": ""}, {"name": "nat.pred", "description": ""}, {"name": "nat.sub_lt", "description": ""}, {"name": "nat.has_sub", "description": ""}, {"name": "nat.bit0_ne_zero", "description": ""}, {"name": "nat.lt_of_lt_of_le", "description": ""}, {"name": "nat.zero_add", "description": ""}, {"name": "nat.zero_lt_bit0", "description": ""}, {"name": "tactic.mk_assoc_pattern'", "description": ""}, {"name": "tactic.assoc_refl", "description": ""}, {"name": "tactic.assoc_rewrite_intl", "description": ""}, {"name": "tactic.match_assoc_pattern", "description": ""}, {"name": "tactic.assoc_root", "description": ""}, {"name": "tactic.match_assoc_pattern'", "description": ""}, {"name": "tactic.enum_assoc_subexpr", "description": ""}, {"name": "tactic.assoc_refl'", "description": ""}, {"name": "tactic.fill_args", "description": ""}, {"name": "tactic.interactive.assoc_rw", "description": "synonym for `assoc_rewrite`"}, {"name": "tactic.mk_assoc_pattern", "description": ""}, {"name": "tactic.enum_assoc_subexpr'", "description": ""}, {"name": "tactic.assoc_rewrite", "description": ""}, {"name": "tactic.assoc_rewrite_hyp", "description": ""}, {"name": "tactic.mk_assoc", "description": ""}, {"name": "tactic.interactive.assoc_rewrite", "description": "`assoc_rewrite [h\u2080,\u2190 h\u2081] at \u22a2 h\u2082` behaves like `rewrite [h\u2080,\u2190 h\u2081] at \u22a2 h\u2082`\nwith the exception that associativity is used implicitly to make rewriting\npossible.\n\nIt works for any function `f` for which an `is_associative f` instance can be found.\n\n```lean\nexample {\u03b1 : Type*} (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) [is_associative \u03b1 f] (a b c d x : \u03b1) :\n  let infix `~` := f in\n  b ~ c = x \u2192 (a ~ b ~ c ~ d) = (a ~ x ~ d) :=\nbegin\n  intro h,\n  assoc_rw h,\nend\n```"}, {"name": "tactic_doc.tactic.assoc_rewrite", "description": "`assoc_rewrite [h\u2080,\u2190 h\u2081] at \u22a2 h\u2082` behaves like `rewrite [h\u2080,\u2190 h\u2081] at \u22a2 h\u2082`\nwith the exception that associativity is used implicitly to make rewriting\npossible.\n\nIt works for any function `f` for which an `is_associative f` instance can be found.\n\n```lean\nexample {\u03b1 : Type*} (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) [is_associative \u03b1 f] (a b c d x : \u03b1) :\n  let infix `~` := f in\n  b ~ c = x \u2192 (a ~ b ~ c ~ d) = (a ~ x ~ d) :=\nbegin\n  intro h,\n  assoc_rw h,\nend\n```"}, {"name": "tactic.mk_assoc_instance", "description": ""}, {"name": "tactic.chain_eq_trans", "description": ""}, {"name": "tactic.id_tag.assoc_proof", "description": "Tag for proofs generated by `assoc_rewrite`."}, {"name": "tactic.flatten", "description": ""}, {"name": "tactic.unify_prefix", "description": ""}, {"name": "tactic.mk_eq_proof", "description": ""}, {"name": "tactic.assoc_rewrite_target", "description": ""}, {"name": "tactic.match_fn", "description": ""}, {"name": "id.is_lawful_traversable", "description": ""}, {"name": "applicative_transformation.preserves_map", "description": ""}, {"name": "option.traversable", "description": ""}, {"name": "applicative_transformation", "description": " A transformation between applicative functors.  It is a natural\ntransformation such that `app` preserves the `has_pure.pure` and\n`functor.map` (`<*>`) operations. See\n`applicative_transformation.preserves_map` for naturality."}, {"name": "applicative_transformation.app", "description": " A transformation between applicative functors.  It is a natural\ntransformation such that `app` preserves the `has_pure.pure` and\n`functor.map` (`<*>`) operations. See\n`applicative_transformation.preserves_map` for naturality."}, {"name": "applicative_transformation.preserves_pure'", "description": " A transformation between applicative functors.  It is a natural\ntransformation such that `app` preserves the `has_pure.pure` and\n`functor.map` (`<*>`) operations. See\n`applicative_transformation.preserves_map` for naturality."}, {"name": "applicative_transformation.preserves_seq'", "description": " A transformation between applicative functors.  It is a natural\ntransformation such that `app` preserves the `has_pure.pure` and\n`functor.map` (`<*>`) operations. See\n`applicative_transformation.preserves_map` for naturality."}, {"name": "applicative_transformation.inhabited", "description": ""}, {"name": "applicative_transformation.coe_inj", "description": ""}, {"name": "applicative_transformation.coe_mk", "description": ""}, {"name": "applicative_transformation.preserves_map'", "description": ""}, {"name": "applicative_transformation.congr_fun", "description": ""}, {"name": "applicative_transformation.comp_apply", "description": ""}, {"name": "applicative_transformation.id_comp", "description": ""}, {"name": "applicative_transformation.preserves_seq", "description": ""}, {"name": "list.traversable", "description": ""}, {"name": "applicative_transformation.ext", "description": ""}, {"name": "applicative_transformation.comp_id", "description": ""}, {"name": "is_lawful_traversable", "description": " A traversable functor is lawful if its `traverse` satisfies a\nnumber of additional properties.  It must send `id.mk` to `id.mk`,\nsend the composition of applicative functors to the composition of the\n`traverse` of each, send each function `f` to `\u03bb x, f <$> x`, and\nsatisfy a naturality condition with respect to applicative\ntransformations."}, {"name": "is_lawful_traversable.to_is_lawful_functor", "description": " A traversable functor is lawful if its `traverse` satisfies a\nnumber of additional properties.  It must send `id.mk` to `id.mk`,\nsend the composition of applicative functors to the composition of the\n`traverse` of each, send each function `f` to `\u03bb x, f <$> x`, and\nsatisfy a naturality condition with respect to applicative\ntransformations."}, {"name": "is_lawful_traversable.id_traverse", "description": " A traversable functor is lawful if its `traverse` satisfies a\nnumber of additional properties.  It must send `id.mk` to `id.mk`,\nsend the composition of applicative functors to the composition of the\n`traverse` of each, send each function `f` to `\u03bb x, f <$> x`, and\nsatisfy a naturality condition with respect to applicative\ntransformations."}, {"name": "is_lawful_traversable.comp_traverse", "description": " A traversable functor is lawful if its `traverse` satisfies a\nnumber of additional properties.  It must send `id.mk` to `id.mk`,\nsend the composition of applicative functors to the composition of the\n`traverse` of each, send each function `f` to `\u03bb x, f <$> x`, and\nsatisfy a naturality condition with respect to applicative\ntransformations."}, {"name": "is_lawful_traversable.traverse_eq_map_id", "description": " A traversable functor is lawful if its `traverse` satisfies a\nnumber of additional properties.  It must send `id.mk` to `id.mk`,\nsend the composition of applicative functors to the composition of the\n`traverse` of each, send each function `f` to `\u03bb x, f <$> x`, and\nsatisfy a naturality condition with respect to applicative\ntransformations."}, {"name": "is_lawful_traversable.naturality", "description": " A traversable functor is lawful if its `traverse` satisfies a\nnumber of additional properties.  It must send `id.mk` to `id.mk`,\nsend the composition of applicative functors to the composition of the\n`traverse` of each, send each function `f` to `\u03bb x, f <$> x`, and\nsatisfy a naturality condition with respect to applicative\ntransformations."}, {"name": "applicative_transformation.has_coe_to_fun", "description": ""}, {"name": "applicative_transformation.congr_arg", "description": ""}, {"name": "sum.traverse", "description": " Defines a `traverse` function on the second component of a sum type.\nThis is used to give a `traversable` instance for the functor `\u03c3 \u2295 -`."}, {"name": "applicative_transformation.comp", "description": "The composition of applicative transformations."}, {"name": "applicative_transformation.ext_iff", "description": ""}, {"name": "traversable", "description": " A traversable functor is a functor along with a way to commute\nwith all applicative functors (see `sequence`).  For example, if `t`\nis the traversable functor `list` and `m` is the applicative functor\n`io`, then given a function `f : \u03b1 \u2192 io \u03b2`, the function `functor.map f` is\n`list \u03b1 \u2192 list (io \u03b2)`, but `traverse f` is `list \u03b1 \u2192 io (list \u03b2)`."}, {"name": "traversable.to_functor", "description": " A traversable functor is a functor along with a way to commute\nwith all applicative functors (see `sequence`).  For example, if `t`\nis the traversable functor `list` and `m` is the applicative functor\n`io`, then given a function `f : \u03b1 \u2192 io \u03b2`, the function `functor.map f` is\n`list \u03b1 \u2192 list (io \u03b2)`, but `traverse f` is `list \u03b1 \u2192 io (list \u03b2)`."}, {"name": "traversable.traverse", "description": " A traversable functor is a functor along with a way to commute\nwith all applicative functors (see `sequence`).  For example, if `t`\nis the traversable functor `list` and `m` is the applicative functor\n`io`, then given a function `f : \u03b1 \u2192 io \u03b2`, the function `functor.map f` is\n`list \u03b1 \u2192 list (io \u03b2)`, but `traverse f` is `list \u03b1 \u2192 io (list \u03b2)`."}, {"name": "sequence", "description": "A traversable functor commutes with all applicative functors."}, {"name": "applicative_transformation.id_transformation", "description": "The identity applicative transformation from an applicative functor to itself."}, {"name": "applicative_transformation.preserves_pure", "description": ""}, {"name": "sum.traversable", "description": ""}, {"name": "id.traversable", "description": ""}, {"name": "applicative_transformation.comp_assoc", "description": ""}, {"name": "applicative_transformation.app_eq_coe", "description": ""}, {"name": "rat.lt_one_iff_num_lt_denom", "description": ""}, {"name": "rat.num_nonneg_iff_zero_le", "description": ""}, {"name": "rat.nonneg_antisymm", "description": ""}, {"name": "rat.has_inf", "description": ""}, {"name": "rat.ordered_semiring", "description": ""}, {"name": "rat.ordered_ring", "description": ""}, {"name": "rat.linear_ordered_add_comm_group", "description": ""}, {"name": "rat.preorder", "description": ""}, {"name": "rat.num_pos_iff_pos", "description": ""}, {"name": "rat.le_trans", "description": ""}, {"name": "rat.partial_order", "description": ""}, {"name": "rat.nonneg_add", "description": ""}, {"name": "rat.le", "description": " Relation `a \u2264 b` on `\u211a` defined as `a \u2264 b \u2194 rat.nonneg (b - a)`. Use `a \u2264 b` instead of\n`rat.le a b`."}, {"name": "rat.linear_ordered_ring", "description": ""}, {"name": "rat.nonneg_total", "description": ""}, {"name": "rat.linear_order", "description": ""}, {"name": "rat.linear_ordered_comm_ring", "description": ""}, {"name": "rat.le_antisymm", "description": ""}, {"name": "rat.distrib_lattice", "description": ""}, {"name": "rat.le_def", "description": ""}, {"name": "rat.le_def'", "description": ""}, {"name": "rat.le_total", "description": ""}, {"name": "rat.lt_def", "description": ""}, {"name": "rat.decidable_nonneg", "description": ""}, {"name": "rat.nonneg", "description": "A rational number is called nonnegative if its numerator is nonnegative."}, {"name": "rat.has_sup", "description": ""}, {"name": "rat.decidable_le", "description": ""}, {"name": "rat.nonneg_mul", "description": ""}, {"name": "rat.ordered_cancel_add_comm_monoid", "description": ""}, {"name": "rat.nonneg_iff_zero_le", "description": ""}, {"name": "rat.mul_nonneg", "description": ""}, {"name": "rat.has_lt", "description": ""}, {"name": "rat.ordered_add_comm_monoid", "description": ""}, {"name": "rat.abs_def", "description": ""}, {"name": "rat.mk_nonneg", "description": ""}, {"name": "rat.linear_ordered_semiring", "description": ""}, {"name": "rat.le_refl", "description": ""}, {"name": "rat.div_lt_div_iff_mul_lt_mul", "description": ""}, {"name": "rat.ordered_add_comm_group", "description": ""}, {"name": "rat.semilattice_inf", "description": ""}, {"name": "rat.lattice", "description": ""}, {"name": "rat.has_le", "description": ""}, {"name": "rat.semilattice_sup", "description": ""}, {"name": "rat.add_le_add_left", "description": ""}, {"name": "rat.linear_ordered_field", "description": ""}, {"name": "list.lex.is_strict_total_order", "description": ""}, {"name": "list.lex.ne_iff", "description": ""}, {"name": "list.lex.is_asymm", "description": ""}, {"name": "list.lex.to_ne", "description": ""}, {"name": "list.has_lt'", "description": ""}, {"name": "list.has_le'", "description": ""}, {"name": "list.lex.append_left", "description": ""}, {"name": "list.lex.append_right", "description": ""}, {"name": "list.lex.imp", "description": ""}, {"name": "list.lex.cons_iff", "description": ""}, {"name": "list.nil_lt_cons", "description": ""}, {"name": "decidable.list.lex.ne_iff", "description": ""}, {"name": "list.lex.is_trichotomous", "description": ""}, {"name": "list.lex.is_order_connected", "description": ""}, {"name": "list.linear_order", "description": ""}, {"name": "list.lex.not_nil_right", "description": ""}, {"name": "list.lex", "description": " Given a strict order `<` on `\u03b1`, the lexicographic strict order on `list \u03b1`, for which\n`[a0, ..., an] < [b0, ..., b_k]` if `a0 < b0` or `a0 = b0` and `[a1, ..., an] < [b1, ..., bk]`.\nThe definition is given for any relation `r`, not only strict orders."}, {"name": "list.lex.nil", "description": " Given a strict order `<` on `\u03b1`, the lexicographic strict order on `list \u03b1`, for which\n`[a0, ..., an] < [b0, ..., b_k]` if `a0 < b0` or `a0 = b0` and `[a1, ..., an] < [b1, ..., bk]`.\nThe definition is given for any relation `r`, not only strict orders."}, {"name": "list.lex.cons", "description": " Given a strict order `<` on `\u03b1`, the lexicographic strict order on `list \u03b1`, for which\n`[a0, ..., an] < [b0, ..., b_k]` if `a0 < b0` or `a0 = b0` and `[a1, ..., an] < [b1, ..., bk]`.\nThe definition is given for any relation `r`, not only strict orders."}, {"name": "list.lex.rel", "description": " Given a strict order `<` on `\u03b1`, the lexicographic strict order on `list \u03b1`, for which\n`[a0, ..., an] < [b0, ..., b_k]` if `a0 < b0` or `a0 = b0` and `[a1, ..., an] < [b1, ..., bk]`.\nThe definition is given for any relation `r`, not only strict orders."}, {"name": "list.lex.decidable_rel", "description": ""}, {"name": "option.bind", "description": ""}, {"name": "option.orelse", "description": ""}, {"name": "option.is_none", "description": ""}, {"name": "option.rhoare", "description": ""}, {"name": "option.to_monad", "description": ""}, {"name": "option.map", "description": ""}, {"name": "option.map_id", "description": ""}, {"name": "option.inhabited", "description": ""}, {"name": "option.get", "description": ""}, {"name": "option.lhoare", "description": ""}, {"name": "option.alternative", "description": ""}, {"name": "option.is_some", "description": ""}, {"name": "option.monad", "description": ""}, {"name": "option.get_or_else", "description": ""}, {"name": "option.decidable_eq", "description": ""}, {"name": "tactic.pi_instance", "description": "`pi_instance` constructs an instance of `my_class (\u03a0 i : I, f i)`\nwhere we know `\u03a0 i, my_class (f i)`. If an order relation is required,\nit defaults to `pi.partial_order`. Any field of the instance that\n`pi_instance` cannot construct is left untouched and generated as a new goal."}, {"name": "tactic_doc.tactic.pi_instance", "description": "`pi_instance` constructs an instance of `my_class (\u03a0 i : I, f i)`\nwhere we know `\u03a0 i, my_class (f i)`. If an order relation is required,\nit defaults to `pi.partial_order`. Any field of the instance that\n`pi_instance` cannot construct is left untouched and generated as a new goal."}, {"name": "tactic.pi_instance_derive_field", "description": "Attempt to clear a goal obtained by refining a `pi_instance` goal."}, {"name": "tactic.interactive.pi_instance", "description": "`pi_instance` constructs an instance of `my_class (\u03a0 i : I, f i)`\nwhere we know `\u03a0 i, my_class (f i)`. If an order relation is required,\nit defaults to `pi.partial_order`. Any field of the instance that\n`pi_instance` cannot construct is left untouched and generated as a new goal."}, {"name": "well_founded.is_asymm", "description": ""}, {"name": "well_founded.well_founded_iff_has_max'", "description": ""}, {"name": "well_founded.self_le_of_strict_mono", "description": ""}, {"name": "well_founded.has_min", "description": " If `r` is a well-founded relation, then any nonempty set has a minimal element\nwith respect to `r`."}, {"name": "function.not_lt_argmin", "description": ""}, {"name": "well_founded.well_founded_iff_has_min'", "description": ""}, {"name": "well_founded.eq_strict_mono_iff_eq_range", "description": ""}, {"name": "well_founded.is_irrefl", "description": ""}, {"name": "well_founded.has_well_founded.r.is_irrefl", "description": ""}, {"name": "well_founded.eq_iff_not_lt_of_le", "description": ""}, {"name": "function.not_lt_argmin_on", "description": ""}, {"name": "well_founded.sup", "description": "The supremum of a bounded, well-founded order"}, {"name": "function.argmin_on", "description": " Given a function `f : \u03b1 \u2192 \u03b2` where `\u03b2` carries a well-founded `<`, and a non-empty subset `s`\nof `\u03b1`, this is an element of `s` whose image under `f` is minimal in the sense of\n`function.not_lt_argmin_on`."}, {"name": "well_founded.lt_succ_iff", "description": ""}, {"name": "well_founded.not_lt_min", "description": ""}, {"name": "well_founded.has_well_founded.r.is_asymm", "description": ""}, {"name": "function.argmin_on_mem", "description": ""}, {"name": "function.argmin", "description": " Given a function `f : \u03b1 \u2192 \u03b2` where `\u03b2` carries a well-founded `<`, this is an element of `\u03b1`\nwhose image under `f` is minimal in the sense of `function.not_lt_argmin`."}, {"name": "well_founded.succ", "description": " A successor of an element `x` in a well-founded order is a minimal element `y` such that\n`x < y` if one exists. Otherwise it is `x` itself."}, {"name": "well_founded.lt_succ", "description": ""}, {"name": "function.argmin_on_le", "description": ""}, {"name": "function.argmin_le", "description": ""}, {"name": "well_founded.well_founded_iff_has_min", "description": ""}, {"name": "well_founded.min", "description": " A minimal element of a nonempty set in a well-founded order.\n\nIf you're working with a nonempty linear order, consider defining a\n`conditionally_complete_linear_order_bot` instance via\n`well_founded.conditionally_complete_linear_order_with_bot` and using `Inf` instead."}, {"name": "well_founded.min_mem", "description": ""}, {"name": "well_founded.min_le", "description": ""}, {"name": "well_founded.lt_sup", "description": ""}, {"name": "doubleround.doubleround_is_inv", "description": "For any `doubleround` output, we can get back to original values using the defined inverse."}, {"name": "doubleround.input", "description": "An input of this form should be invariant."}, {"name": "doubleround.carry_diff_doubleround_for_any_row_and_value", "description": "Proof that the difference is carried after `doubleround` for any row and any value of the input matrices.\nNote:\n- This lemma just prove this for the first row and the first value but it can be generalized after\n`rowround_after_columnround_difference_is_carried`."}, {"name": "doubleround.cat_doubleround", "description": "rowround \u226b columnround"}, {"name": "doubleround.doubleround_is_isomorphic", "description": " Two morphism `doubleround` and `doubleround\u207b\u00b9` are isomorphic if:\n- `doubleround \u2218 doubleround\u207b\u00b9 = \ud835\udfd9 doubleround`, and\n- `doubleround\u207b\u00b9 \u2218 doubleround = \ud835\udfd9 doubleround\u207b\u00b9`."}, {"name": "doubleround.rowround_after_columnround_difference_is_carried", "description": "Prove that the difference is carried for the first output from the first row of the matrix for random and\ncrafted inputs when `rowround` is applied after `columnround`.\n\nNote:\n\n- It can be repeated or generalized for all matrix positions."}, {"name": "doubleround.doubleround'", "description": "A special case of `doubleround` where inputs and outputs are sorted according to the salsa20 spec:\ndoubleround'(x) = rowround'(columnround'(x))"}, {"name": "doubleround.doubleroundType", "description": "A `doubleroundType` structure is four `columnroundType \u226b rowroundType`s."}, {"name": "doubleround.doubleroundType.doubleround1", "description": "A `doubleroundType` structure is four `columnroundType \u226b rowroundType`s."}, {"name": "doubleround.doubleroundType.doubleround2", "description": "A `doubleroundType` structure is four `columnroundType \u226b rowroundType`s."}, {"name": "doubleround.doubleroundType.doubleround3", "description": "A `doubleroundType` structure is four `columnroundType \u226b rowroundType`s."}, {"name": "doubleround.doubleroundType.doubleround4", "description": "A `doubleroundType` structure is four `columnroundType \u226b rowroundType`s."}, {"name": "doubleround.isomorphism_left", "description": "Isomorphism condition 1 : `doubleround \u2218 doubleround\u207b\u00b9 = \ud835\udfd9 doubleround`"}, {"name": "doubleround.isomorphism_right", "description": "Isomorphism condition 2 : `doubleround\u207b\u00b9 \u2218 doubleround = \ud835\udfd9 doubleround\u207b\u00b9`"}, {"name": "doubleround.id_doubleround_inv", "description": "The identity of a `doubleround\u207b\u00b9` morphism given a sequence is the sequence."}, {"name": "doubleround.doubleround_is_inv'", "description": "For any `doubleround'` output, we can get back to original values using the defined inverse."}, {"name": "doubleround.id_doubleround", "description": "The identity of a `doubleround` morphism given a sequence is the sequence."}, {"name": "doubleround.doubleround_inv_is_inverse_of_doubleround", "description": "It is easy to see that `cat_doubleround\u207b\u00b9` after `cat_doubleround` produces the original object."}, {"name": "doubleround.doubleround_is_left_invariant", "description": "`doubleround` is left invariant."}, {"name": "doubleround.cat_doubleround_inv", "description": "columnround\u207b\u00b9 \u226b rowround\u207b\u00b9"}, {"name": "doubleround.doubleround_inv", "description": "doubleround_inv(x) = columnround_inv(rowround_inv(x))"}, {"name": "doubleround.doubleround", "description": "doubleround(x) = rowround(columnround(x))"}, {"name": "doubleround.doubleround_inv'", "description": "A special case of `doubleround_inv` where inputs and outputs are sorted according to the salsa20 spec:\ndoubleround_inv'(x) = columnround_inv'(rowround_inv'(x))"}, {"name": "list.subset_dedup", "description": ""}, {"name": "list.dedup_nil", "description": ""}, {"name": "list.sum_map_count_dedup_eq_length", "description": ""}, {"name": "list.dedup_subset", "description": ""}, {"name": "list.dedup_append", "description": ""}, {"name": "list.dedup_cons_of_not_mem", "description": ""}, {"name": "list.dedup_cons_of_mem'", "description": ""}, {"name": "list.mem_dedup", "description": ""}, {"name": "list.dedup_cons_of_mem", "description": ""}, {"name": "list.count_dedup", "description": ""}, {"name": "list.repeat_dedup", "description": ""}, {"name": "list.dedup_idempotent", "description": ""}, {"name": "list.dedup_sublist", "description": ""}, {"name": "list.nodup_dedup", "description": ""}, {"name": "list.sum_map_count_dedup_filter_eq_countp", "description": "Summing the count of `x` over a list filtered by some `p` is just `countp` applied to `p`"}, {"name": "list.nodup.dedup", "description": ""}, {"name": "list.dedup_eq_self", "description": ""}, {"name": "list.dedup_cons_of_not_mem'", "description": ""}, {"name": "guard", "description": "If the condition `p` is decided to be false, then fail, otherwise, return unit."}, {"name": "optional", "description": ""}, {"name": "alternative", "description": ""}, {"name": "alternative.to_applicative", "description": ""}, {"name": "alternative.to_has_orelse", "description": ""}, {"name": "alternative.failure", "description": ""}, {"name": "failure", "description": ""}, {"name": "assert", "description": ""}, {"name": "guardb", "description": ""}, {"name": "has_orelse", "description": ""}, {"name": "has_orelse.orelse", "description": ""}, {"name": "tactic.existsi", "description": ""}, {"name": "tactic.get_constructors_for", "description": ""}, {"name": "tactic.left", "description": ""}, {"name": "tactic.econstructor", "description": ""}, {"name": "tactic.constructor_idx", "description": ""}, {"name": "tactic.right", "description": ""}, {"name": "tactic.constructor", "description": ""}, {"name": "tactic.fconstructor", "description": ""}, {"name": "tactic.split", "description": ""}, {"name": "push_neg.not_eq", "description": ""}, {"name": "push_neg.not_le_eq", "description": ""}, {"name": "push_neg.normalize_negations", "description": ""}, {"name": "tactic_doc.tactic.push_neg", "description": "Push negations in the goal of some assumption.\n\nFor instance, a hypothesis `h : \u00ac \u2200 x, \u2203 y, x \u2264 y` will be transformed by `push_neg at h` into\n`h : \u2203 x, \u2200 y, y < x`. Variables names are conserved.\n\nThis tactic pushes negations inside expressions. For instance, given an assumption\n```lean\nh : \u00ac \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x, |x - x\u2080| \u2264 \u03b4 \u2192 |f x - y\u2080| \u2264 \u03b5)\n```\nwriting `push_neg at h` will turn `h` into\n```lean\nh : \u2203 \u03b5, \u03b5 > 0 \u2227 \u2200 \u03b4, \u03b4 > 0 \u2192 (\u2203 x, |x - x\u2080| \u2264 \u03b4 \u2227 \u03b5 < |f x - y\u2080|),\n```\n\n(the pretty printer does *not* use the abreviations `\u2200 \u03b4 > 0` and `\u2203 \u03b5 > 0` but this issue\nhas nothing to do with `push_neg`).\nNote that names are conserved by this tactic, contrary to what would happen with `simp`\nusing the relevant lemmas. One can also use this tactic at the goal using `push_neg`,\nat every assumption and the goal using `push_neg at *` or at selected assumptions and the goal\nusing say `push_neg at h h' \u22a2` as usual."}, {"name": "push_neg.not_lt_eq", "description": ""}, {"name": "push_neg.whnf_reducible", "description": ""}, {"name": "push_neg.not_and_eq", "description": ""}, {"name": "push_neg.not_forall_eq", "description": ""}, {"name": "name_with_opt", "description": "Matches either an identifier \"h\" or a pair of identifiers \"h with k\""}, {"name": "push_neg.classical.implies_iff_not_or", "description": ""}, {"name": "push_neg.not_implies_eq", "description": ""}, {"name": "tactic_doc.tactic.contrapose", "description": "Transforms the goal into its contrapositive.\n\n* `contrapose`     turns a goal `P \u2192 Q` into `\u00ac Q \u2192 \u00ac P`\n* `contrapose!`    turns a goal `P \u2192 Q` into `\u00ac Q \u2192 \u00ac P` and pushes negations inside `P` and `Q`\n  using `push_neg`\n* `contrapose h`   first reverts the local assumption `h`, and then uses `contrapose` and `intro h`\n* `contrapose! h`  first reverts the local assumption `h`, and then uses `contrapose!` and `intro h`\n* `contrapose h with new_h` uses the name `new_h` for the introduced hypothesis"}, {"name": "push_neg.push_neg_at_goal", "description": ""}, {"name": "push_neg.push_neg_at_hyp", "description": ""}, {"name": "push_neg.not_exists_eq", "description": ""}, {"name": "push_neg.not_or_eq", "description": ""}, {"name": "push_neg.not_not_eq", "description": ""}, {"name": "tactic.interactive.contrapose", "description": "Transforms the goal into its contrapositive.\n\n* `contrapose`     turns a goal `P \u2192 Q` into `\u00ac Q \u2192 \u00ac P`\n* `contrapose!`    turns a goal `P \u2192 Q` into `\u00ac Q \u2192 \u00ac P` and pushes negations inside `P` and `Q`\n  using `push_neg`\n* `contrapose h`   first reverts the local assumption `h`, and then uses `contrapose` and `intro h`\n* `contrapose! h`  first reverts the local assumption `h`, and then uses `contrapose!` and `intro h`\n* `contrapose h with new_h` uses the name `new_h` for the introduced hypothesis"}, {"name": "tactic.interactive.push_neg", "description": "Push negations in the goal of some assumption.\n\nFor instance, a hypothesis `h : \u00ac \u2200 x, \u2203 y, x \u2264 y` will be transformed by `push_neg at h` into\n`h : \u2203 x, \u2200 y, y < x`. Variables names are conserved.\n\nThis tactic pushes negations inside expressions. For instance, given an assumption\n```lean\nh : \u00ac \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x, |x - x\u2080| \u2264 \u03b4 \u2192 |f x - y\u2080| \u2264 \u03b5)\n```\nwriting `push_neg at h` will turn `h` into\n```lean\nh : \u2203 \u03b5, \u03b5 > 0 \u2227 \u2200 \u03b4, \u03b4 > 0 \u2192 (\u2203 x, |x - x\u2080| \u2264 \u03b4 \u2227 \u03b5 < |f x - y\u2080|),\n```\n\n(the pretty printer does *not* use the abreviations `\u2200 \u03b4 > 0` and `\u2203 \u03b5 > 0` but this issue\nhas nothing to do with `push_neg`).\nNote that names are conserved by this tactic, contrary to what would happen with `simp`\nusing the relevant lemmas. One can also use this tactic at the goal using `push_neg`,\nat every assumption and the goal using `push_neg at *` or at selected assumptions and the goal\nusing say `push_neg at h h' \u22a2` as usual."}, {"name": "imp_of_not_imp_not", "description": ""}, {"name": "simps_cfg", "description": "Configuration options for the `@[simps]` attribute.\n* `attrs` specifies the list of attributes given to the generated lemmas. Default: ``[`simp]``.\n  The attributes can be either basic attributes, or user attributes without parameters.\n  There are two attributes which `simps` might add itself:\n  * If ``[`simp]`` is in the list, then ``[`_refl_lemma]`` is added automatically if appropriate.\n  * If the definition is marked with `@[to_additive ...]` then all generated lemmas are marked\n    with `@[to_additive]`. This is governed by the `add_additive` configuration option.\n* if `simp_rhs` is `tt` then the right-hand-side of the generated lemmas will be put in\n  simp-normal form. More precisely: `dsimp, simp` will be called on all these expressions.\n  See note [dsimp, simp].\n* `type_md` specifies how aggressively definitions are unfolded in the type of expressions\n  for the purposes of finding out whether the type is a function type.\n  Default: `instances`. This will unfold coercion instances (so that a coercion to a function type\n  is recognized as a function type), but not declarations like `set`.\n* `rhs_md` specifies how aggressively definition in the declaration are unfolded for the purposes\n  of finding out whether it is a constructor.\n  Default: `none`\n  Exception: `@[simps]` will automatically add the options\n  `{rhs_md := semireducible, simp_rhs := tt}` if the given definition is not a constructor with\n  the given reducibility setting for `rhs_md`.\n* If `fully_applied` is `ff` then the generated `simp` lemmas will be between non-fully applied\n  terms, i.e. equalities between functions. This does not restrict the recursive behavior of\n  `@[simps]`, so only the \"final\" projection will be non-fully applied.\n  However, it can be used in combination with explicit field names, to get a partially applied\n  intermediate projection.\n* The option `not_recursive` contains the list of names of types for which `@[simps]` doesn't\n  recursively apply projections. For example, given an equivalence `\u03b1 \u00d7 \u03b2 \u2243 \u03b2 \u00d7 \u03b1` one usually\n  wants to only apply the projections for `equiv`, and not also those for `\u00d7`. This option is\n  only relevant if no explicit projection names are given as argument to `@[simps]`.\n* The option `trace` is set to `tt` when you write `@[simps?]`. In this case, the attribute will\n  print all generated lemmas. It is almost the same as setting the option `trace.simps.verbose`,\n  except that it doesn't print information about the found projections.\n* if `add_additive` is `some nm` then `@[to_additive]` is added to the generated lemma. This\n  option is automatically set to `tt` when the original declaration was tagged with\n  `@[to_additive, simps]` (in that order), where `nm` is the additive name of the original\n  declaration."}, {"name": "simps_cfg.attrs", "description": "Configuration options for the `@[simps]` attribute.\n* `attrs` specifies the list of attributes given to the generated lemmas. Default: ``[`simp]``.\n  The attributes can be either basic attributes, or user attributes without parameters.\n  There are two attributes which `simps` might add itself:\n  * If ``[`simp]`` is in the list, then ``[`_refl_lemma]`` is added automatically if appropriate.\n  * If the definition is marked with `@[to_additive ...]` then all generated lemmas are marked\n    with `@[to_additive]`. This is governed by the `add_additive` configuration option.\n* if `simp_rhs` is `tt` then the right-hand-side of the generated lemmas will be put in\n  simp-normal form. More precisely: `dsimp, simp` will be called on all these expressions.\n  See note [dsimp, simp].\n* `type_md` specifies how aggressively definitions are unfolded in the type of expressions\n  for the purposes of finding out whether the type is a function type.\n  Default: `instances`. This will unfold coercion instances (so that a coercion to a function type\n  is recognized as a function type), but not declarations like `set`.\n* `rhs_md` specifies how aggressively definition in the declaration are unfolded for the purposes\n  of finding out whether it is a constructor.\n  Default: `none`\n  Exception: `@[simps]` will automatically add the options\n  `{rhs_md := semireducible, simp_rhs := tt}` if the given definition is not a constructor with\n  the given reducibility setting for `rhs_md`.\n* If `fully_applied` is `ff` then the generated `simp` lemmas will be between non-fully applied\n  terms, i.e. equalities between functions. This does not restrict the recursive behavior of\n  `@[simps]`, so only the \"final\" projection will be non-fully applied.\n  However, it can be used in combination with explicit field names, to get a partially applied\n  intermediate projection.\n* The option `not_recursive` contains the list of names of types for which `@[simps]` doesn't\n  recursively apply projections. For example, given an equivalence `\u03b1 \u00d7 \u03b2 \u2243 \u03b2 \u00d7 \u03b1` one usually\n  wants to only apply the projections for `equiv`, and not also those for `\u00d7`. This option is\n  only relevant if no explicit projection names are given as argument to `@[simps]`.\n* The option `trace` is set to `tt` when you write `@[simps?]`. In this case, the attribute will\n  print all generated lemmas. It is almost the same as setting the option `trace.simps.verbose`,\n  except that it doesn't print information about the found projections.\n* if `add_additive` is `some nm` then `@[to_additive]` is added to the generated lemma. This\n  option is automatically set to `tt` when the original declaration was tagged with\n  `@[to_additive, simps]` (in that order), where `nm` is the additive name of the original\n  declaration."}, {"name": "simps_cfg.simp_rhs", "description": "Configuration options for the `@[simps]` attribute.\n* `attrs` specifies the list of attributes given to the generated lemmas. Default: ``[`simp]``.\n  The attributes can be either basic attributes, or user attributes without parameters.\n  There are two attributes which `simps` might add itself:\n  * If ``[`simp]`` is in the list, then ``[`_refl_lemma]`` is added automatically if appropriate.\n  * If the definition is marked with `@[to_additive ...]` then all generated lemmas are marked\n    with `@[to_additive]`. This is governed by the `add_additive` configuration option.\n* if `simp_rhs` is `tt` then the right-hand-side of the generated lemmas will be put in\n  simp-normal form. More precisely: `dsimp, simp` will be called on all these expressions.\n  See note [dsimp, simp].\n* `type_md` specifies how aggressively definitions are unfolded in the type of expressions\n  for the purposes of finding out whether the type is a function type.\n  Default: `instances`. This will unfold coercion instances (so that a coercion to a function type\n  is recognized as a function type), but not declarations like `set`.\n* `rhs_md` specifies how aggressively definition in the declaration are unfolded for the purposes\n  of finding out whether it is a constructor.\n  Default: `none`\n  Exception: `@[simps]` will automatically add the options\n  `{rhs_md := semireducible, simp_rhs := tt}` if the given definition is not a constructor with\n  the given reducibility setting for `rhs_md`.\n* If `fully_applied` is `ff` then the generated `simp` lemmas will be between non-fully applied\n  terms, i.e. equalities between functions. This does not restrict the recursive behavior of\n  `@[simps]`, so only the \"final\" projection will be non-fully applied.\n  However, it can be used in combination with explicit field names, to get a partially applied\n  intermediate projection.\n* The option `not_recursive` contains the list of names of types for which `@[simps]` doesn't\n  recursively apply projections. For example, given an equivalence `\u03b1 \u00d7 \u03b2 \u2243 \u03b2 \u00d7 \u03b1` one usually\n  wants to only apply the projections for `equiv`, and not also those for `\u00d7`. This option is\n  only relevant if no explicit projection names are given as argument to `@[simps]`.\n* The option `trace` is set to `tt` when you write `@[simps?]`. In this case, the attribute will\n  print all generated lemmas. It is almost the same as setting the option `trace.simps.verbose`,\n  except that it doesn't print information about the found projections.\n* if `add_additive` is `some nm` then `@[to_additive]` is added to the generated lemma. This\n  option is automatically set to `tt` when the original declaration was tagged with\n  `@[to_additive, simps]` (in that order), where `nm` is the additive name of the original\n  declaration."}, {"name": "simps_cfg.type_md", "description": "Configuration options for the `@[simps]` attribute.\n* `attrs` specifies the list of attributes given to the generated lemmas. Default: ``[`simp]``.\n  The attributes can be either basic attributes, or user attributes without parameters.\n  There are two attributes which `simps` might add itself:\n  * If ``[`simp]`` is in the list, then ``[`_refl_lemma]`` is added automatically if appropriate.\n  * If the definition is marked with `@[to_additive ...]` then all generated lemmas are marked\n    with `@[to_additive]`. This is governed by the `add_additive` configuration option.\n* if `simp_rhs` is `tt` then the right-hand-side of the generated lemmas will be put in\n  simp-normal form. More precisely: `dsimp, simp` will be called on all these expressions.\n  See note [dsimp, simp].\n* `type_md` specifies how aggressively definitions are unfolded in the type of expressions\n  for the purposes of finding out whether the type is a function type.\n  Default: `instances`. This will unfold coercion instances (so that a coercion to a function type\n  is recognized as a function type), but not declarations like `set`.\n* `rhs_md` specifies how aggressively definition in the declaration are unfolded for the purposes\n  of finding out whether it is a constructor.\n  Default: `none`\n  Exception: `@[simps]` will automatically add the options\n  `{rhs_md := semireducible, simp_rhs := tt}` if the given definition is not a constructor with\n  the given reducibility setting for `rhs_md`.\n* If `fully_applied` is `ff` then the generated `simp` lemmas will be between non-fully applied\n  terms, i.e. equalities between functions. This does not restrict the recursive behavior of\n  `@[simps]`, so only the \"final\" projection will be non-fully applied.\n  However, it can be used in combination with explicit field names, to get a partially applied\n  intermediate projection.\n* The option `not_recursive` contains the list of names of types for which `@[simps]` doesn't\n  recursively apply projections. For example, given an equivalence `\u03b1 \u00d7 \u03b2 \u2243 \u03b2 \u00d7 \u03b1` one usually\n  wants to only apply the projections for `equiv`, and not also those for `\u00d7`. This option is\n  only relevant if no explicit projection names are given as argument to `@[simps]`.\n* The option `trace` is set to `tt` when you write `@[simps?]`. In this case, the attribute will\n  print all generated lemmas. It is almost the same as setting the option `trace.simps.verbose`,\n  except that it doesn't print information about the found projections.\n* if `add_additive` is `some nm` then `@[to_additive]` is added to the generated lemma. This\n  option is automatically set to `tt` when the original declaration was tagged with\n  `@[to_additive, simps]` (in that order), where `nm` is the additive name of the original\n  declaration."}, {"name": "simps_cfg.rhs_md", "description": "Configuration options for the `@[simps]` attribute.\n* `attrs` specifies the list of attributes given to the generated lemmas. Default: ``[`simp]``.\n  The attributes can be either basic attributes, or user attributes without parameters.\n  There are two attributes which `simps` might add itself:\n  * If ``[`simp]`` is in the list, then ``[`_refl_lemma]`` is added automatically if appropriate.\n  * If the definition is marked with `@[to_additive ...]` then all generated lemmas are marked\n    with `@[to_additive]`. This is governed by the `add_additive` configuration option.\n* if `simp_rhs` is `tt` then the right-hand-side of the generated lemmas will be put in\n  simp-normal form. More precisely: `dsimp, simp` will be called on all these expressions.\n  See note [dsimp, simp].\n* `type_md` specifies how aggressively definitions are unfolded in the type of expressions\n  for the purposes of finding out whether the type is a function type.\n  Default: `instances`. This will unfold coercion instances (so that a coercion to a function type\n  is recognized as a function type), but not declarations like `set`.\n* `rhs_md` specifies how aggressively definition in the declaration are unfolded for the purposes\n  of finding out whether it is a constructor.\n  Default: `none`\n  Exception: `@[simps]` will automatically add the options\n  `{rhs_md := semireducible, simp_rhs := tt}` if the given definition is not a constructor with\n  the given reducibility setting for `rhs_md`.\n* If `fully_applied` is `ff` then the generated `simp` lemmas will be between non-fully applied\n  terms, i.e. equalities between functions. This does not restrict the recursive behavior of\n  `@[simps]`, so only the \"final\" projection will be non-fully applied.\n  However, it can be used in combination with explicit field names, to get a partially applied\n  intermediate projection.\n* The option `not_recursive` contains the list of names of types for which `@[simps]` doesn't\n  recursively apply projections. For example, given an equivalence `\u03b1 \u00d7 \u03b2 \u2243 \u03b2 \u00d7 \u03b1` one usually\n  wants to only apply the projections for `equiv`, and not also those for `\u00d7`. This option is\n  only relevant if no explicit projection names are given as argument to `@[simps]`.\n* The option `trace` is set to `tt` when you write `@[simps?]`. In this case, the attribute will\n  print all generated lemmas. It is almost the same as setting the option `trace.simps.verbose`,\n  except that it doesn't print information about the found projections.\n* if `add_additive` is `some nm` then `@[to_additive]` is added to the generated lemma. This\n  option is automatically set to `tt` when the original declaration was tagged with\n  `@[to_additive, simps]` (in that order), where `nm` is the additive name of the original\n  declaration."}, {"name": "simps_cfg.fully_applied", "description": "Configuration options for the `@[simps]` attribute.\n* `attrs` specifies the list of attributes given to the generated lemmas. Default: ``[`simp]``.\n  The attributes can be either basic attributes, or user attributes without parameters.\n  There are two attributes which `simps` might add itself:\n  * If ``[`simp]`` is in the list, then ``[`_refl_lemma]`` is added automatically if appropriate.\n  * If the definition is marked with `@[to_additive ...]` then all generated lemmas are marked\n    with `@[to_additive]`. This is governed by the `add_additive` configuration option.\n* if `simp_rhs` is `tt` then the right-hand-side of the generated lemmas will be put in\n  simp-normal form. More precisely: `dsimp, simp` will be called on all these expressions.\n  See note [dsimp, simp].\n* `type_md` specifies how aggressively definitions are unfolded in the type of expressions\n  for the purposes of finding out whether the type is a function type.\n  Default: `instances`. This will unfold coercion instances (so that a coercion to a function type\n  is recognized as a function type), but not declarations like `set`.\n* `rhs_md` specifies how aggressively definition in the declaration are unfolded for the purposes\n  of finding out whether it is a constructor.\n  Default: `none`\n  Exception: `@[simps]` will automatically add the options\n  `{rhs_md := semireducible, simp_rhs := tt}` if the given definition is not a constructor with\n  the given reducibility setting for `rhs_md`.\n* If `fully_applied` is `ff` then the generated `simp` lemmas will be between non-fully applied\n  terms, i.e. equalities between functions. This does not restrict the recursive behavior of\n  `@[simps]`, so only the \"final\" projection will be non-fully applied.\n  However, it can be used in combination with explicit field names, to get a partially applied\n  intermediate projection.\n* The option `not_recursive` contains the list of names of types for which `@[simps]` doesn't\n  recursively apply projections. For example, given an equivalence `\u03b1 \u00d7 \u03b2 \u2243 \u03b2 \u00d7 \u03b1` one usually\n  wants to only apply the projections for `equiv`, and not also those for `\u00d7`. This option is\n  only relevant if no explicit projection names are given as argument to `@[simps]`.\n* The option `trace` is set to `tt` when you write `@[simps?]`. In this case, the attribute will\n  print all generated lemmas. It is almost the same as setting the option `trace.simps.verbose`,\n  except that it doesn't print information about the found projections.\n* if `add_additive` is `some nm` then `@[to_additive]` is added to the generated lemma. This\n  option is automatically set to `tt` when the original declaration was tagged with\n  `@[to_additive, simps]` (in that order), where `nm` is the additive name of the original\n  declaration."}, {"name": "simps_cfg.not_recursive", "description": "Configuration options for the `@[simps]` attribute.\n* `attrs` specifies the list of attributes given to the generated lemmas. Default: ``[`simp]``.\n  The attributes can be either basic attributes, or user attributes without parameters.\n  There are two attributes which `simps` might add itself:\n  * If ``[`simp]`` is in the list, then ``[`_refl_lemma]`` is added automatically if appropriate.\n  * If the definition is marked with `@[to_additive ...]` then all generated lemmas are marked\n    with `@[to_additive]`. This is governed by the `add_additive` configuration option.\n* if `simp_rhs` is `tt` then the right-hand-side of the generated lemmas will be put in\n  simp-normal form. More precisely: `dsimp, simp` will be called on all these expressions.\n  See note [dsimp, simp].\n* `type_md` specifies how aggressively definitions are unfolded in the type of expressions\n  for the purposes of finding out whether the type is a function type.\n  Default: `instances`. This will unfold coercion instances (so that a coercion to a function type\n  is recognized as a function type), but not declarations like `set`.\n* `rhs_md` specifies how aggressively definition in the declaration are unfolded for the purposes\n  of finding out whether it is a constructor.\n  Default: `none`\n  Exception: `@[simps]` will automatically add the options\n  `{rhs_md := semireducible, simp_rhs := tt}` if the given definition is not a constructor with\n  the given reducibility setting for `rhs_md`.\n* If `fully_applied` is `ff` then the generated `simp` lemmas will be between non-fully applied\n  terms, i.e. equalities between functions. This does not restrict the recursive behavior of\n  `@[simps]`, so only the \"final\" projection will be non-fully applied.\n  However, it can be used in combination with explicit field names, to get a partially applied\n  intermediate projection.\n* The option `not_recursive` contains the list of names of types for which `@[simps]` doesn't\n  recursively apply projections. For example, given an equivalence `\u03b1 \u00d7 \u03b2 \u2243 \u03b2 \u00d7 \u03b1` one usually\n  wants to only apply the projections for `equiv`, and not also those for `\u00d7`. This option is\n  only relevant if no explicit projection names are given as argument to `@[simps]`.\n* The option `trace` is set to `tt` when you write `@[simps?]`. In this case, the attribute will\n  print all generated lemmas. It is almost the same as setting the option `trace.simps.verbose`,\n  except that it doesn't print information about the found projections.\n* if `add_additive` is `some nm` then `@[to_additive]` is added to the generated lemma. This\n  option is automatically set to `tt` when the original declaration was tagged with\n  `@[to_additive, simps]` (in that order), where `nm` is the additive name of the original\n  declaration."}, {"name": "simps_cfg.trace", "description": "Configuration options for the `@[simps]` attribute.\n* `attrs` specifies the list of attributes given to the generated lemmas. Default: ``[`simp]``.\n  The attributes can be either basic attributes, or user attributes without parameters.\n  There are two attributes which `simps` might add itself:\n  * If ``[`simp]`` is in the list, then ``[`_refl_lemma]`` is added automatically if appropriate.\n  * If the definition is marked with `@[to_additive ...]` then all generated lemmas are marked\n    with `@[to_additive]`. This is governed by the `add_additive` configuration option.\n* if `simp_rhs` is `tt` then the right-hand-side of the generated lemmas will be put in\n  simp-normal form. More precisely: `dsimp, simp` will be called on all these expressions.\n  See note [dsimp, simp].\n* `type_md` specifies how aggressively definitions are unfolded in the type of expressions\n  for the purposes of finding out whether the type is a function type.\n  Default: `instances`. This will unfold coercion instances (so that a coercion to a function type\n  is recognized as a function type), but not declarations like `set`.\n* `rhs_md` specifies how aggressively definition in the declaration are unfolded for the purposes\n  of finding out whether it is a constructor.\n  Default: `none`\n  Exception: `@[simps]` will automatically add the options\n  `{rhs_md := semireducible, simp_rhs := tt}` if the given definition is not a constructor with\n  the given reducibility setting for `rhs_md`.\n* If `fully_applied` is `ff` then the generated `simp` lemmas will be between non-fully applied\n  terms, i.e. equalities between functions. This does not restrict the recursive behavior of\n  `@[simps]`, so only the \"final\" projection will be non-fully applied.\n  However, it can be used in combination with explicit field names, to get a partially applied\n  intermediate projection.\n* The option `not_recursive` contains the list of names of types for which `@[simps]` doesn't\n  recursively apply projections. For example, given an equivalence `\u03b1 \u00d7 \u03b2 \u2243 \u03b2 \u00d7 \u03b1` one usually\n  wants to only apply the projections for `equiv`, and not also those for `\u00d7`. This option is\n  only relevant if no explicit projection names are given as argument to `@[simps]`.\n* The option `trace` is set to `tt` when you write `@[simps?]`. In this case, the attribute will\n  print all generated lemmas. It is almost the same as setting the option `trace.simps.verbose`,\n  except that it doesn't print information about the found projections.\n* if `add_additive` is `some nm` then `@[to_additive]` is added to the generated lemma. This\n  option is automatically set to `tt` when the original declaration was tagged with\n  `@[to_additive, simps]` (in that order), where `nm` is the additive name of the original\n  declaration."}, {"name": "simps_cfg.add_additive", "description": "Configuration options for the `@[simps]` attribute.\n* `attrs` specifies the list of attributes given to the generated lemmas. Default: ``[`simp]``.\n  The attributes can be either basic attributes, or user attributes without parameters.\n  There are two attributes which `simps` might add itself:\n  * If ``[`simp]`` is in the list, then ``[`_refl_lemma]`` is added automatically if appropriate.\n  * If the definition is marked with `@[to_additive ...]` then all generated lemmas are marked\n    with `@[to_additive]`. This is governed by the `add_additive` configuration option.\n* if `simp_rhs` is `tt` then the right-hand-side of the generated lemmas will be put in\n  simp-normal form. More precisely: `dsimp, simp` will be called on all these expressions.\n  See note [dsimp, simp].\n* `type_md` specifies how aggressively definitions are unfolded in the type of expressions\n  for the purposes of finding out whether the type is a function type.\n  Default: `instances`. This will unfold coercion instances (so that a coercion to a function type\n  is recognized as a function type), but not declarations like `set`.\n* `rhs_md` specifies how aggressively definition in the declaration are unfolded for the purposes\n  of finding out whether it is a constructor.\n  Default: `none`\n  Exception: `@[simps]` will automatically add the options\n  `{rhs_md := semireducible, simp_rhs := tt}` if the given definition is not a constructor with\n  the given reducibility setting for `rhs_md`.\n* If `fully_applied` is `ff` then the generated `simp` lemmas will be between non-fully applied\n  terms, i.e. equalities between functions. This does not restrict the recursive behavior of\n  `@[simps]`, so only the \"final\" projection will be non-fully applied.\n  However, it can be used in combination with explicit field names, to get a partially applied\n  intermediate projection.\n* The option `not_recursive` contains the list of names of types for which `@[simps]` doesn't\n  recursively apply projections. For example, given an equivalence `\u03b1 \u00d7 \u03b2 \u2243 \u03b2 \u00d7 \u03b1` one usually\n  wants to only apply the projections for `equiv`, and not also those for `\u00d7`. This option is\n  only relevant if no explicit projection names are given as argument to `@[simps]`.\n* The option `trace` is set to `tt` when you write `@[simps?]`. In this case, the attribute will\n  print all generated lemmas. It is almost the same as setting the option `trace.simps.verbose`,\n  except that it doesn't print information about the found projections.\n* if `add_additive` is `some nm` then `@[to_additive]` is added to the generated lemma. This\n  option is automatically set to `tt` when the original declaration was tagged with\n  `@[to_additive, simps]` (in that order), where `nm` is the additive name of the original\n  declaration."}, {"name": "simps_get_projection_exprs", "description": "Get the projections of a structure used by `@[simps]` applied to the appropriate arguments.\nReturns a list of tuples\n```lean\n(corresponding right-hand-side, given projection name, projection expression, projection numbers,\n  used by default, is prefix)\n```\n(where all fields except the first are packed in a `projection_data` structure)\none for each projection. The given projection name is the name for the projection used by the user\nused to generate (and parse) projection names. For example, in the structure\n\nExample 1: ``simps_get_projection_exprs env `(\u03b1 \u00d7 \u03b2) `(\u27e8x, y\u27e9)`` will give the output\n```lean\n  [(`(x), `fst, `(@prod.fst.{u v} \u03b1 \u03b2), [0], tt, ff),\n   (`(y), `snd, `(@prod.snd.{u v} \u03b1 \u03b2), [1], tt, ff)]\n```\n\nExample 2: ``simps_get_projection_exprs env `(\u03b1 \u2243 \u03b1) `(\u27e8id, id, \u03bb _, rfl, \u03bb _, rfl\u27e9)``\nwill give the output\n```lean\n  [(`(id), `apply, `(coe), [0], tt, ff),\n   (`(id), `symm_apply, `(\u03bb f, \u21d1f.symm), [1], tt, ff),\n   ...,\n   ...]\n```"}, {"name": "projection_data.has_reflect", "description": ""}, {"name": "initialize_simps_projections_cmd", "description": "This command specifies custom names and custom projections for the simp attribute `simps_attr`.\n* You can specify custom names by writing e.g.\n  `initialize_simps_projections equiv (to_fun \u2192 apply, inv_fun \u2192 symm_apply)`.\n* See Note [custom simps projection] and the examples below for information how to declare custom\n  projections.\n* If no custom projection is specified, the projection will be `coe_fn`/`\u21d1` if a `has_coe_to_fun`\n  instance has been declared, or the notation of a notation class (like `has_mul`) if such an\n  instance is available. If none of these cases apply, the projection itself will be used.\n* You can disable a projection by default by running\n  `initialize_simps_projections equiv (-inv_fun)`\n  This will ensure that no simp lemmas are generated for this projection,\n  unless this projection is explicitly specified by the user.\n* If you want the projection name added as a prefix in the generated lemma name, you can add the\n  `as_prefix` modifier:\n  `initialize_simps_projections equiv (to_fun \u2192 coe as_prefix)`\n  Note that this does not influence the parsing of projection names: if you have a declaration\n  `foo` and you want to apply the projections `snd`, `coe` (which is a prefix) and `fst`, in that\n  order you can run `@[simps snd_coe_fst] def foo ...` and this will generate a lemma with the\n  name `coe_foo_snd_fst`.\n  * Run `initialize_simps_projections?` (or `set_option trace.simps.verbose true`)\n  to see the generated projections.\n* You can declare a new name for a projection that is the composite of multiple projections, e.g.\n  ```lean\n    structure A := (proj : \u2115)\n    structure B extends A\n    initialize_simps_projections? B (to_A_proj \u2192 proj, -to_A)\n  ```\n  You can also make your custom projection that is definitionally equal to a composite of\n  projections. In this case, coercions and notation classes are not automatically recognized, and\n  should be manually given by giving a custom projection.\n  This is especially useful when extending a structure (without `old_structure_cmd`).\n  In the above example, it is desirable to add `-to_A`, so that `@[simps]` doesn't automatically\n  apply the `B.to_A` projection and then recursively the `A.proj` projection in the lemmas it\n  generates. If you want to get both the `foo_proj` and `foo_to_A` simp lemmas, you can use\n  `@[simps, simps to_A]`.\n* Running `initialize_simps_projections my_struc` without arguments is not necessary, it has the\n  same effect if you just add `@[simps]` to a declaration.\n* If you do anything to change the default projections, make sure to call either `@[simps]` or\n  `initialize_simps_projections` in the same file as the structure declaration. Otherwise, you might\n  have a file that imports the structure, but not your custom projections.\n\nSome common uses:\n* If you define a new homomorphism-like structure (like `mul_hom`) you can just run\n  `initialize_simps_projections` after defining the `has_coe_to_fun` instance\n  ```lean\n    instance {mM : has_mul M} {mN : has_mul N} : has_coe_to_fun (M \u2192\u2099* N) := ...\n    initialize_simps_projections mul_hom (to_fun \u2192 apply)\n  ```\n  This will generate `foo_apply` lemmas for each declaration `foo`.\n* If you prefer `coe_foo` lemmas that state equalities between functions, use\n  `initialize_simps_projections mul_hom (to_fun \u2192 coe as_prefix)`\n  In this case you have to use `@[simps {fully_applied := ff}]` or equivalently `@[simps as_fn]`\n  whenever you call `@[simps]`.\n* You can also initialize to use both, in which case you have to choose which one to use by default,\n  by using either of the following\n  ```lean\n    initialize_simps_projections mul_hom (to_fun \u2192 apply, to_fun \u2192 coe, -coe as_prefix)\n    initialize_simps_projections mul_hom (to_fun \u2192 apply, to_fun \u2192 coe as_prefix, -apply)\n  ```\n  In the first case, you can get both lemmas using `@[simps, simps coe as_fn]` and in the second\n  case you can get both lemmas using `@[simps as_fn, simps apply]`.\n* If your new homomorphism-like structure extends another structure (without `old_structure_cmd`)\n  (like `rel_embedding`), then you have to specify explicitly that you want to use a coercion\n  as a custom projection. For example\n  ```lean\n    def rel_embedding.simps.apply (h : r \u21aar s) : \u03b1 \u2192 \u03b2 := h\n    initialize_simps_projections rel_embedding (to_embedding_to_fun \u2192 apply, -to_embedding)\n  ```\n* If you have an isomorphism-like structure (like `equiv`) you often want to define a custom\n  projection for the inverse:\n  ```lean\n    def equiv.simps.symm_apply (e : \u03b1 \u2243 \u03b2) : \u03b2 \u2192 \u03b1 := e.symm\n    initialize_simps_projections equiv (to_fun \u2192 apply, inv_fun \u2192 symm_apply)\n  ```"}, {"name": "parsed_projection_data", "description": "Temporary projection data parsed from `initialize_simps_projections` before the expression\n matching this projection has been found. Only used internally in `simps_get_raw_projections`."}, {"name": "parsed_projection_data.orig_name", "description": "Temporary projection data parsed from `initialize_simps_projections` before the expression\n matching this projection has been found. Only used internally in `simps_get_raw_projections`."}, {"name": "parsed_projection_data.new_name", "description": "Temporary projection data parsed from `initialize_simps_projections` before the expression\n matching this projection has been found. Only used internally in `simps_get_raw_projections`."}, {"name": "parsed_projection_data.is_default", "description": "Temporary projection data parsed from `initialize_simps_projections` before the expression\n matching this projection has been found. Only used internally in `simps_get_raw_projections`."}, {"name": "parsed_projection_data.is_prefix", "description": "Temporary projection data parsed from `initialize_simps_projections` before the expression\n matching this projection has been found. Only used internally in `simps_get_raw_projections`."}, {"name": "simps_add_projection", "description": "Add a lemma with `nm` stating that `lhs = rhs`. `type` is the type of both `lhs` and `rhs`,\n `args` is the list of local constants occurring, and `univs` is the list of universe variables."}, {"name": "simps_tac", "description": "`simps_tac` derives `simp` lemmas for all (nested) non-Prop projections of the declaration.\n If `todo` is non-empty, it will generate exactly the names in `todo`.\n If `short_nm` is true, the generated names will only use the last projection name.\n If `trc` is true, trace as if `trace.simps.verbose` is true."}, {"name": "simps_cfg.has_reflect", "description": ""}, {"name": "tactic_doc.attribute.simps", "description": "The `@[simps]` attribute automatically derives lemmas specifying the projections of this\ndeclaration.\n\nExample:\n```lean\n@[simps] def foo : \u2115 \u00d7 \u2124 := (1, 2)\n```\nderives two `simp` lemmas:\n```lean\n@[simp] lemma foo_fst : foo.fst = 1\n@[simp] lemma foo_snd : foo.snd = 2\n```\n\n* It does not derive `simp` lemmas for the prop-valued projections.\n* It will automatically reduce newly created beta-redexes, but will not unfold any definitions.\n* If the structure has a coercion to either sorts or functions, and this is defined to be one\n  of the projections, then this coercion will be used instead of the projection.\n* If the structure is a class that has an instance to a notation class, like `has_mul`, then this\n  notation is used instead of the corresponding projection.\n* You can specify custom projections, by giving a declaration with name\n  `{structure_name}.simps.{projection_name}`. See Note [custom simps projection].\n\n  Example:\n  ```lean\n  def equiv.simps.inv_fun (e : \u03b1 \u2243 \u03b2) : \u03b2 \u2192 \u03b1 := e.symm\n  @[simps] def equiv.trans (e\u2081 : \u03b1 \u2243 \u03b2) (e\u2082 : \u03b2 \u2243 \u03b3) : \u03b1 \u2243 \u03b3 :=\n  \u27e8e\u2082 \u2218 e\u2081, e\u2081.symm \u2218 e\u2082.symm\u27e9\n  ```\n  generates\n  ```lean\n  @[simp] lemma equiv.trans_to_fun : \u2200 {\u03b1 \u03b2 \u03b3} (e\u2081 e\u2082) (a : \u03b1), \u21d1(e\u2081.trans e\u2082) a = (\u21d1e\u2082 \u2218 \u21d1e\u2081) a\n  @[simp] lemma equiv.trans_inv_fun : \u2200 {\u03b1 \u03b2 \u03b3} (e\u2081 e\u2082) (a : \u03b3),\n    \u21d1((e\u2081.trans e\u2082).symm) a = (\u21d1(e\u2081.symm) \u2218 \u21d1(e\u2082.symm)) a\n  ```\n\n* You can specify custom projection names, by specifying the new projection names using\n  `initialize_simps_projections`.\n  Example: `initialize_simps_projections equiv (to_fun \u2192 apply, inv_fun \u2192 symm_apply)`.\n  See `initialize_simps_projections_cmd` for more information.\n\n* If one of the fields itself is a structure, this command will recursively create\n  `simp` lemmas for all fields in that structure.\n  * Exception: by default it will not recursively create `simp` lemmas for fields in the structures\n    `prod` and `pprod`. You can give explicit projection names or change the value of\n    `simps_cfg.not_recursive` to override this behavior.\n\n  Example:\n  ```lean\n  structure my_prod (\u03b1 \u03b2 : Type*) := (fst : \u03b1) (snd : \u03b2)\n  @[simps] def foo : prod \u2115 \u2115 \u00d7 my_prod \u2115 \u2115 := \u27e8\u27e81, 2\u27e9, 3, 4\u27e9\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_snd_fst : foo.snd.fst = 3\n  @[simp] lemma foo_snd_snd : foo.snd.snd = 4\n  ```\n\n* You can use `@[simps proj1 proj2 ...]` to only generate the projection lemmas for the specified\n  projections.\n* Recursive projection names can be specified using `proj1_proj2_proj3`.\n  This will create a lemma of the form `foo.proj1.proj2.proj3 = ...`.\n\n  Example:\n  ```lean\n  structure my_prod (\u03b1 \u03b2 : Type*) := (fst : \u03b1) (snd : \u03b2)\n  @[simps fst fst_fst snd] def foo : prod \u2115 \u2115 \u00d7 my_prod \u2115 \u2115 := \u27e8\u27e81, 2\u27e9, 3, 4\u27e9\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_fst_fst : foo.fst.fst = 1\n  @[simp] lemma foo_snd : foo.snd = {fst := 3, snd := 4}\n  ```\n* If one of the values is an eta-expanded structure, we will eta-reduce this structure.\n\n  Example:\n  ```lean\n  structure equiv_plus_data (\u03b1 \u03b2) extends \u03b1 \u2243 \u03b2 := (data : bool)\n  @[simps] def bar {\u03b1} : equiv_plus_data \u03b1 \u03b1 := { data := tt, ..equiv.refl \u03b1 }\n  ```\n  generates the following:\n  ```lean\n  @[simp] lemma bar_to_equiv : \u2200 {\u03b1 : Sort*}, bar.to_equiv = equiv.refl \u03b1\n  @[simp] lemma bar_data : \u2200 {\u03b1 : Sort*}, bar.data = tt\n  ```\n  This is true, even though Lean inserts an eta-expanded version of `equiv.refl \u03b1` in the\n  definition of `bar`.\n* For configuration options, see the doc string of `simps_cfg`.\n* The precise syntax is `('simps' ident* e)`, where `e` is an expression of type `simps_cfg`.\n* `@[simps]` reduces let-expressions where necessary.\n* When option `trace.simps.verbose` is true, `simps` will print the projections it finds and the\n  lemmas it generates. The same can be achieved by using `@[simps?]`, except that in this case it\n  will not print projection information.\n* Use `@[to_additive, simps]` to apply both `to_additive` and `simps` to a definition, making sure\n  that `simps` comes after `to_additive`. This will also generate the additive versions of all\n  `simp` lemmas."}, {"name": "simps_add_projections", "description": "Derive lemmas specifying the projections of the declaration.\n If `todo` is non-empty, it will generate exactly the names in `todo`.\n `to_apply` is non-empty after a custom projection that is a composition of multiple projections\n was just used. In that case we need to apply these projections before we continue changing lhs."}, {"name": "simps_cfg.inhabited", "description": ""}, {"name": "projection_rule", "description": "The type of rules that specify how metadata for projections in changes.\n See `initialize_simps_projection`."}, {"name": "projection_data.inhabited", "description": ""}, {"name": "simps_attr", "description": "The `@[simps]` attribute automatically derives lemmas specifying the projections of this\ndeclaration.\n\nExample:\n```lean\n@[simps] def foo : \u2115 \u00d7 \u2124 := (1, 2)\n```\nderives two `simp` lemmas:\n```lean\n@[simp] lemma foo_fst : foo.fst = 1\n@[simp] lemma foo_snd : foo.snd = 2\n```\n\n* It does not derive `simp` lemmas for the prop-valued projections.\n* It will automatically reduce newly created beta-redexes, but will not unfold any definitions.\n* If the structure has a coercion to either sorts or functions, and this is defined to be one\n  of the projections, then this coercion will be used instead of the projection.\n* If the structure is a class that has an instance to a notation class, like `has_mul`, then this\n  notation is used instead of the corresponding projection.\n* You can specify custom projections, by giving a declaration with name\n  `{structure_name}.simps.{projection_name}`. See Note [custom simps projection].\n\n  Example:\n  ```lean\n  def equiv.simps.inv_fun (e : \u03b1 \u2243 \u03b2) : \u03b2 \u2192 \u03b1 := e.symm\n  @[simps] def equiv.trans (e\u2081 : \u03b1 \u2243 \u03b2) (e\u2082 : \u03b2 \u2243 \u03b3) : \u03b1 \u2243 \u03b3 :=\n  \u27e8e\u2082 \u2218 e\u2081, e\u2081.symm \u2218 e\u2082.symm\u27e9\n  ```\n  generates\n  ```lean\n  @[simp] lemma equiv.trans_to_fun : \u2200 {\u03b1 \u03b2 \u03b3} (e\u2081 e\u2082) (a : \u03b1), \u21d1(e\u2081.trans e\u2082) a = (\u21d1e\u2082 \u2218 \u21d1e\u2081) a\n  @[simp] lemma equiv.trans_inv_fun : \u2200 {\u03b1 \u03b2 \u03b3} (e\u2081 e\u2082) (a : \u03b3),\n    \u21d1((e\u2081.trans e\u2082).symm) a = (\u21d1(e\u2081.symm) \u2218 \u21d1(e\u2082.symm)) a\n  ```\n\n* You can specify custom projection names, by specifying the new projection names using\n  `initialize_simps_projections`.\n  Example: `initialize_simps_projections equiv (to_fun \u2192 apply, inv_fun \u2192 symm_apply)`.\n  See `initialize_simps_projections_cmd` for more information.\n\n* If one of the fields itself is a structure, this command will recursively create\n  `simp` lemmas for all fields in that structure.\n  * Exception: by default it will not recursively create `simp` lemmas for fields in the structures\n    `prod` and `pprod`. You can give explicit projection names or change the value of\n    `simps_cfg.not_recursive` to override this behavior.\n\n  Example:\n  ```lean\n  structure my_prod (\u03b1 \u03b2 : Type*) := (fst : \u03b1) (snd : \u03b2)\n  @[simps] def foo : prod \u2115 \u2115 \u00d7 my_prod \u2115 \u2115 := \u27e8\u27e81, 2\u27e9, 3, 4\u27e9\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_snd_fst : foo.snd.fst = 3\n  @[simp] lemma foo_snd_snd : foo.snd.snd = 4\n  ```\n\n* You can use `@[simps proj1 proj2 ...]` to only generate the projection lemmas for the specified\n  projections.\n* Recursive projection names can be specified using `proj1_proj2_proj3`.\n  This will create a lemma of the form `foo.proj1.proj2.proj3 = ...`.\n\n  Example:\n  ```lean\n  structure my_prod (\u03b1 \u03b2 : Type*) := (fst : \u03b1) (snd : \u03b2)\n  @[simps fst fst_fst snd] def foo : prod \u2115 \u2115 \u00d7 my_prod \u2115 \u2115 := \u27e8\u27e81, 2\u27e9, 3, 4\u27e9\n  ```\n  generates\n  ```lean\n  @[simp] lemma foo_fst : foo.fst = (1, 2)\n  @[simp] lemma foo_fst_fst : foo.fst.fst = 1\n  @[simp] lemma foo_snd : foo.snd = {fst := 3, snd := 4}\n  ```\n* If one of the values is an eta-expanded structure, we will eta-reduce this structure.\n\n  Example:\n  ```lean\n  structure equiv_plus_data (\u03b1 \u03b2) extends \u03b1 \u2243 \u03b2 := (data : bool)\n  @[simps] def bar {\u03b1} : equiv_plus_data \u03b1 \u03b1 := { data := tt, ..equiv.refl \u03b1 }\n  ```\n  generates the following:\n  ```lean\n  @[simp] lemma bar_to_equiv : \u2200 {\u03b1 : Sort*}, bar.to_equiv = equiv.refl \u03b1\n  @[simp] lemma bar_data : \u2200 {\u03b1 : Sort*}, bar.data = tt\n  ```\n  This is true, even though Lean inserts an eta-expanded version of `equiv.refl \u03b1` in the\n  definition of `bar`.\n* For configuration options, see the doc string of `simps_cfg`.\n* The precise syntax is `('simps' ident* e)`, where `e` is an expression of type `simps_cfg`.\n* `@[simps]` reduces let-expressions where necessary.\n* When option `trace.simps.verbose` is true, `simps` will print the projections it finds and the\n  lemmas it generates. The same can be achieved by using `@[simps?]`, except that in this case it\n  will not print projection information.\n* Use `@[to_additive, simps]` to apply both `to_additive` and `simps` to a definition, making sure\n  that `simps` comes after `to_additive`. This will also generate the additive versions of all\n  `simp` lemmas."}, {"name": "parsed_projection_data.has_to_format", "description": ""}, {"name": "library_note.custom simps projection", "description": "You can specify custom projections for the `@[simps]` attribute.\nTo do this for the projection `my_structure.original_projection` by adding a declaration\n`my_structure.simps.my_projection` that is definitionally equal to\n`my_structure.original_projection` but has the projection in the desired (simp-normal) form.\nThen you can call\n```lean\ninitialize_simps_projections (original_projection \u2192 my_projection, ...)\n```\nto register this projection. See `initialize_simps_projections_cmd` for more information.\n\nYou can also specify custom projections that are definitionally equal to a composite of multiple\nprojections. This is often desirable when extending structures (without `old_structure_cmd`).\n\n`has_coe_to_fun` and notation class (like `has_mul`) instances will be automatically used, if they\nare definitionally equal to a projection of the structure (but not when they are equal to the\ncomposite of multiple projections)."}, {"name": "simps_str_attr", "description": "The `@[_simps_str]` attribute specifies the preferred projections of the given structure,\nused by the `@[simps]` attribute.\n- This will usually be tagged by the `@[simps]` tactic.\n- You can also generate this with the command `initialize_simps_projections`.\n- To change the default value, see Note [custom simps projection].\n- You are strongly discouraged to add this attribute manually.\n- The first argument is the list of names of the universe variables used in the structure\n- The second argument is a list that consists of the projection data for each projection."}, {"name": "projections_info", "description": "Returns the projection information of a structure."}, {"name": "simps_parser", "description": "The parser for the `@[simps]` attribute."}, {"name": "get_composite_of_projections", "description": "Given a structure `str` and a projection `proj`, that could be multiple nested projections\n (separated by `_`), returns an expression that is the composition of these projections and a\n list of natural numbers, that are the projection numbers of the applied projections."}, {"name": "lemmas_only", "description": "A common configuration for `@[simps]`: don't tag the generated lemmas with `@[simp]`."}, {"name": "as_fn", "description": "A common configuration for `@[simps]`: generate equalities between functions instead equalities\n between fully applied expressions."}, {"name": "simps_parse_rule", "description": "Parse a rule for `initialize_simps_projections`. It is either `<name>\u2192<name>` or `-<name>`,\n possibly following by `as_prefix`."}, {"name": "get_composite_of_projections_aux", "description": "Auxiliary function of `get_composite_of_projections`."}, {"name": "projection_data.has_to_tactic_format", "description": ""}, {"name": "notation_class_attr", "description": "The `@[notation_class]` attribute specifies that this is a notation class,\nand this notation should be used instead of projections by @[simps].\n* The first argument `tt` for notation classes and `ff` for classes applied to the structure,\n  like `has_coe_to_sort` and `has_coe_to_fun`\n* The second argument is the name of the projection (by default it is the first projection\n  of the structure)"}, {"name": "projection_data", "description": "Projection data for a single projection of a structure, consisting of the following fields:\n- the name used in the generated `simp` lemmas\n- an expression used by simps for the projection. It must be definitionally equal to an original\n  projection (or a composition of multiple projections).\n  These expressions can contain the universe parameters specified in the first argument of\n  `simps_str_attr`.\n- a list of natural numbers, which is the projection number(s) that have to be applied to the\n  expression. For example the list `[0, 1]` corresponds to applying the first projection of the\n  structure, and then the second projection of the resulting structure (this assumes that the\n  target of the first projection is a structure with at least two projections).\n  The composition of these projections is required to be definitionally equal to the provided\n  expression.\n- A boolean specifying whether `simp` lemmas are generated for this projection by default.\n- A boolean specifying whether this projection is written as prefix."}, {"name": "projection_data.name", "description": "Projection data for a single projection of a structure, consisting of the following fields:\n- the name used in the generated `simp` lemmas\n- an expression used by simps for the projection. It must be definitionally equal to an original\n  projection (or a composition of multiple projections).\n  These expressions can contain the universe parameters specified in the first argument of\n  `simps_str_attr`.\n- a list of natural numbers, which is the projection number(s) that have to be applied to the\n  expression. For example the list `[0, 1]` corresponds to applying the first projection of the\n  structure, and then the second projection of the resulting structure (this assumes that the\n  target of the first projection is a structure with at least two projections).\n  The composition of these projections is required to be definitionally equal to the provided\n  expression.\n- A boolean specifying whether `simp` lemmas are generated for this projection by default.\n- A boolean specifying whether this projection is written as prefix."}, {"name": "projection_data.expr", "description": "Projection data for a single projection of a structure, consisting of the following fields:\n- the name used in the generated `simp` lemmas\n- an expression used by simps for the projection. It must be definitionally equal to an original\n  projection (or a composition of multiple projections).\n  These expressions can contain the universe parameters specified in the first argument of\n  `simps_str_attr`.\n- a list of natural numbers, which is the projection number(s) that have to be applied to the\n  expression. For example the list `[0, 1]` corresponds to applying the first projection of the\n  structure, and then the second projection of the resulting structure (this assumes that the\n  target of the first projection is a structure with at least two projections).\n  The composition of these projections is required to be definitionally equal to the provided\n  expression.\n- A boolean specifying whether `simp` lemmas are generated for this projection by default.\n- A boolean specifying whether this projection is written as prefix."}, {"name": "projection_data.proj_nrs", "description": "Projection data for a single projection of a structure, consisting of the following fields:\n- the name used in the generated `simp` lemmas\n- an expression used by simps for the projection. It must be definitionally equal to an original\n  projection (or a composition of multiple projections).\n  These expressions can contain the universe parameters specified in the first argument of\n  `simps_str_attr`.\n- a list of natural numbers, which is the projection number(s) that have to be applied to the\n  expression. For example the list `[0, 1]` corresponds to applying the first projection of the\n  structure, and then the second projection of the resulting structure (this assumes that the\n  target of the first projection is a structure with at least two projections).\n  The composition of these projections is required to be definitionally equal to the provided\n  expression.\n- A boolean specifying whether `simp` lemmas are generated for this projection by default.\n- A boolean specifying whether this projection is written as prefix."}, {"name": "projection_data.is_default", "description": "Projection data for a single projection of a structure, consisting of the following fields:\n- the name used in the generated `simp` lemmas\n- an expression used by simps for the projection. It must be definitionally equal to an original\n  projection (or a composition of multiple projections).\n  These expressions can contain the universe parameters specified in the first argument of\n  `simps_str_attr`.\n- a list of natural numbers, which is the projection number(s) that have to be applied to the\n  expression. For example the list `[0, 1]` corresponds to applying the first projection of the\n  structure, and then the second projection of the resulting structure (this assumes that the\n  target of the first projection is a structure with at least two projections).\n  The composition of these projections is required to be definitionally equal to the provided\n  expression.\n- A boolean specifying whether `simp` lemmas are generated for this projection by default.\n- A boolean specifying whether this projection is written as prefix."}, {"name": "projection_data.is_prefix", "description": "Projection data for a single projection of a structure, consisting of the following fields:\n- the name used in the generated `simp` lemmas\n- an expression used by simps for the projection. It must be definitionally equal to an original\n  projection (or a composition of multiple projections).\n  These expressions can contain the universe parameters specified in the first argument of\n  `simps_str_attr`.\n- a list of natural numbers, which is the projection number(s) that have to be applied to the\n  expression. For example the list `[0, 1]` corresponds to applying the first projection of the\n  structure, and then the second projection of the resulting structure (this assumes that the\n  target of the first projection is a structure with at least two projections).\n  The composition of these projections is required to be definitionally equal to the provided\n  expression.\n- A boolean specifying whether `simp` lemmas are generated for this projection by default.\n- A boolean specifying whether this projection is written as prefix."}, {"name": "tactic_doc.command.initialize_simps_projections", "description": "This command specifies custom names and custom projections for the simp attribute `simps_attr`.\n* You can specify custom names by writing e.g.\n  `initialize_simps_projections equiv (to_fun \u2192 apply, inv_fun \u2192 symm_apply)`.\n* See Note [custom simps projection] and the examples below for information how to declare custom\n  projections.\n* If no custom projection is specified, the projection will be `coe_fn`/`\u21d1` if a `has_coe_to_fun`\n  instance has been declared, or the notation of a notation class (like `has_mul`) if such an\n  instance is available. If none of these cases apply, the projection itself will be used.\n* You can disable a projection by default by running\n  `initialize_simps_projections equiv (-inv_fun)`\n  This will ensure that no simp lemmas are generated for this projection,\n  unless this projection is explicitly specified by the user.\n* If you want the projection name added as a prefix in the generated lemma name, you can add the\n  `as_prefix` modifier:\n  `initialize_simps_projections equiv (to_fun \u2192 coe as_prefix)`\n  Note that this does not influence the parsing of projection names: if you have a declaration\n  `foo` and you want to apply the projections `snd`, `coe` (which is a prefix) and `fst`, in that\n  order you can run `@[simps snd_coe_fst] def foo ...` and this will generate a lemma with the\n  name `coe_foo_snd_fst`.\n  * Run `initialize_simps_projections?` (or `set_option trace.simps.verbose true`)\n  to see the generated projections.\n* You can declare a new name for a projection that is the composite of multiple projections, e.g.\n  ```lean\n    structure A := (proj : \u2115)\n    structure B extends A\n    initialize_simps_projections? B (to_A_proj \u2192 proj, -to_A)\n  ```\n  You can also make your custom projection that is definitionally equal to a composite of\n  projections. In this case, coercions and notation classes are not automatically recognized, and\n  should be manually given by giving a custom projection.\n  This is especially useful when extending a structure (without `old_structure_cmd`).\n  In the above example, it is desirable to add `-to_A`, so that `@[simps]` doesn't automatically\n  apply the `B.to_A` projection and then recursively the `A.proj` projection in the lemmas it\n  generates. If you want to get both the `foo_proj` and `foo_to_A` simp lemmas, you can use\n  `@[simps, simps to_A]`.\n* Running `initialize_simps_projections my_struc` without arguments is not necessary, it has the\n  same effect if you just add `@[simps]` to a declaration.\n* If you do anything to change the default projections, make sure to call either `@[simps]` or\n  `initialize_simps_projections` in the same file as the structure declaration. Otherwise, you might\n  have a file that imports the structure, but not your custom projections.\n\nSome common uses:\n* If you define a new homomorphism-like structure (like `mul_hom`) you can just run\n  `initialize_simps_projections` after defining the `has_coe_to_fun` instance\n  ```lean\n    instance {mM : has_mul M} {mN : has_mul N} : has_coe_to_fun (M \u2192\u2099* N) := ...\n    initialize_simps_projections mul_hom (to_fun \u2192 apply)\n  ```\n  This will generate `foo_apply` lemmas for each declaration `foo`.\n* If you prefer `coe_foo` lemmas that state equalities between functions, use\n  `initialize_simps_projections mul_hom (to_fun \u2192 coe as_prefix)`\n  In this case you have to use `@[simps {fully_applied := ff}]` or equivalently `@[simps as_fn]`\n  whenever you call `@[simps]`.\n* You can also initialize to use both, in which case you have to choose which one to use by default,\n  by using either of the following\n  ```lean\n    initialize_simps_projections mul_hom (to_fun \u2192 apply, to_fun \u2192 coe, -coe as_prefix)\n    initialize_simps_projections mul_hom (to_fun \u2192 apply, to_fun \u2192 coe as_prefix, -apply)\n  ```\n  In the first case, you can get both lemmas using `@[simps, simps coe as_fn]` and in the second\n  case you can get both lemmas using `@[simps as_fn, simps apply]`.\n* If your new homomorphism-like structure extends another structure (without `old_structure_cmd`)\n  (like `rel_embedding`), then you have to specify explicitly that you want to use a coercion\n  as a custom projection. For example\n  ```lean\n    def rel_embedding.simps.apply (h : r \u21aar s) : \u03b1 \u2192 \u03b2 := h\n    initialize_simps_projections rel_embedding (to_embedding_to_fun \u2192 apply, -to_embedding)\n  ```\n* If you have an isomorphism-like structure (like `equiv`) you often want to define a custom\n  projection for the inverse:\n  ```lean\n    def equiv.simps.symm_apply (e : \u03b1 \u2243 \u03b2) : \u03b2 \u2192 \u03b1 := e.symm\n    initialize_simps_projections equiv (to_fun \u2192 apply, inv_fun \u2192 symm_apply)\n  ```"}, {"name": "simps_get_raw_projections", "description": "  Get the projections used by `simps` associated to a given structure `str`.\n\n  The returned information is also stored in a parameter of the attribute `@[_simps_str]`, which\n  is given to `str`. If `str` already has this attribute, the information is read from this\n  attribute instead. See the documentation for this attribute for the data this tactic returns.\n\n  The returned universe levels are the universe levels of the structure. For the projections there\n  are three cases\n  * If the declaration `{structure_name}.simps.{projection_name}` has been declared, then the value\n    of this declaration is used (after checking that it is definitionally equal to the actual\n    projection. If you rename the projection name, the declaration should have the *new* projection\n    name.\n  * You can also declare a custom projection that is a composite of multiple projections.\n  * Otherwise, for every class with the `notation_class` attribute, and the structure has an\n    instance of that notation class, then the projection of that notation class is used for the\n    projection that is definitionally equal to it (if there is such a projection).\n    This means in practice that coercions to function types and sorts will be used instead of\n    a projection, if this coercion is definitionally equal to a projection. Furthermore, for\n    notation classes like `has_mul` and `has_zero` those projections are used instead of the\n    corresponding projection.\n    Projections for coercions and notation classes are not automatically generated if they are\n    composites of multiple projections (for example when you use `extend` without the\n    `old_structure_cmd`).\n  * Otherwise, the projection of the structure is chosen.\n    For example: ``simps_get_raw_projections env `prod`` gives the default projections\n```lean\n  ([u, v], [prod.fst.{u v}, prod.snd.{u v}])\n```\n    while ``simps_get_raw_projections env `equiv`` gives\n```lean\n  ([u_1, u_2], [\u03bb \u03b1 \u03b2, coe_fn, \u03bb {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2), \u21d1(e.symm), left_inv, right_inv])\n```\n    after declaring the coercion from `equiv` to function and adding the declaration\n```lean\n  def equiv.simps.inv_fun {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2) : \u03b2 \u2192 \u03b1 := e.symm\n```\n\n  Optionally, this command accepts three optional arguments:\n  * If `trace_if_exists` the command will always generate a trace message when the structure already\n    has the attribute `@[_simps_str]`.\n  * The `rules` argument accepts a list of pairs `sum.inl (old_name, new_name)`. This is used to\n    change the projection name `old_name` to the custom projection name `new_name`. Example:\n    for the structure `equiv` the projection `to_fun` could be renamed `apply`. This name will be\n    used for parsing and generating projection names. This argument is ignored if the structure\n    already has an existing attribute. If an element of `rules` is of the form `sum.inr name`, this\n    means that the projection `name` will not be applied by default.\n  * if `trc` is true, this tactic will trace information."}, {"name": "lean.githash", "description": ""}, {"name": "lean.special_version_desc", "description": "Additional version description like \"nightly-2018-03-11\""}, {"name": "lean.is_release", "description": ""}, {"name": "lean.version", "description": ""}, {"name": "congr_arg_kind.has_to_format", "description": ""}, {"name": "congr_arg_kind.to_string", "description": ""}, {"name": "tactic.mk_congr_lemma_simp", "description": "`mk_congr_lemma_simp f nargs md`\ncreates a congruence lemma for the simplifier for the given function argument `f`.\nIf `nargs` is not none, then it tries to create a lemma for an application of arity `nargs`.\nIf `nargs` is none then the number of arguments will be guessed from the type signature of `f`.\n\nThat is, given `f : \u03a0 {\u03b1 \u03b2 \u03b3 \u03b4 : Type}, \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4` and `nargs = some 6`, we get a congruence lemma:\n``` lean\n{ type := \u2200 (\u03b1 \u03b2 \u03b3 \u03b4 : Type), \u2200 (a\u2081 a\u2082 : \u03b1), a\u2081 = a\u2082 \u2192 \u2200 (b\u2081 b\u2082 : \u03b2), b\u2081 = b\u2082 \u2192 f a\u2081 b\u2081 = f a\u2082 b\u2082\n, proof := ...\n, arg_kinds := [fixed, fixed, fixed, fixed, eq,eq]\n}\n```\nSee the docstrings for the cases of `congr_arg_kind` for more detail on how `arg_kinds` are chosen.\nThe system chooses the `arg_kinds` depending on what the other arguments depend on and whether the arguments have subsingleton types.\n\nNote that the number of arguments that `proof` takes can be inferred from `arg_kinds`: `arg_kinds.sum (fixed,cast \u21a6 1 | eq,heq \u21a6 3 | fixed_no_param \u21a6 0)`.\n\nFrom `congr_lemma.cpp`:\n> Create a congruence lemma that is useful for the simplifier.\n> In this kind of lemma, if the i-th argument is a Cast argument, then the lemma\n> contains an input a_i representing the i-th argument in the left-hand-side, and\n> it appears with a cast (e.g., eq.drec ... a_i ...) in the right-hand-side.\n> The idea is that the right-hand-side of this lemma \"tells\" the simplifier\n> how the resulting term looks like."}, {"name": "tactic.mk_specialized_congr_lemma", "description": " Create a specialized theorem using (a prefix of) the arguments of the given application.\n\nFor more information on specialization see the comment in the method body for `get_specialization_prefix_size` in `src/library/fun_info.cpp`."}, {"name": "tactic.mk_specialized_congr_lemma_simp", "description": " Create a specialized theorem using (a prefix of) the arguments of the given application.\n\nAn example of usage can be found in `tests/lean/simp_subsingleton.lean`.\nFor more information on specialization see the comment in the method body for `get_specialization_prefix_size` in `src/library/fun_info.cpp`."}, {"name": "congr_arg_kind", "description": " This is a kind attached to an argument of a congruence lemma that tells the simplifier how to fill it in.\n- `fixed`: It is a parameter for the congruence lemma, the parameter occurs in the left and right hand sides.\n  For example the \u03b1 in the congruence generated from `f: \u03a0 {\u03b1 : Type} \u03b1 \u2192 \u03b1`.\n- `fixed_no_param`: It is not a parameter for the congruence lemma, the lemma was specialized for this parameter.\n  This only happens if the parameter is a subsingleton/proposition, and other parameters depend on it.\n- `eq`: The lemma contains three parameters for this kind of argument `a_i`, `b_i` and `(eq_i : a_i = b_i)`.\n  `a_i` and `b_i` represent the left and right hand sides, and `eq_i` is a proof for their equality.\n  For example the second argument in `f: \u03a0 {\u03b1 : Type}, \u03b1 \u2192 \u03b1`.\n- `cast`: corresponds to arguments that are subsingletons/propositions.\n  For example the `p` in the congruence generated from `f : \u03a0 (x y : \u2115) (p: x < y), \u2115`.\n- `heq` The lemma contains three parameters for this kind of argument `a_i`, `b_i` and `(eq_i : a_i == b_i)`.\n   `a_i` and `b_i` represent the left and right hand sides, and eq_i is a proof for their heterogeneous equality."}, {"name": "congr_arg_kind.fixed", "description": " This is a kind attached to an argument of a congruence lemma that tells the simplifier how to fill it in.\n- `fixed`: It is a parameter for the congruence lemma, the parameter occurs in the left and right hand sides.\n  For example the \u03b1 in the congruence generated from `f: \u03a0 {\u03b1 : Type} \u03b1 \u2192 \u03b1`.\n- `fixed_no_param`: It is not a parameter for the congruence lemma, the lemma was specialized for this parameter.\n  This only happens if the parameter is a subsingleton/proposition, and other parameters depend on it.\n- `eq`: The lemma contains three parameters for this kind of argument `a_i`, `b_i` and `(eq_i : a_i = b_i)`.\n  `a_i` and `b_i` represent the left and right hand sides, and `eq_i` is a proof for their equality.\n  For example the second argument in `f: \u03a0 {\u03b1 : Type}, \u03b1 \u2192 \u03b1`.\n- `cast`: corresponds to arguments that are subsingletons/propositions.\n  For example the `p` in the congruence generated from `f : \u03a0 (x y : \u2115) (p: x < y), \u2115`.\n- `heq` The lemma contains three parameters for this kind of argument `a_i`, `b_i` and `(eq_i : a_i == b_i)`.\n   `a_i` and `b_i` represent the left and right hand sides, and eq_i is a proof for their heterogeneous equality."}, {"name": "congr_arg_kind.fixed_no_param", "description": " This is a kind attached to an argument of a congruence lemma that tells the simplifier how to fill it in.\n- `fixed`: It is a parameter for the congruence lemma, the parameter occurs in the left and right hand sides.\n  For example the \u03b1 in the congruence generated from `f: \u03a0 {\u03b1 : Type} \u03b1 \u2192 \u03b1`.\n- `fixed_no_param`: It is not a parameter for the congruence lemma, the lemma was specialized for this parameter.\n  This only happens if the parameter is a subsingleton/proposition, and other parameters depend on it.\n- `eq`: The lemma contains three parameters for this kind of argument `a_i`, `b_i` and `(eq_i : a_i = b_i)`.\n  `a_i` and `b_i` represent the left and right hand sides, and `eq_i` is a proof for their equality.\n  For example the second argument in `f: \u03a0 {\u03b1 : Type}, \u03b1 \u2192 \u03b1`.\n- `cast`: corresponds to arguments that are subsingletons/propositions.\n  For example the `p` in the congruence generated from `f : \u03a0 (x y : \u2115) (p: x < y), \u2115`.\n- `heq` The lemma contains three parameters for this kind of argument `a_i`, `b_i` and `(eq_i : a_i == b_i)`.\n   `a_i` and `b_i` represent the left and right hand sides, and eq_i is a proof for their heterogeneous equality."}, {"name": "congr_arg_kind.eq", "description": " This is a kind attached to an argument of a congruence lemma that tells the simplifier how to fill it in.\n- `fixed`: It is a parameter for the congruence lemma, the parameter occurs in the left and right hand sides.\n  For example the \u03b1 in the congruence generated from `f: \u03a0 {\u03b1 : Type} \u03b1 \u2192 \u03b1`.\n- `fixed_no_param`: It is not a parameter for the congruence lemma, the lemma was specialized for this parameter.\n  This only happens if the parameter is a subsingleton/proposition, and other parameters depend on it.\n- `eq`: The lemma contains three parameters for this kind of argument `a_i`, `b_i` and `(eq_i : a_i = b_i)`.\n  `a_i` and `b_i` represent the left and right hand sides, and `eq_i` is a proof for their equality.\n  For example the second argument in `f: \u03a0 {\u03b1 : Type}, \u03b1 \u2192 \u03b1`.\n- `cast`: corresponds to arguments that are subsingletons/propositions.\n  For example the `p` in the congruence generated from `f : \u03a0 (x y : \u2115) (p: x < y), \u2115`.\n- `heq` The lemma contains three parameters for this kind of argument `a_i`, `b_i` and `(eq_i : a_i == b_i)`.\n   `a_i` and `b_i` represent the left and right hand sides, and eq_i is a proof for their heterogeneous equality."}, {"name": "congr_arg_kind.cast", "description": " This is a kind attached to an argument of a congruence lemma that tells the simplifier how to fill it in.\n- `fixed`: It is a parameter for the congruence lemma, the parameter occurs in the left and right hand sides.\n  For example the \u03b1 in the congruence generated from `f: \u03a0 {\u03b1 : Type} \u03b1 \u2192 \u03b1`.\n- `fixed_no_param`: It is not a parameter for the congruence lemma, the lemma was specialized for this parameter.\n  This only happens if the parameter is a subsingleton/proposition, and other parameters depend on it.\n- `eq`: The lemma contains three parameters for this kind of argument `a_i`, `b_i` and `(eq_i : a_i = b_i)`.\n  `a_i` and `b_i` represent the left and right hand sides, and `eq_i` is a proof for their equality.\n  For example the second argument in `f: \u03a0 {\u03b1 : Type}, \u03b1 \u2192 \u03b1`.\n- `cast`: corresponds to arguments that are subsingletons/propositions.\n  For example the `p` in the congruence generated from `f : \u03a0 (x y : \u2115) (p: x < y), \u2115`.\n- `heq` The lemma contains three parameters for this kind of argument `a_i`, `b_i` and `(eq_i : a_i == b_i)`.\n   `a_i` and `b_i` represent the left and right hand sides, and eq_i is a proof for their heterogeneous equality."}, {"name": "congr_arg_kind.heq", "description": " This is a kind attached to an argument of a congruence lemma that tells the simplifier how to fill it in.\n- `fixed`: It is a parameter for the congruence lemma, the parameter occurs in the left and right hand sides.\n  For example the \u03b1 in the congruence generated from `f: \u03a0 {\u03b1 : Type} \u03b1 \u2192 \u03b1`.\n- `fixed_no_param`: It is not a parameter for the congruence lemma, the lemma was specialized for this parameter.\n  This only happens if the parameter is a subsingleton/proposition, and other parameters depend on it.\n- `eq`: The lemma contains three parameters for this kind of argument `a_i`, `b_i` and `(eq_i : a_i = b_i)`.\n  `a_i` and `b_i` represent the left and right hand sides, and `eq_i` is a proof for their equality.\n  For example the second argument in `f: \u03a0 {\u03b1 : Type}, \u03b1 \u2192 \u03b1`.\n- `cast`: corresponds to arguments that are subsingletons/propositions.\n  For example the `p` in the congruence generated from `f : \u03a0 (x y : \u2115) (p: x < y), \u2115`.\n- `heq` The lemma contains three parameters for this kind of argument `a_i`, `b_i` and `(eq_i : a_i == b_i)`.\n   `a_i` and `b_i` represent the left and right hand sides, and eq_i is a proof for their heterogeneous equality."}, {"name": "congr_arg_kind.subsingleton_inst", "description": " This is a kind attached to an argument of a congruence lemma that tells the simplifier how to fill it in.\n- `fixed`: It is a parameter for the congruence lemma, the parameter occurs in the left and right hand sides.\n  For example the \u03b1 in the congruence generated from `f: \u03a0 {\u03b1 : Type} \u03b1 \u2192 \u03b1`.\n- `fixed_no_param`: It is not a parameter for the congruence lemma, the lemma was specialized for this parameter.\n  This only happens if the parameter is a subsingleton/proposition, and other parameters depend on it.\n- `eq`: The lemma contains three parameters for this kind of argument `a_i`, `b_i` and `(eq_i : a_i = b_i)`.\n  `a_i` and `b_i` represent the left and right hand sides, and `eq_i` is a proof for their equality.\n  For example the second argument in `f: \u03a0 {\u03b1 : Type}, \u03b1 \u2192 \u03b1`.\n- `cast`: corresponds to arguments that are subsingletons/propositions.\n  For example the `p` in the congruence generated from `f : \u03a0 (x y : \u2115) (p: x < y), \u2115`.\n- `heq` The lemma contains three parameters for this kind of argument `a_i`, `b_i` and `(eq_i : a_i == b_i)`.\n   `a_i` and `b_i` represent the left and right hand sides, and eq_i is a proof for their heterogeneous equality."}, {"name": "tactic.mk_hcongr_lemma", "description": " Make a congruence lemma using hetrogeneous equality `heq` instead of `eq`.\nFor example `mk_hcongr_lemma (f : \u03a0 (\u03b1 : \u2115 \u2192 Type) (n:\u2115) (b:\u03b1 n), \u2115` )` will make\n\n``` lean\n{ type := \u2200 \u03b1 \u03b1', \u03b1 = \u03b1' \u2192 \u2200 n n', n = n' \u2192 \u2200 (b : \u03b1 n) (b' : \u03b1' n'), b == b' \u2192 f \u03b1 n b == f \u03b1' n' b'\n, proof := ...\n, arg_kinds := [eq,eq,heq]\n}\n```\n\n(Using merely `mk_congr_lemma` instead will produce `[fixed,fixed,eq]` instaed.)"}, {"name": "congr_arg_kind.has_repr", "description": ""}, {"name": "congr_lemma", "description": "A congruence lemma is a proof that two terms are equal using a congruence proof generated by `mk_congr_lemma_simp` and friends.\nSee the docstring for `mk_congr_lemma_simp` and `congr_arg_kind` for more information.\nThe conclusion is prepended by a set of arguments. `arg_kinds` gives a suggestion of how that argument should be filled in using a simplifier."}, {"name": "congr_lemma.type", "description": "A congruence lemma is a proof that two terms are equal using a congruence proof generated by `mk_congr_lemma_simp` and friends.\nSee the docstring for `mk_congr_lemma_simp` and `congr_arg_kind` for more information.\nThe conclusion is prepended by a set of arguments. `arg_kinds` gives a suggestion of how that argument should be filled in using a simplifier."}, {"name": "congr_lemma.proof", "description": "A congruence lemma is a proof that two terms are equal using a congruence proof generated by `mk_congr_lemma_simp` and friends.\nSee the docstring for `mk_congr_lemma_simp` and `congr_arg_kind` for more information.\nThe conclusion is prepended by a set of arguments. `arg_kinds` gives a suggestion of how that argument should be filled in using a simplifier."}, {"name": "congr_lemma.arg_kinds", "description": "A congruence lemma is a proof that two terms are equal using a congruence proof generated by `mk_congr_lemma_simp` and friends.\nSee the docstring for `mk_congr_lemma_simp` and `congr_arg_kind` for more information.\nThe conclusion is prepended by a set of arguments. `arg_kinds` gives a suggestion of how that argument should be filled in using a simplifier."}, {"name": "tactic.mk_congr_lemma", "description": " Similar to `mk_congr_lemma_simp`, this will make a `congr_lemma` object.\nThe difference is that for each `congr_arg_kind.cast` argument, two proof arguments are generated.\n\nConsider some function `f : \u03a0 (x : \u2115) (p : x < 4), \u2115`.\n- `mk_congr_simp` will produce a congruence lemma with type `\u2200 (x x_1 : \u2115) (e_1 : x = x_1) (p : x < 4), f x p = f x_1 _`.\n- `mk_congr` will produce a congruence lemma with type `\u2200 (x x_1 : \u2115) (e_1 : x = x_1) (p : x < 4) (p_1 : x_1 < 4), f x p = f x_1 p_1`.\n\nFrom `congr_lemma.cpp`:\n> Create a congruence lemma for the congruence closure module.\n> In this kind of lemma, if the i-th argument is a Cast argument, then the lemma\n> contains two inputs a_i and b_i representing the i-th argument in the left-hand-side and\n> right-hand-side.\n> This lemma is based on the congruence lemma for the simplifier.\n> It uses subsinglenton elimination to show that the congr-simp lemma right-hand-side\n> is equal to the right-hand-side of this lemma."}, {"name": "monad_io_environment", "description": ""}, {"name": "monad_io_environment.get_env", "description": ""}, {"name": "monad_io_environment.get_cwd", "description": ""}, {"name": "monad_io_environment.set_cwd", "description": ""}, {"name": "io.error", "description": ""}, {"name": "io.error.other", "description": ""}, {"name": "io.error.sys", "description": ""}, {"name": "monad_io_random", "description": ""}, {"name": "monad_io_random.set_rand_gen", "description": ""}, {"name": "monad_io_random.rand", "description": ""}, {"name": "io.process.spawn_args", "description": ""}, {"name": "io.process.spawn_args.cmd", "description": ""}, {"name": "io.process.spawn_args.args", "description": ""}, {"name": "io.process.spawn_args.stdin", "description": ""}, {"name": "io.process.spawn_args.stdout", "description": ""}, {"name": "io.process.spawn_args.stderr", "description": ""}, {"name": "io.process.spawn_args.cwd", "description": ""}, {"name": "io.process.spawn_args.env", "description": ""}, {"name": "monad_io_is_alternative", "description": ""}, {"name": "monad_io_process", "description": ""}, {"name": "monad_io_process.child", "description": ""}, {"name": "monad_io_process.stdin", "description": ""}, {"name": "monad_io_process.stdout", "description": ""}, {"name": "monad_io_process.stderr", "description": ""}, {"name": "monad_io_process.spawn", "description": ""}, {"name": "monad_io_process.wait", "description": ""}, {"name": "monad_io_process.sleep", "description": ""}, {"name": "io.process.stdio", "description": ""}, {"name": "io.process.stdio.piped", "description": ""}, {"name": "io.process.stdio.inherit", "description": ""}, {"name": "io.process.stdio.null", "description": ""}, {"name": "monad_io_serial", "description": ""}, {"name": "monad_io_serial.serialize", "description": ""}, {"name": "monad_io_serial.deserialize", "description": ""}, {"name": "monad_io_terminal", "description": ""}, {"name": "monad_io_terminal.put_str", "description": ""}, {"name": "monad_io_terminal.get_line", "description": ""}, {"name": "monad_io_terminal.cmdline_args", "description": ""}, {"name": "monad_io_file_system", "description": ""}, {"name": "monad_io_file_system.mk_file_handle", "description": ""}, {"name": "monad_io_file_system.is_eof", "description": ""}, {"name": "monad_io_file_system.flush", "description": ""}, {"name": "monad_io_file_system.close", "description": ""}, {"name": "monad_io_file_system.read", "description": ""}, {"name": "monad_io_file_system.write", "description": ""}, {"name": "monad_io_file_system.get_line", "description": ""}, {"name": "monad_io_file_system.stdin", "description": ""}, {"name": "monad_io_file_system.stdout", "description": ""}, {"name": "monad_io_file_system.stderr", "description": ""}, {"name": "monad_io_file_system.file_exists", "description": ""}, {"name": "monad_io_file_system.dir_exists", "description": ""}, {"name": "monad_io_file_system.remove", "description": ""}, {"name": "monad_io_file_system.rename", "description": ""}, {"name": "monad_io_file_system.mkdir", "description": ""}, {"name": "monad_io_file_system.rmdir", "description": ""}, {"name": "io.mode", "description": ""}, {"name": "io.mode.read", "description": ""}, {"name": "io.mode.write", "description": ""}, {"name": "io.mode.read_write", "description": ""}, {"name": "io.mode.append", "description": ""}, {"name": "monad_io_is_monad_fail", "description": ""}, {"name": "monad_io_net_system", "description": ""}, {"name": "monad_io_net_system.socket", "description": ""}, {"name": "monad_io_net_system.listen", "description": ""}, {"name": "monad_io_net_system.accept", "description": ""}, {"name": "monad_io_net_system.connect", "description": ""}, {"name": "monad_io_net_system.recv", "description": ""}, {"name": "monad_io_net_system.send", "description": ""}, {"name": "monad_io_net_system.close", "description": ""}, {"name": "monad_io_is_monad", "description": ""}, {"name": "monad_io", "description": ""}, {"name": "monad_io.monad", "description": ""}, {"name": "monad_io.catch", "description": ""}, {"name": "monad_io.fail", "description": ""}, {"name": "monad_io.iterate", "description": ""}, {"name": "monad_io.handle", "description": ""}, {"name": "tactic.interactive.by_contra'", "description": "If the target of the main goal is a proposition `p`,\n`by_contra'` reduces the goal to proving `false` using the additional hypothesis `h : \u00ac p`.\n`by_contra' h` can be used to name the hypothesis `h : \u00ac p`.\nThe hypothesis `\u00ac p` will be negation normalized using `push_neg`.\nFor instance, `\u00ac a < b` will be changed to `b \u2264 a`.\n`by_contra' h : q` will normalize negations in `\u00ac p`, normalize negations in `q`,\nand then check that the two normalized forms are equal.\nThe resulting hypothesis is the pre-normalized form, `q`.\n\nIf the name `h` is not explicitly provided, then `this` will be used as name.\n\nThis tactic uses classical reasoning.\nIt is a variant on the tactic `by_contra` (`tactic.interactive.by_contra`).\n\nExamples:\n\n```lean\nexample : 1 < 2 :=\nbegin\n  by_contra' h,\n  -- h : 2 \u2264 1 \u22a2 false\nend\n\nexample : 1 < 2 :=\nbegin\n  by_contra' h : \u00ac 1 < 2,\n  -- h : \u00ac 1 < 2 \u22a2 false\nend\n```"}, {"name": "tactic_doc.tactic.by_contra'", "description": "If the target of the main goal is a proposition `p`,\n`by_contra'` reduces the goal to proving `false` using the additional hypothesis `h : \u00ac p`.\n`by_contra' h` can be used to name the hypothesis `h : \u00ac p`.\nThe hypothesis `\u00ac p` will be negation normalized using `push_neg`.\nFor instance, `\u00ac a < b` will be changed to `b \u2264 a`.\n`by_contra' h : q` will normalize negations in `\u00ac p`, normalize negations in `q`,\nand then check that the two normalized forms are equal.\nThe resulting hypothesis is the pre-normalized form, `q`.\n\nIf the name `h` is not explicitly provided, then `this` will be used as name.\n\nThis tactic uses classical reasoning.\nIt is a variant on the tactic `by_contra` (`tactic.interactive.by_contra`).\n\nExamples:\n\n```lean\nexample : 1 < 2 :=\nbegin\n  by_contra' h,\n  -- h : 2 \u2264 1 \u22a2 false\nend\n\nexample : 1 < 2 :=\nbegin\n  by_contra' h : \u00ac 1 < 2,\n  -- h : \u00ac 1 < 2 \u22a2 false\nend\n```"}, {"name": "tactic.back_lemmas_find", "description": ""}, {"name": "tactic.back_chaining_using_hs", "description": ""}, {"name": "tactic.back_lemmas_add_extra", "description": ""}, {"name": "tactic.back_lemmas_insert_core", "description": ""}, {"name": "tactic.back_chaining", "description": ""}, {"name": "tactic.mk_back_lemmas_core", "description": ""}, {"name": "tactic.back_lemmas", "description": ""}, {"name": "tactic.back_chaining_using", "description": ""}, {"name": "tactic.back_lemmas_insert", "description": ""}, {"name": "tactic.back_chaining_core", "description": ""}, {"name": "tactic.mk_back_lemmas", "description": ""}, {"name": "tactic.backward_chaining_core", "description": ""}, {"name": "conv.interactive.slice", "description": "`slice` is a conv tactic; if the current focus is a composition of several morphisms,\n`slice a b` reassociates as needed, and zooms in on the `a`-th through `b`-th morphisms.\n\nThus if the current focus is `(a \u226b b) \u226b ((c \u226b d) \u226b e)`, then `slice 2 3` zooms to `b \u226b c`."}, {"name": "conv.repeat_with_results", "description": ""}, {"name": "conv.slice", "description": ""}, {"name": "tactic.interactive.slice_lhs", "description": "`slice_lhs a b { tac }` zooms to the left hand side, uses associativity for categorical\ncomposition as needed, zooms in on the `a`-th through `b`-th morphisms, and invokes `tac`."}, {"name": "tactic_doc.tactic.slice", "description": "`slice_lhs a b { tac }` zooms to the left hand side, uses associativity for categorical\ncomposition as needed, zooms in on the `a`-th through `b`-th morphisms, and invokes `tac`.\n\n`slice_rhs a b { tac }` zooms to the right hand side, uses associativity for categorical\ncomposition as needed, zooms in on the `a`-th through `b`-th morphisms, and invokes `tac`."}, {"name": "conv.slice_lhs", "description": ""}, {"name": "conv.slice_rhs", "description": ""}, {"name": "tactic.repeat_count", "description": ""}, {"name": "tactic.interactive.slice_rhs", "description": "`slice_rhs a b { tac }` zooms to the right hand side, uses associativity for categorical\ncomposition as needed, zooms in on the `a`-th through `b`-th morphisms, and invokes `tac`."}, {"name": "tactic.repeat_with_results", "description": ""}, {"name": "conv.repeat_count", "description": ""}, {"name": "mk_definition", "description": ""}, {"name": "declaration.type", "description": ""}, {"name": "declaration.to_name", "description": ""}, {"name": "declaration.value_task", "description": ""}, {"name": "declaration.update_value_task", "description": ""}, {"name": "declaration.is_definition", "description": ""}, {"name": "declaration.to_definition", "description": ""}, {"name": "declaration.update_name", "description": ""}, {"name": "declaration.instantiate_value_univ_params", "description": "Instantiate a universe polymorphic declaration value with the given universes."}, {"name": "declaration.map_value", "description": ""}, {"name": "declaration.update_value", "description": ""}, {"name": "declaration.value", "description": ""}, {"name": "declaration.is_trusted", "description": ""}, {"name": "declaration", "description": "Reflect a C++ declaration object. The VM replaces it with the C++ implementation."}, {"name": "declaration.defn", "description": "Reflect a C++ declaration object. The VM replaces it with the C++ implementation."}, {"name": "declaration.thm", "description": "Reflect a C++ declaration object. The VM replaces it with the C++ implementation."}, {"name": "declaration.cnst", "description": "Reflect a C++ declaration object. The VM replaces it with the C++ implementation."}, {"name": "declaration.ax", "description": "Reflect a C++ declaration object. The VM replaces it with the C++ implementation."}, {"name": "declaration.update_type", "description": ""}, {"name": "reducibility_hints", "description": "Reducibility hints are used in the convertibility checker.\nWhen trying to solve a constraint such a\n\n           (f ...) =?= (g ...)\n\nwhere f and g are definitions, the checker has to decide which one will be unfolded.\n  If      f (g) is opaque,     then g (f) is unfolded if it is also not marked as opaque,\n  Else if f (g) is abbrev,     then f (g) is unfolded if g (f) is also not marked as abbrev,\n  Else if f and g are regular, then we unfold the one with the biggest definitional height.\n  Otherwise both are unfolded.\n\nThe arguments of the `regular` constructor are: the definitional height and the flag `self_opt`.\n\nThe definitional height is by default computed by the kernel. It only takes into account\nother regular definitions used in a definition. When creating declarations using meta-programming,\nwe can specify the definitional depth manually.\n\nFor definitions marked as regular, we also have a hint for constraints such as\n\n          (f a) =?= (f b)\n\nif self_opt == true, then checker will first try to solve (a =?= b), only if it fails,\nit unfolds f.\n\nRemark: the hint only affects performance. None of the hints prevent the kernel from unfolding a\ndeclaration during type checking.\n\nRemark: the reducibility_hints are not related to the attributes: reducible/irrelevance/semireducible.\nThese attributes are used by the elaborator. The reducibility_hints are used by the kernel (and elaborator).\nMoreover, the reducibility_hints cannot be changed after a declaration is added to the kernel."}, {"name": "reducibility_hints.opaque", "description": "Reducibility hints are used in the convertibility checker.\nWhen trying to solve a constraint such a\n\n           (f ...) =?= (g ...)\n\nwhere f and g are definitions, the checker has to decide which one will be unfolded.\n  If      f (g) is opaque,     then g (f) is unfolded if it is also not marked as opaque,\n  Else if f (g) is abbrev,     then f (g) is unfolded if g (f) is also not marked as abbrev,\n  Else if f and g are regular, then we unfold the one with the biggest definitional height.\n  Otherwise both are unfolded.\n\nThe arguments of the `regular` constructor are: the definitional height and the flag `self_opt`.\n\nThe definitional height is by default computed by the kernel. It only takes into account\nother regular definitions used in a definition. When creating declarations using meta-programming,\nwe can specify the definitional depth manually.\n\nFor definitions marked as regular, we also have a hint for constraints such as\n\n          (f a) =?= (f b)\n\nif self_opt == true, then checker will first try to solve (a =?= b), only if it fails,\nit unfolds f.\n\nRemark: the hint only affects performance. None of the hints prevent the kernel from unfolding a\ndeclaration during type checking.\n\nRemark: the reducibility_hints are not related to the attributes: reducible/irrelevance/semireducible.\nThese attributes are used by the elaborator. The reducibility_hints are used by the kernel (and elaborator).\nMoreover, the reducibility_hints cannot be changed after a declaration is added to the kernel."}, {"name": "reducibility_hints.abbrev", "description": "Reducibility hints are used in the convertibility checker.\nWhen trying to solve a constraint such a\n\n           (f ...) =?= (g ...)\n\nwhere f and g are definitions, the checker has to decide which one will be unfolded.\n  If      f (g) is opaque,     then g (f) is unfolded if it is also not marked as opaque,\n  Else if f (g) is abbrev,     then f (g) is unfolded if g (f) is also not marked as abbrev,\n  Else if f and g are regular, then we unfold the one with the biggest definitional height.\n  Otherwise both are unfolded.\n\nThe arguments of the `regular` constructor are: the definitional height and the flag `self_opt`.\n\nThe definitional height is by default computed by the kernel. It only takes into account\nother regular definitions used in a definition. When creating declarations using meta-programming,\nwe can specify the definitional depth manually.\n\nFor definitions marked as regular, we also have a hint for constraints such as\n\n          (f a) =?= (f b)\n\nif self_opt == true, then checker will first try to solve (a =?= b), only if it fails,\nit unfolds f.\n\nRemark: the hint only affects performance. None of the hints prevent the kernel from unfolding a\ndeclaration during type checking.\n\nRemark: the reducibility_hints are not related to the attributes: reducible/irrelevance/semireducible.\nThese attributes are used by the elaborator. The reducibility_hints are used by the kernel (and elaborator).\nMoreover, the reducibility_hints cannot be changed after a declaration is added to the kernel."}, {"name": "reducibility_hints.regular", "description": "Reducibility hints are used in the convertibility checker.\nWhen trying to solve a constraint such a\n\n           (f ...) =?= (g ...)\n\nwhere f and g are definitions, the checker has to decide which one will be unfolded.\n  If      f (g) is opaque,     then g (f) is unfolded if it is also not marked as opaque,\n  Else if f (g) is abbrev,     then f (g) is unfolded if g (f) is also not marked as abbrev,\n  Else if f and g are regular, then we unfold the one with the biggest definitional height.\n  Otherwise both are unfolded.\n\nThe arguments of the `regular` constructor are: the definitional height and the flag `self_opt`.\n\nThe definitional height is by default computed by the kernel. It only takes into account\nother regular definitions used in a definition. When creating declarations using meta-programming,\nwe can specify the definitional depth manually.\n\nFor definitions marked as regular, we also have a hint for constraints such as\n\n          (f a) =?= (f b)\n\nif self_opt == true, then checker will first try to solve (a =?= b), only if it fails,\nit unfolds f.\n\nRemark: the hint only affects performance. None of the hints prevent the kernel from unfolding a\ndeclaration during type checking.\n\nRemark: the reducibility_hints are not related to the attributes: reducible/irrelevance/semireducible.\nThese attributes are used by the elaborator. The reducibility_hints are used by the kernel (and elaborator).\nMoreover, the reducibility_hints cannot be changed after a declaration is added to the kernel."}, {"name": "declaration.instantiate_type_univ_params", "description": "Instantiate a universe polymorphic declaration type with the given universes."}, {"name": "declaration.univ_params", "description": ""}, {"name": "tactic.mk_has_sizeof_instance_core", "description": ""}, {"name": "tactic.mk_has_sizeof_instance", "description": ""}, {"name": "multiset.nodup.le_nsmul_iff_le", "description": ""}, {"name": "multiset.dedup_subset", "description": ""}, {"name": "multiset.dedup_eq_self", "description": ""}, {"name": "multiset.dedup_singleton", "description": ""}, {"name": "multiset.dedup_cons_of_mem", "description": ""}, {"name": "multiset.subset_dedup'", "description": ""}, {"name": "multiset.nodup_dedup", "description": ""}, {"name": "multiset.mem_dedup", "description": ""}, {"name": "multiset.dedup_cons_of_not_mem", "description": ""}, {"name": "multiset.dedup_ext", "description": ""}, {"name": "multiset.subset_dedup", "description": ""}, {"name": "multiset.coe_dedup", "description": ""}, {"name": "multiset.nodup.dedup", "description": "**Alias** of the reverse direction of `multiset.dedup_eq_self`."}, {"name": "multiset.dedup_eq_zero", "description": ""}, {"name": "multiset.le_dedup", "description": ""}, {"name": "multiset.dedup_nsmul", "description": ""}, {"name": "multiset.dedup", "description": "`dedup s` removes duplicates from `s`, yielding a `nodup` multiset."}, {"name": "multiset.dedup_zero", "description": ""}, {"name": "multiset.dedup_le", "description": ""}, {"name": "multiset.dedup_subset'", "description": ""}, {"name": "multiset.nodup.le_dedup_iff_le", "description": ""}, {"name": "multiset.dedup_map_dedup_eq", "description": ""}, {"name": "fin.vne_of_ne", "description": ""}, {"name": "fin.has_lt", "description": ""}, {"name": "fin.has_le", "description": ""}, {"name": "fin.mk", "description": "Backwards-compatible constructor for `fin n`."}, {"name": "fin.eq_of_veq", "description": ""}, {"name": "fin.ne_of_vne", "description": ""}, {"name": "fin.veq_of_eq", "description": ""}, {"name": "fin", "description": "`fin n` is the subtype of `\u2115` consisting of natural numbers strictly smaller than `n`."}, {"name": "fin.lt", "description": ""}, {"name": "fin.decidable_lt", "description": ""}, {"name": "fin.decidable_eq", "description": ""}, {"name": "fin.decidable_le", "description": ""}, {"name": "fin.elim0", "description": ""}, {"name": "fin.le", "description": ""}, {"name": "doubleround_examples.output'", "description": ""}, {"name": "doubleround_examples.input", "description": ""}, {"name": "doubleround_examples.output", "description": ""}, {"name": "doubleround_examples.input'", "description": ""}, {"name": "int.bit", "description": ""}, {"name": "int.nat_bitwise", "description": ""}, {"name": "int.bitwise", "description": ""}, {"name": "int.div2", "description": ""}, {"name": "int.land", "description": ""}, {"name": "int.ldiff", "description": ""}, {"name": "int.lnot", "description": ""}, {"name": "int.shiftr", "description": ""}, {"name": "int.bodd", "description": ""}, {"name": "int.shiftl", "description": ""}, {"name": "int.test_bit", "description": ""}, {"name": "int.lor", "description": ""}, {"name": "int.lxor", "description": ""}, {"name": "core_examples.result", "description": ""}, {"name": "core_examples.U", "description": ""}, {"name": "core_examples.W'", "description": ""}, {"name": "core_examples.input'", "description": ""}, {"name": "core_examples.input''", "description": ""}, {"name": "core_examples.output''", "description": ""}, {"name": "core_examples.output", "description": ""}, {"name": "core_examples.U'", "description": ""}, {"name": "core_examples.W", "description": ""}, {"name": "core_examples.result'", "description": ""}, {"name": "core_examples.input", "description": ""}, {"name": "core_examples.Z", "description": ""}, {"name": "core_examples.Z'", "description": ""}, {"name": "core_examples.output'", "description": ""}, {"name": "std_range", "description": ""}, {"name": "std_gen.random_gen", "description": ""}, {"name": "random_gen", "description": ""}, {"name": "random_gen.range", "description": ""}, {"name": "random_gen.next", "description": ""}, {"name": "random_gen.split", "description": ""}, {"name": "std_gen", "description": ""}, {"name": "std_gen.s1", "description": ""}, {"name": "std_gen.s2", "description": ""}, {"name": "std_next", "description": ""}, {"name": "rand_nat", "description": "Generate a random natural number in the interval [lo, hi]."}, {"name": "std_split", "description": ""}, {"name": "std_gen.has_repr", "description": ""}, {"name": "rand_bool", "description": "Generate a random Boolean."}, {"name": "mk_std_gen", "description": "Return a standard number generator."}, {"name": "conv.monad", "description": ""}, {"name": "conv.lhs", "description": ""}, {"name": "conv.alternative", "description": ""}, {"name": "conv.monad_fail", "description": ""}, {"name": "conv.update_lhs", "description": "`\u22a2 lhs = rhs` ~~> `\u22a2 lhs' = rhs` using `h : lhs = lhs'`."}, {"name": "conv.funext", "description": "Create a conversion from the function extensionality tactic."}, {"name": "conv.dsimp", "description": "dsimp the LHS."}, {"name": "conv.whnf", "description": "Put LHS in WHNF."}, {"name": "conv.skip", "description": "Use reflexivity to prove."}, {"name": "conv", "description": " `conv \u03b1` is a tactic for discharging goals of the form `lhs ~ rhs` for some relation `~` (usually equality) and fixed lhs, rhs.\nKnown in the literature as a __conversion__ tactic.\nSo for example, if one had the lemma `p : x = y`, then the conversion for `p` would be one that solves `p`."}, {"name": "tactic.id_tag.conv", "description": ""}, {"name": "conv.change", "description": "Change `lhs` to something definitionally equal to it."}, {"name": "conv.congr", "description": "Take the target equality `f x y = X` and try to apply the congruence lemma for `f` to it (namely `x = x' \u2192 y = y' \u2192 f x y = f x' y'`)."}, {"name": "conv.rhs", "description": ""}, {"name": "conv.convert", "description": "Applies the conversion `c`. Returns `(rhs,p)` where `p : r lhs rhs`. Throws away the return value of `c`."}, {"name": "tactic_doc.tactic.trunc_cases", "description": "`trunc_cases e` performs case analysis on a `trunc` expression `e`,\nattempting the following strategies:\n1. when the goal is a subsingleton, calling `induction e using trunc.rec_on_subsingleton`,\n2. when the goal does not depend on `e`, calling `fapply trunc.lift_on e`,\n   and using `intro` and `clear` afterwards to make the goals look like we used `induction`,\n3. otherwise, falling through to `trunc.rec_on`, and in the new invariance goal\n   calling `cases h_p` on the useless `h_p : true` hypothesis,\n   and then attempting to simplify the `eq.rec`.\n\n`trunc_cases e with h` names the new hypothesis `h`.\nIf `e` is a local hypothesis already,\n`trunc_cases` defaults to reusing the same name.\n\n`trunc_cases e with h h_a h_b` will use the names `h_a` and `h_b` for the new hypothesis\nin the invariance goal if `trunc_cases` uses `trunc.lift_on` or `trunc.rec_on`.\n\nFinally, if the new hypothesis from inside the `trunc` is a type class,\n`trunc_cases` resets the instance cache so that it is immediately available."}, {"name": "tactic.interactive.trunc_cases", "description": "`trunc_cases e` performs case analysis on a `trunc` expression `e`,\nattempting the following strategies:\n1. when the goal is a subsingleton, calling `induction e using trunc.rec_on_subsingleton`,\n2. when the goal does not depend on `e`, calling `fapply trunc.lift_on e`,\n   and using `intro` and `clear` afterwards to make the goals look like we used `induction`,\n3. otherwise, falling through to `trunc.rec_on`, and in the new invariance goal\n   calling `cases h_p` on the useless `h_p : true` hypothesis,\n   and then attempting to simplify the `eq.rec`.\n\n`trunc_cases e with h` names the new hypothesis `h`.\nIf `e` is a local hypothesis already,\n`trunc_cases` defaults to reusing the same name.\n\n`trunc_cases e with h h_a h_b` will use the names `h_a` and `h_b` for the new hypothesis\nin the invariance goal if `trunc_cases` uses `trunc.lift_on` or `trunc.rec_on`.\n\nFinally, if the new hypothesis from inside the `trunc` is a type class,\n`trunc_cases` resets the instance cache so that it is immediately available."}, {"name": "pprod.forall'", "description": ""}, {"name": "pprod.exists'", "description": ""}, {"name": "pprod.mk.eta", "description": ""}, {"name": "pprod.exists", "description": ""}, {"name": "pprod.forall", "description": ""}, {"name": "function.injective.pprod_map", "description": ""}, {"name": "mk_iff.list_option_merge", "description": "Iterate over two lists, if the first element of the first list is `none`, insert `none` into the\nresult and continue with the tail of first list. Otherwise, wrap the first element of the second\nlist with `some` and continue with the tails of both lists. Return when either list is empty.\n\nExample:\n```lean\nlist_option_merge [none, some (), none, some ()] [0, 1, 2, 3, 4] = [none, (some 0), none, (some 1)]\n```"}, {"name": "tactic_doc.command.mk_iff_of_inductive_prop", "description": "`mk_iff_of_inductive_prop i r` makes an `iff` rule for the inductively-defined proposition `i`.\nThe new rule `r` has the shape `\u2200ps is, i as \u2194 \u22c1_j, \u2203cs, is = cs`, where `ps` are the type\nparameters, `is` are the indices, `j` ranges over all possible constructors, the `cs` are the\nparameters for each of the constructors, and the equalities `is = cs` are the instantiations for\neach constructor for each of the indices to the inductive type `i`.\n\nIn each case, we remove constructor parameters (i.e. `cs`) when the corresponding equality would\nbe just `c = i` for some index `i`.\n\nFor example, `mk_iff_of_inductive_prop` on `list.chain` produces:\n\n```lean\n\u2200 {\u03b1 : Type*} (R : \u03b1 \u2192 \u03b1 \u2192 Prop) (a : \u03b1) (l : list \u03b1),\n  chain R a l \u2194 l = [] \u2228 \u2203{b : \u03b1} {l' : list \u03b1}, R a b \u2227 chain R b l \u2227 l = b :: l'\n```\n\nSee also the `mk_iff` user attribute."}, {"name": "mk_iff.to_cases", "description": ""}, {"name": "mk_iff.compact_relation", "description": " `compact_relation bs as_ps`: Produce a relation of the form:\n```lean\nR as := \u2203 bs, \u039b_i a_i = p_i[bs]\n```\nThis relation is user-visible, so we compact it by removing each `b_j` where a `p_i = b_j`, and\nhence `a_i = b_j`. We need to take care when there are `p_i` and `p_j` with `p_i = p_j = b_k`.\n\nTODO: this is a variant of `compact_relation` in `coinductive_predicates.lean`, export it there."}, {"name": "tactic.mk_iff_of_inductive_prop", "description": "`mk_iff_of_inductive_prop i r` makes an `iff` rule for the inductively-defined proposition `i`.\nThe new rule `r` has the shape `\u2200ps is, i as \u2194 \u22c1_j, \u2203cs, is = cs`, where `ps` are the type\nparameters, `is` are the indices, `j` ranges over all possible constructors, the `cs` are the\nparameters for each of the constructors, and the equalities `is = cs` are the instantiations for\neach constructor for each of the indices to the inductive type `i`.\n\nIn each case, we remove constructor parameters (i.e. `cs`) when the corresponding equality would\nbe just `c = i` for some index `i`.\n\nFor example, `mk_iff_of_inductive_prop` on `list.chain` produces:\n\n```lean\n\u2200 {\u03b1 : Type*} (R : \u03b1 \u2192 \u03b1 \u2192 Prop) (a : \u03b1) (l : list \u03b1),\n  chain R a l \u2194 l = [] \u2228 \u2203{b : \u03b1} {l' : list \u03b1}, R a b \u2227 chain R b l \u2227 l = b :: l'\n```"}, {"name": "mk_iff.to_inductive", "description": ""}, {"name": "mk_iff_attr", "description": "Applying the `mk_iff` attribute to an inductively-defined proposition `mk_iff` makes an `iff` rule\n`r` with the shape `\u2200ps is, i as \u2194 \u22c1_j, \u2203cs, is = cs`, where `ps` are the type parameters, `is` are\nthe indices, `j` ranges over all possible constructors, the `cs` are the parameters for each of the\nconstructors, and the equalities `is = cs` are the instantiations for each constructor for each of\nthe indices to the inductive type `i`.\n\nIn each case, we remove constructor parameters (i.e. `cs`) when the corresponding equality would\nbe just `c = i` for some index `i`.\n\nFor example, if we try the following:\n```lean\n@[mk_iff] structure foo (m n : \u2115) : Prop :=\n(equal : m = n)\n(sum_eq_two : m + n = 2)\n```\n\nThen `#check foo_iff` returns:\n```lean\nfoo_iff : \u2200 (m n : \u2115), foo m n \u2194 m = n \u2227 m + n = 2\n```\n\nYou can add an optional string after `mk_iff` to change the name of the generated lemma.\nFor example, if we try the following:\n```lean\n@[mk_iff bar] structure foo (m n : \u2115) : Prop :=\n(equal : m = n)\n(sum_eq_two : m + n = 2)\n```\n\nThen `#check bar` returns:\n```lean\nbar : \u2200 (m n : \u2115), foo m n \u2194 m = n \u2227 m + n = 2\n```\n\nSee also the user command `mk_iff_of_inductive_prop`."}, {"name": "mk_iff_of_inductive_prop_cmd", "description": "`mk_iff_of_inductive_prop i r` makes an `iff` rule for the inductively-defined proposition `i`.\nThe new rule `r` has the shape `\u2200ps is, i as \u2194 \u22c1_j, \u2203cs, is = cs`, where `ps` are the type\nparameters, `is` are the indices, `j` ranges over all possible constructors, the `cs` are the\nparameters for each of the constructors, and the equalities `is = cs` are the instantiations for\neach constructor for each of the indices to the inductive type `i`.\n\nIn each case, we remove constructor parameters (i.e. `cs`) when the corresponding equality would\nbe just `c = i` for some index `i`.\n\nFor example, `mk_iff_of_inductive_prop` on `list.chain` produces:\n\n```lean\n\u2200 {\u03b1 : Type*} (R : \u03b1 \u2192 \u03b1 \u2192 Prop) (a : \u03b1) (l : list \u03b1),\n  chain R a l \u2194 l = [] \u2228 \u2203{b : \u03b1} {l' : list \u03b1}, R a b \u2227 chain R b l \u2227 l = b :: l'\n```\n\nSee also the `mk_iff` user attribute."}, {"name": "mk_iff.select", "description": " `select m n` runs `tactic.right` `m` times, and then `tactic.left` `(n-m)` times.\nFails if `n < m`."}, {"name": "mk_iff.constr_to_prop", "description": ""}, {"name": "tactic_doc.attribute.mk_iff", "description": "Applying the `mk_iff` attribute to an inductively-defined proposition `mk_iff` makes an `iff` rule\n`r` with the shape `\u2200ps is, i as \u2194 \u22c1_j, \u2203cs, is = cs`, where `ps` are the type parameters, `is` are\nthe indices, `j` ranges over all possible constructors, the `cs` are the parameters for each of the\nconstructors, and the equalities `is = cs` are the instantiations for each constructor for each of\nthe indices to the inductive type `i`.\n\nIn each case, we remove constructor parameters (i.e. `cs`) when the corresponding equality would\nbe just `c = i` for some index `i`.\n\nFor example, if we try the following:\n```lean\n@[mk_iff] structure foo (m n : \u2115) : Prop :=\n(equal : m = n)\n(sum_eq_two : m + n = 2)\n```\n\nThen `#check foo_iff` returns:\n```lean\nfoo_iff : \u2200 (m n : \u2115), foo m n \u2194 m = n \u2227 m + n = 2\n```\n\nYou can add an optional string after `mk_iff` to change the name of the generated lemma.\nFor example, if we try the following:\n```lean\n@[mk_iff bar] structure foo (m n : \u2115) : Prop :=\n(equal : m = n)\n(sum_eq_two : m + n = 2)\n```\n\nThen `#check bar` returns:\n```lean\nbar : \u2200 (m n : \u2115), foo m n \u2194 m = n \u2227 m + n = 2\n```\n\nSee also the user command `mk_iff_of_inductive_prop`."}, {"name": "psigma.lex_wf", "description": ""}, {"name": "psigma.rev_lex_wf", "description": ""}, {"name": "psigma.has_well_founded", "description": ""}, {"name": "psigma.rev_lex_accessible", "description": ""}, {"name": "psigma.mk_skip_left", "description": ""}, {"name": "psigma.rev_lex", "description": ""}, {"name": "psigma.rev_lex.left", "description": ""}, {"name": "psigma.rev_lex.right", "description": ""}, {"name": "psigma.lex", "description": ""}, {"name": "psigma.lex.left", "description": ""}, {"name": "psigma.lex.right", "description": ""}, {"name": "psigma.skip_left_wf", "description": ""}, {"name": "psigma.skip_left", "description": ""}, {"name": "psigma.lex_accessible", "description": ""}, {"name": "psigma.lex_ndep_wf", "description": ""}, {"name": "psigma.lex_ndep", "description": ""}, {"name": "list.forall\u2082_reverse_iff", "description": ""}, {"name": "list.sublist_forall\u2082.is_refl", "description": ""}, {"name": "list.rel_reverse", "description": ""}, {"name": "list.forall\u2082_cons", "description": ""}, {"name": "list.forall\u2082_nil_left_iff", "description": ""}, {"name": "list.forall\u2082.mp", "description": ""}, {"name": "list.forall\u2082_refl", "description": ""}, {"name": "list.left_unique_forall\u2082'", "description": ""}, {"name": "list.forall\u2082_cons_right_iff", "description": ""}, {"name": "list.rel_map", "description": ""}, {"name": "list.forall\u2082_and_left", "description": ""}, {"name": "list.rel_bind", "description": ""}, {"name": "list.rel_append", "description": ""}, {"name": "list.forall\u2082.flip", "description": ""}, {"name": "list.sublist_forall\u2082.is_trans", "description": ""}, {"name": "list.forall\u2082_map_right_iff", "description": ""}, {"name": "list.rel_foldr", "description": ""}, {"name": "list.rel_filter_map", "description": ""}, {"name": "relator.left_unique.forall\u2082", "description": ""}, {"name": "relator.right_unique.forall\u2082", "description": ""}, {"name": "list.rel_filter", "description": ""}, {"name": "list.forall\u2082.imp", "description": ""}, {"name": "list.forall\u2082_drop_append", "description": ""}, {"name": "list.sublist.sublist_forall\u2082", "description": ""}, {"name": "list.forall\u2082_same", "description": ""}, {"name": "relator.bi_unique.forall\u2082", "description": ""}, {"name": "list.rel_prod", "description": ""}, {"name": "list.forall\u2082_cons_left_iff", "description": ""}, {"name": "list.forall\u2082_take_append", "description": ""}, {"name": "list.sublist_forall\u2082", "description": "Given a relation `r`, `sublist_forall\u2082 r l\u2081 l\u2082` indicates that there is a sublist of `l\u2082` such\n that `forall\u2082 r l\u2081 l\u2082`."}, {"name": "list.sublist_forall\u2082.nil", "description": "Given a relation `r`, `sublist_forall\u2082 r l\u2081 l\u2082` indicates that there is a sublist of `l\u2082` such\n that `forall\u2082 r l\u2081 l\u2082`."}, {"name": "list.sublist_forall\u2082.cons", "description": "Given a relation `r`, `sublist_forall\u2082 r l\u2081 l\u2082` indicates that there is a sublist of `l\u2082` such\n that `forall\u2082 r l\u2081 l\u2082`."}, {"name": "list.sublist_forall\u2082.cons_right", "description": "Given a relation `r`, `sublist_forall\u2082 r l\u2081 l\u2082` indicates that there is a sublist of `l\u2082` such\n that `forall\u2082 r l\u2081 l\u2082`."}, {"name": "list.forall\u2082_iff_zip", "description": ""}, {"name": "list.forall\u2082_zip", "description": ""}, {"name": "list.forall\u2082_drop", "description": ""}, {"name": "list.rel_join", "description": ""}, {"name": "list.right_unique_forall\u2082'", "description": ""}, {"name": "list.rel_mem", "description": ""}, {"name": "list.sublist_forall\u2082_iff", "description": ""}, {"name": "list.forall\u2082_eq_eq_eq", "description": ""}, {"name": "list.forall\u2082_length_eq", "description": ""}, {"name": "list.forall\u2082_take", "description": ""}, {"name": "list.rel_sum", "description": ""}, {"name": "list.forall\u2082_map_left_iff", "description": ""}, {"name": "list.rel_foldl", "description": ""}, {"name": "list.forall\u2082_nil_right_iff", "description": ""}, {"name": "list.forall\u2082_iff", "description": ""}, {"name": "list.tail_sublist_forall\u2082_self", "description": ""}, {"name": "expr.coord.repr", "description": ""}, {"name": "expr.address", "description": " An address is a list of coordinates used to reference subterms of an expression.\nThe first coordinate in the list corresponds to the root of the expression."}, {"name": "expr.address.is_below", "description": ""}, {"name": "expr.coord.follow", "description": " Use this to pick the subexpression of a given expression that cooresponds\nto the given coordinate."}, {"name": "expr.coord.has_lt", "description": ""}, {"name": "expr.coord", "description": " An enum representing a recursive argument in an `expr` constructor.\nTypes of local and meta variables are not included because they are not consistently set and\ndepend on context."}, {"name": "expr.coord.app_fn", "description": " An enum representing a recursive argument in an `expr` constructor.\nTypes of local and meta variables are not included because they are not consistently set and\ndepend on context."}, {"name": "expr.coord.app_arg", "description": " An enum representing a recursive argument in an `expr` constructor.\nTypes of local and meta variables are not included because they are not consistently set and\ndepend on context."}, {"name": "expr.coord.lam_var_type", "description": " An enum representing a recursive argument in an `expr` constructor.\nTypes of local and meta variables are not included because they are not consistently set and\ndepend on context."}, {"name": "expr.coord.lam_body", "description": " An enum representing a recursive argument in an `expr` constructor.\nTypes of local and meta variables are not included because they are not consistently set and\ndepend on context."}, {"name": "expr.coord.pi_var_type", "description": " An enum representing a recursive argument in an `expr` constructor.\nTypes of local and meta variables are not included because they are not consistently set and\ndepend on context."}, {"name": "expr.coord.pi_body", "description": " An enum representing a recursive argument in an `expr` constructor.\nTypes of local and meta variables are not included because they are not consistently set and\ndepend on context."}, {"name": "expr.coord.elet_var_type", "description": " An enum representing a recursive argument in an `expr` constructor.\nTypes of local and meta variables are not included because they are not consistently set and\ndepend on context."}, {"name": "expr.coord.elet_assignment", "description": " An enum representing a recursive argument in an `expr` constructor.\nTypes of local and meta variables are not included because they are not consistently set and\ndepend on context."}, {"name": "expr.coord.elet_body", "description": " An enum representing a recursive argument in an `expr` constructor.\nTypes of local and meta variables are not included because they are not consistently set and\ndepend on context."}, {"name": "expr.address.has_to_string", "description": ""}, {"name": "expr.coord.has_repr", "description": ""}, {"name": "expr.coord.has_dec_eq", "description": ""}, {"name": "expr.coord.has_to_string", "description": ""}, {"name": "expr.address.has_append", "description": ""}, {"name": "expr.address.has_dec_eq", "description": ""}, {"name": "expr.address.has_repr", "description": ""}, {"name": "expr.coord.has_to_format", "description": ""}, {"name": "expr.address.has_to_format", "description": ""}, {"name": "expr.coord.code", "description": "Convert the coord enum to its index number."}, {"name": "expr.address.follow", "description": "`follow a e` finds the subexpression of `e` at the given address `a`."}, {"name": "expr.address.to_string", "description": ""}, {"name": "expr.address.as_below", "description": "`as_below x y` is some z when it finds `\u2203 z, x = y ++ z`"}, {"name": "json.inhabited", "description": ""}, {"name": "json.has_to_format", "description": ""}, {"name": "json.to_format", "description": ""}, {"name": "json.decidable_eq", "description": ""}, {"name": "json.unparse", "description": ""}, {"name": "json.int_coe", "description": ""}, {"name": "json.array_coe", "description": ""}, {"name": "json.float_coe", "description": ""}, {"name": "json", "description": ""}, {"name": "json.of_string", "description": ""}, {"name": "json.of_int", "description": ""}, {"name": "json.of_float", "description": ""}, {"name": "json.of_bool", "description": ""}, {"name": "json.null", "description": ""}, {"name": "json.object", "description": ""}, {"name": "json.array", "description": ""}, {"name": "json.has_repr", "description": ""}, {"name": "json.string_coe", "description": ""}, {"name": "json.parse", "description": ""}, {"name": "json.has_to_string", "description": ""}, {"name": "json.bool_coe", "description": ""}, {"name": "tactic.nth_rewrite.tracked_rewrite.eval", "description": " Postprocess a tracked rewrite into a pair\nof a rewritten expression and a proof witness of the rewrite."}, {"name": "tactic.nth_rewrite.tracked_rewrite", "description": " A data structure to track rewrites of subexpressions.\nThe field `exp` contains the new expression,\nwhile `proof` contains a proof that `exp` is equivalent to the expression that was rewritten."}, {"name": "tactic.nth_rewrite.tracked_rewrite.exp", "description": " A data structure to track rewrites of subexpressions.\nThe field `exp` contains the new expression,\nwhile `proof` contains a proof that `exp` is equivalent to the expression that was rewritten."}, {"name": "tactic.nth_rewrite.tracked_rewrite.proof", "description": " A data structure to track rewrites of subexpressions.\nThe field `exp` contains the new expression,\nwhile `proof` contains a proof that `exp` is equivalent to the expression that was rewritten."}, {"name": "tactic.nth_rewrite.tracked_rewrite.addr", "description": " A data structure to track rewrites of subexpressions.\nThe field `exp` contains the new expression,\nwhile `proof` contains a proof that `exp` is equivalent to the expression that was rewritten."}, {"name": "tactic.nth_rewrite.cfg", "description": "Configuration options for nth_rewrite."}, {"name": "tactic.nth_rewrite.cfg.to_rewrite_cfg", "description": "Configuration options for nth_rewrite."}, {"name": "tactic.nth_rewrite.cfg.try_simp", "description": "Configuration options for nth_rewrite."}, {"name": "tactic.nth_rewrite.cfg.discharger", "description": "Configuration options for nth_rewrite."}, {"name": "tactic.nth_rewrite.cfg.simplifier", "description": "Configuration options for nth_rewrite."}, {"name": "tactic.interactive.show_term", "description": "`show_term { tac }` runs the tactic `tac`,\nand then prints the term that was constructed.\n\nThis is useful for\n* constructing term mode proofs from tactic mode proofs, and\n* understanding what tactics are doing, and how metavariables are handled.\n\nAs an example, in\n```lean\nexample {P Q R : Prop} (h\u2081 : Q \u2192 P) (h\u2082 : R) (h\u2083 : R \u2192 Q) : P \u2227 R :=\nby show_term { tauto }\n```\nthe term mode proof `\u27e8h\u2081 (h\u2083 h\u2082), eq.mpr rfl h\u2082\u27e9` produced by `tauto` will be printed.\n\nAs another example, if the goal is `\u2115 \u00d7 \u2115`, `show_term { split, exact 0 }` will\nprint `refine (0, _)`, and afterwards there will be one remaining goal (of type `\u2115`).\nThis indicates that `split, exact 0` partially filled in the original metavariable,\nbut created a new metavariable for the resulting sub-goal."}, {"name": "tactic_doc.tactic.show_term", "description": "`show_term { tac }` runs the tactic `tac`,\nand then prints the term that was constructed.\n\nThis is useful for\n* constructing term mode proofs from tactic mode proofs, and\n* understanding what tactics are doing, and how metavariables are handled.\n\nAs an example, in\n```lean\nexample {P Q R : Prop} (h\u2081 : Q \u2192 P) (h\u2082 : R) (h\u2083 : R \u2192 Q) : P \u2227 R :=\nby show_term { tauto }\n```\nthe term mode proof `\u27e8h\u2081 (h\u2083 h\u2082), eq.mpr rfl h\u2082\u27e9` produced by `tauto` will be printed.\n\nAs another example, if the goal is `\u2115 \u00d7 \u2115`, `show_term { split, exact 0 }` will\nprint `refine (0, _)`, and afterwards there will be one remaining goal (of type `\u2115`).\nThis indicates that `split, exact 0` partially filled in the original metavariable,\nbut created a new metavariable for the resulting sub-goal."}, {"name": "tactic.interactive.hint", "description": "Report a list of tactics that can make progress against the current goal."}, {"name": "tactic_doc.tactic.hint", "description": "`hint` lists possible tactics which will make progress (that is, not fail) against the current goal.\n\n```lean\nexample {P Q : Prop} (p : P) (h : P \u2192 Q) : Q :=\nbegin\n  hint,\n  /- the following tactics make progress:\n     ----\n     Try this: solve_by_elim\n     Try this: finish\n     Try this: tauto\n  -/\n  solve_by_elim,\nend\n```\n\nYou can add a tactic to the list that `hint` tries by either using\n1. `attribute [hint_tactic] my_tactic`, if `my_tactic` is already of type `tactic string`\n(`tactic unit` is allowed too, in which case the printed string will be the name of the\ntactic), or\n2. `add_hint_tactic \"my_tactic\"`, specifying a string which works as an interactive tactic."}, {"name": "tactic.hint", "description": "Report a list of tactics that can make progress against the current goal,\nand for each such tactic, the number of remaining goals afterwards."}, {"name": "tactic.hint.hint_tactic_attribute", "description": " An attribute marking a `tactic unit` or `tactic string` which should be used by the `hint`\ntactic."}, {"name": "tactic_doc.attribute.hint_tactic", "description": " An attribute marking a `tactic unit` or `tactic string` which should be used by the `hint`\ntactic."}, {"name": "tactic.hint.add_hint_tactic", "description": "`add_hint_tactic t` runs the tactic `t` whenever `hint` is invoked.\nThe typical use case is `add_hint_tactic \"foo\"` for some interactive tactic `foo`."}, {"name": "tactic_doc.command.add_hint_tactic", "description": "`add_hint_tactic t` runs the tactic `t` whenever `hint` is invoked.\nThe typical use case is `add_hint_tactic \"foo\"` for some interactive tactic `foo`."}, {"name": "min_eq_left_of_lt", "description": ""}, {"name": "max_self", "description": ""}, {"name": "tactic.interactive.min_tac", "description": ""}, {"name": "max_comm", "description": ""}, {"name": "max_lt", "description": ""}, {"name": "max_assoc", "description": ""}, {"name": "le_min", "description": ""}, {"name": "max_eq_right", "description": ""}, {"name": "le_max_left", "description": ""}, {"name": "eq_min", "description": ""}, {"name": "lt_min", "description": ""}, {"name": "min_eq_left", "description": ""}, {"name": "min_comm", "description": ""}, {"name": "max_le", "description": ""}, {"name": "min_def", "description": ""}, {"name": "min_le_right", "description": ""}, {"name": "max_eq_left", "description": ""}, {"name": "min_assoc", "description": ""}, {"name": "min_left_comm", "description": ""}, {"name": "max_def", "description": ""}, {"name": "min_self", "description": ""}, {"name": "min_eq_right", "description": ""}, {"name": "min_eq_right_of_lt", "description": ""}, {"name": "max_left_comm", "description": ""}, {"name": "eq_max", "description": ""}, {"name": "max_eq_right_of_lt", "description": ""}, {"name": "min_le_left", "description": ""}, {"name": "le_max_right", "description": ""}, {"name": "max_eq_left_of_lt", "description": ""}, {"name": "littleendian.littleendian_is_inv", "description": "The `littleendian` function is invertible and its inverse is `littleendian_inv`.\n\n## TODO:\n\n- prove."}, {"name": "littleendian.littleendian_inv", "description": "The inverse of little-endian is indeed the function that sends a word (32 bits) \nback to the sequence of 4 bytes in a little endian way, so the least significant\nbyte goes first, and the most significant byte goes last. \nSo it maps \ud835\udc64 to w & 0xff, (w >> 8) & 0xff, (w >> 16) & 0xff, (w >> 24) & 0xff\n\nhttps://crypto.stackexchange.com/a/22314"}, {"name": "littleendian.littleendian", "description": " If b = (b\u2080, b\u2081, b\u2082, b\u2083) then\nlittleendian(b) = b\u2080 + (2^8)*b\u2081 + (2^16)*b\u2082 + (2^24)*b\u2083"}, {"name": "well_founded.fix", "description": "Well-founded fixpoint"}, {"name": "prod.rprod_wf", "description": ""}, {"name": "nat.lt_wf", "description": "less-than is well-founded"}, {"name": "prod.rprod", "description": ""}, {"name": "prod.rprod.intro", "description": ""}, {"name": "subrelation.accessible", "description": ""}, {"name": "inv_image.accessible", "description": ""}, {"name": "sizeof_measure", "description": ""}, {"name": "prod.lex", "description": ""}, {"name": "prod.lex.left", "description": ""}, {"name": "prod.lex.right", "description": ""}, {"name": "measure", "description": ""}, {"name": "acc", "description": " A value `x : \u03b1` is accessible from `r` when every value that's lesser under `r` is also\naccessible. Note that any value that's minimal under `r` is vacuously accessible.\n\nEquivalently, `acc r x` when there is no infinite chain of elements starting at `x` that are related\nunder `r`.\n\nThis is used to state the definition of well-foundedness (see `well_founded`)."}, {"name": "acc.intro", "description": " A value `x : \u03b1` is accessible from `r` when every value that's lesser under `r` is also\naccessible. Note that any value that's minimal under `r` is vacuously accessible.\n\nEquivalently, `acc r x` when there is no infinite chain of elements starting at `x` that are related\nunder `r`.\n\nThis is used to state the definition of well-foundedness (see `well_founded`)."}, {"name": "well_founded", "description": " A relation `r : \u03b1 \u2192 \u03b1 \u2192 Prop` is well-founded when `\u2200 x, (\u2200 y, r y x \u2192 P y \u2192 P x) \u2192 P x` for all\npredicates `P`. Equivalently, `acc r x` for all `x`.\n\nOnce you know that a relation is well_founded, you can use it to define fixpoint functions on `\u03b1`."}, {"name": "well_founded.apply", "description": " A relation `r : \u03b1 \u2192 \u03b1 \u2192 Prop` is well-founded when `\u2200 x, (\u2200 y, r y x \u2192 P y \u2192 P x) \u2192 P x` for all\npredicates `P`. Equivalently, `acc r x` for all `x`.\n\nOnce you know that a relation is well_founded, you can use it to define fixpoint functions on `\u03b1`."}, {"name": "subrelation.wf", "description": ""}, {"name": "well_founded.fix_F", "description": ""}, {"name": "prod.lex_wf", "description": ""}, {"name": "inv_image.wf", "description": ""}, {"name": "well_founded.recursion", "description": ""}, {"name": "well_founded.induction", "description": ""}, {"name": "prod.lex_accessible", "description": ""}, {"name": "has_well_founded_of_has_sizeof", "description": ""}, {"name": "prod.has_well_founded", "description": ""}, {"name": "sizeof_measure_wf", "description": ""}, {"name": "well_founded.fix_F_eq", "description": ""}, {"name": "empty_wf", "description": "Empty relation is well-founded"}, {"name": "measure_wf", "description": ""}, {"name": "well_founded.fix_eq", "description": "Well-founded fixpoint satisfies fixpoint equation"}, {"name": "has_well_founded", "description": ""}, {"name": "has_well_founded.r", "description": ""}, {"name": "has_well_founded.wf", "description": ""}, {"name": "acc.inv", "description": ""}, {"name": "prod.rprod_sub_lex", "description": ""}, {"name": "rat.division_ring", "description": ""}, {"name": "rat.field", "description": ""}, {"name": "option_t.monad_run", "description": ""}, {"name": "option_t.fail", "description": ""}, {"name": "option_t.bind", "description": ""}, {"name": "option_t.orelse", "description": ""}, {"name": "option_t.monad_map", "description": ""}, {"name": "option_t.alternative", "description": ""}, {"name": "option_t.pure", "description": ""}, {"name": "option_t.catch", "description": ""}, {"name": "option_t.monad_functor", "description": ""}, {"name": "option_t.of_option", "description": ""}, {"name": "option_t.has_monad_lift", "description": ""}, {"name": "option_t", "description": ""}, {"name": "option_t.run", "description": ""}, {"name": "option_t.bind_cont", "description": ""}, {"name": "option_t.monad_except", "description": ""}, {"name": "option_t.monad", "description": ""}, {"name": "option_t.lift", "description": ""}, {"name": "restate_axiom", "description": "`restate_axiom` takes a structure field, and makes a new, definitionally simplified copy of it.\nIf the existing field name ends with a `'`, the new field just has the prime removed. Otherwise,\nwe append `_lemma`.\nThe main application is to provide clean versions of structure fields that have been tagged with\nan auto_param."}, {"name": "restate_axiom_cmd", "description": "`restate_axiom` makes a new copy of a structure field, first definitionally simplifying the type.\nThis is useful to remove `auto_param` or `opt_param` from the statement.\n\nAs an example, we have:\n```lean\nstructure A :=\n(x : \u2115)\n(a' : x = 1 . skip)\n\nexample (z : A) : z.x = 1 := by rw A.a' -- rewrite tactic failed, lemma is not an equality nor a iff\n\nrestate_axiom A.a'\nexample (z : A) : z.x = 1 := by rw A.a\n```\n\nBy default, `restate_axiom` names the new lemma by removing a trailing `'`, or otherwise appending\n`_lemma` if there is no trailing `'`. You can also give `restate_axiom` a second argument to\nspecify the new name, as in\n```lean\nrestate_axiom A.a f\nexample (z : A) : z.x = 1 := by rw A.f\n```"}, {"name": "tactic_doc.command.restate_axiom", "description": "`restate_axiom` makes a new copy of a structure field, first definitionally simplifying the type.\nThis is useful to remove `auto_param` or `opt_param` from the statement.\n\nAs an example, we have:\n```lean\nstructure A :=\n(x : \u2115)\n(a' : x = 1 . skip)\n\nexample (z : A) : z.x = 1 := by rw A.a' -- rewrite tactic failed, lemma is not an equality nor a iff\n\nrestate_axiom A.a'\nexample (z : A) : z.x = 1 := by rw A.a\n```\n\nBy default, `restate_axiom` names the new lemma by removing a trailing `'`, or otherwise appending\n`_lemma` if there is no trailing `'`. You can also give `restate_axiom` a second argument to\nspecify the new name, as in\n```lean\nrestate_axiom A.a f\nexample (z : A) : z.x = 1 := by rw A.f\n```"}, {"name": "punit.countable", "description": ""}, {"name": "ulift.countable", "description": ""}, {"name": "exists_surjective_nat", "description": ""}, {"name": "fin.countable", "description": ""}, {"name": "plift.countable", "description": ""}, {"name": "equiv.countable_iff", "description": ""}, {"name": "countable_iff_exists_injective", "description": ""}, {"name": "subtype.countable", "description": ""}, {"name": "subsingleton.to_countable", "description": ""}, {"name": "bool.countable", "description": ""}, {"name": "countable_iff_exists_surjective", "description": ""}, {"name": "countable.of_equiv", "description": ""}, {"name": "Prop.countable'", "description": ""}, {"name": "function.injective.countable", "description": ""}, {"name": "quot.countable", "description": ""}, {"name": "countable", "description": "A type `\u03b1` is countable if there exists an injective map `\u03b1 \u2192 \u2115`."}, {"name": "countable.exists_injective_nat", "description": "A type `\u03b1` is countable if there exists an injective map `\u03b1 \u2192 \u2115`."}, {"name": "Prop.countable", "description": ""}, {"name": "nat.countable", "description": ""}, {"name": "finite.to_countable", "description": ""}, {"name": "function.surjective.countable", "description": ""}, {"name": "quotient.countable", "description": ""}, {"name": "list.duplicate.mono_sublist", "description": ""}, {"name": "list.duplicate_cons_iff_of_ne", "description": ""}, {"name": "list.duplicate.of_duplicate_cons", "description": ""}, {"name": "list.nodup_iff_forall_not_duplicate", "description": ""}, {"name": "list.duplicate.not_nodup", "description": ""}, {"name": "list.duplicate.ne_singleton", "description": ""}, {"name": "list.duplicate.elim_nil", "description": ""}, {"name": "list.duplicate.mem_cons_self", "description": ""}, {"name": "list.duplicate.duplicate_cons", "description": ""}, {"name": "list.duplicate_cons_iff", "description": ""}, {"name": "list.duplicate_iff_sublist", "description": "The contrapositive of `list.nodup_iff_sublist`."}, {"name": "list.mem.duplicate_cons_self", "description": ""}, {"name": "list.duplicate_cons_self_iff", "description": ""}, {"name": "list.duplicate_iff_two_le_count", "description": ""}, {"name": "list.duplicate.elim_singleton", "description": ""}, {"name": "list.not_duplicate_nil", "description": ""}, {"name": "list.decidable_duplicate", "description": ""}, {"name": "list.duplicate", "description": "Property that an element `x : \u03b1` of `l : list \u03b1` can be found in the list more than once."}, {"name": "list.duplicate.cons_mem", "description": "Property that an element `x : \u03b1` of `l : list \u03b1` can be found in the list more than once."}, {"name": "list.duplicate.cons_duplicate", "description": "Property that an element `x : \u03b1` of `l : list \u03b1` can be found in the list more than once."}, {"name": "list.exists_duplicate_iff_not_nodup", "description": ""}, {"name": "list.duplicate.mem", "description": ""}, {"name": "list.not_duplicate_singleton", "description": ""}, {"name": "list.duplicate.ne_nil", "description": ""}, {"name": "tactic_doc.tactic.apply_fun", "description": "Apply a function to an equality or inequality in either a local hypothesis or the goal.\n\n* If we have `h : a = b`, then `apply_fun f at h` will replace this with `h : f a = f b`.\n* If we have `h : a \u2264 b`, then `apply_fun f at h` will replace this with `h : f a \u2264 f b`,\n  and create a subsidiary goal `monotone f`.\n  `apply_fun` will automatically attempt to discharge this subsidiary goal using `mono`,\n  or an explicit solution can be provided with `apply_fun f at h using P`, where `P : monotone f`.\n* If the goal is `a \u2260 b`, `apply_fun f` will replace this with `f a \u2260 f b`.\n* If the goal is `a = b`, `apply_fun f` will replace this with `f a = f b`,\n  and create a subsidiary goal `injective f`.\n  `apply_fun` will automatically attempt to discharge this subsidiary goal using local hypotheses,\n  or if `f` is actually an `equiv`,\n  or an explicit solution can be provided with `apply_fun f using P`, where `P : injective f`.\n* If the goal is `a \u2264 b` (or similarly for `a < b`), and `f` is actually an `order_iso`,\n  `apply_fun f` will replace the goal with `f a \u2264 f b`.\n  If `f` is anything else (e.g. just a function, or an `equiv`), `apply_fun` will fail.\n\n\nTypical usage is:\n```lean\nopen function\n\nexample (X Y Z : Type) (f : X \u2192 Y) (g : Y \u2192 Z) (H : injective $ g \u2218 f) :\n  injective f :=\nbegin\n  intros x x' h,\n  apply_fun g at h,\n  exact H h\nend\n```"}, {"name": "tactic.apply_fun_to_goal", "description": "Attempt to \"apply\" a function `f` represented by the argument `e : pexpr` to the goal.\n\nIf the goal is of the form `a \u2260 b`, we obtain the new goal `f a \u2260 f b`.\nIf the goal is of the form `a = b`, we obtain a new goal `f a = f b`, and a subsidiary goal\n`injective f`.\n(We attempt to discharge this subsidiary goal automatically, or using the optional argument.)\nIf the goal is of the form `a \u2264 b` (or similarly for `a < b`), and `f` is an `order_iso`,\nwe obtain a new goal `f a \u2264 f b`."}, {"name": "tactic.interactive.apply_fun", "description": "Apply a function to an equality or inequality in either a local hypothesis or the goal.\n\n* If we have `h : a = b`, then `apply_fun f at h` will replace this with `h : f a = f b`.\n* If we have `h : a \u2264 b`, then `apply_fun f at h` will replace this with `h : f a \u2264 f b`,\n  and create a subsidiary goal `monotone f`.\n  `apply_fun` will automatically attempt to discharge this subsidiary goal using `mono`,\n  or an explicit solution can be provided with `apply_fun f at h using P`, where `P : monotone f`.\n* If the goal is `a \u2260 b`, `apply_fun f` will replace this with `f a \u2260 f b`.\n* If the goal is `a = b`, `apply_fun f` will replace this with `f a = f b`,\n  and create a subsidiary goal `injective f`.\n  `apply_fun` will automatically attempt to discharge this subsidiary goal using local hypotheses,\n  or if `f` is actually an `equiv`,\n  or an explicit solution can be provided with `apply_fun f using P`, where `P : injective f`.\n* If the goal is `a \u2264 b` (or similarly for `a < b`), and `f` is actually an `order_iso`,\n  `apply_fun f` will replace the goal with `f a \u2264 f b`.\n  If `f` is anything else (e.g. just a function, or an `equiv`), `apply_fun` will fail.\n\n\nTypical usage is:\n```lean\nopen function\n\nexample (X Y Z : Type) (f : X \u2192 Y) (g : Y \u2192 Z) (H : injective $ g \u2218 f) :\n  injective f :=\nbegin\n  intros x x' h,\n  apply_fun g at h,\n  exact H h\nend\n```"}, {"name": "tactic.apply_fun_to_hyp", "description": " Apply the function `f` given by `e : pexpr` to the local hypothesis `hyp`, which must either be\nof the form `a = b` or `a \u2264 b`, replacing the type of `hyp` with `f a = f b` or `f a \u2264 f b`. If\n`hyp` names an inequality then a new goal `monotone f` is created, unless the name of a proof of\nthis fact is passed as the optional argument `mono_lem`, or the `mono` tactic can prove it."}, {"name": "int.cast_eq_zero", "description": ""}, {"name": "int.cast_injective", "description": ""}, {"name": "int.cast_inj", "description": ""}, {"name": "ring_hom.injective_int", "description": ""}, {"name": "int.cast_ne_zero", "description": ""}, {"name": "int.cast_div_char_zero", "description": ""}, {"name": "task.bind", "description": ""}, {"name": "task.flatten", "description": ""}, {"name": "task.pure", "description": ""}, {"name": "task.get", "description": ""}, {"name": "task.delay", "description": ""}, {"name": "task.map", "description": ""}, {"name": "task", "description": "A task is a promise to produce a value later. They perform the same role as promises in JavaScript."}, {"name": "string.get_rest", "description": "`get_rest s t` returns `some r` if `s = t ++ r`.\n If `t` is not a prefix of `s`, returns `none`"}, {"name": "string.popn", "description": "Removes the first `n` elements from the string `s`"}, {"name": "string.map_tokens", "description": " `string.map_tokens c f s` tokenizes `s : string` on `c : char`, maps `f` over each token, and\nthen reassembles the string by intercalating the separator token `c` over the mapped tokens."}, {"name": "string.is_nat", "description": "`is_nat s` is true iff `s` is a nonempty sequence of digits."}, {"name": "string.ends_with", "description": "`x.ends_with y` is true if `y` is a suffix of `x`, and is false otherwise."}, {"name": "string.split_on", "description": "`s.split_on c` tokenizes `s : string` on `c : char`."}, {"name": "string.is_suffix_of", "description": "Tests whether the first string is a suffix of the second string."}, {"name": "string.is_prefix_of", "description": "Tests whether the first string is a prefix of the second string."}, {"name": "string.starts_with", "description": "`x.starts_with y` is true if `y` is a prefix of `x`, and is false otherwise."}, {"name": "string.head", "description": "Produce the head character from the string `s`, if `s` is not empty, otherwise 'A'."}, {"name": "int.cast_div", "description": ""}, {"name": "int.cast_neg_nat_cast", "description": "Auxiliary lemma for norm_cast to move the cast `-\u2191n` upwards to `\u2191-\u2191n`.\n\n(The restriction to `field` is necessary, otherwise this would also apply in the case where\n`R = \u2124` and cause nontermination.)"}, {"name": "exceptional.to_bool", "description": ""}, {"name": "exceptional.to_option", "description": ""}, {"name": "exceptional.has_to_string", "description": ""}, {"name": "exceptional.return", "description": ""}, {"name": "exceptional.to_string", "description": ""}, {"name": "exceptional.fail", "description": ""}, {"name": "exceptional", "description": "An exceptional is similar to `Result` in Haskell."}, {"name": "exceptional.success", "description": "An exceptional is similar to `Result` in Haskell."}, {"name": "exceptional.exception", "description": "An exceptional is similar to `Result` in Haskell."}, {"name": "exceptional.monad", "description": ""}, {"name": "exceptional.bind", "description": ""}, {"name": "show_widget_cmd", "description": " Accepts terms with the type `component tactic_state empty` or `html empty` and\nrenders them interactively."}, {"name": "tactic.clear'", "description": " Clears all the hypotheses in `hyps`. The tactic fails if any of the `hyps`\nis not a local or if the target depends on any of the `hyps`. It also fails if\n`hyps` contains duplicates.\n\nIf there are local hypotheses or definitions, say `H`, which are not in `hyps`\nbut depend on one of the `hyps`, what we do depends on `clear_dependent`. If it\nis true, `H` is implicitly also cleared. If it is false, `clear'` fails."}, {"name": "tactic.interactive.clear_dependent", "description": "A variant of `clear'` which clears not only the given hypotheses, but also any\nother hypotheses depending on them.\n\n```lean\nexample {\u03b1} {\u03b2 : \u03b1 \u2192 Type} (a : \u03b1) (b : \u03b2 a) : unit :=\nbegin\n  try { clear' a },  -- fails since `b` depends on `a`\n  clear_dependent a, -- succeeds, clearing `a` and `b`\n  exact ()\nend\n```"}, {"name": "tactic.interactive.clear'", "description": "An improved version of the standard `clear` tactic. `clear` is sensitive to the\norder of its arguments: `clear x y` may fail even though both `x` and `y` could\nbe cleared (if the type of `y` depends on `x`). `clear'` lifts this limitation.\n\n```lean\nexample {\u03b1} {\u03b2 : \u03b1 \u2192 Type} (a : \u03b1) (b : \u03b2 a) : unit :=\nbegin\n  try { clear a b }, -- fails since `b` depends on `a`\n  clear' a b,        -- succeeds\n  exact ()\nend\n```"}, {"name": "tactic_doc.tactic.clear'", "description": "An improved version of the standard `clear` tactic. `clear` is sensitive to the\norder of its arguments: `clear x y` may fail even though both `x` and `y` could\nbe cleared (if the type of `y` depends on `x`). `clear'` lifts this limitation.\n\n```lean\nexample {\u03b1} {\u03b2 : \u03b1 \u2192 Type} (a : \u03b1) (b : \u03b2 a) : unit :=\nbegin\n  try { clear a b }, -- fails since `b` depends on `a`\n  clear' a b,        -- succeeds\n  exact ()\nend\n```"}, {"name": "tactic.replacer", "description": ""}, {"name": "tactic_doc.command.def_replacer", "description": "`def_replacer foo` sets up a stub definition `foo : tactic unit`, which can\neffectively be defined and re-defined later, by tagging definitions with `@[foo]`.\n\n- `@[foo] meta def foo_1 : tactic unit := ...` replaces the current definition of `foo`.\n- `@[foo] meta def foo_2 (old : tactic unit) : tactic unit := ...` replaces the current\n  definition of `foo`, and provides access to the previous definition via `old`.\n  (The argument can also be an `option (tactic unit)`, which is provided as `none` if\n  this is the first definition tagged with `@[foo]` since `def_replacer` was invoked.)\n\n`def_replacer foo : \u03b1 \u2192 \u03b2 \u2192 tactic \u03b3` allows the specification of a replacer with\ncustom input and output types. In this case all subsequent redefinitions must have the\nsame type, or the type `\u03b1 \u2192 \u03b2 \u2192 tactic \u03b3 \u2192 tactic \u03b3` or\n`\u03b1 \u2192 \u03b2 \u2192 option (tactic \u03b3) \u2192 tactic \u03b3` analogously to the previous cases."}, {"name": "tactic.unprime", "description": ""}, {"name": "tactic.def_replacer_cmd", "description": "`def_replacer foo` sets up a stub definition `foo : tactic unit`, which can\neffectively be defined and re-defined later, by tagging definitions with `@[foo]`.\n\n- `@[foo] meta def foo_1 : tactic unit := ...` replaces the current definition of `foo`.\n- `@[foo] meta def foo_2 (old : tactic unit) : tactic unit := ...` replaces the current\n  definition of `foo`, and provides access to the previous definition via `old`.\n  (The argument can also be an `option (tactic unit)`, which is provided as `none` if\n  this is the first definition tagged with `@[foo]` since `def_replacer` was invoked.)\n\n`def_replacer foo : \u03b1 \u2192 \u03b2 \u2192 tactic \u03b3` allows the specification of a replacer with\ncustom input and output types. In this case all subsequent redefinitions must have the\nsame type, or the type `\u03b1 \u2192 \u03b2 \u2192 tactic \u03b3 \u2192 tactic \u03b3` or\n`\u03b1 \u2192 \u03b2 \u2192 option (tactic \u03b3) \u2192 tactic \u03b3` analogously to the previous cases."}, {"name": "tactic.mk_replacer\u2082", "description": ""}, {"name": "tactic.def_replacer", "description": "Define a new replaceable tactic."}, {"name": "tactic.mk_replacer", "description": ""}, {"name": "tactic.replacer_core", "description": ""}, {"name": "tactic.replaceable_attr", "description": ""}, {"name": "tactic.mk_replacer\u2081", "description": ""}, {"name": "tactic.replacer_attr", "description": ""}, {"name": "tactic.valid_types", "description": ""}, {"name": "tactic_doc.command.reassoc_axiom", "description": "When declaring a class of categories, the axioms can be reformulated to be more amenable\nto manipulation in right associated expressions:\n\n```lean\nclass some_class (C : Type) [category C] :=\n(foo : \u03a0 X : C, X \u27f6 X)\n(bar : \u2200 {X Y : C} (f : X \u27f6 Y), foo X \u226b f = f \u226b foo Y)\n\nreassoc_axiom some_class.bar\n```\n\nThe above will produce:\n\n```lean\nlemma some_class.bar_assoc {Z : C} (g : Y \u27f6 Z) :\n  foo X \u226b f \u226b g = f \u226b foo Y \u226b g := ...\n```\n\nHere too, the `reassoc` attribute can be used instead. It works well when combined with\n`simp`:\n\n```lean\nattribute [simp, reassoc] some_class.bar\n```"}, {"name": "tactic.interactive.reassoc", "description": " `reassoc h`, for assumption `h : x \u226b y = z`, creates a new assumption\n`h : \u2200 {W} (f : Z \u27f6 W), x \u226b y \u226b f = z \u226b f`.\n`reassoc! h`, does the same but deletes the initial `h` assumption.\n(You can also add the attribute `@[reassoc]` to lemmas to generate new declarations generalized\nin this way.)"}, {"name": "category_theory.reassoc_of", "description": " With `h : x \u226b y \u226b z = x` (with universal quantifiers tolerated),\n`reassoc_of h : \u2200 {X'} (f : W \u27f6 X'), x \u226b y \u226b z \u226b f = x \u226b f`.\n\nThe type and proof of `reassoc_of h` is generated by `tactic.derive_reassoc_proof`\nwhich make `reassoc_of` meta-programming adjacent. It is not called as a tactic but as\nan expression. The goal is to avoid creating assumptions that are dismissed after one use:\n\n```lean\nexample (X Y Z W : C) (x : X \u27f6 Y) (y : Y \u27f6 Z) (z z' : Z \u27f6 W) (w : X \u27f6 Z)\n  (h : x \u226b y = w)\n  (h' : y \u226b z = y \u226b z') :\n  x \u226b y \u226b z = w \u226b z' :=\nbegin\n  rw [h',reassoc_of h],\nend\n```"}, {"name": "tactic.get_cat_inst", "description": "From an expression `f \u226b g`, extract the expression representing the category instance."}, {"name": "tactic_doc.tactic.category_theory.reassoc_of", "description": "`reassoc_of h` takes local assumption `h` and add a ` \u226b f` term on the right of\nboth sides of the equality. Instead of creating a new assumption from the result, `reassoc_of h`\nstands for the proof of that reassociated statement. This keeps complicated assumptions that are\nused only once or twice from polluting the local context.\n\nIn the following, assumption `h` is needed in a reassociated form. Instead of proving it as a new\ngoal and adding it as an assumption, we use `reassoc_of h` as a rewrite rule which works just as\nwell.\n\n```lean\nexample (X Y Z W : C) (x : X \u27f6 Y) (y : Y \u27f6 Z) (z z' : Z \u27f6 W) (w : X \u27f6 Z)\n  (h : x \u226b y = w)\n  (h' : y \u226b z = y \u226b z') :\n  x \u226b y \u226b z = w \u226b z' :=\nbegin\n  -- reassoc_of h : \u2200 {X' : C} (f : W \u27f6 X'), x \u226b y \u226b f = w \u226b f\n  rw [h',reassoc_of h],\nend\n```\n\nAlthough `reassoc_of` is not a tactic or a meta program, its type is generated\nthrough meta-programming to make it usable inside normal expressions."}, {"name": "tactic.calculated_Prop", "description": ""}, {"name": "tactic.reassoc_attr", "description": "The `reassoc` attribute can be applied to a lemma\n\n```lean\n@[reassoc]\nlemma some_lemma : foo \u226b bar = baz := ...\n```\n\nto produce\n\n```lean\nlemma some_lemma_assoc {Y : C} (f : X \u27f6 Y) : foo \u226b bar \u226b f = baz \u226b f := ...\n```\n\nThe name of the produced lemma can be specified with `@[reassoc other_lemma_name]`. If\n`simp` is added first, the generated lemma will also have the `simp` attribute."}, {"name": "tactic.prove_reassoc", "description": " (internals for `@[reassoc]`)\nGiven a lemma of the form `\u2200 ..., f \u226b g = h`, proves a new lemma of the form\n`h : \u2200 ... {W} (k), f \u226b (g \u226b k) = h \u226b k`, and returns the type and proof of this lemma."}, {"name": "tactic.derive_reassoc_proof", "description": ""}, {"name": "tactic.reassoc_axiom", "description": " (implementation for `@[reassoc]`)\nGiven a declaration named `n` of the form `\u2200 ..., f \u226b g = h`, proves a new lemma named `n'`\nof the form `\u2200 ... {W} (k), f \u226b (g \u226b k) = h \u226b k`."}, {"name": "tactic.reassoc_cmd", "description": "When declaring a class of categories, the axioms can be reformulated to be more amenable\nto manipulation in right associated expressions:\n\n```lean\nclass some_class (C : Type) [category C] :=\n(foo : \u03a0 X : C, X \u27f6 X)\n(bar : \u2200 {X Y : C} (f : X \u27f6 Y), foo X \u226b f = f \u226b foo Y)\n\nreassoc_axiom some_class.bar\n```\n\nThe above will produce:\n\n```lean\nlemma some_class.bar_assoc {Z : C} (g : Y \u27f6 Z) :\n  foo X \u226b f \u226b g = f \u226b foo Y \u226b g := ...\n```\n\nHere too, the `reassoc` attribute can be used instead. It works well when combined with\n`simp`:\n\n```lean\nattribute [simp, reassoc] some_class.bar\n```"}, {"name": "tactic_doc.attribute.reassoc", "description": "The `reassoc` attribute can be applied to a lemma\n\n```lean\n@[reassoc]\nlemma some_lemma : foo \u226b bar = baz := ...\n```\n\nto produce\n\n```lean\nlemma some_lemma_assoc {Y : C} (f : X \u27f6 Y) : foo \u226b bar \u226b f = baz \u226b f := ...\n```\n\nThe name of the produced lemma can be specified with `@[reassoc other_lemma_name]`. If\n`simp` is added first, the generated lemma will also have the `simp` attribute."}, {"name": "rbtree.default_lt", "description": ""}, {"name": "mk_nat_val_le_proof", "description": ""}, {"name": "mk_int_val_ne_proof", "description": ""}, {"name": "mk_nat_val_ne_proof", "description": ""}, {"name": "mk_fin_val_ne_proof", "description": ""}, {"name": "mk_nat_val_lt_proof", "description": ""}, {"name": "tactic.comp_val", "description": ""}, {"name": "mk_char_val_ne_proof", "description": ""}, {"name": "mk_string_val_ne_proof", "description": ""}, {"name": "tactic.interactive.comp_val", "description": "Close goals of the form `n \u2260 m` when `n` and `m` have type `nat`, `char`, `string`, `int` or\n   subtypes `{i : \u2115 // p i}`, and they are literals.\n   It also closes goals of the form `n < m`, `n > m`, `n \u2264 m` and `n \u2265 m` for `nat`.\n   If the goal is of the form `n = m`, then it tries to close it using reflexivity."}, {"name": "pexpr.of_expr", "description": ""}, {"name": "pexpr.mk_placeholder", "description": ""}, {"name": "pexpr", "description": "Quoted expressions. They can be converted into expressions by using a tactic."}, {"name": "has_to_pexpr", "description": ""}, {"name": "has_to_pexpr.to_pexpr", "description": ""}, {"name": "pexpr.mk_structure_instance", "description": "Create a structure instance expression."}, {"name": "pexpr.is_placeholder", "description": ""}, {"name": "reflected.has_to_pexpr", "description": ""}, {"name": "expr.has_to_pexpr", "description": ""}, {"name": "structure_instance_info", "description": "Information about unelaborated structure instance expressions."}, {"name": "structure_instance_info.struct", "description": "Information about unelaborated structure instance expressions."}, {"name": "structure_instance_info.field_names", "description": "Information about unelaborated structure instance expressions."}, {"name": "structure_instance_info.field_values", "description": "Information about unelaborated structure instance expressions."}, {"name": "structure_instance_info.sources", "description": "Information about unelaborated structure instance expressions."}, {"name": "pexpr.has_to_pexpr", "description": ""}, {"name": "pexpr.mk_explicit", "description": ""}, {"name": "pexpr.is_choice_macro", "description": "Choice macros are used to implement overloading."}, {"name": "to_pexpr", "description": ""}, {"name": "pexpr.mk_field_macro", "description": ""}, {"name": "pexpr.get_structure_instance_info", "description": ""}, {"name": "if_false_left_eq_and", "description": ""}, {"name": "if_true_right_eq_or", "description": ""}, {"name": "if_true_left_eq_or", "description": ""}, {"name": "if_false_right_eq_and", "description": ""}, {"name": "expr.to_rat", "description": " Evaluates an expression as a rational number,\nif that expression represents a numeral, the quotient of two numerals,\nthe negation of a numeral, or the negation of the quotient of two numerals."}, {"name": "rat.reflect", "description": "`rat.reflect q` represents the rational number `q` as a numeral expression of type `\u211a`."}, {"name": "rat.mk_numeral", "description": "`rat.mk_numeral q` embeds `q` as a numeral expression inside a type with 0, 1, +, -, and /\n\n`type`: an expression representing the target type. This must live in Type 0.\n`has_zero`, `has_one`, `has_add`: expressions of the type `has_zero %%type`, etc.\n\nThis function is similar to `expr.of_rat` but takes more hypotheses and is not tactic valued."}, {"name": "expr.eval_rat", "description": "Evaluates an expression into a rational number, if that expression is built up from\n numerals, +, -, *, /, \u207b\u00b9"}, {"name": "tactic.instance_cache.of_rat", "description": " `c.of_rat q` embeds `q` as a numeral expression inside the type `\u03b1`.\nLean will try to infer the correct type classes on `c.\u03b1`, and the tactic will fail if it cannot.\nThis function is similar to `rat.mk_numeral` but it takes fewer hypotheses and is tactic valued."}, {"name": "rat.to_pexpr", "description": "`rat.to_pexpr q` creates a `pexpr` that will evaluate to `q`.\nThe `pexpr` does not hold any typing information:\n`to_expr ``((%%(rat.to_pexpr (3/4)) : K))` will create a native `K` numeral `(3/4 : K)`."}, {"name": "expr.of_rat", "description": " `expr.of_rat \u03b1 q` embeds `q` as a numeral expression inside the type `\u03b1`.\nLean will try to infer the correct type classes on `\u03b1`, and the tactic will fail if it cannot.\nThis function is similar to `rat.mk_numeral` but it takes fewer hypotheses and is tactic valued."}, {"name": "expr.to_nonneg_rat", "description": " Evaluates an expression as a rational number,\nif that expression represents a numeral or the quotient of two numerals."}, {"name": "string.iterator.length_next_to_string_next", "description": ""}, {"name": "string.iterator.next_to_string_mk_iterator", "description": ""}, {"name": "string.iterator.zero_lt_length_next_to_string_of_has_next", "description": ""}, {"name": "string.split", "description": ""}, {"name": "tagged_format.map", "description": ""}, {"name": "tagged_format", "description": "An alternative to format that keeps structural information stored as a tag."}, {"name": "tagged_format.tag", "description": "An alternative to format that keeps structural information stored as a tag."}, {"name": "tagged_format.compose", "description": "An alternative to format that keeps structural information stored as a tag."}, {"name": "tagged_format.group", "description": "An alternative to format that keeps structural information stored as a tag."}, {"name": "tagged_format.nest", "description": "An alternative to format that keeps structural information stored as a tag."}, {"name": "tagged_format.highlight", "description": "An alternative to format that keeps structural information stored as a tag."}, {"name": "tagged_format.of_format", "description": "An alternative to format that keeps structural information stored as a tag."}, {"name": "tactic_state.pp_tagged", "description": " A special version of pp which also preserves expression boundary information.\n\nOn a tag \u27e8e,a\u27e9, note that the given expr `e` is _not_ necessarily the subexpression of the root\nexpression that `tactic_state.pp_tagged` was called with. For example if the subexpression is\nunder a binder then all of the `expr.var 0`s will be replaced with a local constant not in\nthe local context with the name and type set to that of the binder."}, {"name": "tagged_format.m_untag", "description": ""}, {"name": "tagged_format.has_to_fmt", "description": ""}, {"name": "tagged_format.untag", "description": ""}, {"name": "eformat", "description": "tagged_format with information about subexpressions."}, {"name": "tactic.pp_tagged", "description": ""}, {"name": "tagged_format.is_functor", "description": ""}, {"name": "tactic.protect_proj_tac", "description": "Tactic that is executed when a structure is marked with the `protect_proj` attribute"}, {"name": "tactic_doc.attribute.protect_proj", "description": "Attribute to protect the projections of a structure.\nIf a structure `foo` is marked with the `protect_proj` user attribute, then\nall of the projections become protected, meaning they must always be referred to by\ntheir full name `foo.bar`, even when the `foo` namespace is open.\n\n`protect_proj without bar baz` will protect all projections except for `bar` and `baz`.\n\n```lean\n@[protect_proj without baz bar] structure foo : Type :=\n(bar : unit) (baz : unit) (qux : unit)\n```"}, {"name": "tactic_doc.attribute.protected", "description": "Attribute to protect a declaration.\nIf a declaration `foo.bar` is marked protected, then it must be referred to\nby its full name `foo.bar`, even when the `foo` namespace is open.\n\nProtectedness is a built in parser feature that is independent of this attribute.\nA declaration may be protected even if it does not have the `@[protected]` attribute.\nThis provides a convenient way to protect many declarations at once."}, {"name": "tactic.protected_attr", "description": "Attribute to protect a declaration.\nIf a declaration `foo.bar` is marked protected, then it must be referred to\nby its full name `foo.bar`, even when the `foo` namespace is open.\n\nProtectedness is a built in parser feature that is independent of this attribute.\nA declaration may be protected even if it does not have the `@[protected]` attribute.\nThis provides a convenient way to protect many declarations at once."}, {"name": "tactic.protect_proj_attr", "description": "Attribute to protect the projections of a structure.\nIf a structure `foo` is marked with the `protect_proj` user attribute, then\nall of the projections become protected, meaning they must always be referred to by\ntheir full name `foo.bar`, even when the `foo` namespace is open.\n\n`protect_proj without bar baz` will protect all projections except for `bar` and `baz`.\n\n```lean\n@[protect_proj without baz bar] structure foo : Type :=\n(bar : unit) (baz : unit) (qux : unit)\n```"}, {"name": "monad.filter", "description": ""}, {"name": "monad.foldl", "description": ""}, {"name": "mjoin", "description": ""}, {"name": "monad.sequence'", "description": ""}, {"name": "monad.whenb", "description": ""}, {"name": "monad.join", "description": ""}, {"name": "list.mfirst", "description": ""}, {"name": "list.mfilter", "description": ""}, {"name": "monad.sequence", "description": ""}, {"name": "monad.cond", "description": ""}, {"name": "monad.mapm", "description": ""}, {"name": "when", "description": ""}, {"name": "list.mmap", "description": ""}, {"name": "list.mfoldl", "description": ""}, {"name": "monad.unlessb", "description": ""}, {"name": "mwhen", "description": ""}, {"name": "monad.mapm'", "description": ""}, {"name": "mcond", "description": ""}, {"name": "list.mfoldr", "description": ""}, {"name": "list.mmap'", "description": ""}, {"name": "tactic.abstract_if_success", "description": ""}, {"name": "tactic.chain_core", "description": ""}, {"name": "tactic.trace_output", "description": ""}, {"name": "tactic.chain", "description": ""}, {"name": "tactic.tactic_script_unit_has_to_string", "description": ""}, {"name": "tactic.chain_single", "description": "`chain_many tac` recursively tries `tac` on all goals, working depth-first on generated subgoals,\nuntil it no longer succeeds on any goal. `chain_many` automatically makes auxiliary definitions."}, {"name": "tactic.chain_iter", "description": "`chain_many tac` recursively tries `tac` on all goals, working depth-first on generated subgoals,\nuntil it no longer succeeds on any goal. `chain_many` automatically makes auxiliary definitions."}, {"name": "tactic.chain_many", "description": "`chain_many tac` recursively tries `tac` on all goals, working depth-first on generated subgoals,\nuntil it no longer succeeds on any goal. `chain_many` automatically makes auxiliary definitions."}, {"name": "tactic.congr", "description": ""}, {"name": "tactic.apply_heq_congr_core", "description": ""}, {"name": "tactic.apply_eq_congr_core", "description": ""}, {"name": "tactic.apply_congr_core", "description": ""}, {"name": "tactic.congr_core", "description": ""}, {"name": "widget.tc", "description": "A component that implicitly depends on tactic_state. For efficiency we always assume that the tactic_state is unchanged between component renderings."}, {"name": "widget.tc.to_html", "description": ""}, {"name": "widget.tc.to_component", "description": ""}, {"name": "widget.tc.of_component", "description": ""}, {"name": "widget.tc.map_action", "description": ""}, {"name": "widget.tc.has_coe_to_fun", "description": ""}, {"name": "widget.tc.stateless", "description": ""}, {"name": "widget.tc.mk_simple", "description": " Make a tactic component from some init, update, views which are expecting a tactic.\nThe tactic_state never mutates."}, {"name": "widget.tc.map_props", "description": ""}, {"name": "tactic.auto_cases.auto_cases_tac", "description": "Structure representing a tactic which can be used by `tactic.auto_cases`."}, {"name": "tactic.auto_cases.auto_cases_tac.name", "description": "Structure representing a tactic which can be used by `tactic.auto_cases`."}, {"name": "tactic.auto_cases.auto_cases_tac.\u03b1", "description": "Structure representing a tactic which can be used by `tactic.auto_cases`."}, {"name": "tactic.auto_cases.auto_cases_tac.tac", "description": "Structure representing a tactic which can be used by `tactic.auto_cases`."}, {"name": "tactic.auto_cases_at", "description": "Applies `cases` or `induction` on the local_hypothesis `hyp : expr`."}, {"name": "tactic.auto_cases.tac_cases", "description": "The `auto_cases_tac` for `tactic.cases`."}, {"name": "tactic.auto_cases", "description": "Applies `cases` or `induction` on certain hypotheses."}, {"name": "tactic.auto_cases.find_tac", "description": "Find an `auto_cases_tac` which matches the given `type : expr`."}, {"name": "tactic.auto_cases.tac_induction", "description": "The `auto_cases_tac` for `tactic.induction`."}, {"name": "list.all_iff_forall", "description": ""}, {"name": "list.any_iff_exists_prop", "description": ""}, {"name": "list.any_of_mem", "description": ""}, {"name": "list.all_iff_forall_prop", "description": ""}, {"name": "list.all_nil", "description": ""}, {"name": "list.any_nil", "description": ""}, {"name": "list.all_cons", "description": ""}, {"name": "list.any_iff_exists", "description": ""}, {"name": "list.any_cons", "description": ""}, {"name": "has_pos_part", "description": "The positive part of an element admiting a decomposition into positive and negative parts."}, {"name": "has_pos_part.pos", "description": "The positive part of an element admiting a decomposition into positive and negative parts."}, {"name": "has_neg_part", "description": "The negative part of an element admiting a decomposition into positive and negative parts."}, {"name": "has_neg_part.neg", "description": "The negative part of an element admiting a decomposition into positive and negative parts."}, {"name": "has_abs", "description": "Absolute value is a unary operator with properties similar to the absolute value of a real number."}, {"name": "has_abs.abs", "description": "Absolute value is a unary operator with properties similar to the absolute value of a real number."}, {"name": "has_seq_left", "description": ""}, {"name": "has_seq_left.seq_left", "description": ""}, {"name": "applicative", "description": ""}, {"name": "applicative.to_functor", "description": ""}, {"name": "applicative.to_has_pure", "description": ""}, {"name": "applicative.to_has_seq", "description": ""}, {"name": "applicative.to_has_seq_left", "description": ""}, {"name": "applicative.to_has_seq_right", "description": ""}, {"name": "has_seq_right", "description": ""}, {"name": "has_seq_right.seq_right", "description": ""}, {"name": "has_seq", "description": ""}, {"name": "has_seq.seq", "description": ""}, {"name": "has_pure", "description": ""}, {"name": "has_pure.pure", "description": ""}, {"name": "relator.lift_fun", "description": ""}, {"name": "relator.right_total", "description": ""}, {"name": "relator.left_unique.flip", "description": ""}, {"name": "relator.bi_total.rel_exists", "description": ""}, {"name": "relator.bi_unique", "description": ""}, {"name": "relator.bi_total.rel_forall", "description": ""}, {"name": "relator.rel_not", "description": ""}, {"name": "relator.rel_or", "description": ""}, {"name": "relator.left_total.rel_exists", "description": ""}, {"name": "relator.rel_iff", "description": ""}, {"name": "relator.right_total.rel_forall", "description": ""}, {"name": "relator.left_total", "description": ""}, {"name": "relator.rel_imp", "description": ""}, {"name": "relator.bi_total_eq", "description": ""}, {"name": "relator.bi_total", "description": ""}, {"name": "relator.left_unique_of_rel_eq", "description": ""}, {"name": "relator.right_unique", "description": ""}, {"name": "relator.rel_and", "description": ""}, {"name": "relator.left_unique", "description": ""}, {"name": "relator.rel_eq", "description": ""}, {"name": "tactic.interactive.delta_instance", "description": "`delta_instance id\u2081 id\u2082 ...` tries to solve the goal by calling `apply_instance`,\nfirst unfolding the definitions in `id\u1d62`."}, {"name": "tactic.delta_instance_handler", "description": "Tries to derive instances by unfolding the newly introduced type and applying type class resolution.\n\nFor example,\n```lean\n@[derive ring] def new_int : Type := \u2124\n```\nadds an instance `ring new_int`, defined to be the instance of `ring \u2124` found by `apply_instance`.\n\nMultiple instances can be added with `@[derive [ring, module \u211d]]`.\n\nThis derive handler applies only to declarations made using `def`, and will fail on such a\ndeclaration if it is unable to derive an instance. It is run with higher priority than the built-in\nhandlers, which will fail on `def`s."}, {"name": "tactic.delta_instance", "description": "`delta_instance ids` tries to solve the goal by calling `apply_instance`,\nfirst unfolding the definitions in `ids`."}, {"name": "tactic.delta_instance_name", "description": " Guess a name for an instance from its expression.\n\nThis is a poor-man's version of the C++ `heuristic_inst_name`, and tries much less hard to pick a\ngood name."}, {"name": "tactic.mk_pattern", "description": " `mk_pattern umetas emetas target uoutput eoutput` creates a new pattern. The arguments are\n- `umetas` a list of level params to be replaced with temporary universe metavariables.\n- `emetas` a list of local constants to be replaced with temporary metavariables.\n- `target` the expression to be matched.\n- `uoutput` a list of levels to return upon matching. Fails if this depends on metavariables.\n- `eoutput` a list of expressions to return upon matching. Fails if this depends on metavariables.\n\nThe procedure is as follows:\n1. Convert all metavariables in `target` to temporary metavariables.\n2. For each item in `umetas` amd `emetas`, create a temporary\n   metavariable and replace each instance of the item in `target` with a temporary metavariable\n3. Replace these instances in `uoutput` and `eoutput` too.\n4. Return these replaced versions as a `pattern`.\n\n## Example\nLet `h`,`t` be exprs with types `\u03b1` and `list \u03b1` respectively.\nThen `mk_pattern [] [\u03b1,h,t] `(@list.cons \u03b1 h t) [] [h,t]` would `match_pattern` against any expr which is a list.cons constructor and return the head and tail arguments."}, {"name": "tactic.match_subexpr", "description": "Similar to match_expr, but it tries to match a subexpression of e.\n  Remark: the procedure does not go inside binders."}, {"name": "tactic.match_hypothesis", "description": "Match hypothesis in the main goal target.\n  The result is pair (hypothesis, substitution)."}, {"name": "tactic.match_expr", "description": "Convert pre-term into a pattern and try to match e.\n  Given p of the form `\u03bb x\u2081 ... x\u2099, t[x\u2081, ..., x\u2099]`, a successful\n  match will produce a list of length n."}, {"name": "tactic.match_target_subexpr", "description": "Match a subterm in the main goal target."}, {"name": "tactic.pattern.has_to_tactic_format", "description": ""}, {"name": "tactic.match_target", "description": "Match the main goal target."}, {"name": "tactic.match_pattern", "description": "`mk_pattern p e m` matches (pattern.target p) and e using transparency m.\n  If the matching is successful, then return the instantiation of `pattern.output p`.\n  The tactic fails if not all (temporary) meta-variables are assigned."}, {"name": "tactic.pattern", "description": " A pattern is an expression `target` containing temporary metavariables.\nA pattern also contains a list of `outputs` which also depend on these temporary metavariables.\nWhen we run `match p e`, the system will match `p.target` with `e` and assign\nthe temporary metavariables. It then returns the outputs with the assigned variables.\n\n## Fields\n\n- `target` Term to match. Contains temporary metavariables.\n- `uoutput` List of universes that are returned on a successful match.\n- `moutput` List of expressions that are returned on a successful match.\n- `nuvars` Number of (temporary) universe metavariables in this pattern.\n- `nmvars` Number of (temporary) metavariables in this pattern.\n\n## Example\n\nThe pattern for `list.cons h t` returning `h` and `t` would be\n```lean\n{ target  := `(@list.cons ?x_0 ?x_1 ?x_2),\n  uoutput := [],\n  moutput := [?x_1,?x_2],\n  nuvars  := 0,\n  nmvars  := 3\n}\n```"}, {"name": "tactic.pattern.target", "description": " A pattern is an expression `target` containing temporary metavariables.\nA pattern also contains a list of `outputs` which also depend on these temporary metavariables.\nWhen we run `match p e`, the system will match `p.target` with `e` and assign\nthe temporary metavariables. It then returns the outputs with the assigned variables.\n\n## Fields\n\n- `target` Term to match. Contains temporary metavariables.\n- `uoutput` List of universes that are returned on a successful match.\n- `moutput` List of expressions that are returned on a successful match.\n- `nuvars` Number of (temporary) universe metavariables in this pattern.\n- `nmvars` Number of (temporary) metavariables in this pattern.\n\n## Example\n\nThe pattern for `list.cons h t` returning `h` and `t` would be\n```lean\n{ target  := `(@list.cons ?x_0 ?x_1 ?x_2),\n  uoutput := [],\n  moutput := [?x_1,?x_2],\n  nuvars  := 0,\n  nmvars  := 3\n}\n```"}, {"name": "tactic.pattern.uoutput", "description": " A pattern is an expression `target` containing temporary metavariables.\nA pattern also contains a list of `outputs` which also depend on these temporary metavariables.\nWhen we run `match p e`, the system will match `p.target` with `e` and assign\nthe temporary metavariables. It then returns the outputs with the assigned variables.\n\n## Fields\n\n- `target` Term to match. Contains temporary metavariables.\n- `uoutput` List of universes that are returned on a successful match.\n- `moutput` List of expressions that are returned on a successful match.\n- `nuvars` Number of (temporary) universe metavariables in this pattern.\n- `nmvars` Number of (temporary) metavariables in this pattern.\n\n## Example\n\nThe pattern for `list.cons h t` returning `h` and `t` would be\n```lean\n{ target  := `(@list.cons ?x_0 ?x_1 ?x_2),\n  uoutput := [],\n  moutput := [?x_1,?x_2],\n  nuvars  := 0,\n  nmvars  := 3\n}\n```"}, {"name": "tactic.pattern.moutput", "description": " A pattern is an expression `target` containing temporary metavariables.\nA pattern also contains a list of `outputs` which also depend on these temporary metavariables.\nWhen we run `match p e`, the system will match `p.target` with `e` and assign\nthe temporary metavariables. It then returns the outputs with the assigned variables.\n\n## Fields\n\n- `target` Term to match. Contains temporary metavariables.\n- `uoutput` List of universes that are returned on a successful match.\n- `moutput` List of expressions that are returned on a successful match.\n- `nuvars` Number of (temporary) universe metavariables in this pattern.\n- `nmvars` Number of (temporary) metavariables in this pattern.\n\n## Example\n\nThe pattern for `list.cons h t` returning `h` and `t` would be\n```lean\n{ target  := `(@list.cons ?x_0 ?x_1 ?x_2),\n  uoutput := [],\n  moutput := [?x_1,?x_2],\n  nuvars  := 0,\n  nmvars  := 3\n}\n```"}, {"name": "tactic.pattern.nuvars", "description": " A pattern is an expression `target` containing temporary metavariables.\nA pattern also contains a list of `outputs` which also depend on these temporary metavariables.\nWhen we run `match p e`, the system will match `p.target` with `e` and assign\nthe temporary metavariables. It then returns the outputs with the assigned variables.\n\n## Fields\n\n- `target` Term to match. Contains temporary metavariables.\n- `uoutput` List of universes that are returned on a successful match.\n- `moutput` List of expressions that are returned on a successful match.\n- `nuvars` Number of (temporary) universe metavariables in this pattern.\n- `nmvars` Number of (temporary) metavariables in this pattern.\n\n## Example\n\nThe pattern for `list.cons h t` returning `h` and `t` would be\n```lean\n{ target  := `(@list.cons ?x_0 ?x_1 ?x_2),\n  uoutput := [],\n  moutput := [?x_1,?x_2],\n  nuvars  := 0,\n  nmvars  := 3\n}\n```"}, {"name": "tactic.pattern.nmvars", "description": " A pattern is an expression `target` containing temporary metavariables.\nA pattern also contains a list of `outputs` which also depend on these temporary metavariables.\nWhen we run `match p e`, the system will match `p.target` with `e` and assign\nthe temporary metavariables. It then returns the outputs with the assigned variables.\n\n## Fields\n\n- `target` Term to match. Contains temporary metavariables.\n- `uoutput` List of universes that are returned on a successful match.\n- `moutput` List of expressions that are returned on a successful match.\n- `nuvars` Number of (temporary) universe metavariables in this pattern.\n- `nmvars` Number of (temporary) metavariables in this pattern.\n\n## Example\n\nThe pattern for `list.cons h t` returning `h` and `t` would be\n```lean\n{ target  := `(@list.cons ?x_0 ?x_1 ?x_2),\n  uoutput := [],\n  moutput := [?x_1,?x_2],\n  nuvars  := 0,\n  nmvars  := 3\n}\n```"}, {"name": "tactic.pexpr_to_pattern", "description": "Given a pre-term of the form `\u03bb x\u2081 ... x\u2099, t[x\u2081, ..., x\u2099]`, converts it\n  into the pattern `t[?x\u2081, ..., ?x\u2099]` with outputs `[?x\u2081, ..., ?x\u2099]`"}, {"name": "function.equiv.refl", "description": ""}, {"name": "function.equiv.trans", "description": ""}, {"name": "function.equiv.is_equivalence", "description": ""}, {"name": "function.fun_to_extfun", "description": "The map from functions into the qquotient by pointwise equality."}, {"name": "funext", "description": "Function extensionality, proven using quotients."}, {"name": "pi.subsingleton", "description": ""}, {"name": "function.equiv.symm", "description": ""}, {"name": "function.extfun_app", "description": "From an element of `extfun` we can retrieve an actual function."}, {"name": "function.equiv", "description": "The relation stating that two functions are pointwise equal."}, {"name": "function.extfun", "description": "The quotient of the function type by pointwise equality."}, {"name": "function.fun_setoid", "description": "The setoid generated by pointwise equality."}, {"name": "tactic.mk_dec_eq_instance", "description": ""}, {"name": "tactic.mk_dec_eq_instance_core", "description": ""}, {"name": "tactic.binder_info.has_decidable_eq", "description": ""}, {"name": "tactic.decidable_eq_derive_handler", "description": ""}, {"name": "tactic.generalize_proofs", "description": "Generalize proofs in the goal, naming them with the provided list."}, {"name": "tactic_doc.tactic.generalize_proofs", "description": " Generalize proofs in the goal, naming them with the provided list.\n\nFor example:\n```lean\nexample : list.nth_le [1, 2] 1 dec_trivial = 2 :=\nbegin\n  -- \u22a2 [1, 2].nth_le 1 _ = 2\n  generalize_proofs h,\n  -- h : 1 < [1, 2].length\n  -- \u22a2 [1, 2].nth_le 1 h = 2\nend\n```"}, {"name": "tactic.interactive.generalize_proofs", "description": " Generalize proofs in the goal, naming them with the provided list.\n\nFor example:\n```lean\nexample : list.nth_le [1, 2] 1 dec_trivial = 2 :=\nbegin\n  -- \u22a2 [1, 2].nth_le 1 _ = 2\n  generalize_proofs h,\n  -- h : 1 < [1, 2].length\n  -- \u22a2 [1, 2].nth_le 1 h = 2\nend\n```"}, {"name": "char.is_whitespace", "description": ""}, {"name": "char.to_lower", "description": ""}, {"name": "char.is_lower", "description": ""}, {"name": "char.decidable_is_digit", "description": ""}, {"name": "char.is_punctuation", "description": ""}, {"name": "char.decidable_is_punctuation", "description": ""}, {"name": "char.decidable_is_upper", "description": ""}, {"name": "char.is_upper", "description": ""}, {"name": "char.is_alpha", "description": ""}, {"name": "char.is_digit", "description": ""}, {"name": "char.is_alphanum", "description": ""}, {"name": "char.decidable_is_lower", "description": ""}, {"name": "char.decidable_is_whitespace", "description": ""}, {"name": "char.decidable_is_alpha", "description": ""}, {"name": "char.decidable_is_alphanum", "description": ""}, {"name": "tactic.alias.alias_attr", "description": "An auxiliary attribute which is placed on definitions created by the `alias` command."}, {"name": "tactic.alias.target.has_reflect", "description": ""}, {"name": "tactic_doc.command.alias", "description": "The `alias` command can be used to create copies\nof a theorem or definition with different names.\n\nSyntax:\n\n```lean\n/-- doc string -/\nalias my_theorem \u2190 alias1 alias2 ...\n```\n\nThis produces defs or theorems of the form:\n\n```lean\n/-- doc string -/\n@[alias] theorem alias1 : <type of my_theorem> := my_theorem\n\n/-- doc string -/\n@[alias] theorem alias2 : <type of my_theorem> := my_theorem\n```\n\nIff alias syntax:\n\n```lean\nalias A_iff_B \u2194 B_of_A A_of_B\nalias A_iff_B \u2194 ..\n```\n\nThis gets an existing biconditional theorem `A_iff_B` and produces\nthe one-way implications `B_of_A` and `A_of_B` (with no change in\nimplicit arguments). A blank `_` can be used to avoid generating one direction.\nThe `..` notation attempts to generate the 'of'-names automatically when the\ninput theorem has the form `A_iff_B` or `A_iff_B_left` etc."}, {"name": "tactic.alias.mk_iff_mp_app", "description": " Given a proof of `\u03a0 x y z, a \u2194 b`, produces a proof of `\u03a0 x y z, a \u2192 b` or `\u03a0 x y z, b \u2192 a`\n(depending on whether `iffmp` is `iff.mp` or `iff.mpr`). The variable `f` supplies the proof,\nunder the specified number of binders."}, {"name": "tactic.alias.target.to_string", "description": "The docstring for an alias. Used by `alias` _and_ by `to_additive`"}, {"name": "tactic.alias.target", "description": "An alias can be in one of three forms"}, {"name": "tactic.alias.target.plain", "description": "An alias can be in one of three forms"}, {"name": "tactic.alias.target.forward", "description": "An alias can be in one of three forms"}, {"name": "tactic.alias.target.backwards", "description": "An alias can be in one of three forms"}, {"name": "tactic.alias.alias_cmd", "description": "The `alias` command can be used to create copies\nof a theorem or definition with different names.\n\nSyntax:\n\n```lean\n/-- doc string -/\nalias my_theorem \u2190 alias1 alias2 ...\n```\n\nThis produces defs or theorems of the form:\n\n```lean\n/-- doc string -/\n@[alias] theorem alias1 : <type of my_theorem> := my_theorem\n\n/-- doc string -/\n@[alias] theorem alias2 : <type of my_theorem> := my_theorem\n```\n\nIff alias syntax:\n\n```lean\nalias A_iff_B \u2194 B_of_A A_of_B\nalias A_iff_B \u2194 ..\n```\n\nThis gets an existing biconditional theorem `A_iff_B` and produces\nthe one-way implications `B_of_A` and `A_of_B` (with no change in\nimplicit arguments). A blank `_` can be used to avoid generating one direction.\nThe `..` notation attempts to generate the 'of'-names automatically when the\ninput theorem has the form `A_iff_B` or `A_iff_B_left` etc."}, {"name": "tactic.alias.alias_direct", "description": "The core tactic which handles `alias d \u2190 al`. Creates an alias `al` for declaration `d`."}, {"name": "tactic.alias.alias_iff", "description": " The core tactic which handles `alias d \u2194 al _` or `alias d \u2194 _ al`. `ns` is the current\nnamespace, and `is_forward` is true if this is the forward implication (the first form)."}, {"name": "tactic.alias.get_alias_target", "description": " Given a definition, look up the definition that it is an alias of.\nReturns `none` if this defintion is not an alias."}, {"name": "tactic.alias.make_left_right", "description": "Get the default names for left/right to be used by `alias d \u2194 ..`."}, {"name": "tactic.alias.target.to_name", "description": "The name underlying an alias target"}, {"name": "equiv_functor.map_equiv_apply", "description": ""}, {"name": "equiv_functor.map_equiv_refl", "description": ""}, {"name": "equiv_functor.map_trans", "description": ""}, {"name": "equiv_functor", "description": "An `equiv_functor` is only functorial with respect to equivalences.\n\nTo construct an `equiv_functor`, it suffices to supply just the function `f \u03b1 \u2192 f \u03b2` from\nan equivalence `\u03b1 \u2243 \u03b2`, and then prove the functor laws. It's then a consequence that\nthis function is part of an equivalence, provided by `equiv_functor.map_equiv`."}, {"name": "equiv_functor.map", "description": "An `equiv_functor` is only functorial with respect to equivalences.\n\nTo construct an `equiv_functor`, it suffices to supply just the function `f \u03b1 \u2192 f \u03b2` from\nan equivalence `\u03b1 \u2243 \u03b2`, and then prove the functor laws. It's then a consequence that\nthis function is part of an equivalence, provided by `equiv_functor.map_equiv`."}, {"name": "equiv_functor.map_refl'", "description": "An `equiv_functor` is only functorial with respect to equivalences.\n\nTo construct an `equiv_functor`, it suffices to supply just the function `f \u03b1 \u2192 f \u03b2` from\nan equivalence `\u03b1 \u2243 \u03b2`, and then prove the functor laws. It's then a consequence that\nthis function is part of an equivalence, provided by `equiv_functor.map_equiv`."}, {"name": "equiv_functor.map_trans'", "description": "An `equiv_functor` is only functorial with respect to equivalences.\n\nTo construct an `equiv_functor`, it suffices to supply just the function `f \u03b1 \u2192 f \u03b2` from\nan equivalence `\u03b1 \u2243 \u03b2`, and then prove the functor laws. It's then a consequence that\nthis function is part of an equivalence, provided by `equiv_functor.map_equiv`."}, {"name": "equiv_functor.of_is_lawful_functor", "description": ""}, {"name": "equiv_functor.map_equiv.injective", "description": ""}, {"name": "equiv_functor.map_equiv_symm", "description": ""}, {"name": "equiv_functor.map_equiv", "description": "An `equiv_functor` in fact takes every equiv to an equiv."}, {"name": "equiv_functor.map_equiv_symm_apply", "description": ""}, {"name": "equiv_functor.map_equiv_trans", "description": "The composition of `map_equiv`s is carried over the `equiv_functor`.\nFor plain `functor`s, this lemma is named `map_map` when applied\nor `map_comp_map` when not applied."}, {"name": "equiv_functor.map_refl", "description": ""}, {"name": "nat.cast_injective", "description": ""}, {"name": "nat.cast_ne_one", "description": ""}, {"name": "char_zero_of_inj_zero", "description": ""}, {"name": "nat.cast_inj", "description": ""}, {"name": "nat.cast_add_one_ne_zero", "description": ""}, {"name": "nat.cast_eq_zero", "description": ""}, {"name": "char_zero", "description": " Typeclass for monoids with characteristic zero.\n  (This is usually stated on fields but it makes sense for any additive monoid with 1.)\n\n*Warning*: for a semiring `R`, `char_zero R` and `char_p R 0` need not coincide.\n* `char_zero R` requires an injection `\u2115 \u21aa R`;\n* `char_p R 0` asks that only `0 : \u2115` maps to `0 : R` under the map `\u2115 \u2192 R`.\n\nFor instance, endowing `{0, 1}` with addition given by `max` (i.e. `1` is absorbing), shows that\n`char_zero {0, 1}` does not hold and yet `char_p {0, 1} 0` does.\nThis example is formalized in `counterexamples/char_p_zero_ne_char_zero`."}, {"name": "char_zero.cast_injective", "description": " Typeclass for monoids with characteristic zero.\n  (This is usually stated on fields but it makes sense for any additive monoid with 1.)\n\n*Warning*: for a semiring `R`, `char_zero R` and `char_p R 0` need not coincide.\n* `char_zero R` requires an injection `\u2115 \u21aa R`;\n* `char_p R 0` asks that only `0 : \u2115` maps to `0 : R` under the map `\u2115 \u2192 R`.\n\nFor instance, endowing `{0, 1}` with addition given by `max` (i.e. `1` is absorbing), shows that\n`char_zero {0, 1}` does not hold and yet `char_p {0, 1} 0` does.\nThis example is formalized in `counterexamples/char_p_zero_ne_char_zero`."}, {"name": "nat.cast_eq_one", "description": ""}, {"name": "nat.cast_ne_zero", "description": ""}, {"name": "sum.inhabited_left", "description": ""}, {"name": "sum.inhabited_right", "description": ""}, {"name": "obviously'", "description": "The default implementation of `obviously`\ndischarges any goals which contain `sorry` in their type using `sorry`,\nand then calls `tidy`."}, {"name": "obviously", "description": "The `obviously` tactic is a \"replaceable\" tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields."}, {"name": "obviously.attr", "description": ""}, {"name": "dlist_singleton", "description": ""}, {"name": "dlist.join", "description": " Concatenates a list of difference lists to form a single difference list. Similar to\n`list.join`."}, {"name": "dlist_lazy", "description": ""}, {"name": "list.reflect", "description": ""}, {"name": "reflected_value.subst", "description": ""}, {"name": "reflected_value.expr", "description": ""}, {"name": "has_reflect", "description": "`has_reflect \u03b1` lets you produce an `expr` from an instance of \u03b1. That is, it is a function from \u03b1 to expr such that the expr has type \u03b1."}, {"name": "punit.reflect", "description": ""}, {"name": "unsigned.reflect", "description": ""}, {"name": "name.reflect", "description": ""}, {"name": "reflected_value", "description": ""}, {"name": "reflected_value.val", "description": ""}, {"name": "reflected_value.reflect", "description": ""}, {"name": "nat.reflect", "description": ""}, {"name": "tactic.choose1", "description": " Changes `(h : \u2200xs, \u2203a:\u03b1, p a) \u22a2 g` to `(d : \u2200xs, a) (s : \u2200xs, p (d xs)) \u22a2 g` and\n`(h : \u2200xs, p xs \u2227 q xs) \u22a2 g` to `(d : \u2200xs, p xs) (s : \u2200xs, q xs) \u22a2 g`.\n`choose1` returns a pair of the second local constant it introduces,\nand the error result (see below).\n\nIf `nondep` is true and `\u03b1` is inhabited, then it will remove the dependency of `d` on\nall propositional assumptions in `xs`. For example if `ys` are propositions then\n`(h : \u2200xs ys, \u2203a:\u03b1, p a) \u22a2 g` becomes `(d : \u2200xs, a) (s : \u2200xs ys, p (d xs)) \u22a2 g`.\n\nThe second value returned by `choose1` is the result of nondep elimination:\n* `none`: nondep elimination was not attempted or was not applicable\n* `some none`: nondep elimination was successful\n* ``some (some `(nonempty \u03b1))``: nondep elimination was unsuccessful\n  because we could not find a `nonempty \u03b1` instance"}, {"name": "tactic.choose", "description": " Changes `(h : \u2200xs, \u2203as, p as \u2227 q as) \u22a2 g` to a list of functions `as`,\nand a final hypothesis on `p as` and `q as`. If `nondep` is true then the functions will\nbe made to not depend on propositional arguments, when possible.\n\nThe last argument is an internal recursion variable, indicating whether nondep elimination\nhas been useful so far. The tactic fails if `nondep` is true, and nondep elimination is\nattempted at least once, and it fails every time it is attempted, in which case it returns\nan error complaining about the first attempt."}, {"name": "tactic_doc.tactic.choose", "description": " `choose a b h h' using hyp` takes an hypothesis `hyp` of the form\n`\u2200 (x : X) (y : Y), \u2203 (a : A) (b : B), P x y a b \u2227 Q x y a b`\nfor some `P Q : X \u2192 Y \u2192 A \u2192 B \u2192 Prop` and outputs\ninto context a function `a : X \u2192 Y \u2192 A`, `b : X \u2192 Y \u2192 B` and two assumptions:\n`h : \u2200 (x : X) (y : Y), P x y (a x y) (b x y)` and\n`h' : \u2200 (x : X) (y : Y), Q x y (a x y) (b x y)`. It also works with dependent versions.\n\n`choose! a b h h' using hyp` does the same, except that it will remove dependency of\nthe functions on propositional arguments if possible. For example if `Y` is a proposition\nand `A` and `B` are nonempty in the above example then we will instead get\n`a : X \u2192 A`, `b : X \u2192 B`, and the assumptions\n`h : \u2200 (x : X) (y : Y), P x y (a x) (b x)` and\n`h' : \u2200 (x : X) (y : Y), Q x y (a x) (b x)`.\n\nExamples:\n\n```lean\nexample (h : \u2200n m : \u2115, \u2203i j, m = n + i \u2228 m + j = n) : true :=\nbegin\n  choose i j h using h,\n  guard_hyp i : \u2115 \u2192 \u2115 \u2192 \u2115,\n  guard_hyp j : \u2115 \u2192 \u2115 \u2192 \u2115,\n  guard_hyp h : \u2200 (n m : \u2115), m = n + i n m \u2228 m + j n m = n,\n  trivial\nend\n```\n\n```lean\nexample (h : \u2200 i : \u2115, i < 7 \u2192 \u2203 j, i < j \u2227 j < i+i) : true :=\nbegin\n  choose! f h h' using h,\n  guard_hyp f : \u2115 \u2192 \u2115,\n  guard_hyp h : \u2200 (i : \u2115), i < 7 \u2192 i < f i,\n  guard_hyp h' : \u2200 (i : \u2115), i < 7 \u2192 f i < i + i,\n  trivial,\nend\n```"}, {"name": "tactic.mk_sometimes", "description": " Given `\u03b1 : Sort u`, `nonemp : nonempty \u03b1`, `p : \u03b1 \u2192 Prop`, a context of local variables\n`ctxt`, and a pair of an element `val : \u03b1` and `spec : p val`,\n`mk_sometimes u \u03b1 nonemp p ctx (val, spec)` produces another pair `val', spec'`\nsuch that `val'` does not have any free variables from elements of `ctxt` whose types are\npropositions. This is done by applying `function.sometimes` to abstract over all the propositional\narguments."}, {"name": "tactic.interactive.choose", "description": " `choose a b h h' using hyp` takes an hypothesis `hyp` of the form\n`\u2200 (x : X) (y : Y), \u2203 (a : A) (b : B), P x y a b \u2227 Q x y a b`\nfor some `P Q : X \u2192 Y \u2192 A \u2192 B \u2192 Prop` and outputs\ninto context a function `a : X \u2192 Y \u2192 A`, `b : X \u2192 Y \u2192 B` and two assumptions:\n`h : \u2200 (x : X) (y : Y), P x y (a x y) (b x y)` and\n`h' : \u2200 (x : X) (y : Y), Q x y (a x y) (b x y)`. It also works with dependent versions.\n\n`choose! a b h h' using hyp` does the same, except that it will remove dependency of\nthe functions on propositional arguments if possible. For example if `Y` is a proposition\nand `A` and `B` are nonempty in the above example then we will instead get\n`a : X \u2192 A`, `b : X \u2192 B`, and the assumptions\n`h : \u2200 (x : X) (y : Y), P x y (a x) (b x)` and\n`h' : \u2200 (x : X) (y : Y), Q x y (a x) (b x)`.\n\nExamples:\n\n```lean\nexample (h : \u2200n m : \u2115, \u2203i j, m = n + i \u2228 m + j = n) : true :=\nbegin\n  choose i j h using h,\n  guard_hyp i : \u2115 \u2192 \u2115 \u2192 \u2115,\n  guard_hyp j : \u2115 \u2192 \u2115 \u2192 \u2115,\n  guard_hyp h : \u2200 (n m : \u2115), m = n + i n m \u2228 m + j n m = n,\n  trivial\nend\n```\n\n```lean\nexample (h : \u2200 i : \u2115, i < 7 \u2192 \u2203 j, i < j \u2227 j < i+i) : true :=\nbegin\n  choose! f h h' using h,\n  guard_hyp f : \u2115 \u2192 \u2115,\n  guard_hyp h : \u2200 (i : \u2115), i < 7 \u2192 i < f i,\n  guard_hyp h' : \u2200 (i : \u2115), i < 7 \u2192 f i < i + i,\n  trivial,\nend\n```"}, {"name": "tactic.eapply'", "description": "Same as `apply'` but only goals that don't depend on other goals are added to goal list."}, {"name": "tactic.interactive.symmetry'", "description": "`symmetry'` behaves like `symmetry` but also offers the option `symmetry' at h` to apply symmetry\nto assumption `h`"}, {"name": "tactic.reorder_goals", "description": " With `gs` a list of proof goals, `reorder_goals gs new_g` will use the `new_goals` policy\n`new_g` to rearrange the dependent goals to either drop them, push them to the end of the list\nor leave them in place. The `bool` values in `gs` indicates whether the goal is dependent or not."}, {"name": "tactic.interactive.reflexivity'", "description": "Similar to `reflexivity` with the difference that `apply'` is used instead of `apply`."}, {"name": "tactic.apply'", "description": " `apply'` mimics the behavior of `apply_core`. When\n`apply_core` fails, it is retried by providing the term with meta\nvariables as additional arguments. The meta variables can then\nbecome new goals depending on the `cfg.new_goals` policy.\n\n`apply'` also finds instances and applies opt_params and auto_params."}, {"name": "tactic.interactive.apply_with'", "description": "Similar to the `apply'` tactic, but allows the user to provide a `apply_cfg` configuration object."}, {"name": "tactic.interactive.mapply'", "description": "Similar to the `apply'` tactic, but uses matching instead of unification.\n`mapply' t` is equivalent to `apply_with' t {unify := ff}`"}, {"name": "tactic.interactive.fapply'", "description": "Similar to the `apply'` tactic, but does not reorder goals."}, {"name": "tactic.fapply'", "description": "Same as `apply'` but __all__ arguments that weren't inferred are added to goal list."}, {"name": "tactic.symmetry'", "description": "Similar to `symmetry` with the difference that `apply'` is used instead of `apply`"}, {"name": "tactic.interactive.eapply'", "description": "Similar to the `apply'` tactic, but only creates subgoals for non-dependent premises that have not\nbeen fixed by type inference or type class resolution."}, {"name": "tactic.transitivity'", "description": "Similar to `transitivity` with the difference that `apply'` is used instead of `apply`"}, {"name": "tactic.interactive.apply'", "description": "Similarly to `apply`, the `apply'` tactic tries to match the current goal against the conclusion\nof the type of term.\n\nIt differs from `apply` in that it does not unfold definition in order to find out what the\nassumptions of the provided term is. It is especially useful when defining relations on function\nspaces (e.g. `\u2264`) so that rules like transitivity on `le : (\u03b1 \u2192 \u03b2) \u2192 (\u03b1 \u2192 \u03b2) \u2192 (\u03b1 \u2192 \u03b2)` will be\nconsidered to have three parameters and two assumptions (i.e. `f g h : \u03b1 \u2192 \u03b2`, `H\u2080 : f \u2264 g`,\n`H\u2081 : g \u2264 h`) instead of three parameters, two assumptions and then one more parameter\n(i.e. `f g h : \u03b1 \u2192 \u03b2`, `H\u2080 : f \u2264 g`, `H\u2081 : g \u2264 h`, `x : \u03b1`). Whereas `apply` would expect the goal\n`f x \u2264 h x`, `apply'` will work with the goal `f \u2264 h`."}, {"name": "tactic.interactive.transitivity'", "description": "Similar to `transitivity` with the difference that `apply'` is used instead of `apply`."}, {"name": "tactic.reflexivity'", "description": "Similar to `reflexivity` with the difference that `apply'` is used instead of `apply`"}, {"name": "tactic.interactive.refl'", "description": "Shorter name for the tactic `reflexivity'`."}, {"name": "tactic.interactive.nth_rewrite", "description": " `nth_rewrite n rules` performs only the `n`th possible rewrite using the `rules`.\nThe tactics `nth_rewrite_lhs` and `nth_rewrite_rhs` are variants\nthat operate on the left and right hand sides of an equation or iff.\n\nNote: `n` is zero-based, so `nth_rewrite 0 h`\nwill rewrite along `h` at the first possible location.\n\nIn more detail, given `rules = [h1, ..., hk]`,\nthis tactic will search for all possible locations\nwhere one of `h1, ..., hk` can be rewritten,\nand perform the `n`th occurrence.\n\nExample: Given a goal of the form `a + x = x + b`, and hypothesis `h : x = y`,\nthe tactic `nth_rewrite 1 h` will change the goal to `a + x = y + b`.\n\nThe core `rewrite` has a `occs` configuration setting intended to achieve a similar\npurpose, but this doesn't really work. (If a rule matches twice, but with different\nvalues of arguments, the second match will not be identified.)"}, {"name": "tactic.interactive.nth_rewrite_lhs", "description": " `nth_rewrite n rules` performs only the `n`th possible rewrite using the `rules`.\nThe tactics `nth_rewrite_lhs` and `nth_rewrite_rhs` are variants\nthat operate on the left and right hand sides of an equation or iff.\n\nNote: `n` is zero-based, so `nth_rewrite 0 h`\nwill rewrite along `h` at the first possible location.\n\nIn more detail, given `rules = [h1, ..., hk]`,\nthis tactic will search for all possible locations\nwhere one of `h1, ..., hk` can be rewritten,\nand perform the `n`th occurrence.\n\nExample: Given a goal of the form `a + x = x + b`, and hypothesis `h : x = y`,\nthe tactic `nth_rewrite 1 h` will change the goal to `a + x = y + b`.\n\nThe core `rewrite` has a `occs` configuration setting intended to achieve a similar\npurpose, but this doesn't really work. (If a rule matches twice, but with different\nvalues of arguments, the second match will not be identified.)"}, {"name": "tactic.target_or_hyp_type", "description": " Returns the target of the goal when passed `none`,\notherwise, return the type of `h` in `some h`."}, {"name": "tactic.nth_rewrite_core", "description": " Rewrite the `n`th occurrence of the rewrite rules `q` (optionally on a side)\nat all the locations `loc`."}, {"name": "tactic.interactive.nth_rewrite_rhs", "description": " `nth_rewrite n rules` performs only the `n`th possible rewrite using the `rules`.\nThe tactics `nth_rewrite_lhs` and `nth_rewrite_rhs` are variants\nthat operate on the left and right hand sides of an equation or iff.\n\nNote: `n` is zero-based, so `nth_rewrite 0 h`\nwill rewrite along `h` at the first possible location.\n\nIn more detail, given `rules = [h1, ..., hk]`,\nthis tactic will search for all possible locations\nwhere one of `h1, ..., hk` can be rewritten,\nand perform the `n`th occurrence.\n\nExample: Given a goal of the form `a + x = x + b`, and hypothesis `h : x = y`,\nthe tactic `nth_rewrite 1 h` will change the goal to `a + x = y + b`.\n\nThe core `rewrite` has a `occs` configuration setting intended to achieve a similar\npurpose, but this doesn't really work. (If a rule matches twice, but with different\nvalues of arguments, the second match will not be identified.)"}, {"name": "tactic.replace_in_state", "description": " Replace the target, or a hypothesis, depending on whether `none` or `some h` is given as the\nfirst argument."}, {"name": "tactic_doc.tactic.nth_rewrite / nth_rewrite_lhs / nth_rewrite_rhs", "description": " `nth_rewrite n rules` performs only the `n`th possible rewrite using the `rules`.\nThe tactics `nth_rewrite_lhs` and `nth_rewrite_rhs` are variants\nthat operate on the left and right hand sides of an equation or iff.\n\nNote: `n` is zero-based, so `nth_rewrite 0 h`\nwill rewrite along `h` at the first possible location.\n\nIn more detail, given `rules = [h1, ..., hk]`,\nthis tactic will search for all possible locations\nwhere one of `h1, ..., hk` can be rewritten,\nand perform the `n`th occurrence.\n\nExample: Given a goal of the form `a + x = x + b`, and hypothesis `h : x = y`,\nthe tactic `nth_rewrite 1 h` will change the goal to `a + x = y + b`.\n\nThe core `rewrite` has a `occs` configuration setting intended to achieve a similar\npurpose, but this doesn't really work. (If a rule matches twice, but with different\nvalues of arguments, the second match will not be identified.)"}, {"name": "tactic.get_nth_rewrite", "description": " Get the `n`th rewrite of rewrite rules `q` in expression `e`,\nor fail if there are not enough such rewrites."}, {"name": "tactic.get_nth_rewrite_with_zoom", "description": " Rewrite the `n`th occurrence of the rewrite rules `q` of (optionally after zooming into) a\nhypothesis or target `h` which is an application of a relation."}, {"name": "category_theory.nat_trans", "description": "`nat_trans F G` represents a natural transformation between functors `F` and `G`.\n\nThe field `app` provides the components of the natural transformation.\n\nNaturality is expressed by `\u03b1.naturality_lemma`."}, {"name": "category_theory.nat_trans.app", "description": "`nat_trans F G` represents a natural transformation between functors `F` and `G`.\n\nThe field `app` provides the components of the natural transformation.\n\nNaturality is expressed by `\u03b1.naturality_lemma`."}, {"name": "category_theory.nat_trans.naturality'", "description": "`nat_trans F G` represents a natural transformation between functors `F` and `G`.\n\nThe field `app` provides the components of the natural transformation.\n\nNaturality is expressed by `\u03b1.naturality_lemma`."}, {"name": "category_theory.nat_trans.naturality", "description": ""}, {"name": "category_theory.congr_app", "description": ""}, {"name": "category_theory.nat_trans.inhabited", "description": ""}, {"name": "category_theory.nat_trans.ext", "description": ""}, {"name": "category_theory.nat_trans.vcomp", "description": "`vcomp \u03b1 \u03b2` is the vertical compositions of natural transformations."}, {"name": "category_theory.nat_trans.naturality_assoc", "description": ""}, {"name": "category_theory.nat_trans.id", "description": "`nat_trans.id F` is the identity natural transformation on a functor `F`."}, {"name": "category_theory.nat_trans.ext_iff", "description": ""}, {"name": "category_theory.nat_trans.vcomp_app", "description": ""}, {"name": "category_theory.nat_trans.id_app'", "description": ""}, {"name": "ordering", "description": ""}, {"name": "ordering.lt", "description": ""}, {"name": "ordering.eq", "description": ""}, {"name": "ordering.gt", "description": ""}, {"name": "ordering.decidable_eq", "description": ""}, {"name": "ordering.has_repr", "description": ""}, {"name": "ordering.swap_swap", "description": ""}, {"name": "cmp_using", "description": ""}, {"name": "cmp", "description": ""}, {"name": "ordering.swap", "description": ""}, {"name": "ordering.or_else", "description": ""}, {"name": "tactic.nth_rewrite.congr.rewrite_without_new_mvars", "description": " Helper function which just tries to rewrite `e` using the equality `r` without assigning any\nmetavariables in the tactic state, and without creating any metavariables which cannot be\ndischarged by `cfg.discharger` in the process."}, {"name": "tactic.nth_rewrite.congr.all_rewrites", "description": " List of all rewrites of an expression `e` by `r : expr \u00d7 bool`.\nHere `r.1` is the substituting expression and `r.2` flags the direction of the rewrite."}, {"name": "tactic.nth_rewrite.congr.rewrite_at_lens", "description": " Function which tries to perform the rewrite associated to the equality `r : expr \u00d7 bool` (the\nbool indicates whether we should flip the equality first), at the position pointed to by\n`l : expr_lens`, by rewriting `e : expr`. If this succeeds, `rewrite_at_lens` computes (by unwinding\n`l`) a proof that the entire expression represented by `l.fill e` is equal to the entire expression\n`l.fill f`, where `f` is the `expr` which has replaced `e` due to the rewrite. It then returns the\nsingleton list containing this rewrite (and the tracking data needed to reconstruct it directly). If\nit fails, it just returns the empty list."}, {"name": "tactic.nth_rewrite.congr.rewrite_is_of_entire", "description": " Returns true if the argument is a proof that the entire expression was rewritten.\n\nThis is a bit of a hack: we manually inspect the proof that `rewrite_core` produced, and deduce from\nthat whether or not the entire expression was rewritten."}, {"name": "has_bind", "description": ""}, {"name": "has_bind.bind", "description": ""}, {"name": "has_bind.seq", "description": ""}, {"name": "has_bind.and_then", "description": ""}, {"name": "monad", "description": ""}, {"name": "monad.to_applicative", "description": ""}, {"name": "monad.to_has_bind", "description": ""}, {"name": "return", "description": ""}, {"name": "mathlib_dir_locator", "description": "This is a dummy declaration that is used to determine the project folder of mathlib, using the\n tactic `tactic.decl_olean`. This is used in `tactic.get_mathlib_dir`."}, {"name": "match_failed", "description": ""}, {"name": "monad_fail_lift", "description": ""}, {"name": "monad_fail", "description": ""}, {"name": "monad_fail.fail", "description": ""}, {"name": "tactic.simp_cmd", "description": "The basic usage is `#simp e`, where `e` is an expression,\nwhich will print the simplified form of `e`.\n\nYou can specify additional simp lemmas as usual for example using\n`#simp [f, g] : e`, or `#simp with attr : e`.\n(The colon is optional, but helpful for the parser.)\n\n`#simp` understands local variables, so you can use them to\nintroduce parameters."}, {"name": "tactic.simp_arg_type.replace_subexprs", "description": " `simp_arg_type.replace_subexprs` calls `expr.replace_subexprs` on the underlying `pexpr`, if\nthere is one, and then prepares the result for use by the simplifier."}, {"name": "tactic_doc.command.#simp", "description": "The basic usage is `#simp e`, where `e` is an expression,\nwhich will print the simplified form of `e`.\n\nYou can specify additional simp lemmas as usual for example using\n`#simp [f, g] : e`, or `#simp with attr : e`.\n(The colon is optional, but helpful for the parser.)\n\n`#simp` understands local variables, so you can use them to\nintroduce parameters."}, {"name": "tactic.simp_arg_type.to_pexpr", "description": " `simp_arg_type.to_pexpr` retrieves the `pexpr` underlying the given `simp_arg_type`, if there is\none."}, {"name": "setoid.trans", "description": ""}, {"name": "setoid.symm", "description": ""}, {"name": "setoid", "description": ""}, {"name": "setoid.r", "description": ""}, {"name": "setoid.iseqv", "description": ""}, {"name": "setoid_has_equiv", "description": ""}, {"name": "setoid.refl", "description": ""}, {"name": "is_simp_eq", "description": " Checks whether two expressions are equal for the simplifier. That is,\nthey are reducibly-definitional equal, and they have the same head symbol."}, {"name": "library_note.simp-normal form", "description": "This note gives you some tips to debug any errors that the simp-normal form linter raises.\n\nThe reason that a lemma was considered faulty is because its left-hand side is not in simp-normal\nform.\nThese lemmas are hence never used by the simplifier.\n\nThis linter gives you a list of other simp lemmas: look at them!\n\nHere are some tips depending on the error raised by the linter:\n\n  1. 'the left-hand side reduces to XYZ':\n     you should probably use XYZ as the left-hand side.\n\n  2. 'simp can prove this':\n     This typically means that lemma is a duplicate, or is shadowed by another lemma:\n\n     2a. Always put more general lemmas after specific ones:\n      ```lean\n      @[simp] lemma zero_add_zero : 0 + 0 = 0 := rfl\n      @[simp] lemma add_zero : x + 0 = x := rfl\n      ```\n\n      And not the other way around!  The simplifier always picks the last matching lemma.\n\n     2b. You can also use `@[priority]` instead of moving simp-lemmas around in the file.\n\n      Tip: the default priority is 1000.\n      Use `@[priority 1100]` instead of moving a lemma down,\n      and `@[priority 900]` instead of moving a lemma up.\n\n     2c. Conditional simp lemmas are tried last. If they are shadowed\n         just remove the `simp` attribute.\n\n     2d. If two lemmas are duplicates, the linter will complain about the first one.\n         Try to fix the second one instead!\n         (You can find it among the other simp lemmas the linter prints out!)\n\n  3. 'try_for tactic failed, timeout':\n     This typically means that there is a loop of simp lemmas.\n     Try to apply squeeze_simp to the right-hand side (removing this lemma from the simp set) to see\n     what lemmas might be causing the loop.\n\n     Another trick is to `set_option trace.simplify.rewrite true` and\n     then apply `try_for 10000 { simp }` to the right-hand side.  You will\n     see a periodic sequence of lemma applications in the trace message."}, {"name": "linter.simp_comm", "description": "A linter for commutativity lemmas that are marked simp."}, {"name": "linter.simp_var_head", "description": "A linter for simp lemmas whose lhs has a variable as head symbol,\nand which hence never fire."}, {"name": "linter.simp_nf", "description": "A linter for simp lemmas whose lhs is not in simp-normal form, and which hence never fire."}, {"name": "simp_nf_linter", "description": "Reports declarations that are simp lemmas whose left-hand side is not in simp-normal form."}, {"name": "tactic.reflexivity", "description": ""}, {"name": "tactic.target_lhs_rhs", "description": "If the main target has the form `r lhs rhs`, then return `(r,lhs,rhs)`."}, {"name": "tactic.symmetry", "description": ""}, {"name": "tactic.relation_lhs_rhs", "description": ""}, {"name": "tactic.subst_vars", "description": "Try to apply subst exhaustively"}, {"name": "tactic.transitivity", "description": ""}, {"name": "rowround_examples.input'", "description": ""}, {"name": "rowround_examples.output", "description": ""}, {"name": "rowround_examples.input", "description": ""}, {"name": "rowround_examples.output'", "description": ""}, {"name": "embedding_like", "description": " The class `embedding_like F \u03b1 \u03b2` expresses that terms of type `F` have an\ninjective coercion to injective functions `\u03b1 \u21aa \u03b2`."}, {"name": "embedding_like.to_fun_like", "description": " The class `embedding_like F \u03b1 \u03b2` expresses that terms of type `F` have an\ninjective coercion to injective functions `\u03b1 \u21aa \u03b2`."}, {"name": "embedding_like.injective'", "description": " The class `embedding_like F \u03b1 \u03b2` expresses that terms of type `F` have an\ninjective coercion to injective functions `\u03b1 \u21aa \u03b2`."}, {"name": "embedding_like.comp_injective", "description": ""}, {"name": "embedding_like.injective", "description": ""}, {"name": "embedding_like.apply_eq_iff_eq", "description": ""}, {"name": "id_bind", "description": ""}, {"name": "id.monad", "description": ""}, {"name": "id.monad_run", "description": ""}, {"name": "subtype.exists_of_subtype", "description": ""}, {"name": "subtype.inhabited", "description": ""}, {"name": "subtype.eta", "description": ""}, {"name": "subtype.eq", "description": ""}, {"name": "subtype.tag_irrelevant", "description": ""}, {"name": "subtype.ne_of_val_ne", "description": ""}, {"name": "tactic.get_string_option", "description": ""}, {"name": "tactic.set_nat_option", "description": ""}, {"name": "tactic.set_string_option", "description": ""}, {"name": "tactic.get_nat_option", "description": ""}, {"name": "tactic.set_bool_option", "description": ""}, {"name": "tactic.get_bool_option", "description": ""}, {"name": "subtype.decidable_eq", "description": ""}, {"name": "operations_examples.example_xor", "description": "0xc0a8787e \u2295 0x9fd1161d = 0x5f796e63"}, {"name": "operations_examples.example_mod", "description": "0xc0a8787e + 0x9fd1161d = 0x60798e9b"}, {"name": "operations_examples.example_inverse_xor", "description": "0x5f796e63 \u2295 0x9fd1161d = 0xc0a8787e"}, {"name": "operations_examples.example_rotl", "description": "0xc0a8787e <<< 5 = 0x150f0fd8"}, {"name": "operations_examples.example_rotl_inv", "description": "0x150f0fd8 <<<\u207b\u00b9 5 = 0xc0a8787e"}, {"name": "tactic_doc.tactic.Instance cache tactics", "description": "For performance reasons, Lean does not automatically update its database\nof class instances during a proof. The group of tactics described below\nhelps to force such updates. For a simple (but very artificial) example,\nconsider the function `default` from the core library. It has type\n`\u03a0 (\u03b1 : Sort u) [inhabited \u03b1], \u03b1`, so one can use `default` only if Lean\ncan find a registered instance of `inhabited \u03b1`. Because the database of\nsuch instance is not automatically updated during a proof, the following\nattempt won't work (Lean will not pick up the instance from the local\ncontext):\n```lean\ndef my_id (\u03b1 : Type) : \u03b1 \u2192 \u03b1 :=\nbegin\n  intro x,\n  have : inhabited \u03b1 := \u27e8x\u27e9,\n  exact default, -- Won't work!\nend\n```\nHowever, it will work, producing the identity function, if one replaces `have`\nby its variant `haveI` described below.\n\n* `resetI`: Reset the instance cache. This allows any instances\n  currently in the context to be used in typeclass inference.\n\n* `unfreezingI { tac }`: Unfreeze local instances while executing the tactic `tac`.\n\n* `introI`/`introsI`: `intro`/`intros` followed by `resetI`. Like\n  `intro`/`intros`, but uses the introduced variable in typeclass inference.\n\n* `casesI`: like `cases`, but can also be used with instance arguments.\n\n* `substI`: like `subst`, but can also substitute in type-class arguments\n\n* `haveI`/`letI`: `have`/`let` followed by `resetI`. Used to add typeclasses\n  to the context so that they can be used in typeclass inference.\n\n* `exactI`: `resetI` followed by `exact`. Like `exact`, but uses all\n  variables in the context for typeclass inference."}, {"name": "tactic.mk_inhabited_instance", "description": ""}, {"name": "list.qsort_cons", "description": ""}, {"name": "list.qsort", "description": ""}, {"name": "list.qsort.F", "description": ""}, {"name": "list.qsort_nil", "description": ""}, {"name": "mathlib_linters", "description": "The default linters used in mathlib CI."}, {"name": "tactic_doc.command.linting commands", "description": "User commands to spot common mistakes in the code\n\n* `#lint`: check all declarations in the current file\n* `#lint_mathlib`: check all declarations in mathlib (so excluding core or other projects,\n  and also excluding the current file)\n* `#lint_all`: check all declarations in the environment (the current file and all\n  imported files)\n\nThe following linters are run by default:\n1. `unused_arguments` checks for unused arguments in declarations.\n2. `def_lemma` checks whether a declaration is incorrectly marked as a def/lemma.\n3. `dup_namespce` checks whether a namespace is duplicated in the name of a declaration.\n4. `ge_or_gt` checks whether \u2265/> is used in the declaration.\n5. `instance_priority` checks that instances that always apply have priority below default.\n6. `doc_blame` checks for missing doc strings on definitions and constants.\n7.  `has_nonempty_instance` checks whether every type has an associated `inhabited`, `unique`\n    or `nonempty` instance.\n8.  `impossible_instance` checks for instances that can never fire.\n9.  `incorrect_type_class_argument` checks for arguments in [square brackets] that are not classes.\n10. `dangerous_instance` checks for instances that generate type-class problems with metavariables.\n11. `fails_quickly` tests that type-class inference ends (relatively) quickly when applied to\n    variables.\n12. `has_coe_variable` tests that there are no instances of type `has_coe \u03b1 t` for a variable `\u03b1`.\n13. `inhabited_nonempty` checks for `inhabited` instance arguments that should be changed to\n    `nonempty`.\n14. `simp_nf` checks that the left-hand side of simp lemmas is in simp-normal form.\n15. `simp_var_head` checks that there are no variables as head symbol of left-hand sides of\n    simp lemmas.\n16. `simp_comm` checks that no commutativity lemmas (such as `add_comm`) are marked simp.\n17. `decidable_classical` checks for `decidable` hypotheses that are used in the proof of a\n    proposition but not in the statement, and could be removed using `classical`.\n    Theorems in the `decidable` namespace are exempt.\n18. `has_coe_to_fun` checks that every type that coerces to a function has a direct\n    `has_coe_to_fun` instance.\n19. `check_type` checks that the statement of a declaration is well-typed.\n20. `check_univs` checks that there are no bad `max u v` universe levels.\n21. `syn_taut` checks that declarations are not syntactic tautologies.\n22. `check_reducibility` checks whether non-instances with a class as type are reducible.\n23. `unprintable_interactive` checks that interactive tactics have parser documentation.\n24. `to_additive_doc` checks if additive versions of lemmas have documentation.\n\nThe following linters are not run by default:\n1. `doc_blame_thm`, checks for missing doc strings on lemmas and theorems.\n2. `explicit_vars_of_iff` checks if there are explicit variables used on both sides of an iff.\n\nThe command `#list_linters` prints a list of the names of all available linters.\n\nYou can append a `*` to any command (e.g. `#lint_mathlib*`) to omit the slow tests (4).\n\nYou can append a `-` to any command (e.g. `#lint_mathlib-`) to run a silent lint\nthat suppresses the output if all checks pass.\nA silent lint will fail if any test fails.\n\nYou can append a `+` to any command (e.g. `#lint_mathlib+`) to run a verbose lint\nthat reports the result of each linter, including  the successes.\n\nYou can append a sequence of linter names to any command to run extra tests, in addition to the\ndefault ones. e.g. `#lint doc_blame_thm` will run all default tests and `doc_blame_thm`.\n\nYou can append `only name1 name2 ...` to any command to run a subset of linters, e.g.\n`#lint only unused_arguments`\n\nYou can add custom linters by defining a term of type `linter` in the `linter` namespace.\nA linter defined with the name `linter.my_new_check` can be run with `#lint my_new_check`\nor `lint only my_new_check`.\nIf you add the attribute `@[linter]` to `linter.my_new_check` it will run by default.\n\nAdding the attribute `@[nolint doc_blame unused_arguments]` to a declaration\nomits it from only the specified linter checks."}, {"name": "tactic.interactive.simp_rw", "description": "`simp_rw` functions as a mix of `simp` and `rw`. Like `rw`, it applies each\nrewrite rule in the given order, but like `simp` it repeatedly applies these\nrules and also under binders like `\u2200 x, ...`, `\u2203 x, ...` and `\u03bb x, ...`.\n\nUsage:\n  - `simp_rw [lemma_1, ..., lemma_n]` will rewrite the goal by applying the\n    lemmas in that order. A lemma preceded by `\u2190` is applied in the reverse direction.\n  - `simp_rw [lemma_1, ..., lemma_n] at h\u2081 ... h\u2099` will rewrite the given hypotheses.\n  - `simp_rw [...] at \u22a2 h\u2081 ... h\u2099` rewrites the goal as well as the given hypotheses.\n  - `simp_rw [...] at *` rewrites in the whole context: all hypotheses and the goal.\n\nLemmas passed to `simp_rw` must be expressions that are valid arguments to `simp`.\n\nFor example, neither `simp` nor `rw` can solve the following, but `simp_rw` can:\n```lean\nexample {\u03b1 \u03b2 : Type} {f : \u03b1 \u2192 \u03b2} {t : set \u03b2} :\n  (\u2200 s, f '' s \u2286 t) = \u2200 s : set \u03b1, \u2200 x \u2208 s, x \u2208 f \u207b\u00b9' t :=\nby simp_rw [set.image_subset_iff, set.subset_def]\n```"}, {"name": "tactic_doc.tactic.simp_rw", "description": "`simp_rw` functions as a mix of `simp` and `rw`. Like `rw`, it applies each\nrewrite rule in the given order, but like `simp` it repeatedly applies these\nrules and also under binders like `\u2200 x, ...`, `\u2203 x, ...` and `\u03bb x, ...`.\n\nUsage:\n  - `simp_rw [lemma_1, ..., lemma_n]` will rewrite the goal by applying the\n    lemmas in that order. A lemma preceded by `\u2190` is applied in the reverse direction.\n  - `simp_rw [lemma_1, ..., lemma_n] at h\u2081 ... h\u2099` will rewrite the given hypotheses.\n  - `simp_rw [...] at \u22a2 h\u2081 ... h\u2099` rewrites the goal as well as the given hypotheses.\n  - `simp_rw [...] at *` rewrites in the whole context: all hypotheses and the goal.\n\nLemmas passed to `simp_rw` must be expressions that are valid arguments to `simp`.\n\nFor example, neither `simp` nor `rw` can solve the following, but `simp_rw` can:\n```lean\nexample {\u03b1 \u03b2 : Type} {f : \u03b1 \u2192 \u03b2} {t : set \u03b2} :\n  (\u2200 s, f '' s \u2286 t) = \u2200 s : set \u03b1, \u2200 x \u2208 s, x \u2208 f \u207b\u00b9' t :=\nby simp_rw [set.image_subset_iff, set.subset_def]\n```"}, {"name": "tactic_doc.tactic.dec_trivial", "description": " `dec_trivial` tries to use decidability to prove a goal\n(i.e., using `exact dec_trivial`).\nThe variant `dec_trivial!` will revert all hypotheses on which the target depends,\nbefore it tries `exact dec_trivial`.\n\nExample:\n```lean\nexample (n : \u2115) (h : n < 2) : n = 0 \u2228 n = 1 :=\nby dec_trivial!\n```"}, {"name": "tactic.interactive.dec_trivial", "description": " `dec_trivial` tries to use decidability to prove a goal\n(i.e., using `exact dec_trivial`).\nThe variant `dec_trivial!` will revert all hypotheses on which the target depends,\nbefore it tries `exact dec_trivial`.\n\nExample:\n```lean\nexample (n : \u2115) (h : n < 2) : n = 0 \u2228 n = 1 :=\nby dec_trivial!\n```"}, {"name": "expr.rename_var", "description": "Rename bound variable `old` to `new` in an `expr`"}, {"name": "tactic.rename_var_at_goal", "description": "Rename bound variable `old` to `new` in goal"}, {"name": "tactic.rename_var_at_hyp", "description": "Rename bound variable `old` to `new` in assumption `h`"}, {"name": "tactic_doc.tactic.rename_var", "description": "`rename_var old new` renames all bound variables named `old` to `new` in the goal.\n`rename_var old new at h` does the same in hypothesis `h`.\nThis is meant for teaching bound variables only. Such a renaming should never be relevant to Lean.\n\n```lean\nexample (P : \u2115 \u2192  \u2115 \u2192 Prop) (h : \u2200 n, \u2203 m, P n m) : \u2200 l, \u2203 m, P l m :=\nbegin\n  rename_var n q at h, -- h is now \u2200 (q : \u2115), \u2203 (m : \u2115), P q m,\n  rename_var m n, -- goal is now \u2200 (l : \u2115), \u2203 (n : \u2115), P k n,\n  exact h -- Lean does not care about those bound variable names\nend\n```"}, {"name": "tactic.interactive.rename_var", "description": "`rename_var old new` renames all bound variables named `old` to `new` in the goal.\n`rename_var old new at h` does the same in hypothesis `h`."}, {"name": "params.byte_len", "description": "A byte is a bitvec of 8 bits."}, {"name": "params.word_len", "description": "A word is a bitvec of 32 bits."}, {"name": "params.max_bitvec", "description": "The maxumum value a bitvec of `word_len` can take."}, {"name": "params.two_31", "description": "2\u00b3\u00b9 as a bitvector of 32 bits."}, {"name": "params.mod", "description": "Sums are all done modulo 2\u00b3\u00b2."}, {"name": "tactic_doc.tactic.pretty_cases", "description": "Query the proof goal and print the skeleton of a proof by\ncases.\n\nFor example, let us consider the following proof:\n\n```lean\nexample {\u03b1} (xs ys : list \u03b1) (h : xs ~ ys) : true :=\nbegin\n  induction h,\n  pretty_cases,\n    -- Try this:\n    --   case list.perm.nil :\n    --   { admit },\n    --   case list.perm.cons : h_x h_l\u2081 h_l\u2082 h_a h_ih\n    --   { admit },\n    --   case list.perm.swap : h_x h_y h_l\n    --   { admit },\n    --   case list.perm.trans : h_l\u2081 h_l\u2082 h_l\u2083 h_a h_a_1 h_ih_a h_ih_a_1\n    --   { admit },\nend\n```\n\nThe output helps the user layout the cases and rename the\nintroduced variables."}, {"name": "tactic.interactive.pretty_cases", "description": "Query the proof goal and print the skeleton of a proof by\ncases.\n\nFor example, let us consider the following proof:\n\n```lean\nexample {\u03b1} (xs ys : list \u03b1) (h : xs ~ ys) : true :=\nbegin\n  induction h,\n  pretty_cases,\n    -- Try this:\n    --   case list.perm.nil :\n    --   { admit },\n    --   case list.perm.cons : h_x h_l\u2081 h_l\u2082 h_a h_ih\n    --   { admit },\n    --   case list.perm.swap : h_x h_y h_l\n    --   { admit },\n    --   case list.perm.trans : h_l\u2081 h_l\u2082 h_l\u2083 h_a h_a_1 h_ih_a h_ih_a_1\n    --   { admit },\nend\n```\n\nThe output helps the user layout the cases and rename the\nintroduced variables."}, {"name": "tactic.pretty_cases_advice", "description": "Query the proof goal and print the skeleton of a proof by cases."}, {"name": "tactic_doc.tactic.wlog", "description": " Without loss of generality: reduces to one goal under variables permutations.\n\nGiven a goal of the form `g xs`, a predicate `p` over a set of variables, as well as variable\npermutations `xs_i`. Then `wlog` produces goals of the form\n\n* The case goal, i.e. the permutation `xs_i` covers all possible cases:\n  `\u22a2 p xs_0 \u2228 \u22ef \u2228 p xs_n`\n* The main goal, i.e. the goal reduced to `xs_0`:\n  `(h : p xs_0) \u22a2 g xs_0`\n* The invariant goals, i.e. `g` is invariant under `xs_i`:\n  `(h : p xs_i) (this : g xs_0) \u22a2 gs xs_i`\n\nEither the permutation is provided, or a proof of the disjunction is provided to compute the\npermutation. The disjunction need to be in assoc normal form, e.g. `p\u2080 \u2228 (p\u2081 \u2228 p\u2082)`. In many cases\nthe invariant goals can be solved by AC rewriting using `cc` etc.\n\nFor example, on a state `(n m : \u2115) \u22a2 p n m` the tactic `wlog h : n \u2264 m using [n m, m n]` produces\nthe following states:\n* `(n m : \u2115) \u22a2 n \u2264 m \u2228 m \u2264 n`\n* `(n m : \u2115) (h : n \u2264 m) \u22a2 p n m`\n* `(n m : \u2115) (h : m \u2264 n) (this : p n m) \u22a2 p m n`\n\n`wlog` supports different calling conventions. The name `h` is used to give a name to the introduced\ncase hypothesis. If the name is avoided, the default will be `case`.\n\n1. `wlog : p xs0 using [xs0, \u2026, xsn]`  \n   Results in the case goal `p xs0 \u2228 \u22ef \u2228 ps xsn`, the main goal `(case : p xs0) \u22a2 g xs0` and the\n   invariance goals `(case : p xsi) (this : g xs0) \u22a2 g xsi`.\n\n2. `wlog : p xs0 := r using xs0`  \n   The expression `r` is a proof of the shape `p xs0 \u2228 \u22ef \u2228 p xsi`, it is also used to compute the\n   variable permutations.\n\n3. `wlog := r using xs0`  \n   The expression `r` is a proof of the shape `p xs0 \u2228 \u22ef \u2228 p xsi`, it is also used to compute the\n   variable permutations. This is not as stable as (2), for example `p` cannot be a disjunction.\n\n4. `wlog : R x y using x y` and `wlog : R x y`  \n   Produces the case `R x y \u2228 R y x`. If `R` is \u2264, then the disjunction discharged using linearity.\n   If `using x y` is avoided then `x` and `y` are the last two variables appearing in the\n   expression `R x y`."}, {"name": "tactic.interactive.wlog", "description": " Without loss of generality: reduces to one goal under variables permutations.\n\nGiven a goal of the form `g xs`, a predicate `p` over a set of variables, as well as variable\npermutations `xs_i`. Then `wlog` produces goals of the form\n\n* The case goal, i.e. the permutation `xs_i` covers all possible cases:\n  `\u22a2 p xs_0 \u2228 \u22ef \u2228 p xs_n`\n* The main goal, i.e. the goal reduced to `xs_0`:\n  `(h : p xs_0) \u22a2 g xs_0`\n* The invariant goals, i.e. `g` is invariant under `xs_i`:\n  `(h : p xs_i) (this : g xs_0) \u22a2 gs xs_i`\n\nEither the permutation is provided, or a proof of the disjunction is provided to compute the\npermutation. The disjunction need to be in assoc normal form, e.g. `p\u2080 \u2228 (p\u2081 \u2228 p\u2082)`. In many cases\nthe invariant goals can be solved by AC rewriting using `cc` etc.\n\nFor example, on a state `(n m : \u2115) \u22a2 p n m` the tactic `wlog h : n \u2264 m using [n m, m n]` produces\nthe following states:\n* `(n m : \u2115) \u22a2 n \u2264 m \u2228 m \u2264 n`\n* `(n m : \u2115) (h : n \u2264 m) \u22a2 p n m`\n* `(n m : \u2115) (h : m \u2264 n) (this : p n m) \u22a2 p m n`\n\n`wlog` supports different calling conventions. The name `h` is used to give a name to the introduced\ncase hypothesis. If the name is avoided, the default will be `case`.\n\n1. `wlog : p xs0 using [xs0, \u2026, xsn]`  \n   Results in the case goal `p xs0 \u2228 \u22ef \u2228 ps xsn`, the main goal `(case : p xs0) \u22a2 g xs0` and the\n   invariance goals `(case : p xsi) (this : g xs0) \u22a2 g xsi`.\n\n2. `wlog : p xs0 := r using xs0`  \n   The expression `r` is a proof of the shape `p xs0 \u2228 \u22ef \u2228 p xsi`, it is also used to compute the\n   variable permutations.\n\n3. `wlog := r using xs0`  \n   The expression `r` is a proof of the shape `p xs0 \u2228 \u22ef \u2228 p xsi`, it is also used to compute the\n   variable permutations. This is not as stable as (2), for example `p` cannot be a disjunction.\n\n4. `wlog : R x y using x y` and `wlog : R x y`  \n   Produces the case `R x y \u2228 R y x`. If `R` is \u2264, then the disjunction discharged using linearity.\n   If `using x y` is avoided then `x` and `y` are the last two variables appearing in the\n   expression `R x y`."}, {"name": "tactic.wlog", "description": ""}, {"name": "ex_of_psig", "description": ""}, {"name": "psigma.eq", "description": ""}, {"name": "sigma.eq", "description": ""}, {"name": "tactic.mk_has_reflect_instance", "description": "Solves a goal of the form `has_reflect \u03b1` where \u03b1 is an inductive type.\n   Needs to synthesize a `reflected` instance for each inductive parameter type of \u03b1\n   and for each constructor parameter of \u03b1."}, {"name": "tactic.save_info_with_widgets", "description": ""}, {"name": "conv.interactive.apply_congr", "description": "Apply a congruence lemma inside `conv` mode.\n\nWhen called without an argument `apply_congr` will try applying all lemmas marked with `@[congr]`.\nOtherwise `apply_congr e` will apply the lemma `e`.\n\nRecall that a goal that appears as `\u2223 X` in `conv` mode\nrepresents a goal of `\u22a2 X = ?m`,\ni.e. an equation with a metavariable for the right hand side.\n\nTo successfully use `apply_congr e`, `e` will need to be an equation\n(possibly after function arguments),\nwhich can be unified with a goal of the form `X = ?m`.\nThe right hand side of `e` will then determine the metavariable,\nand `conv` will subsequently replace `X` with that right hand side.\n\nAs usual, `apply_congr` can create new goals;\nany of these which are _not_ equations with a metavariable on the right hand side\nwill be hard to deal with in `conv` mode.\nThus `apply_congr` automatically calls `intros` on any new goals,\nand fails if they are not then equations.\n\nIn particular it is useful for rewriting inside the operand of a `finset.sum`,\nas it provides an extra hypothesis asserting we are inside the domain.\n\nFor example:\n\n```lean\nexample (f g : \u2124 \u2192 \u2124) (S : finset \u2124) (h : \u2200 m \u2208 S, f m = g m) :\n  finset.sum S f = finset.sum S g :=\nbegin\n  conv_lhs\n  { -- If we just call `congr` here, in the second goal we're helpless,\n    -- because we are only given the opportunity to rewrite `f`.\n    -- However `apply_congr` uses the appropriate `@[congr]` lemma,\n    -- so we get to rewrite `f x`, in the presence of the crucial `H : x \u2208 S` hypothesis.\n    apply_congr,\n    skip,\n    simp [h, H], }\nend\n```\n\nIn the above example, when the `apply_congr` tactic is called it gives the hypothesis `H : x \u2208 S`\nwhich is then used to rewrite the `f x` to `g x`."}, {"name": "tactic_doc.tactic.apply_congr", "description": "Apply a congruence lemma inside `conv` mode.\n\nWhen called without an argument `apply_congr` will try applying all lemmas marked with `@[congr]`.\nOtherwise `apply_congr e` will apply the lemma `e`.\n\nRecall that a goal that appears as `\u2223 X` in `conv` mode\nrepresents a goal of `\u22a2 X = ?m`,\ni.e. an equation with a metavariable for the right hand side.\n\nTo successfully use `apply_congr e`, `e` will need to be an equation\n(possibly after function arguments),\nwhich can be unified with a goal of the form `X = ?m`.\nThe right hand side of `e` will then determine the metavariable,\nand `conv` will subsequently replace `X` with that right hand side.\n\nAs usual, `apply_congr` can create new goals;\nany of these which are _not_ equations with a metavariable on the right hand side\nwill be hard to deal with in `conv` mode.\nThus `apply_congr` automatically calls `intros` on any new goals,\nand fails if they are not then equations.\n\nIn particular it is useful for rewriting inside the operand of a `finset.sum`,\nas it provides an extra hypothesis asserting we are inside the domain.\n\nFor example:\n\n```lean\nexample (f g : \u2124 \u2192 \u2124) (S : finset \u2124) (h : \u2200 m \u2208 S, f m = g m) :\n  finset.sum S f = finset.sum S g :=\nbegin\n  conv_lhs\n  { -- If we just call `congr` here, in the second goal we're helpless,\n    -- because we are only given the opportunity to rewrite `f`.\n    -- However `apply_congr` uses the appropriate `@[congr]` lemma,\n    -- so we get to rewrite `f x`, in the presence of the crucial `H : x \u2208 S` hypothesis.\n    apply_congr,\n    skip,\n    simp [h, H], }\nend\n```\n\nIn the above example, when the `apply_congr` tactic is called it gives the hypothesis `H : x \u2208 S`\nwhich is then used to rewrite the `f x` to `g x`."}, {"name": "bool.univ_eq", "description": ""}, {"name": "bool.range_eq", "description": ""}, {"name": "has_bracket", "description": "The has_bracket class has three intended uses:\n\n 1. for certain binary operations on structures, like the product `\u2045x, y\u2046` of two elements\n   `x`, `y` in a Lie algebra or the commutator of two elements `x` and `y` in a group.\n\n 2. for certain actions of one structure on another, like the action `\u2045x, m\u2046` of an element `x`\n   of a Lie algebra on an element `m` in one of its modules (analogous to `has_smul` in the\n   associative setting).\n\n 3. for binary operations on substructures, like the commutator `\u2045H, K\u2046` of two subgroups `H` and\n    `K` of a group."}, {"name": "has_bracket.bracket", "description": "The has_bracket class has three intended uses:\n\n 1. for certain binary operations on structures, like the product `\u2045x, y\u2046` of two elements\n   `x`, `y` in a Lie algebra or the commutator of two elements `x` and `y` in a group.\n\n 2. for certain actions of one structure on another, like the action `\u2045x, m\u2046` of an element `x`\n   of a Lie algebra on an element `m` in one of its modules (analogous to `has_smul` in the\n   associative setting).\n\n 3. for binary operations on substructures, like the commutator `\u2045H, K\u2046` of two subgroups `H` and\n    `K` of a group."}, {"name": "tactic.interactive.async", "description": "Proves the first goal asynchronously as a separate lemma."}, {"name": "tactic.prove_goal_async", "description": ""}, {"name": "tactic.run_async", "description": ""}, {"name": "debugger.attr", "description": ""}, {"name": "tactic.interactive.simpa", "description": "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ...] using e` will simplify the goal and the type of\n  `e` using `rules`, then try to close the goal using `e`.\n\n  Simplifying the type of `e` makes it more likely to match the goal\n  (which has also been simplified). This construction also tends to be\n  more robust under changes to the simp lemma set.\n\n* `simpa [rules, ...]` will simplify the goal and the type of a\n  hypothesis `this` if present in the context, then try to close the goal using\n  the `assumption` tactic."}, {"name": "tactic_doc.tactic.simpa", "description": "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ...] using e` will simplify the goal and the type of\n  `e` using `rules`, then try to close the goal using `e`.\n\n  Simplifying the type of `e` makes it more likely to match the goal\n  (which has also been simplified). This construction also tends to be\n  more robust under changes to the simp lemma set.\n\n* `simpa [rules, ...]` will simplify the goal and the type of a\n  hypothesis `this` if present in the context, then try to close the goal using\n  the `assumption` tactic."}, {"name": "mul_opposite.division_ring", "description": ""}, {"name": "mul_opposite.field", "description": ""}]